{% extends "calendar_app/base.html" %}
{% load static %}

{% block title %}Book {{ service.name }} – {{ org.name }}{% endblock %}

{% block main_class %}w-full max-w-none px-0 py-0 sm:max-w-6xl sm:mx-auto sm:px-4 sm:py-6 md:p-6{% endblock %}

{% block content %}
<style>
  .calendar-container {
    position: relative;
    max-width: 900px;
    margin: 20px auto;
    background: #fafafa;
    border-radius: 18px;
    padding: 8px;
    box-shadow:
      0 14px 34px rgba(17, 24, 39, 0.10),
      0 2px 10px rgba(17, 24, 39, 0.06);
    border: 1px solid rgba(17, 24, 39, 0.06);
    transform: translateZ(0);
  }
  /* Mobile: make the calendar ~95% width of the screen */
  @media (max-width: 767px) {
    .calendar-container {
      width: 95vw;
      max-width: 95vw;
      margin: 28px auto 16px;
      padding: 8px;
    }
  }
  @media (min-width: 768px) {
    .calendar-container { margin: 40px auto; padding: 12px; }
  }
  .month-header { text-align: center; font-size: 1.3rem; font-weight: bold; margin-bottom: 6px; color: #111; }
  @media (min-width: 768px) {
    .month-header { font-size: 1.7rem; margin-bottom: 10px; }
  }
  /* Smooth fade-out/in for month header */
  #monthHeader { opacity: 1; transition: opacity 180ms ease; }
  #monthHeader.is-fading { opacity: 0; }
  .calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 6px; padding: 12px 0; min-height: 200px; }
  @media (min-width: 768px) {
    .calendar-grid { gap: 12px; padding: 20px 0; min-height: 240px; }
  }
  /* Smooth fade-in for calendar grid on month change */
  .calendar-grid {
    opacity: 1;
    transition: opacity 180ms ease;
    will-change: opacity;
  }
  .calendar-grid.is-fading {
    opacity: 0;
    pointer-events: none;
  }
  .day-circle {
    width: 100%;
    height: auto;
    max-width: 40px;
    aspect-ratio: 1 / 1;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #1f1f29;
    color: white;
    cursor: pointer;
    transition: transform .18s ease, background .18s ease, box-shadow .18s ease;
    border: 1px solid rgba(255,255,255,0.15);
    margin: 0 auto;
    font-size: 0.9rem;
    z-index: 1;
    position: relative;
    justify-self: center;
    box-shadow:
      0 10px 18px rgba(17, 24, 39, 0.14),
      inset 0 1px 0 rgba(255,255,255,0.08);
    transform: translateZ(0);
    will-change: transform;
  }
  @media (min-width: 768px) {
    .day-circle { max-width: 52px; font-size: 1rem; }
  }
  .day-circle:hover {
    transform: translateY(-2px) scale(1.07);
    background: #4b59f0;
    box-shadow:
      0 16px 26px rgba(17, 24, 39, 0.18),
      inset 0 1px 0 rgba(255,255,255,0.10);
  }
  /* Disabled days: greyed out like past-day or unavailable, not clickable */
  .day-circle.disabled {
    opacity: 0.65;
    pointer-events: none !important;
    background: #69696990 !important;
    color: #393535ff !important;
    border: 2px solid #454545ff !important;
    font-weight: 600;
    transform: none !important;
    transition: none !important;
    z-index: 1;
  }
  .day-circle.disabled:hover { 
    transform: none !important; 
    background: #69696990 !important; 
    color: #393535ff !important; 
    cursor: not-allowed !important; 
  }

  /* Weekday header aligned with grid */
  .weekday-row { display: grid; grid-template-columns: repeat(7, 1fr); gap: 6px; padding: 4px 0 0 0; }
  @media (min-width: 768px) {
    .weekday-row { gap: 12px; }
  }
  .weekday-cell { text-align: center; font-size: 0.75rem; color: #555; text-transform: lowercase; }
  @media (min-width: 768px) {
    .weekday-cell { font-size: 0.9rem; }
  }

  #timeModal { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.65); justify-content: center; align-items: center; padding: 8px; z-index: 50; }
  @media (min-width: 768px) {
    #timeModal { padding: 16px; }
  }
  .modal-box { 
    background: #ffffff; 
    padding: 32px 12px 12px 12px; /* extra top padding for close button */ 
    border-radius: 12px; 
    width: 100%; 
    max-width: 95vw; 
    max-height: 85vh; 
    overflow-y: auto; 
    box-shadow: 0 10px 30px rgba(0,0,0,0.2); 
    position: relative; 
    z-index: 100; 
  }
  @media (min-width: 768px) {
    .modal-box { padding: 32px 16px 16px 16px; width: 640px; max-height: 80vh; }
  }
  .time-block { padding: 8px; background: #f3f4f6; border-radius: 8px; margin-bottom: 8px; cursor: pointer; transition: background .15s ease; border: 1px solid #e5e7eb; font-size: 0.9rem; }
  @media (min-width: 768px) {
    .time-block { padding: 10px; margin-bottom: 10px; font-size: 1rem; }
  }
  .time-block:hover { background: #4b59f0; color: white; }
  .modal-title { font-weight: 600; margin-bottom: 8px; font-size: 1rem; }
  @media (min-width: 768px) {
    .modal-title { font-size: 1.125rem; }
  }
  .modal-actions { display:flex; justify-content:space-between; align-items:center; gap:8px; flex-wrap: wrap; }
  .modal-close {
    position: absolute;
    top: 8px;
    right: 10px;
    background: transparent;
    border: none;
    font-size: 24px;
    cursor: pointer !important;
    color: #666;
    z-index: 101;
  }

  /* Loading overlay for slow month renders */
  .calendar-loading {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 10px;
    background: rgba(250, 250, 250, 0.78);
    border-radius: 12px;
    z-index: 30;
  }
  .calendar-loading.hidden { display: none; }
  .calendar-loading .spinner {
    width: 36px;
    height: 36px;
    border-radius: 9999px;
    border: 4px solid rgba(79, 70, 229, 0.18);
    border-top-color: rgba(79, 70, 229, 0.95);
    animation: spin 0.85s linear infinite;
  }
  .calendar-loading .label {
    font-size: 0.95rem;
    color: #374151;
    font-weight: 600;
  }
  @keyframes spin { to { transform: rotate(360deg); } }

  /* Centered service selector styles */
  #mainServiceSelect {
    flex: 1;
    min-width: 120px;
    padding: 0.5rem 0.75rem;
    border: 1px solid #d1d5db;
    border-radius: 0.375rem;
    background-color: #fff;
    color: #111;
    font-size: 0.875rem;
    line-height: 1.25rem;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
  }
  #mainServiceSelect:focus {
    outline: none;
    ring: 2px solid #2563eb;
    ring-offset: 2px;
  }
  #serviceInfoIcon {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background: #e0e7ff;
    color: #374151;
    font-size: 18px;
    border: 1px solid #c7d2fe;
    cursor: pointer;
    transition: background 0.2s ease, transform 0.2s ease;
  }
  #serviceInfoIcon:hover {
    background: #d1e7ff;
    transform: scale(1.05);
  }
  #mainServiceDetails {
    position: absolute;
    top: 24px;
    left: 500px;
    padding: 1rem;
    z-index: 9999;
    width: 340px;
    border: 2px solid #2563eb;
    border-radius: 0.375rem;
    background-color: #f9fafb;
    color: #111;
    font-size: 1rem;
    line-height: 1.5rem;
    box-shadow: 0 4px 24px rgba(0,0,0,0.12);
  }
  #mainServiceDetails strong {
    font-weight: 600;
    color: #111;
  }
  #mainServiceDetails span {
    color: #374151;
  }

  .service-details-fade {
    opacity: 0;
    transition: opacity 250ms ease;
    display: none; /* hidden by default via class, not ID */
  }
  .service-details-fade.visible {
    opacity: 1;
    display: block !important; /* show when visible class applied */
  }

  /* Add this to style spacers in the calendar grid */
  .calendar-grid .spacer {
     pointer-events: none;
     background: transparent;
     /* keep spacer height set by JS so layout stays correct, but don't block pointer events */
     min-height: 0 !important; /* Ensure minimum height is preserved */
     height: auto !important; /* Allow height to be set by JS */
  }
</style>

<script>
  // In third-party iframes, cookies/CSRF often break (Safari/Chrome). For embed
  // widgets we browse availability here, but complete booking on the full page.
  window.CC_IS_EMBED = {{ is_embed|yesno:"true,false" }};
  window.CC_EMBED_BREAKOUT = {{ embed_breakout|yesno:"true,false" }};
  window.CC_TOP_BOOK_URL = "{% url 'bookings:public_service_page' org.slug service.slug %}";
</script>

<div class="calendar-container" style="position:relative;">
  
  {% if trialing_active %}
    <div class="mb-4 p-3 rounded-md bg-amber-50 border-l-4 border-amber-400 text-amber-800" role="status" aria-live="polite">
      <span style="font-size:1.2rem; margin-right:8px;">⚠️</span>
      <span style="font-weight:600;">Trial:</span>
      <span style="margin-left:8px;">The current owner of this business is on a trial run which is why there is only a limited amount of days available to book. Once the trial is over or when the user subscribes, the availability will open up for future days/months.</span>
    </div>
  {% endif %}
  <div class="month-nav" style="display:flex; align-items:center; justify-content:space-between; gap:6px; margin-bottom:8px;">
    <button id="prevMonthBtn" class="px-2 md:px-3 py-1 rounded bg-gray-200 hover:bg-gray-300 text-sm md:text-base">Prev</button>
    <h1 class="month-header flex-1" id="monthHeader" style="font-size: clamp(1rem, 4vw, 1.7rem);"></h1>
    <button id="nextMonthBtn" class="px-2 md:px-3 py-1 rounded bg-gray-200 hover:bg-gray-300 text-sm md:text-base">Next</button>
  </div>

  {% if services or service %}
    <div class="service-dropdown-row" style="display:flex; align-items:center; justify-content:center; gap:10px; margin-bottom:18px; position:relative; z-index:20;">
      <label for="mainServiceSelect" class="font-medium text-gray-700">Service:</label>
      <select id="mainServiceSelect" class="px-3 py-2 rounded border border-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-transparent">
        {% if services %}
          {% for s in services %}
            <option value="{{ s.slug }}" {% if show_with_line %}data-assigned-names="{{ s.assigned_names|default:''|escapejs }}"{% endif %} {% if s.slug == service.slug %}selected{% endif %}>{{ s.name }}</option>
          {% endfor %}
        {% else %}
          <option value="{{ service.slug }}" {% if show_with_line %}data-assigned-names="{{ service.assigned_names|default:''|escapejs }}"{% endif %} selected>{{ service.name }}</option>
        {% endif %}
      </select>
      <span id="serviceInfoIcon" class="ml-2 cursor-pointer" style="display:inline-flex; align-items:center; justify-content:center; width:28px; height:28px; border-radius:50%; background:#e0e7ff; color:#374151; font-size:18px; border:1px solid #c7d2fe;" title="View service details">&#9432;</span>
    </div>
  {% endif %}

  <div id="calendarGridWrap" style="position:relative;">
    <div id="calendarLoading" class="calendar-loading hidden" role="status" aria-live="polite" aria-label="Loading calendar">
      <div class="spinner"></div>
      <div class="label">Loading...</div>
    </div>

    <div class="weekday-row" id="weekdayRow">
      <div class="weekday-cell">sun</div>
      <div class="weekday-cell">mon</div>
      <div class="weekday-cell">tue</div>
      <div class="weekday-cell">wed</div>
      <div class="weekday-cell">thu</div>
      <div class="weekday-cell">fri</div>
      <div class="weekday-cell">sat</div>
    </div>
    <div class="calendar-grid" id="dayGrid"></div>
  </div>

  <div id="mainServiceDetails" class="service-details-fade">
    <div id="mainSvcTitle" class="modal-title" style="margin-bottom:6px;"></div>
    {% if show_with_line %}<div><strong>With:</strong> <span id="mainSvcTeam"></span></div>{% endif %}
    <div><strong>Description:</strong> <span id="mainSvcDesc"></span></div>
    <div><strong>Duration:</strong> <span id="mainSvcDuration"></span> minutes</div>
    <div><strong>Price:</strong> $<span id="mainSvcPrice"></span></div>
    <div><strong>Refunds:</strong>
      <span id="mainSvcRefundLine"></span>
      <div id="mainSvcRefundText" class="mt-1 text-gray-600" style="display:none;"></div>
    </div>
  </div>
</div>

<!-- TIME MODAL -->
  <script>
  // Build SERVICE_MAP for info box (outside DOMContentLoaded for global access)
  const SERVICE_MAP = {};
  {% for s in services %}
    SERVICE_MAP["{{ s.slug }}"] = {
      name: "{{ s.name|escapejs }}",
      description: "{{ s.description|default:""|escapejs }}",
      duration: {{ s.duration|default:0 }},
      price: {{ s.price|default:0 }},
      {% if show_with_line %}assigned_names: "{{ s.assigned_names|default:''|escapejs }}",{% endif %}
      refunds_allowed: {{ s.refunds_allowed|yesno:"true,false" }},
      refund_cutoff_hours: {{ s.refund_cutoff_hours|default:0 }},
      refund_policy_text: "{{ s.refund_policy_text|default:""|escapejs }}",
      buffer_after: {{ s.buffer_after|default:0 }},
      allow_ends_after_availability: {{ s.allow_ends_after_availability|yesno:"true,false" }},
      time_increment_minutes: {{ s.time_increment_minutes|default:30 }},
      use_fixed_increment: {{ s.use_fixed_increment|yesno:"true,false" }},
      allow_squished_bookings: {{ s.allow_squished_bookings|yesno:"true,false" }}
    };
  {% endfor %}

  document.addEventListener("DOMContentLoaded", function () {
    // Info box elements
    const mainServiceSelect = document.getElementById("mainServiceSelect");
    const mainServiceDetails = document.getElementById("mainServiceDetails");
    const mainSvcDesc = document.getElementById("mainSvcDesc");
    const mainSvcDuration = document.getElementById("mainSvcDuration");
    const mainSvcPrice = document.getElementById("mainSvcPrice");
    const mainSvcRefundLine = document.getElementById("mainSvcRefundLine");
    const mainSvcRefundText = document.getElementById("mainSvcRefundText");
    const serviceInfoIcon = document.getElementById("serviceInfoIcon");

    function updateMainServiceDetails(slug) {
      const d = SERVICE_MAP[slug];
      if (!d) return;
      const mainSvcTitle = document.getElementById('mainSvcTitle');
      if (mainSvcTitle) mainSvcTitle.textContent = d.name;
      mainSvcDesc.textContent = d.description || "—";
      mainSvcDuration.textContent = d.duration || 0;
      mainSvcPrice.textContent = (typeof d.price === 'number') ? d.price.toFixed(2) : d.price;
      // Populate assigned team members (read from the select option dataset when present)
      try {
        const mainSvcTeamEl = document.getElementById('mainSvcTeam');
        const opt = mainServiceSelect && mainServiceSelect.options ? mainServiceSelect.options[mainServiceSelect.selectedIndex] : null;
        const assigned = (opt && opt.dataset && opt.dataset.assignedNames) ? opt.dataset.assignedNames : (d.assigned_names || '');
        if (mainSvcTeamEl) mainSvcTeamEl.textContent = assigned || '—';
      } catch (err) { /* ignore */ }
      if (d.refunds_allowed) {
        mainSvcRefundLine.textContent = `Refunds permitted except within ${d.refund_cutoff_hours} hours of the appointment.`;
        if (d.refund_policy_text) {
          mainSvcRefundText.style.display = '';
          mainSvcRefundText.textContent = d.refund_policy_text;
        } else {
          mainSvcRefundText.style.display = 'none';
          mainSvcRefundText.textContent = '';
        }
      } else {
        mainSvcRefundLine.textContent = 'Refunds are not permitted for this service.';
        mainSvcRefundText.style.display = 'none';
        mainSvcRefundText.textContent = '';
      }
      // (Client-facing info intentionally omits buffer/increment/fixed details)
    }

    // Show/hide info box on icon hover or click
    let infoVisible = false;
    function showInfoBox() {
      updateMainServiceDetails(mainServiceSelect.value);
      mainServiceDetails.style.display = '';
      mainServiceDetails.classList.add('visible');
      infoVisible = true;
    }
    function hideInfoBox() {
      mainServiceDetails.style.display = 'none';
      mainServiceDetails.classList.remove('visible');
      infoVisible = false;
    }
    serviceInfoIcon.addEventListener('mouseenter', showInfoBox);
    serviceInfoIcon.addEventListener('mouseleave', hideInfoBox);
    serviceInfoIcon.addEventListener('click', function () {
      if (infoVisible) {
        hideInfoBox();
      } else {
        showInfoBox();
      }
    });

    // Update info box when dropdown changes
    if (mainServiceSelect) {
      mainServiceSelect.addEventListener('change', function (e) {
        updateMainServiceDetails(e.target.value);
        if (infoVisible) {
          mainServiceDetails.style.display = '';
          mainServiceDetails.classList.add('visible');
        } else {
          mainServiceDetails.style.display = 'none';
          mainServiceDetails.classList.remove('visible');
        }
        // Also update calendar to use new service
        window.selectedServiceSlug = e.target.value;
        if (typeof generateCalendar === 'function') {
          generateCalendar(currentMonth, currentYear);
        }
      });
      // Initial details
      updateMainServiceDetails(mainServiceSelect.value);
      window.selectedServiceSlug = mainServiceSelect.value;
      mainServiceDetails.style.display = 'none';
      mainServiceDetails.classList.remove('visible');
      infoVisible = false;
    }
  });
  </script>
<div id="timeModal">
  <!-- Modal View 1: Time Slots -->
  <div class="modal-box" id="timeModalViewSlots">
    <button class="modal-close" type="button" onclick="closeTimeModal()">×</button>
    <h3 id="selectedDateLabel" class="modal-title text-gray-900"></h3>
    <div id="timeSlots"></div>
  </div>

  <!-- Modal View 2: Service + Details -->
  <div class="modal-box" id="timeModalViewDetails" style="display:none;">
    <button class="modal-close" type="button" onclick="closeTimeModal()">×</button>
    <h3 id="selectedDateTimeLabel" class="modal-title text-gray-900"></h3>

    <form method="POST" action="">
      {% csrf_token %}
      <input type="hidden" name="start" id="startInput">
      <input type="hidden" name="end" id="endInput">
      <input type="hidden" name="reschedule_source" id="rescheduleSourceInput" value="{{ reschedule_source|default:'' }}">
      <input type="hidden" name="reschedule_token" id="rescheduleTokenInput" value="{{ reschedule_token|default:'' }}">

      <label class="block text-sm text-gray-700 mb-1">Select service</label>
      <select id="serviceSelect" name="service_slug" required class="w-full mb-3 px-3 py-2 text-base rounded border border-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-transparent">
        {% if services %}
          {% for s in services %}
            <option value="{{ s.slug }}" {% if show_with_line %}data-assigned-names="{{ s.assigned_names|default:''|escapejs }}"{% endif %} {% if s.slug == service.slug %}selected{% endif %}>{{ s.name }}</option>
          {% endfor %}
        {% else %}
          <option value="{{ service.slug }}" {% if show_with_line %}data-assigned-names="{{ service.assigned_names|default:''|escapejs }}"{% endif %} selected>{{ service.name }}</option>
        {% endif %}
      </select>

      <!-- Service details preview -->
      <div id="serviceDetails" class="mb-4 p-3 rounded border border-gray-200 bg-gray-50 text-sm">
        <div><strong>Name:</strong> <span id="svcName">{{ service.name }}</span></div>
        {% if show_with_line %}<div><strong>With:</strong> <span id="svcTeam"></span></div>{% endif %}
        <div><strong>Description:</strong> <span id="svcDesc">{{ service.description|default:"—" }}</span></div>
        <div><strong>Duration:</strong> <span id="svcDuration">{{ service.duration }}</span> minutes</div>
        <div><strong>Price:</strong> $<span id="svcPrice">{{ service.price }}</span></div>
        <!-- Client-facing modal intentionally omits buffer/increment/fixed/allow settings -->
        <div><strong>Refunds:</strong>
          <span id="svcRefundLine">
            {% if service.refunds_allowed %}
              Refunds permitted except within {{ service.refund_cutoff_hours }} hours of the appointment.
            {% else %}
              Refunds are not permitted for this service.
            {% endif %}
          </span>
          {% if service.refunds_allowed and service.refund_policy_text %}
            <div id="svcRefundText" class="mt-1 text-gray-600">{{ service.refund_policy_text }}</div>
          {% else %}
            <div id="svcRefundText" class="mt-1 text-gray-600" style="display:none;"></div>
          {% endif %}
        </div>
      </div>

      <label class="block text-sm text-gray-700 mb-1">Your name</label>
      <input type="text" name="client_name" required value="{{ prefill_client_name|default:'' }}" class="w-full mb-3 px-3 py-2 text-base rounded border border-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-transparent" placeholder="John Doe">

      <label class="block text-sm text-gray-700 mb-1">Email</label>
      <input type="email" name="client_email" required value="{{ prefill_client_email|default:'' }}" class="w-full mb-4 px-3 py-2 text-base rounded border border-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-transparent" placeholder="john@example.com">

      <div id="paymentSection" class="mb-4" style="display:none;">
        <label class="block text-sm text-gray-700 mb-2">Different payment methods:</label>

        <div id="paymentFreeNote" class="text-sm text-gray-700" style="display:none;">
          No payment is required for this service.
        </div>

        <div id="paymentUnavailableNote" class="text-sm text-gray-700" style="display:none;">
          This service can’t be booked online right now.
        </div>

        <div id="paymentMethodChoices" class="space-y-2" style="display:none;">
          <label class="flex items-start gap-2" id="pmStripeWrap">
            <input type="radio" name="payment_method" value="stripe" checked>
            <span class="text-sm text-gray-800">Pay with card (Stripe)</span>
          </label>

          <div id="pmOfflineMethodsWrap" class="space-y-2" style="display:none;">
            <label class="flex items-start gap-2" id="pmOfflineVenmoWrap" style="display:none;">
              <input type="radio" name="payment_method" value="venmo">
              <span class="text-sm text-gray-800">Venmo</span>
            </label>
            <label class="flex items-start gap-2" id="pmOfflineZelleWrap" style="display:none;">
              <input type="radio" name="payment_method" value="zelle">
              <span class="text-sm text-gray-800">Zelle</span>
            </label>
            <label class="flex items-start gap-2" id="pmOfflineCashWrap" style="display:none;">
              <input type="radio" name="payment_method" value="cash">
              <span class="text-sm text-gray-800">Cash</span>
            </label>
          </div>
          <div id="offlineInstructions" class="text-xs text-gray-600 ml-6" style="display:none; white-space: pre-line;">
            {% if offline_instructions %}
              {{ offline_instructions }}
            {% else %}
              Offline payment instructions will be shown after booking.
            {% endif %}
          </div>

          <div id="offlineQrWrap" class="ml-6 mt-3" style="display:none;">
            <div class="text-xs text-gray-700" style="font-weight:600;">Scan to pay now</div>
            <div class="mt-2 flex items-start gap-3">
              <img id="offlineQrImg" src="" alt="Payment QR code" style="display:none; width:160px; height:160px; border:1px solid #e5e7eb; border-radius:8px; background:#fff;" />
              <div class="text-xs text-gray-600" style="line-height:1.35;">
                If you prefer paying later prior to the appointment or in-person on the day of, this QR code is also included in your confirmation email.
              </div>
            </div>
            <div id="offlineQrFallback" class="text-xs text-gray-600 mt-2" style="display:none;">QR code unavailable — the business owner will provide payment details.</div>
          </div>
        </div>

        <p class="text-xs text-gray-500 mt-2">Payment options appear for paid services.</p>
      </div>

      <div class="modal-actions">
        <button type="button" id="backToSlotsBtn" class="px-4 py-2 text-sm md:text-base rounded border border-gray-300 text-gray-700 hover:bg-gray-100 flex-1 md:flex-none">Back</button>
        <button type="submit" id="bookNowBtn" class="bg-blue-600 text-white px-4 py-2 text-sm md:text-base rounded hover:bg-blue-700 flex-1 md:flex-none">Book now</button>
      </div>
    </form>
  </div>

  <!-- Modal View 3: Embedded Stripe Checkout -->
  <div class="modal-box" id="timeModalViewCheckout" style="display:none;">
    <button class="modal-close" type="button" onclick="closeTimeModal()">×</button>
    <h3 class="modal-title text-gray-900">Complete payment</h3>
    <div id="embedded-checkout" class="mt-3"></div>
    <div class="mt-3 text-xs text-gray-600">Secured by Stripe.</div>
  </div>
</div>

{% if open_checkout %}
<script src="https://js.stripe.com/v3/"></script>
{% endif %}

{{ service_payment_controls|json_script:"service-payment-controls" }}

<script>
// Global variable to track booked slots during this session
window.bookedSlotsThisSession = window.bookedSlotsThisSession || [];
</script>

<script>
document.addEventListener("DOMContentLoaded", async function () {
  try { /* init */ } catch (e) {}
  const dayGrid = document.getElementById("dayGrid");
  const monthHeader = document.getElementById("monthHeader");
  const calendarLoading = document.getElementById('calendarLoading');
  const mainServiceSelectForCalendar = document.getElementById('mainServiceSelect');
  const prevBtn = document.getElementById('prevMonthBtn');
  const nextBtn = document.getElementById('nextMonthBtn');
  const timeModal = document.getElementById("timeModal");
  const timeModalViewSlots = document.getElementById("timeModalViewSlots");
  const timeModalViewDetails = document.getElementById("timeModalViewDetails");
  const timeModalViewCheckout = document.getElementById("timeModalViewCheckout");
  const selectedDateLabel = document.getElementById("selectedDateLabel");
  const selectedDateTimeLabel = document.getElementById("selectedDateTimeLabel");
  const timeSlots = document.getElementById("timeSlots");
  const startInput = document.getElementById("startInput");
  const endInput = document.getElementById("endInput");
  const serviceSelect = document.getElementById("serviceSelect");
  const detailsBox = document.getElementById("serviceDetails");
  const svcName = document.getElementById("svcName");
  const svcDesc = document.getElementById("svcDesc");
  const svcDuration = document.getElementById("svcDuration");
  const svcPrice = document.getElementById("svcPrice");
  const svcRefundLine = document.getElementById("svcRefundLine");
  const svcRefundText = document.getElementById("svcRefundText");
  const paymentSection = document.getElementById('paymentSection');
  const paymentFreeNote = document.getElementById('paymentFreeNote');
  const paymentUnavailableNote = document.getElementById('paymentUnavailableNote');
  const paymentMethodChoices = document.getElementById('paymentMethodChoices');
  const offlineInstructions = document.getElementById('offlineInstructions');
  const offlineQrWrap = document.getElementById('offlineQrWrap');
  const offlineQrImg = document.getElementById('offlineQrImg');
  const offlineQrFallback = document.getElementById('offlineQrFallback');

  const OFFLINE_INSTRUCTIONS_RAW = "{{ offline_instructions|default:''|escapejs }}";

  function _isMethodLine(line){
    try{
      return /^\s*(venmo|zelle|cash)\s*[:\-]/i.test(String(line || ''));
    }catch(e){ return false; }
  }

  function _filterOfflineInstructionsTextFor(method){
    try{
      const m = String(method || '').toLowerCase();
      const full = String(OFFLINE_INSTRUCTIONS_RAW || '').trim();
      if (!full) return '';
      const lines = full.split(/\r?\n/);
      const out = [];
      for (const rawLine of lines){
        const line = String(rawLine || '');
        if (_isMethodLine(line)){
          if (m === 'venmo' && /^\s*venmo\s*[:\-]/i.test(line)) out.push(line);
          else if (m === 'zelle' && /^\s*zelle\s*[:\-]/i.test(line)) out.push(line);
          else if (m === 'cash' && /^\s*cash\s*[:\-]/i.test(line)) out.push(line);
          continue;
        }
        if (line.trim() !== '') out.push(line);
      }
      return out.join('\n').trim();
    }catch(e){ return ''; }
  }

  function _extractOfflineLineFor(method){
    try{
      const m = String(method || '').toLowerCase();
      const full = String(OFFLINE_INSTRUCTIONS_RAW || '').trim();
      if (!full) return '';
      const lines = full.split(/\r?\n/);
      const re = new RegExp('^\\s*' + m + '\\s*[:\\-]\\s*(.+)$', 'i');
      for (const line of lines){
        const match = String(line || '').match(re);
        if (match && match[1]) return String(match[1]).trim();
      }
      return '';
    }catch(e){ return ''; }
  }

  function _isOfflineChoice(v){
    v = String(v || '').toLowerCase();
    return v === 'venmo' || v === 'zelle' || v === 'cash';
  }

  function _refreshOfflineInstructionsDisplay(){
    try{
      if (!offlineInstructions) return;
      const selected = paymentSection ? paymentSection.querySelector('input[name="payment_method"]:checked') : null;
      const v = selected ? String(selected.value || '').toLowerCase() : '';
      if (!_isOfflineChoice(v)) return;

      // Cash is always an in-person flow; never show Venmo/Zelle details.
      if (v === 'cash') {
        offlineInstructions.textContent = 'Pay in-person. If unable to make appointment, please try to cancel prior to the time established in the Refund Policy';
        return;
      }

      const filtered = _filterOfflineInstructionsTextFor(v);
      // Never fall back to server-rendered instructions here (it may contain the other method).
      offlineInstructions.textContent = filtered || 'Offline payment instructions will be shown after booking.';
    }catch(e){ /* ignore */ }
  }

  function _refreshOfflineQrDisplay(){
    try{
      if (!offlineQrWrap) return;
      if (offlineQrImg) offlineQrImg.style.display = 'none';
      if (offlineQrFallback) offlineQrFallback.style.display = 'none';

      const selected = paymentSection ? paymentSection.querySelector('input[name="payment_method"]:checked') : null;
      const v = selected ? String(selected.value || '').toLowerCase() : '';
      // Only show QR for Venmo/Zelle (cash has no reliable QR flow).
      if (v !== 'venmo' && v !== 'zelle') { offlineQrWrap.style.display = 'none'; return; }

      // Derive QR payload from offline instructions. Prefer a method-specific line (e.g. "Venmo: @handle").
      const methodLine = _extractOfflineLineFor(v);
      // If the method-specific line is missing, don't fall back to full instructions
      // (it may contain the other method's details).
      if (!methodLine){
        offlineQrWrap.style.display = '';
        if (offlineQrFallback) offlineQrFallback.style.display = '';
        return;
      }

      const qrText = (v.toUpperCase() + ': ' + methodLine);

      const url = 'https://api.qrserver.com/v1/create-qr-code/?size=180x180&data=' + encodeURIComponent(qrText);
      if (offlineQrImg){
        offlineQrImg.src = url;
        offlineQrImg.style.display = '';
      }
      offlineQrWrap.style.display = '';
    }catch(e){ try{ if (offlineQrWrap) offlineQrWrap.style.display = 'none'; }catch(_){ } }
  }

  const SERVICE_PAYMENT = JSON.parse(
    (document.getElementById('service-payment-controls') || {}).textContent || '{}'
  );

  // Ensure we always have a deterministic service slug for calendar fetches.
  // (Avoids occasional "all disabled" renders when the selected slug isn't set yet.)
  try {
    const initialSlug = (mainServiceSelectForCalendar && mainServiceSelectForCalendar.value)
      ? mainServiceSelectForCalendar.value
      : (window.selectedServiceSlug || '{{ service.slug }}');
    window.selectedServiceSlug = initialSlug;
  } catch (e) {}

  const now = new Date();
  let currentMonth = now.getMonth();
  let currentYear = now.getFullYear();
  // Render synchronization guards
  let renderToken = 0;
  let isRendering = false;

  function updatePaymentSectionForServiceSlug(slug) {
    if (!paymentSection) return;
    const bookNowBtn = document.getElementById('bookNowBtn');
    if (paymentUnavailableNote) paymentUnavailableNote.style.display = 'none';
    if (bookNowBtn) bookNowBtn.disabled = false;
    let price = 0;
    try {
      const d = SERVICE_MAP[slug];
      price = Number(d && d.price != null ? d.price : 0) || 0;
    } catch (e) {
      price = 0;
    }

    // Always show the section so clients understand whether payment is required.
    paymentSection.style.display = '';

    const isPaid = price > 0;
    if (paymentFreeNote) paymentFreeNote.style.display = isPaid ? 'none' : '';
    if (paymentMethodChoices) paymentMethodChoices.style.display = isPaid ? '' : 'none';

    // Default behavior: hide offline instructions until selected
    if (offlineInstructions) offlineInstructions.style.display = 'none';
    if (offlineQrWrap) offlineQrWrap.style.display = 'none';

    if (!isPaid) return;

    // Per-service allowed payment methods
    const pm = (SERVICE_PAYMENT && SERVICE_PAYMENT[slug]) ? SERVICE_PAYMENT[slug] : null;
    const stripeAllowed = pm ? !!pm.allow_stripe : true;
    const offlineMethods = (pm && Array.isArray(pm.offline_methods)) ? pm.offline_methods.map(x => String(x || '').toLowerCase()).filter(Boolean) : [];
    const offlineAllowed = offlineMethods.length > 0;

    const stripeWrap = document.getElementById('pmStripeWrap');
    const offlineMethodsWrap = document.getElementById('pmOfflineMethodsWrap');
    const venmoWrap = document.getElementById('pmOfflineVenmoWrap');
    const zelleWrap = document.getElementById('pmOfflineZelleWrap');
    const cashWrap = document.getElementById('pmOfflineCashWrap');

    if (stripeWrap) stripeWrap.style.display = stripeAllowed ? '' : 'none';
    if (offlineMethodsWrap) offlineMethodsWrap.style.display = offlineAllowed ? '' : 'none';
    if (venmoWrap) venmoWrap.style.display = (offlineAllowed && offlineMethods.includes('venmo')) ? '' : 'none';
    if (zelleWrap) zelleWrap.style.display = (offlineAllowed && offlineMethods.includes('zelle')) ? '' : 'none';
    if (cashWrap) cashWrap.style.display = (offlineAllowed && offlineMethods.includes('cash')) ? '' : 'none';

    // Choose a valid default selection
    const stripeRadio = paymentSection.querySelector('input[name="payment_method"][value="stripe"]');
    const venmoRadio = paymentSection.querySelector('input[name="payment_method"][value="venmo"]');
    const zelleRadio = paymentSection.querySelector('input[name="payment_method"][value="zelle"]');
    const cashRadio = paymentSection.querySelector('input[name="payment_method"][value="cash"]');
    const selected = paymentSection.querySelector('input[name="payment_method"]:checked');

    const offlineRadios = [venmoRadio, zelleRadio, cashRadio].filter(Boolean);
    const allowedOfflineValues = new Set(offlineMethods);
    const firstAllowedOfflineRadio = offlineRadios.find(r => allowedOfflineValues.has(String(r.value).toLowerCase())) || null;

    function isOfflineValue(v){
      v = String(v || '').toLowerCase();
      return v === 'venmo' || v === 'zelle' || v === 'cash';
    }

    // Enforce availability at the input level too (prevents submitting a hidden/invalid option).
    if (stripeRadio) {
      stripeRadio.disabled = !stripeAllowed;
      if (!stripeAllowed) stripeRadio.checked = false;
    }
    for (const r of offlineRadios){
      const v = String(r.value || '').toLowerCase();
      const enabled = offlineAllowed && allowedOfflineValues.has(v);
      r.disabled = !enabled;
      if (!enabled) r.checked = false;
    }

    // If neither payment method is allowed for a paid service, block booking.
    if (!stripeAllowed && !offlineAllowed) {
      if (paymentMethodChoices) paymentMethodChoices.style.display = 'none';
      if (offlineInstructions) offlineInstructions.style.display = 'none';
      if (paymentUnavailableNote) paymentUnavailableNote.style.display = '';
      if (bookNowBtn) bookNowBtn.disabled = true;
      return;
    }

    if (selected && selected.value === 'stripe' && !stripeAllowed && offlineAllowed) {
      if (firstAllowedOfflineRadio) firstAllowedOfflineRadio.checked = true;
    } else if (selected && isOfflineValue(selected.value) && (!offlineAllowed || !allowedOfflineValues.has(String(selected.value).toLowerCase())) && stripeAllowed) {
      if (stripeRadio) stripeRadio.checked = true;
    } else {
      const selectedNow = paymentSection.querySelector('input[name="payment_method"]:checked');
      if (!selectedNow) {
        if (stripeAllowed && stripeRadio) stripeRadio.checked = true;
        else if (offlineAllowed && firstAllowedOfflineRadio) firstAllowedOfflineRadio.checked = true;
      }
    }

    // Show instructions only when an offline method is selected AND offline is available
    const selected2 = paymentSection.querySelector('input[name="payment_method"]:checked');
    if (offlineInstructions) {
      offlineInstructions.style.display = (offlineAllowed && selected2 && isOfflineValue(selected2.value) && allowedOfflineValues.has(String(selected2.value).toLowerCase())) ? '' : 'none';
    }
    try{ _refreshOfflineInstructionsDisplay(); }catch(e){}
    try{ _refreshOfflineQrDisplay(); }catch(e){}
  }

  if (paymentSection) {
    paymentSection.addEventListener('change', function (e) {
      try {
        const slug = (serviceSelect && serviceSelect.value) ? serviceSelect.value : (window.selectedServiceSlug || '{{ service.slug }}');
        updatePaymentSectionForServiceSlug(slug);
        _refreshOfflineQrDisplay();
      } catch (err) {}
    });
  }

  // Render month header and circles
  // Store day summary globally for guards
  let dayHasSlots = {};

  let loadingTimer = null;
  function setCalendarBusy(busy, opts) {
    const immediate = !!(opts && opts.immediate);

    if (prevBtn) prevBtn.disabled = !!busy;
    if (nextBtn) nextBtn.disabled = !!busy;
    if (prevBtn) prevBtn.style.opacity = busy ? '0.6' : '';
    if (nextBtn) nextBtn.style.opacity = busy ? '0.6' : '';

    if (!calendarLoading) return;
    if (!busy) {
      if (loadingTimer) { clearTimeout(loadingTimer); loadingTimer = null; }
      calendarLoading.classList.add('hidden');
      return;
    }

    if (loadingTimer) { clearTimeout(loadingTimer); loadingTimer = null; }
    if (immediate) {
      calendarLoading.classList.remove('hidden');
    } else {
      // Delay slightly so quick renders don't flash the loader.
      loadingTimer = setTimeout(() => {
        calendarLoading.classList.remove('hidden');
      }, 180);
    }
  }

  function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  async function generateCalendar(month, year) {
    // Advance render token so only latest render will apply
    const myToken = ++renderToken;
    isRendering = true;
    const isInitial = dayGrid && dayGrid.childElementCount === 0;
    setCalendarBusy(true, { immediate: isInitial });
    try {
      const activeServiceSlug = (function () {
        try {
          const el = document.getElementById('mainServiceSelect');
          if (el && el.value) return el.value;
        } catch (e) {}
        return window.selectedServiceSlug || '{{ service.slug }}';
      })();
      window.selectedServiceSlug = activeServiceSlug;

      // Fade out current view first; only clear after fade completes.
      dayGrid.classList.add('is-fading');
      monthHeader.classList.add('is-fading');
      const newHeaderText = new Date(year, month).toLocaleString("default", { month: "long", year: "numeric" });

      if (!isInitial) {
        await sleep(180);
      }

      if (myToken !== renderToken) {
        return;
      }

      // Now that we're faded out, swap content while hidden.
      monthHeader.innerText = newHeaderText;
      dayGrid.innerHTML = "";

      // Build all elements off-DOM to avoid partial/incremental rendering
      const fragment = document.createDocumentFragment();

    const firstDay = new Date(year, month, 1).getDay();
    const numDays = new Date(year, month + 1, 0).getDate();

    for (let i = 0; i < firstDay; i++) {
      const spacer = document.createElement("div");
      spacer.style.minHeight = "52px";
      spacer.className = "spacer"; /* Add spacer class */
      fragment.appendChild(spacer);
    }

    // Fetch batch availability summary for the entire month in one call
    const todayMidnight = new Date(); todayMidnight.setHours(0,0,0,0);
    const pad = n => String(n).padStart(2, '0');
    function toIsoLocal(d) {
      const yyyy = d.getFullYear();
      const mm = pad(d.getMonth() + 1);
      const dd = pad(d.getDate());
      const HH = pad(d.getHours());
      const MM = pad(d.getMinutes());
      return `${yyyy}-${mm}-${dd}T${HH}:${MM}:00`;
    }

    const monthStart = new Date(year, month, 1, 0, 0, 0);
    const monthEnd = new Date(year, month + 1, 0, 23, 59, 59);
    const cacheBuster = `&_t=${Date.now()}`;
    const batchUrl = "{% url 'bookings:batch_availability_summary' org.slug 'SERVICE_SLUG' %}".replace('SERVICE_SLUG', activeServiceSlug) + `?start=${encodeURIComponent(toIsoLocal(monthStart))}&end=${encodeURIComponent(toIsoLocal(monthEnd))}${cacheBuster}`;
    
    dayHasSlots = {};
    let batchFailed = false;
    try {
      const resp = await fetch(batchUrl);
      if (resp.ok) dayHasSlots = await resp.json();
      else batchFailed = true;
    } catch(e) {
      console.error('Batch availability fetch failed', e);
      batchFailed = true;
    }

    // Prefetch server-effective settings for this service/date so month rendering
    // and the per-day detailed calls use the same (saved) increment/fixed flags.
    let svcForLoop = SERVICE_MAP[activeServiceSlug] || {};
    try {
      const effUrl = "{% url 'bookings:service_effective_settings' org.slug 'SERVICE_SLUG' %}".replace('SERVICE_SLUG', activeServiceSlug) + '?date=' + encodeURIComponent(toIsoLocal(monthStart).split('T')[0]);
      const effResp = await fetch(effUrl);
      if (effResp.ok) {
        const eff = await effResp.json();
        if (eff && typeof eff.use_fixed_increment === 'boolean') {
          svcForLoop = Object.assign({}, svcForLoop, {
            use_fixed_increment: eff.use_fixed_increment,
            time_increment_minutes: eff.time_increment_minutes,
            allow_ends_after_availability: eff.allow_ends_after_availability
          });
        }
      }
    } catch (e) {
      
    }

    // Strict availability checker: only treat clearly positive values as available
    function hasAvailability(val) {
      if (val === undefined || val === null) return false;
      // Normalize strings
      if (typeof val === 'string') {
        const s = val.trim();
        if (s === '' || s === 'false' || s === '0') return false;
        if (s.startsWith('[') || s.startsWith('{')) {
          try { val = JSON.parse(s); } catch (_) { return false; }
        } else {
          // Any other string is treated as no availability
          return false;
        }
      }
      // Arrays: must have length > 0
      if (Array.isArray(val)) return val.length > 0;
      // Numbers: must be > 0
      if (typeof val === 'number') return val > 0;
      // Booleans: only true means available
      if (typeof val === 'boolean') return val === true;
      // Objects: check common shapes
      if (typeof val === 'object') {
        if ('count' in val) return Number(val.count) > 0;
        if ('slots' in val && Array.isArray(val.slots)) return val.slots.length > 0;
        // Unknown object shapes are treated as unavailable
        return false;
      }
      return false;
    }

    // Prefetch detailed availability in parallel for candidate days, then render in one batch
    const detailedDayHasSlots = {};
    const fetches = [];
    for (let day = 1; day <= numDays; day++) {
      const date = new Date(year, month, day);
      const yyyy = date.getFullYear();
      const mm = String(date.getMonth()+1).padStart(2,'0');
      const dd = String(date.getDate()).padStart(2,'0');
      const dateKey = `${yyyy}-${mm}-${dd}`;
      const summaryVal = dayHasSlots[dateKey];
      const isAvailable = hasAvailability(summaryVal);
      // If the batch summary call fails, fall back to checking every day in-range.
      // This prevents intermittent "all disabled" renders.
      if (date >= todayMidnight && (batchFailed || isAvailable)) {
        const start = new Date(year, month, day, 0, 0, 0);
        const end = new Date(year, month, day, 23, 59, 59);
        const pad = n => String(n).padStart(2,'0');
        const toIsoLocal = (d) => `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}:00`;
        const cacheBuster = `&_t=${Date.now()}`;
        // Determine whether to apply edge buffers for this service. Preference order:
        // 1) explicit localStorage override if present, 2) server-side service setting.
        function getEdgeBuffersForService(slug) {
          try {
            const raw = localStorage.getItem('edge_buffers_' + slug);
            if (raw === '1' || raw === 'true') return 1;
            if (raw === '0' || raw === 'false') return 0;
          } catch (e) {}
          // Do NOT default to the service's `allow_ends_after_availability` here.
          // Edge buffer behavior should only be controlled via explicit local override.
          return 0;
        }
        const edgeVal = getEdgeBuffersForService(activeServiceSlug);
        // If the service is configured to use fixed increments, do NOT force an `inc` param
        // so the server can apply duration+buffer spacing. Otherwise include the preview tick.
        // use `svcForLoop` prefetched above (may contain server effective settings)
        let incQuery = '';
        
        if (!svcForLoop.use_fixed_increment) {
          const incVal = Math.max(5, Number(svcForLoop.time_increment_minutes || 30));
          incQuery = `&inc=${incVal}`;
        }
        
        const availUrl = "{% url 'bookings:service_availability' org.slug 'SERVICE_SLUG' %}".replace('SERVICE_SLUG', activeServiceSlug) + `?start=${encodeURIComponent(toIsoLocal(start))}&end=${encodeURIComponent(toIsoLocal(end))}${incQuery}&edge_buffers=${edgeVal}${cacheBuster}`;
        fetches.push(
          fetch(availUrl)
            .then(r => r.ok ? r.json() : [])
            .then(slots => { detailedDayHasSlots[dateKey] = Array.isArray(slots) && slots.length > 0; })
            .catch(() => { detailedDayHasSlots[dateKey] = false; })
        );
      } else {
        detailedDayHasSlots[dateKey] = false; // past or summary says no
      }
    }

    // Wait for all detailed availability calls to resolve
    try { await Promise.all(fetches); } catch (_) {}

    // If a newer render started, abort applying this one
    if (myToken !== renderToken) {
      return;
    }

    // Now render circles in one batch with accurate disabled states
    const circles = [];
    for (let day = 1; day <= numDays; day++) {
      const date = new Date(year, month, day);
      const circle = document.createElement("div");
      circle.className = "day-circle";
      circle.innerText = day;
      const yyyy = date.getFullYear();
      const mm = String(date.getMonth()+1).padStart(2,'0');
      const dd = String(date.getDate()).padStart(2,'0');
      const dateKey = `${yyyy}-${mm}-${dd}`;
      circle.dataset.date = dateKey;

      const enabled = date >= todayMidnight && !!detailedDayHasSlots[dateKey];
      if (enabled) {
        circle.style.cursor = 'pointer';
        circle.tabIndex = 0;
        circle.addEventListener("click", () => openTimeModal(year, month, day, dateKey));
      } else {
        circle.classList.add("disabled");
        circle.style.pointerEvents = 'none';
        circle.style.cursor = 'not-allowed';
        circle.setAttribute('aria-disabled', 'true');
        circle.tabIndex = -1;
      }
      fragment.appendChild(circle);
      circles.push(circle);
    }

    // Append all circles in one batch to prevent partial paints
    dayGrid.appendChild(fragment);

    // Fade in the newly-rendered month
    requestAnimationFrame(() => {
      if (myToken !== renderToken) return;
      dayGrid.classList.remove('is-fading');
      monthHeader.classList.remove('is-fading');
    });
    } catch (e) {
      console.error('generateCalendar failed', e);
      // If this is still the latest render, don't leave the UI in a faded-out state.
      requestAnimationFrame(() => {
        if (myToken !== renderToken) return;
        dayGrid.classList.remove('is-fading');
        monthHeader.classList.remove('is-fading');
      });
    } finally {
      // Only the latest render should control the busy state.
      if (myToken === renderToken) {
        isRendering = false;
        setCalendarBusy(false);
      }
    }
  }

  // Fetch availability from server and show time circles for selected day
  async function openTimeModal(year, month, day, dateKey) {
    // Default the booking modal to the service currently selected on the calendar.
    try {
      const selectedSlug = window.selectedServiceSlug || '{{ service.slug }}';
      if (serviceSelect && selectedSlug && serviceSelect.value !== selectedSlug) {
        serviceSelect.value = selectedSlug;
      }
    } catch (e) {}

    // Embedded widget: break out of iframe for actual booking (only when needed).
    try {
      if (window.CC_IS_EMBED && window.CC_EMBED_BREAKOUT) {
        try {
          if (window.top) {
            window.top.location.href = window.CC_TOP_BOOK_URL;
          } else {
            window.location.href = window.CC_TOP_BOOK_URL;
          }
        } catch (e) {
          window.location.href = window.CC_TOP_BOOK_URL;
        }
        return;
      }
    } catch (e) {}

    const date = new Date(year, month, day);
    selectedDateLabel.innerText = date.toDateString();
    timeSlots.innerHTML = "";

    // Guard: if summary indicates no slots, do not open.
    // Important: if the summary is missing (e.g., batch fetch failed), don't block —
    // the modal will fetch live availability below.
    const hasSummary = (function () {
      try { return Object.prototype.hasOwnProperty.call(dayHasSlots || {}, dateKey); } catch (e) { return false; }
    })();
    if (hasSummary) {
      const summary = dayHasSlots[dateKey];
      // Robust guard: treat ambiguous or empty shapes as no slots
      let summaryNoSlots = (
        summary === null || summary === false || summary === 0 || summary === "0" ||
        (Array.isArray(summary) && summary.length === 0)
      );
      if (!summaryNoSlots && typeof summary === 'object' && summary !== null) {
        const hasCount = ('count' in summary) && Number(summary.count) === 0;
        const hasEmptySlots = ('slots' in summary) && Array.isArray(summary.slots) && summary.slots.length === 0;
        summaryNoSlots = hasCount || hasEmptySlots;
      }
      if (!summaryNoSlots && typeof summary === 'string') {
        const s = summary.trim();
        if (s === '' || s === 'false' || s === '0') {
          summaryNoSlots = true;
        } else if (s.startsWith('[') || s.startsWith('{')) {
          try {
            const parsed = JSON.parse(s);
            if (Array.isArray(parsed)) summaryNoSlots = parsed.length === 0;
            else if (parsed && typeof parsed === 'object') {
              const c0 = ('count' in parsed) && Number(parsed.count) === 0;
              const e0 = ('slots' in parsed) && Array.isArray(parsed.slots) && parsed.slots.length === 0;
              summaryNoSlots = c0 || e0;
            }
          } catch (_) {
            summaryNoSlots = true;
          }
        } else {
          summaryNoSlots = true;
        }
      }
      if (summaryNoSlots) {
        return; // prevent opening modal for fully booked day
      }
    }

    // Build local ISO (avoid timezone drift like 1am)
    const rangeStartDate = new Date(year, month, day, 0, 0, 0);
    const rangeEndDate = new Date(year, month, day, 23, 59, 59);
    function toIsoLocal(d) {
      const pad = n => String(n).padStart(2,'0');
      const yyyy = d.getFullYear();
      const mm = pad(d.getMonth() + 1);
      const dd = pad(d.getDate());
      const HH = pad(d.getHours());
      const MM = pad(d.getMinutes());
      return `${yyyy}-${mm}-${dd}T${HH}:${MM}:00`;
    }

    try {
      // Add cache-busting timestamp to always fetch fresh data
      const cacheBuster = `&_t=${Date.now()}`;
      // Fetch ONLY availability - include increment override so backend can adjust slot stepping
      // Prefer server-side effective settings (this reflects saved changes). Fall back
      // to localStorage/client override when server call fails.
      let previewIncrement = 30;
      let eff = null; // effective settings from server
      try {
        const svcSlugLocal = window.selectedServiceSlug || '{{ service.slug }}';
        const effUrl = "{% url 'bookings:service_effective_settings' org.slug 'SERVICE_SLUG' %}".replace('SERVICE_SLUG', svcSlugLocal) + '?date=' + encodeURIComponent(toIsoLocal(rangeStartDate).split('T')[0]);
        const effResp = await fetch(effUrl);
        if (effResp.ok) {
            eff = await effResp.json();
            if (eff && typeof eff.time_increment_minutes === 'number') previewIncrement = eff.time_increment_minutes;
            
          } else {
            
          }
      } catch (e) {
        
      }
      try {
        if (!eff) {
          const svc = SERVICE_MAP[window.selectedServiceSlug || '{{ service.slug }}'] || {};
          if (typeof svc.time_increment_minutes === 'number') previewIncrement = svc.time_increment_minutes;
          const rawPreview = localStorage.getItem('client_view_settings');
          if (rawPreview) {
            const parsed = JSON.parse(rawPreview);
            if (typeof parsed.increment === 'number') previewIncrement = parsed.increment;
          }
        }
      } catch (e) {}

      function updateServiceDetails(slug) {
        const d = SERVICE_MAP[slug];
        if (!d) return;
        svcName.textContent = d.name;
        svcDesc.textContent = d.description || "—";
        svcDuration.textContent = d.duration || 0;
        svcPrice.textContent = (typeof d.price === 'number') ? d.price.toFixed(2) : d.price;
        // Populate team members into the booking modal (reads option dataset if available)
        try {
          const opt = serviceSelect && serviceSelect.options ? serviceSelect.options[serviceSelect.selectedIndex] : null;
          const assigned = (opt && opt.dataset && opt.dataset.assignedNames) ? opt.dataset.assignedNames : (d.assigned_names || '');
          const svcTeamEl = document.getElementById('svcTeam');
          if (svcTeamEl) svcTeamEl.textContent = assigned || '—';
        } catch (err) { /* ignore */ }
        if (d.refunds_allowed) {
          svcRefundLine.textContent = `Refunds permitted except within ${d.refund_cutoff_hours} hours of the appointment.`;
          if (d.refund_policy_text) {
            svcRefundText.style.display = '';
            svcRefundText.textContent = d.refund_policy_text;
          } else {
            svcRefundText.style.display = 'none';
            svcRefundText.textContent = '';
          }
        } else {
          svcRefundLine.textContent = 'Refunds are not permitted for this service.';
          svcRefundText.style.display = 'none';
          svcRefundText.textContent = '';
        }
        // Client-facing modal intentionally omits buffer/increment/fixed/allow details
      }

      // Initialize details
      updateServiceDetails(serviceSelect.value);
      updatePaymentSectionForServiceSlug(serviceSelect.value);
      serviceSelect.addEventListener('change', (e) => {
        updateServiceDetails(e.target.value);
        updatePaymentSectionForServiceSlug(e.target.value);
      });
      // Include edge buffer preference (prefer server setting, allow local override)
      const edgeVal2 = (function(){
        try {
          const raw = localStorage.getItem('edge_buffers_' + (window.selectedServiceSlug || '{{ service.slug }}'));
          if (raw === '1' || raw === 'true') return 1;
          if (raw === '0' || raw === 'false') return 0;
        } catch (e) {}
        // Default to 0 (do not apply edge buffers) unless explicitly overridden.
        return 0;
      })();
      // If service enforces fixed increments, don't send `inc` so server uses duration+buffer
      // Determine whether server indicates use_fixed_increment; prefer eff if present
      const svcPreview = SERVICE_MAP[window.selectedServiceSlug || '{{ service.slug }}'] || {};
      const useFixed = (eff && typeof eff.use_fixed_increment === 'boolean') ? eff.use_fixed_increment : !!svcPreview.use_fixed_increment;
      const previewIncQuery = (useFixed ? '' : `&inc=${previewIncrement}`);
      const svcSlug = serviceSelect.value || window.selectedServiceSlug || '{{ service.slug }}';
      let allowEndsForAvail = false;
      try {
        allowEndsForAvail = (eff && typeof eff.allow_ends_after_availability === 'boolean') ? !!eff.allow_ends_after_availability : !!svcPreview.allow_ends_after_availability;
      } catch (err) { /* ignore */ }
      const availUrl = "{% url 'bookings:service_availability' org.slug 'SERVICE_SLUG' %}".replace('SERVICE_SLUG', svcSlug) + `?start=${encodeURIComponent(toIsoLocal(rangeStartDate))}&end=${encodeURIComponent(toIsoLocal(rangeEndDate))}${previewIncQuery}&edge_buffers=${edgeVal2}&allow_ends_after_availability=${allowEndsForAvail?1:0}${cacheBuster}`;
      
      const availResp = await fetch(availUrl);
      if (!availResp.ok) throw new Error("Failed to load availability");
      const slots = await availResp.json();

      // If detailed fetch yields no slots, do not mutate the day circle state.
      // Simply avoid opening the modal or show a lightweight notice.
      if (!Array.isArray(slots) || slots.length === 0) {
        // Avoid turning the circle grey on click; just return quietly
        return;
      }

      // Read client view settings (saved from internal calendar)
      // Default increment starts as the previewIncrement (which prefers server eff when available)
      let clientSettings = { block: 1, increment: previewIncrement, startHour: 9 };
      try {
        const raw = localStorage.getItem('client_view_settings');
        if (raw) {
          const parsed = JSON.parse(raw);
          if (typeof parsed.block === 'number') clientSettings.block = parsed.block;
          if (typeof parsed.increment === 'number') clientSettings.increment = parsed.increment;
          if (typeof parsed.startHour === 'number') clientSettings.startHour = parsed.startHour;
        }
      } catch (e) {}

      // If we fetched effective server settings, prefer them for the public display
      try {
        if (eff && typeof eff.time_increment_minutes === 'number') {
          clientSettings.increment = eff.time_increment_minutes;
        }
      } catch (e) {}

      const blockMinutes = Math.max(1, clientSettings.block) * 60;
      const inc = Math.max(5, clientSettings.increment);

      // Styles for circles
      const styleId = 'publicTimeCirclesStyle';
      if (!document.getElementById(styleId)) {
        const style = document.createElement('style');
        style.id = styleId;
        style.innerHTML = `
          .time-circle { width: 80px; height: 80px; border-radius: 50%; display:flex; justify-content:center; align-items:center; cursor:pointer; font-size:13px; color:white; transition:transform .1s ease; }
          .time-circle.open { background:#28a745; }
          .time-circle.booked { background:#9ca3af; cursor:not-allowed; }
          .time-circle:hover { transform: scale(1.08); }
          .circles-row { display:flex; align-items:center; justify-content:space-between; gap:8px; border-bottom:1px solid #e5e7eb; padding:8px 0; }
          .circles-hour { width:70px; font-weight:bold; }
          .circles-container { display:flex; flex-wrap:wrap; gap:8px; margin-left:auto; }
          @media (max-width: 768px) {
            .modal-box { width: 95vw; }
            .time-circle { width: 68px; height: 68px; font-size:12px; }
          }
        `;
        document.head.appendChild(style);
      }

      // If no slots, show message
      if (!Array.isArray(slots) || slots.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'text-gray-600';
        empty.innerText = 'No available times on this day.';
        timeSlots.appendChild(empty);
        timeModal.style.display = 'flex';
        return;
      }

      // Convert slots to minute ranges (treat server times as local to avoid TZ drift)
      function isoToLocalMinutes(isoStr) {
        // Expect formats like YYYY-MM-DDTHH:MM or with seconds, possibly with 'Z'.
        // Parse HH and MM directly to avoid timezone shifts.
        const m = isoStr.match(/T(\d{2}):(\d{2})/);
        if (!m) return null;
        const h = parseInt(m[1], 10);
        const mm = parseInt(m[2], 10);
        return h * 60 + mm;
      }
      // Preserve metadata such as violates_buffer when present
      const slotRanges = slots.map(s => {
        const startMin = isoToLocalMinutes(s.start);
        const endMin = isoToLocalMinutes(s.end);
        return { startMin, endMin, meta: { violates_buffer: !!s.violates_buffer } };
      }).filter(r => r.startMin != null && r.endMin != null && r.endMin > r.startMin);

      // Group slots by hour for exact rendering; labels derive from slot starts
      const slotsByHour = new Map(); // hourStartMin -> [{startMin, endMin, label}]
        for (let idx=0; idx<slots.length; idx++) {
          const s = slots[idx];
          const sm = isoToLocalMinutes(s.start);
          const em = isoToLocalMinutes(s.end);
          if (sm == null || em == null || em <= sm) continue;
          const hourKey = Math.floor(sm/60)*60;
          const h = Math.floor(sm/60);
          const m = sm % 60;
          const ampm = h >= 12 ? 'PM' : 'AM';
          let dispH = h % 12; if (dispH === 0) dispH = 12;
          const label = `${dispH}:${String(m).padStart(2,'0')} ${ampm}`;
          const arr = slotsByHour.get(hourKey) || [];
          // attach index so we can cross-reference metadata later
          arr.push({ startMin: sm, endMin: em, label, slotIndex: idx });
          slotsByHour.set(hourKey, arr);
        }

      // Render rows using saved Client View settings (block size + increment),
      // but only at valid server-provided start times.
      if (slotRanges.length > 0) {
        // Do NOT clamp to clientSettings.startHour when earlier valid slots exist;
        // honor the earliest server-provided availability.
        const minStart = Math.min(...slotRanges.map(r => r.startMin));
        const maxEnd = Math.max(...slotRanges.map(r => r.endMin));

        // Map of valid start -> end (from server slots)
        const startToEnd = new Map();
        for (const s of slots) {
          const sm = isoToLocalMinutes(s.start);
          const em = isoToLocalMinutes(s.end);
          if (sm != null && em != null && em > sm) startToEnd.set(sm, em);
        }

        // Helper: format label from minute-of-day
        function labelFromMin(totalMin) {
          const h24 = Math.floor(totalMin/60);
          const m = totalMin % 60;
          const ampm = h24 >= 12 ? 'PM' : 'AM';
          let h = h24 % 12; if (h === 0) h = 12;
          return `${h}:${String(m).padStart(2,'0')} ${ampm}`;
        }

        // NEW: Iterate from earliest start minute directly, stepping by client increment, preserving irregular offsets.
        // Group rows by the hour of each slot's start for readability.
        const validStarts = Array.from(startToEnd.keys()).sort((a,b)=>a-b);
        const hours = [];
        const hourMap = new Map();
        for (const sm of validStarts) {
          const hourStart = Math.floor(sm/60)*60; // minute-of-day of the hour
          if (!hourMap.has(hourStart)) {
            hourMap.set(hourStart, []);
            hours.push(hourStart);
          }
          hourMap.get(hourStart).push(sm);
        }

        for (const hourStart of hours) {
          const row = document.createElement('div');
          row.className = 'circles-row';
          const hourLabel = document.createElement('div');
          hourLabel.className = 'circles-hour';
          const labelDate = new Date(year, month, day);
          labelDate.setHours(Math.floor(hourStart/60), hourStart%60, 0, 0);
          // Show minutes if not on the hour, e.g., 8:20 AM
          const labelOpts = { hour: 'numeric', minute: (hourStart%60!==0?'2-digit':undefined), hour12: true };
          hourLabel.textContent = labelDate.toLocaleString(undefined, labelOpts);
          row.appendChild(hourLabel);

          const circlesContainer = document.createElement('div');
          circlesContainer.className = 'circles-container';

          // Render circles for all server-provided starts (each window may have its own baseline).
          for (const sm of hourMap.get(hourStart)) {
            const endMin = startToEnd.get(sm);
            // find original slot object to read metadata
            const slotObj = slots.find(sl => {
              const ssm = isoToLocalMinutes(sl.start);
              return ssm === sm;
            }) || {};
            const slotKey = `${year}-${month}-${day}-${sm}`;
            const wasBookedThisSession = window.bookedSlotsThisSession.includes(slotKey);
            const circle = document.createElement('div');
            circle.className = wasBookedThisSession ? 'time-circle booked' : 'time-circle open';
            circle.textContent = labelFromMin(sm);
            circle.dataset.startMin = String(sm);
            circle.dataset.endMin = String(endMin);
            // If this slot violates buffer rules we no longer show a tooltip
            // or change the circle background here so it appears like other slots.
            // (Keep metadata on `slotObj` for potential server-side handling.)

            if (!wasBookedThisSession) {
              circle.addEventListener('click', () => {
                const start = new Date(year, month, day);
                const h = Math.floor(sm/60), m = sm % 60;
                start.setHours(h, m, 0, 0);
                const endDate = new Date(start);
                endDate.setMinutes(endDate.getMinutes() + (endMin - sm));
                function toLocalISOString(d) {
                  const pad = n => String(n).padStart(2,'0');
                  return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
                }
                startInput.value = toLocalISOString(start);
                endInput.value = toLocalISOString(endDate);
                const headerText = `${date.toDateString()} • ${labelFromMin(sm)}`;
                selectedDateLabel.innerText = headerText;
                selectedDateTimeLabel.innerText = headerText;
                circle.dataset.slotKey = slotKey;
                timeModalViewSlots.style.display = 'none';
                timeModalViewDetails.style.display = 'block';
              });
            }
            circlesContainer.appendChild(circle);
          }
          if (circlesContainer.children.length > 0) {
            row.appendChild(circlesContainer);
            timeSlots.appendChild(row);
          }
        }
      }

      if (timeSlots.lastElementChild) {
        timeSlots.lastElementChild.style.borderBottom = 'none';
      }
      timeModal.style.display = 'flex';
    } catch (e) {
      console.error(e);
      try { showToast('error', "Could not load availability. Please try another day."); } catch(err){ console.error('toast failed', err); }
    }
  }

  function closeTimeModal() { 
    timeModal.style.display = "none"; 
    // Reset to slots view when closing
    timeModalViewDetails.style.display = 'none';
    if (timeModalViewCheckout) timeModalViewCheckout.style.display = 'none';
    timeModalViewSlots.style.display = 'block';
  }
  window.closeTimeModal = closeTimeModal;

  // Back button to return to time slots view
  const backBtn = document.getElementById('backToSlotsBtn');
  if (backBtn) {
    backBtn.addEventListener('click', () => {
      timeModalViewDetails.style.display = 'none';
      timeModalViewSlots.style.display = 'block';
    });
  }

  // Handle booking form submission - mark slot as booked immediately
  const bookingForm = document.querySelector('#timeModalViewDetails form');
  if (bookingForm) {
    bookingForm.addEventListener('submit', (e) => {
      try{
        const selected = bookingForm.querySelector('input[name="payment_method"]:checked');
        const v = selected ? String(selected.value || '').toLowerCase() : '';
        if (_isOfflineChoice(v)){
          if (v === 'venmo' || v === 'zelle'){
            try {
              const msg = 'This payment method must be paid prior to your appointment. Please scan the QR code to pay now. If you prefer paying later, the QR code is included in your confirmation email.';
              if (typeof showToast === 'function') showToast('warning', msg, 0);
              else alert(msg);
            } catch (e) {}
          } else if (v === 'cash'){
            alert('Cash payments are handled directly with the business. Please bring cash to your appointment as required by the business owner.');
          }
        }
      }catch(err){}
      // Get the slot key from the start input
      const startVal = startInput.value;
      const endVal = endInput.value;
      if (startVal) {
        try {
          const startDate = new Date(startVal);
          const endDate = endVal ? new Date(endVal) : null;
          const slotKey = `${startDate.getFullYear()}-${startDate.getMonth()}-${startDate.getDate()}-${startDate.getHours() * 60 + startDate.getMinutes()}`;
          // Mark this slot as booked for this session
          if (!window.bookedSlotsThisSession.includes(slotKey)) {
            window.bookedSlotsThisSession.push(slotKey);
          }
          // Remove circles that overlap the booked range (including the booked one)
          const bookedStartMin = startDate.getHours() * 60 + startDate.getMinutes();
          const bookedEndMin = endDate ? (endDate.getHours() * 60 + endDate.getMinutes()) : (bookedStartMin);
          document.querySelectorAll('#timeSlots .time-circle').forEach(c => {
            const sm = parseInt(c.dataset.startMin || '-1', 10);
            const em = parseInt(c.dataset.endMin || '-1', 10);
            if (sm >= 0 && em >= 0) {
              const overlaps = !(em <= bookedStartMin || sm >= bookedEndMin);
              if (overlaps) {
                c.remove();
              }
            }
          });
        } catch (err) {
          console.error('Failed to track booked slot:', err);
        }
      }
      // Form will submit normally and redirect
    });
  }

  // If this page load is a Stripe embedded-checkout continuation, open the modal and mount Stripe.
  const openCheckout = {{ open_checkout|default:False|yesno:"true,false" }};
  const stripePublishableKey = "{{ stripe_publishable_key|default:''|escapejs }}";
  const stripeClientSecret = "{{ stripe_client_secret|default:''|escapejs }}";
  const stripeConnectedAccountId = "{{ stripe_connected_account_id|default:''|escapejs }}";
  if (openCheckout && stripePublishableKey && stripeClientSecret && timeModal && timeModalViewCheckout) {
    try {
      timeModalViewSlots.style.display = 'none';
      timeModalViewDetails.style.display = 'none';
      timeModalViewCheckout.style.display = 'block';
      timeModal.style.display = 'flex';
    } catch (e) {}

    (async function () {
      try {
        if (typeof Stripe !== 'function') throw new Error('Stripe.js not loaded');
        const stripe = stripeConnectedAccountId ? Stripe(stripePublishableKey, { stripeAccount: stripeConnectedAccountId }) : Stripe(stripePublishableKey);
        const checkout = await stripe.initEmbeddedCheckout({ clientSecret: stripeClientSecret });
        checkout.mount('#embedded-checkout');
      } catch (err) {
        const wrap = document.getElementById('embedded-checkout');
        if (wrap) wrap.innerHTML = '<div class="text-sm text-red-600">Unable to load payment form. Please refresh and try again.</div>';
      }
    })();
  }

  // Ensure header and grid start transparent, preventing any crossfade flash
  dayGrid.classList.add('is-fading');
  monthHeader.classList.add('is-fading');

  // Initial render
  try { generateCalendar(currentMonth, currentYear); } catch (e) { console.error('generateCalendar failed', e); }

  if (prevBtn) {
    prevBtn.onclick = function () {
      // Prevent overlapping renders; queue the latest intent
      if (isRendering) return;
      if (currentMonth === 0) { currentMonth = 11; currentYear--; } else { currentMonth--; }
      generateCalendar(currentMonth, currentYear);
    };
  }
  if (nextBtn) {
    nextBtn.onclick = function () {
      if (isRendering) return;
      if (currentMonth === 11) { currentMonth = 0; currentYear++; } else { currentMonth++; }
      generateCalendar(currentMonth, currentYear);
    };
  }

  // Re-render the month grid when the main service selector changes.
  // (Previously the change handler lived in a different script scope and could not call `generateCalendar`.)
  const mainServiceSelect = document.getElementById('mainServiceSelect');
  if (mainServiceSelect) {
    mainServiceSelect.addEventListener('change', function (e) {
      window.selectedServiceSlug = e.target.value;
      // Always re-render current month/year for the newly selected service.
      generateCalendar(currentMonth, currentYear);
    });
  }

  // No service selection impacts availability at this stage; service is chosen in the booking form
});
</script>
{% endblock %}
