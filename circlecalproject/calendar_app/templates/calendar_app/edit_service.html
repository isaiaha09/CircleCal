{% extends "calendar_app/base.html" %}
{% load circlecal_filters %}

{% block title %}Edit Service • {{ org.name }}{% endblock %}

{# Mobile-only: break out of base <main> constraints; keep normal base layout on sm+ #}
{% block main_class %}w-full max-w-none px-0 py-0 sm:max-w-6xl sm:mx-auto sm:px-4 sm:py-6 md:px-6 md:py-8{% endblock %}

{% block content %}
{% block extra_head %}
<style>
  /* Match the palette tokens used in calendar.html (base.html does not define these) */
  :root {
    --primary-500: #3b82f6;
    --primary-600: #2563eb;
    --primary-700: #1d4ed8;
    --success-500: #10b981;
    --success-600: #059669;
    --danger-500: #ef4444;
    --danger-600: #dc2626;
    --gray-50: #f9fafb;
    --gray-100: #f3f4f6;
    --gray-200: #e5e7eb;
    --gray-300: #d1d5db;
    --gray-600: #4b5563;
    --gray-700: #374151;
    --gray-900: #111827;
  }

  /* Page-specific enhanced field styling (aligned with create service) */
  .cc-field {
    border: 1px solid #d1d5db; /* gray-300 */
    background: #ffffff;
    padding: 0.7rem 0.9rem;
    border-radius: 0.5rem;
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.6);
    font-size: 0.97rem;
    width: 100%;
  }
  .cc-field[disabled] { background:#f8fafc; opacity:.9; }
  .cc-field:focus { outline:none; border-color:#2563eb; box-shadow:0 0 0 4px rgba(37,99,235,0.08); }
  /* Mobile: use ~95% screen width; restore existing padding on sm+ */
  .cc-page { width:95vw; max-width:78rem; margin:0 auto; padding:2.5rem 0; }
  @media (min-width:640px){ .cc-page { width:auto; padding:2.5rem 1.5rem; } }
  @media (min-width:768px){ .cc-page { padding:3rem 2rem; } }

  /* Mobile-only: slightly smaller placeholder/example text */
  @media (max-width: 640px) {
    .cc-page input::placeholder,
    .cc-page textarea::placeholder {
      font-size: 0.85rem;
    }

    /* Stack top/bottom action bars and shrink buttons */
    .cc-page .svc-actionbar,
    .cc-page .svc-actionbar-bottom {
      flex-direction: column;
      align-items: stretch;
      gap: 10px;
    }
    .cc-page .svc-actionbar a,
    .cc-page .svc-actionbar-bottom a {
      text-align: center;
    }
    .cc-page .svc-actionbar-actions,
    .cc-page .svc-actionbar-actions-bottom {
      flex-direction: column;
      align-items: stretch;
      gap: 10px;
    }

    /* Mobile-only: swap Cancel and View public page positions (above title). */
    .cc-page .svc-actionbar > a {
      order: 2;
    }
    .cc-page .svc-actionbar .svc-actionbar-actions {
      order: 1;
    }
    .cc-page .svc-actionbar #svc-view-btn {
      order: 0;
    }
    .cc-page .svc-actionbar .svc-save-btn {
      order: 1;
    }
    .cc-page .svc-save-btn,
    .cc-page #svc-view-btn,
    .cc-page #svc-view-btn-bottom {
      width: 100%;
      margin-left: 0 !important;
      padding: 9px 12px !important;
      font-size: 0.85rem !important;
      justify-content: center;
    }

    /* Stack 2-col grids vertically on mobile */
    .cc-page .grid.grid-cols-2 {
      grid-template-columns: repeat(1, minmax(0, 1fr)) !important;
    }

    /* Service availability: compact typography/controls */
    #cc-open-calendar-from-service {
      width: 100%;
      justify-content: center;
      padding: 8px 10px;
      font-size: 0.85rem;
    }
    #svcAvailEditor > div > div.flex {
      flex-direction: column;
      align-items: flex-start;
      gap: 6px;
    }
    #svcAvailEditor > div > div.flex > div:first-child {
      font-size: 0.95rem;
      width: auto !important;
    }
    #svcAvailEditor .svc-day-editor label,
    #svcAvailEditor .svc-day-editor .text-sm {
      font-size: 0.85rem;
    }
    #svcAvailEditor .svc-day-editor .text-xs,
    #svcAvailEditor .svc-add-range {
      font-size: 0.8rem;
    }
    #svcAvailEditor .svc-add-range {
      margin-top: 8px !important;
    }
    #svcAvailEditor .svc-range-row {
      flex-wrap: wrap;
      gap: 8px !important;
    }
    #svcAvailEditor .svc-range-row .time-input-container {
      flex: 1 1 calc(50% - 6px);
      min-width: 0;
    }
    #svcAvailEditor input.range-start,
    #svcAvailEditor input.range-end {
      max-width: none !important;
      width: 100%;
      padding: 6px 8px;
      font-size: 0.9rem;
    }
    #svcAvailEditor .svc-range-row button {
      flex: 1 1 100%;
      padding: 8px 10px;
      border: 1px solid var(--gray-300);
      border-radius: 10px;
      background: var(--gray-50);
      font-size: 0.85rem;
    }
    #svcAvailEditor .custom-time-picker {
      min-width: 240px;
      max-width: 92vw;
      padding: 12px;
    }
    #svcAvailEditor .time-picker-display {
      font-size: 24px;
      margin-bottom: 12px;
    }
    #svcAvailEditor .time-picker-selectors {
      gap: 10px;
      margin-bottom: 12px;
    }
    #svcAvailEditor .time-scroll-container {
      height: 140px;
    }
    #svcAvailEditor .time-option {
      padding: 8px;
      font-size: 13px;
    }
    #svcAvailEditor .time-picker-btn {
      padding: 8px;
      font-size: 12px;
    }
  }
  .section-card { background:#fff; border:1px solid #c0c7d1; border-radius:0.75rem; padding:1rem 1.25rem; margin-bottom:1rem; }
  /* Make all section cards fill the page content area so they align with other sections */
  .section-card { box-sizing: border-box; width: 100%; max-width: none; margin-left: 0; margin-right: 0; }
  .section-title { font-size:1rem; font-weight:600; margin-bottom:0.5rem; }
  /* Inputs inside section cards use a unified light border so areas are obvious */
  .section-card input[type="text"],
  .section-card input[type="number"],
  .section-card input[type="email"],
  .section-card textarea,
  .section-card select,
  .section-card .cc-field,
  .section-card .mt-1.block {
    border: 1px solid #c0c7d1; /* same as card border (darker) */
    background: #ffffff;
    padding: 0.6rem 0.8rem;
    border-radius: 0.5rem;
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.6);
  }
  .section-card input[disabled], .section-card textarea[disabled] { background:#f8fafc; opacity:.95; }
  .section-card input:focus, .section-card textarea:focus, .section-card select:focus, .section-card .cc-field:focus {
    outline: none;
    border-color: #2563eb;
    box-shadow: 0 0 0 4px rgba(37,99,235,0.06);
  }
  /* Availability disabled overlay */
  .availability-disabled { position: relative; opacity: 0.8; }
  .availability-disabled .availability-overlay { position: absolute; inset: 0; background: rgba(255,255,255,0.85); display:flex; align-items:center; justify-content:center; border-radius:0.75rem; z-index:20; }
  .availability-disabled .availability-overlay .msg { max-width:56rem; padding:1rem 1.5rem; text-align:center; color:#374151; }

  /* Service availability: hard-lock days that are fully blocked by member availability */
  #svcAvailEditor .cc-svc-day-locked {
    opacity: 0.6;
    background: #f9fafb;
  }
  #svcAvailEditor .cc-svc-day-locked .svc-day-editor,
  #svcAvailEditor .cc-svc-day-locked .svc-day-editor * {
    pointer-events: none;
  }
  #svcAvailEditor .cc-svc-day-locked .svc-day-editor {
    cursor: not-allowed;
  }

  /* Locked advanced settings overlay */
  .cc-adv-lock-wrap { position: relative; }
  .cc-adv-lock-wrap.cc-adv-locked,
  .cc-adv-lock-wrap.cc-adv-locked * {
    cursor: default !important;
  }
  .cc-adv-lock-overlay {
    position: absolute;
    inset: 0;
    z-index: 50;
    background: rgba(255, 255, 255, 0.01);
    cursor: default;
    border-radius: 0.5rem;
  }
  /* Selected member chips shown in the dropdown label */
  .member-chip { display:inline-block; background:#eef6ff; color:#0b5cff; padding:6px 10px; border-radius:999px; font-size:0.95rem; margin-right:6px; margin-bottom:2px; }
  .member-chip .member-chip-remove { display:inline-block; margin-left:8px; color:#0840c6; background:transparent; border-radius:999px; padding:0 6px; cursor:pointer; font-weight:700; line-height:1; }
  .member-chip .member-chip-remove:hover { background:rgba(11,92,255,0.08); }

  /* Service availability: match Calendar default availability time picker UI */
  #svcAvailEditor .time-input-container { position: relative; display: inline-block; }
  /* Border around each time range row (Start/End/Remove) */
  #svcAvailEditor .svc-range-row {
    border: none;
    border-radius: 0;
    padding: 0;
    background: transparent;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  #svcAvailEditor .svc-range-row .cc-field {
    border: 1px solid var(--gray-900);
  }
  #svcAvailEditor .range-start,
  #svcAvailEditor .range-end {
    text-align: center;
    padding: 6px 8px;
    border-radius: 8px;
    border: 1px solid var(--gray-900);
    background: white;
    font-weight: 600;
    min-width: 0;
  }

  #svcAvailEditor .custom-time-picker {
    position: absolute;
    top: calc(100% + 5px);
    left: 0;
    background: white;
    border: 1px solid var(--gray-300);
    border-radius: 12px;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15), 0 4px 10px rgba(0, 0, 0, 0.1);
    z-index: 2000;
    padding: 16px;
    min-width: 280px;
    display: none;
    animation: svcSlideDown 0.2s ease-out;
  }
  @keyframes svcSlideDown {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
  }
  #svcAvailEditor .custom-time-picker.active { display: block; }

  #svcAvailEditor .time-picker-header {
    font-size: 13px;
    font-weight: 600;
    color: var(--gray-700);
    margin-bottom: 12px;
    text-align: center;
  }
  #svcAvailEditor .time-picker-display {
    font-size: 32px;
    font-weight: 700;
    text-align: center;
    color: var(--primary-600);
    margin-bottom: 16px;
    font-variant-numeric: tabular-nums;
    letter-spacing: 0.05em;
  }
  #svcAvailEditor .time-picker-selectors { display: flex; gap: 12px; margin-bottom: 16px; }
  #svcAvailEditor .time-selector { flex: 1; display: flex; flex-direction: column; gap: 8px; }
  #svcAvailEditor .time-selector-label {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    color: var(--gray-600);
    text-align: center;
    letter-spacing: 0.5px;
  }
  #svcAvailEditor .time-scroll-container {
    height: 180px;
    overflow-y: auto;
    border: 1px solid var(--gray-200);
    border-radius: 8px;
    background: var(--gray-50);
    padding: 4px;
  }
  #svcAvailEditor .time-scroll-container::-webkit-scrollbar { width: 6px; }
  #svcAvailEditor .time-scroll-container::-webkit-scrollbar-track { background: transparent; }
  #svcAvailEditor .time-scroll-container::-webkit-scrollbar-thumb { background: var(--gray-300); border-radius: 3px; }
  #svcAvailEditor .time-option {
    padding: 10px;
    text-align: center;
    cursor: pointer;
    border-radius: 6px;
    font-size: 15px;
    font-weight: 500;
    transition: all 0.15s ease;
    color: var(--gray-700);
  }
  #svcAvailEditor .time-option:hover { background: white; color: var(--primary-600); }
  #svcAvailEditor .time-option.selected { background: var(--primary-500); color: white; font-weight: 600; }
  #svcAvailEditor .time-option.disabled {
    opacity: 0.35;
    filter: grayscale(1);
    cursor: not-allowed;
    pointer-events: none;
  }
  #svcAvailEditor .time-picker-actions { display: flex; gap: 8px; margin-top: 12px; align-items: stretch; }
  #svcAvailEditor .time-picker-btn {
    flex: 1;
    padding: 10px;
    border: 1px solid var(--gray-300);
    border-radius: 8px;
    font-weight: 600;
    font-size: 13px;
    cursor: pointer;
    transition: all 0.15s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    line-height: 1.1;
  }
  #svcAvailEditor .time-picker-btn.confirm { background: var(--primary-500); border-color: var(--primary-700); color: white; }
  #svcAvailEditor .time-picker-btn.confirm:hover {
    background: var(--primary-600);
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
  }
  #svcAvailEditor .time-picker-btn.cancel { background: var(--gray-50); border-color: var(--gray-300); color: var(--gray-900); }
  #svcAvailEditor .time-picker-btn.cancel:hover { background: var(--gray-300); }

  /* Mobile: keep time range rows + picker fully within container */
  @media (max-width: 640px) {
    #svcAvailEditor .svc-range-row {
      flex-wrap: wrap;
      gap: 10px;
    }
    #svcAvailEditor .svc-range-row .time-input-container {
      flex: 1 1 calc(50% - 10px);
      min-width: 0;
    }
    #svcAvailEditor input.range-start,
    #svcAvailEditor input.range-end {
      width: 100%;
      max-width: none;
    }
    #svcAvailEditor .svc-range-row button {
      flex: 1 1 100%;
      text-align: left;
      padding: 6px 0;
    }

    #svcAvailEditor .custom-time-picker {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      animation: none;
      min-width: 0;
      width: min(360px, 92vw);
      max-width: 92vw;
      max-height: 90vh;
      overflow-y: auto;
      box-sizing: border-box;
      margin: 0;
      z-index: 2600;
    }
    #svcAvailEditor .time-scroll-container {
      height: 160px;
    }
    #svcAvailEditor .time-picker-btn {
      min-width: 0;
    }
  }

  /* Extra-small mobile: 320px wide devices */
  @media (max-width: 360px) {
    #svcAvailEditor .svc-range-row {
      gap: 8px;
    }
    #svcAvailEditor .range-start,
    #svcAvailEditor .range-end {
      font-size: 10px;
      padding: 6px 4px;
      line-height: 1.2;
    }
    #svcAvailEditor .custom-time-picker {
      width: min(320px, 94vw);
      padding: 14px;
    }
    #svcAvailEditor .time-picker-display {
      font-size: 28px;
    }
    #svcAvailEditor .time-option {
      padding: 8px;
      font-size: 14px;
    }
    #svcAvailEditor .time-picker-btn {
      font-size: 13px;
      padding: 10px 8px;
    }
  }

  /* Saving overlay (shown while AJAX save runs) */
  #svc-saving-overlay {
    position: fixed;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    background: rgba(17, 24, 39, 0.35); /* gray-900 with alpha */
    z-index: 2500;
  }
  #svc-saving-overlay.active { display: flex; }
  #svc-saving-overlay .panel {
    background: #ffffff;
    border: 1px solid var(--gray-200);
    border-radius: 14px;
    padding: 16px 18px;
    min-width: 280px;
    max-width: 92vw;
    display: flex;
    align-items: center;
    gap: 12px;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.18);
  }
  #svc-saving-overlay .spinner {
    width: 22px;
    height: 22px;
    border-radius: 999px;
    border: 3px solid var(--gray-200);
    border-top-color: var(--primary-600);
    animation: svcSpin 0.8s linear infinite;
    flex: 0 0 auto;
  }
  @keyframes svcSpin { to { transform: rotate(360deg); } }
  #svc-saving-overlay .text {
    display: flex;
    flex-direction: column;
    gap: 2px;
  }
  #svc-saving-overlay .title { font-weight: 700; color: var(--gray-900); }
  #svc-saving-overlay .sub { font-size: 0.9rem; color: var(--gray-700); }
</style>
{% endblock %}

<div class="cc-page">
  <div id="svc-saving-overlay" role="status" aria-live="polite" aria-hidden="true">
    <div class="panel">
      <div class="spinner" aria-hidden="true"></div>
      <div class="text">
        <div class="title">Saving changes…</div>
        <div class="sub">Please wait.</div>
      </div>
    </div>
  </div>
  <form class="cc-form" method="post">
    {% csrf_token %}
  {% if request.GET.saved %}
    <div id="svc-saved-banner" class="mb-4 p-3 rounded bg-green-50 border-l-4 border-green-400 text-green-800 text-center" role="status" aria-live="polite">
      <strong>Changes saved</strong>
      <div class="text-sm mt-1">Your changes were saved successfully.</div>
    </div>
  {% endif %}
  {% if request.GET.public_show_denied %}
    <div class="mb-4 p-3 rounded bg-red-50 border-l-4 border-red-400 text-red-900 text-center" role="alert" aria-live="polite">
      <strong>Public visibility not enabled</strong>
      <div class="text-sm mt-1">
        {{ request.GET.public_show_reason|default:"This service can't be shown publicly yet." }}
      </div>
      <div class="text-sm mt-2 text-red-800">Fix the issue above (availability + settings), then turn on “Show on public booking page” again.</div>
    </div>
  {% endif %}
  <!-- Top action buttons: Cancel (left) and Save (right) -->
  <div class="flex items-center justify-between mb-4 svc-actionbar">
    <a href="{% url 'calendar_app:dashboard' org.slug %}" class="text-sm text-gray-500 hover:text-gray-700">Cancel</a>
    <div class="flex items-center svc-actionbar-actions">
      <button type="button" class="svc-save-btn inline-flex items-center px-4 py-2 rounded-md bg-blue-600 text-white text-sm font-medium hover:bg-blue-700">Save Changes</button>
      <a id="svc-view-btn" data-saved="{{ request.GET.saved|yesno:'1,0' }}" href="{% url 'bookings:public_service_page' org.slug service.slug %}" target="_blank" rel="noopener noreferrer" class="inline-flex items-center px-3 py-2 ml-3 rounded-md text-sm font-medium border border-blue-600 text-blue-600 bg-white hover:bg-blue-50 {% if not request.GET.saved %}opacity-50 cursor-not-allowed{% endif %}">View public page</a>
    </div>
  </div>

  <h1 class="text-2xl font-semibold mb-2 text-center">Edit Service</h1>
  <p class="text-sm text-gray-500 mb-6 text-center max-w-2xl mx-auto">
    Update your service details.
  </p>

    <!-- Public visibility toggle (availability-fit gated) -->
    <div class="section-card mb-4" style="border:1px solid #2563eb;background:#f0f9ff;box-shadow:0 2px 6px rgba(37,99,235,0.06);">
      <div class="flex items-center justify-between">
        <div>
          <label for="show_on_public_calendar" class="inline-flex items-center">
            <input type="checkbox" name="show_on_public_calendar" id="show_on_public_calendar"
                   {% if service.show_on_public_calendar %}checked{% endif %}
              class="rounded border-gray-300 text-blue-600 focus:ring-blue-500 {% if public_show_locked and not service.show_on_public_calendar or service_availability_fully_blocked and not service.show_on_public_calendar or not can_toggle_public %}opacity-60 cursor-not-allowed{% endif %}"
              {% if public_show_locked and not service.show_on_public_calendar or service_availability_fully_blocked and not service.show_on_public_calendar or not can_toggle_public %}disabled aria-disabled="true"{% endif %}>
            <div class="ml-3">
              <div class="text-lg font-semibold text-gray-800">Show on public booking page</div>
              <div class="text-sm text-gray-600">Clients can see and book this service</div>
            </div>
          </label>
          {% if not can_toggle_public %}
            <p class="mt-2 text-sm text-gray-700">Only owners/GMs can change public visibility.</p>
          {% elif service_availability_fully_blocked and not service.show_on_public_calendar %}
            <p class="mt-2 text-sm text-gray-700">{{ service_availability_fully_blocked_reason|default:"This service cannot be shown publicly yet." }}</p>
          {% elif public_show_locked %}
            <p class="mt-2 text-sm text-gray-700">{{ public_show_reason }}</p>
          {% elif service.show_on_public_calendar and not can_show_publicly %}
            <p class="mt-2 text-sm text-gray-700">{{ public_show_reason }}</p>
          {% endif %}
        </div>
        <div class="text-sm text-gray-700">
          <span class="inline-flex items-center px-2 py-1 rounded bg-white text-gray-700">Important</span>
        </div>
      </div>
    </div>

    <script>
    // Hours / minutes helper for buffer_after: keep hidden `buffer_after` in minutes in-sync
    document.addEventListener('DOMContentLoaded', function(){
      try{
        const hidden = document.getElementById('buffer_hidden');
        const h = document.getElementById('buffer_hours');
        const m = document.getElementById('buffer_minutes');
        if (!hidden || !h || !m) return;

        function setFieldsFromHidden(){
          const total = Number(hidden.value) || 0;
          const hours = Math.floor(total / 60);
          const mins = total % 60;
          h.value = hours;
          m.value = mins;
        }

        function updateHidden(){
          const hours = Math.max(0, Number(h.value) || 0);
          let mins = Math.max(0, Number(m.value) || 0);
          if (mins > 59) mins = 59;
          const total = (hours * 60) + mins;
          hidden.value = total;
        }

        h.addEventListener('input', updateHidden);
        m.addEventListener('input', updateHidden);

        // initialize
        setFieldsFromHidden();
      } catch(e){ console.warn('buffer hours/min wiring failed', e); }
    });
    </script>

    {% if needs_migration %}
      <div class="mb-4 p-3 rounded bg-yellow-50 border-l-4 border-yellow-400 text-yellow-800">
        <strong>Database migration required:</strong>
        <div class="text-sm">The feature "Allow appointment to end after availability" requires a database migration. Please run <code>python manage.py migrate</code> on the server to enable this setting.</div>
      </div>
    {% endif %}

    <div class="section-card">
      <div class="section-title">Basic Info</div>
      <div class="mb-3">
        <label class="block text-sm font-medium text-gray-700">Name</label>
        <input name="name" type="text" required value="{{ service.name }}" class="cc-field mt-1 w-full">
      </div>
      <div class="mb-3">
        <label class="block text-sm font-medium text-gray-700">Slug (URL-friendly)</label>
        {% if can_edit_slug %}
          <input name="slug" type="text" value="{{ service.slug }}" class="cc-field mt-1 w-full">
          <p class="mt-1 text-xs text-gray-500">You may change the URL slug while no bookings exist for this service. Once a booking exists, the slug becomes immutable to avoid breaking booking links.</p>
        {% else %}
          <input type="text" value="{{ service.slug }}" disabled class="cc-field mt-1 w-full">
          <p class="mt-1 text-xs text-gray-500">Slug cannot be changed because this service already has bookings. To edit the slug, remove all bookings first.</p>
        {% endif %}
      </div>
      <div>
        <label class="block text-sm font-medium text-gray-700">Description</label>
        <textarea name="description" rows="4" class="cc-field mt-1 w-full">{{ service.description }}</textarea>
      </div>
    </div>

    <!-- core timing controls are shown below in a grouped card -->

    {% if is_team_plan %}
    <!-- Assign service to one or more team members -->
    <div class="section-card">
      <div class="section-title">Assign to team members</div>
      <p class="text-sm text-gray-600 mb-3">Select which team member(s) can deliver this service. Leave empty to make the service unassigned.</p>

      <div class="mb-3">
        <div id="member-dropdown" class="relative">
          <button type="button" id="member-dropdown-toggle" class="cc-field text-left w-full flex items-center justify-between" aria-haspopup="listbox" aria-expanded="false">
            <span id="member-dropdown-label">Select team members...</span>
            <span style="font-size:0.9rem;color:#6b7280">▾</span>
          </button>

          <div id="member-dropdown-panel" role="listbox" aria-multiselectable="true" style="display:none;position:absolute;z-index:60;left:0;right:0;margin-top:6px;background:#fff;border:1px solid #e6eef6;border-radius:6px;max-height:320px;overflow:auto;box-shadow:0 6px 18px rgba(16,24,40,0.06);">
            <div style="padding:8px;border-bottom:1px solid #eef3f8">
              <input id="member-search" type="search" placeholder="Search team members..." class="cc-field" style="margin:0;" />
            </div>
            <div id="member-list" style="padding:8px;">
              {% if org.members.all %}
                {% for m in org.members.all %}
                  {% if m.is_active %}
                    {% with user=m.user %}
                      <div class="member-item flex items-center justify-between py-2 px-2 rounded hover:bg-gray-50 {% if m.id not in members_with_any_availability_ids %}opacity-60{% endif %}" data-name="{% if user.first_name or user.last_name %}{{ user.first_name }} {{ user.last_name }}{% else %}{{ user.email }}{% endif %}" data-id="{{ m.id }}" data-has-avail="{% if m.id in members_with_any_availability_ids %}1{% else %}0{% endif %}">
                        <div>
                          <div class="text-sm text-gray-800">{% if user.first_name or user.last_name %}{{ user.first_name }} {{ user.last_name }}{% else %}{{ user.email }}{% endif %}</div>
                          <div class="text-xs text-gray-500">{{ m.role|role_label }}{% if m.id not in members_with_any_availability_ids %}<span class="ml-2 text-xs text-red-600">No availability</span>{% endif %}</div>
                        </div>
                        <div class="select-indicator text-sm text-blue-600" aria-hidden="true">&nbsp;</div>
                      </div>
                    {% endwith %}
                  {% endif %}
                {% endfor %}
              {% else %}
                <div class="text-sm text-gray-500">No team members found for this business.</div>
              {% endif %}
            </div>
          </div>
        </div>
      </div>

      <script>
        (function(){
          try{
            const toggle = document.getElementById('member-dropdown-toggle');
            const panel = document.getElementById('member-dropdown-panel');
            const input = document.getElementById('member-search');
            const list = document.getElementById('member-list');
            const label = document.getElementById('member-dropdown-label');

            if (!toggle || !panel || !input || !list) return;

            const selected = new Set();
            try{
              const initial = {{ assigned_member_ids|default:'[]'|safe }};
              for (const v of initial){ selected.add(String(v)); }
            }catch(e){ }

            function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
            function updateLabel(){
              if (!selected.size){ label.textContent = 'Select team members...'; return; }
              const items = [];
              for (const it of list.querySelectorAll('.member-item')){
                const id = it.getAttribute('data-id');
                if (selected.has(id)) {
                  const nameEl = it.querySelector('.text-sm');
                  const name = nameEl ? nameEl.textContent.trim() : (it.getAttribute('data-name')||'');
                  items.push({id: String(id), name: name});
                }
              }
              if (!items.length){ label.textContent = 'Select team members...'; return; }
              // render chips with a small remove affordance
              label.innerHTML = items.map(function(itm){
                return '<span class="member-chip" data-id="' + escapeHtml(itm.id) + '">' + escapeHtml(itm.name) + ' <span class="member-chip-remove" data-id="' + escapeHtml(itm.id) + '" title="Remove" aria-hidden="true">&times;</span></span>';
              }).join(' ');
            }

            function syncHiddenInputs(){
              Array.from(document.querySelectorAll('input[name="assigned_members"][data-generated]')).forEach(i => i.remove());
              const form = toggle.closest('form');
              if (!form) return;
              for (const id of selected){
                const inp = document.createElement('input');
                inp.type = 'hidden';
                inp.name = 'assigned_members';
                inp.value = id;
                inp.setAttribute('data-generated','1');
                form.appendChild(inp);
              }
            }

            async function refreshServiceAvailabilityConstraints(){
              try{
                const editor = document.getElementById('svcAvailEditor');

                const url = new URL("{% url 'calendar_app:service_availability_constraints' org.slug %}", window.location.origin);
                url.searchParams.set('exclude_service_id', String({{ service.id }}));
                for (const id of selected){ url.searchParams.append('member_ids', String(id)); }

                const resp = await fetch(url.toString(), { credentials: 'same-origin' });
                if (!resp.ok) return;
                const data = await resp.json();

                try{
                  window.__ccWeeklyServiceConstraints = { days: (data.days || []).map(function(d){ return { remaining: (d && d.remaining) ? d.remaining : [] }; }) };
                } catch(e){ /* ignore */ }

                if (!editor) return;
                for (let ui = 0; ui < 7; ui++){
                  const day = (data.days || [])[ui] || {};
                  const allowedEmpty = !!day.allowed_empty;
                  const allowedText = (day.allowed_ranges_text || '').trim();

                  const labelEl = editor.querySelector('.cc-allowed-label[data-ui="' + ui + '"]');
                  if (labelEl){
                    const shown = allowedText ? allowedText : '—';
                    labelEl.textContent = 'Allowed (client-facing): ' + shown;
                  }

                  const hidden = editor.querySelector('input.svc-avail-hidden[data-ui="' + ui + '"]');
                  const hasSvc = !!(hidden && (hidden.value || '').trim());

                  const card = hidden ? (hidden.closest('.border') || hidden.closest('div')) : null;
                  // If there is *no allowed time at all* for the selected assignees on this day,
                  // force the day to Unavailable (prevents keeping stale ranges).
                  const hardLock = allowedEmpty;
                  if (card){
                    card.classList.toggle('cc-svc-day-locked', hardLock);
                  }

                  if (allowedEmpty){
                    try{
                      if (hidden && hasSvc){
                        hidden.value = '';
                        try{ hidden.dispatchEvent(new Event('input', { bubbles: true })); }catch(e){}
                        try{ hidden.dispatchEvent(new Event('change', { bubbles: true })); }catch(e){}
                      }
                      const dayEditor = editor.querySelector('.svc-day-editor[data-ui="' + ui + '"]');
                      if (dayEditor){
                        const cb = dayEditor.querySelector('input.svc-unavail');
                        if (cb) cb.checked = true;
                        const ranges = dayEditor.querySelector('.svc-ranges');
                        if (ranges) ranges.innerHTML = '';
                      }
                    }catch(e){ /* ignore */ }
                  }

                  const meta = editor.querySelector('.cc-svc-day-meta[data-ui="' + ui + '"]');
                  if (meta){
                    meta.setAttribute('data-allowed-empty', allowedEmpty ? '1' : '0');
                    meta.setAttribute('data-hard-lock', hardLock ? '1' : '0');
                    meta.setAttribute('data-no-remaining', (allowedEmpty && hasSvc) ? '1' : '0');
                  }
                }
              }catch(e){ /* ignore */ }
            }

            for (const it of list.querySelectorAll('.member-item')){
              const id = it.getAttribute('data-id');
              const indicator = it.querySelector('.select-indicator');
              if (selected.has(id)) { indicator.textContent = '✓'; it.classList.add('bg-blue-50'); }
              it.addEventListener('click', function(){
                  // Team plan rule: prevent assigning members with no availability configured.
                  try{
                    const hasAvail = it.getAttribute('data-has-avail');
                    if (!selected.has(id) && String(hasAvail) === '0'){
                      const nameEl = it.querySelector('.text-sm');
                      const name = nameEl ? nameEl.textContent.trim() : (it.getAttribute('data-name')||'This member');
                      const url = new URL("{% url 'calendar_app:calendar' org.slug %}", window.location.origin);
                      url.searchParams.set('select_member', String(id));
                      const ok = confirm(name + " has no availability set yet.\n\nOpen Calendar to set their availability now?");
                      if (ok){
                        try{ window.location.href = url.toString(); }catch(e){}
                      }
                      return;
                    }
                  }catch(e){ /* ignore */ }
                  if (selected.has(id)){
                    selected.delete(id); indicator.textContent = '\u00A0'; it.classList.remove('bg-blue-50');
                  } else { selected.add(id); indicator.textContent = '✓'; it.classList.add('bg-blue-50'); }
                updateLabel();
                syncHiddenInputs();
                refreshServiceAvailabilityConstraints();
              });
            }

            input.addEventListener('input', function(){
              const q = (input.value || '').toLowerCase().trim();
              for (const it of list.querySelectorAll('.member-item')){
                const name = (it.getAttribute('data-name')||'').toLowerCase();
                it.style.display = name.indexOf(q) === -1 ? 'none' : '';
              }
            });

            toggle.addEventListener('click', function(){
              const open = panel.style.display !== 'none';
              panel.style.display = open ? 'none' : 'block';
              toggle.setAttribute('aria-expanded', String(!open));
              if (!open) input.focus();
            });

            document.addEventListener('click', function(e){
              if (!toggle.contains(e.target) && !panel.contains(e.target)){
                panel.style.display = 'none';
                toggle.setAttribute('aria-expanded','false');
              }
            });

            // Allow clicking the small remove "×" inside a rendered chip to deselect that member
                label.addEventListener('click', function(e){
              try{
                const rem = e.target && (e.target.closest ? e.target.closest('.member-chip-remove') : null);
                if (!rem) return;
                const id = rem.getAttribute('data-id');
                if (!id) return;
                if (selected.has(id)){
                  selected.delete(id);
                  const it = list.querySelector('.member-item[data-id="' + id + '"]');
                  if (it){
                    const indicator = it.querySelector('.select-indicator');
                    if (indicator) indicator.textContent = '\u00A0';
                    it.classList.remove('bg-blue-50');
                  }
                  updateLabel();
                  syncHiddenInputs();
                  refreshServiceAvailabilityConstraints();
                  e.stopPropagation();
                  e.preventDefault();
                }
              }catch(err){ /* ignore */ }
            });

            updateLabel();
            syncHiddenInputs();
            // Ensure the time picker constraints sync after the availability editor exists.
            if (document.readyState === 'loading') {
              document.addEventListener('DOMContentLoaded', function(){ refreshServiceAvailabilityConstraints(); }, { once: true });
            } else {
              refreshServiceAvailabilityConstraints();
            }
          }catch(e){ console.warn('member dropdown failed', e); }
        })();
      </script>
    </div>
    {% endif %}


    <!-- Client slot settings moved into the Timing section below (keeps related settings together). -->

    <!-- Facility resources (cages/rooms/etc) -->
    <div class="section-card">
      <div class="section-title">Facility resources</div>

      {% if can_use_facility_resources %}
        <p class="text-sm text-gray-600 mb-3">
          Enable capacity enforcement for this service and choose which spaces it can use.
        </p>

        <label class="inline-flex items-center mb-3">
          <input type="checkbox" name="requires_facility_resources" id="requires_facility_resources" value="1"
                 {% if service.requires_facility_resources %}checked{% endif %}
                 class="rounded border-gray-300 text-blue-600 focus:ring-blue-500 {% if not can_toggle_facility_required %}opacity-60 cursor-not-allowed{% endif %}"
                 {% if not can_toggle_facility_required %}disabled aria-disabled="true"{% endif %}>
          <span class="ml-2 text-sm text-gray-700">Requires facility resources/capacity</span>
        </label>

        <div class="mb-3">
          <a href="{% url 'calendar_app:resources_page' org.slug %}" class="text-sm text-blue-600 hover:text-blue-700">Manage resources →</a>
        </div>

        {% if user_org_role != 'owner' %}
          <div class="mb-3 p-3 rounded bg-yellow-50 border border-yellow-200 text-sm text-yellow-800">
            Only the business owner can change resource settings.
          </div>
        {% endif %}

        <p id="ccFacilityResourcesOffHint" class="text-sm text-gray-600 mb-2" {% if service.requires_facility_resources %}style="display:none;"{% endif %}>
          Capacity is not enforced for this service.
        </p>

        <div id="ccFacilityResourcesPicker" {% if not service.requires_facility_resources %}style="display:none;"{% endif %}>
          {% if facility_resources %}
            <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
              {% for r in facility_resources %}
                <label class="flex items-center gap-2 px-3 py-2 rounded border border-gray-200 bg-white {% if r.cc_disabled %}opacity-60 bg-gray-50 cursor-not-allowed{% endif %}">
                  <input type="checkbox" name="resource_ids" value="{{ r.id }}" class="rounded border-gray-300"
                         {% if r.id in selected_resource_ids %}checked{% endif %}
                         {% if user_org_role != 'owner' or r.cc_disabled %}disabled{% endif %}>
                  <span class="text-sm text-gray-800">{{ r.name }}</span>
                  {% if r.cc_disabled %}<span class="text-xs text-gray-500">(in use)</span>{% endif %}
                  {% if not r.is_active %}<span class="text-xs text-gray-500">(inactive)</span>{% endif %}
                  {% if r.cc_max_services != None %}
                    <span class="ml-auto text-xs text-gray-500">
                      {% if r.cc_max_services == 0 %}
                        Unlimited
                      {% else %}
                        {{ r.cc_used_services|default:0 }}/{{ r.cc_max_services }}
                      {% endif %}
                    </span>
                  {% endif %}
                </label>
              {% endfor %}
            </div>
            <p class="mt-2 text-xs text-gray-500">When enabled, select at least one resource.</p>
          {% else %}
            <div class="text-sm text-gray-600">No resources created yet. Create space capacity first, then enable capacity for this service.</div>
          {% endif %}
        </div>
      {% else %}
        <p class="text-sm text-gray-600">Facility resources are available on the Team plan.</p>
      {% endif %}
    </div>

    <script>
      (function(){
        try{
          const toggle = document.getElementById('requires_facility_resources');
          const picker = document.getElementById('ccFacilityResourcesPicker');
          const hintOff = document.getElementById('ccFacilityResourcesOffHint');
          if (!toggle || !picker) return;
          function update(){
            const on = !!toggle.checked;
            if (picker) picker.style.display = on ? 'block' : 'none';
            if (hintOff) hintOff.style.display = on ? 'none' : 'block';
            if (!on){
              for (const cb of picker.querySelectorAll('input[type="checkbox"][name="resource_ids"]')){
                try{ cb.checked = false; }catch(e){}
              }
            }
          }
          toggle.addEventListener('change', update);
          update();
        }catch(e){ }
      })();
    </script>

    <script>
      // When Use Fixed Increments is enabled, disable/grey the Allow Squished and the increment input.
      // Also keep the increment in-sync with the Day Schedule modal via localStorage ('client_view_settings').
      (function(){
        try {
          const CAN_USE_PRO_TEAM = {{ can_use_pro_team|yesno:'true,false' }};
          const fixed = document.getElementById('use_fixed_increment');
          const squish = document.getElementById('allow_squished_bookings');
          const incInput = document.getElementById('time_increment_minutes');
          const form = document.querySelector('form.cc-form');
          if (!fixed) return;

          // Visual helper class
          const style = document.createElement('style');
          style.innerHTML = '.squish-disabled-label { opacity: 0.6; } .inc-disabled { opacity: 0.55; }';
          document.head.appendChild(style);

          const parentLabel = squish ? (squish.closest('label') || squish.parentNode) : null;

          function updateState() {
            const disabled = fixed.checked;
            if (squish) {
              try { squish.disabled = (!CAN_USE_PRO_TEAM) ? true : disabled; } catch(e){}
              if (parentLabel) parentLabel.classList.toggle('squish-disabled-label', disabled);
            }
            if (incInput) {
              try { incInput.disabled = disabled; } catch(e){}
              incInput.classList.toggle('inc-disabled', disabled);
            }

            // Propagate the effective client increment to localStorage so the public
            // calendar reflects the change immediately. When fixed increments are
            // enabled, use duration + buffer_after; otherwise use the visible input.
            try {
              const durationEl = document.querySelector('input[name="duration"]');
              const bufferEl = document.querySelector('input[name="buffer_after"]');
              const dur = durationEl ? Number(durationEl.value) : null;
              const buf = bufferEl ? Number(bufferEl.value) : 0;
              if (disabled) {
                // fixed increment
                if (dur != null && !isNaN(dur)) {
                  setClientIncrementFromInput(Number(dur) + Number(buf));
                }
              } else {
                if (incInput) setClientIncrementFromInput(Number(incInput.value) || 30);
              }
            } catch (e) { /* ignore */ }
          }

          // When increment input changes, ask to confirm and propagate to localStorage so modal reads it
          const initialIncVal = incInput ? Number(incInput.value) : null;

          function setClientIncrementFromInput(val) {
            try {
              const raw = localStorage.getItem('client_view_settings') || '{}';
              let parsed = {};
              try { parsed = JSON.parse(raw); } catch(_) { parsed = {}; }
              parsed.increment = Number(val) || 30;
              localStorage.setItem('client_view_settings', JSON.stringify(parsed));
              try { showToast('success', 'Client increment updated for Day Schedule modal.'); } catch(e){}
            } catch (e) { console.warn('setClientIncrement failed', e); }
          }

          if (incInput) {
            incInput.addEventListener('change', function(ev){
              try {
                if (fixed.checked) {
                  // Shouldn't happen because input is disabled, but guard
                  try { showToast('warning', 'Disable Fixed Increments to change the client increment.'); } catch(e){}
                  incInput.value = initialIncVal;
                  return;
                }
                const newVal = Number(incInput.value);
                if (isNaN(newVal) || newVal < 5) {
                  try { showToast('warning', 'Enter a valid increment (5+ minutes).'); } catch(e){}
                  incInput.value = initialIncVal;
                  return;
                }
                const confirmMsg = `Change client increment to ${newVal} minutes? This will update the Day Schedule modal's client view settings.`;
                if (!confirm(confirmMsg)) {
                  // revert
                  incInput.value = initialIncVal;
                    const btns = Array.from(document.querySelectorAll('.svc-save-btn'));
                }
                // propagate to localStorage so calendar modal picks it up
                setClientIncrementFromInput(newVal);
              } catch (e) { console.warn('inc change handler failed', e); }
            });
          }

          // Reflect localStorage changes (from modal or other tabs) into this input
          window.addEventListener('storage', function(e){
            if (e.key === 'client_view_settings') {
              try {
                const parsed = JSON.parse(e.newValue || '{}');
                if (parsed && typeof parsed.increment === 'number' && incInput && !fixed.checked) {
                  incInput.value = String(parsed.increment);
                }
              } catch (err) { /* ignore */ }
            }
          });

          // Before submitting the service edit form, if the increment was changed from the original value,
          // confirm the user wants to persist the change to the server as well.
          if (form && incInput) {
            form.addEventListener('submit', function(ev){
              try {
                const cur = Number(incInput.value);
                if (!isNaN(initialIncVal) && cur !== Number(initialIncVal)) {
                  const ok = confirm(`You changed the slot increment from ${initialIncVal} to ${cur} minutes. Save this change to the service?`);
                  if (!ok) {
                    ev.preventDefault();
                    return false;
                  }
                  // Also update localStorage so modal and other tabs reflect the new value
                  setClientIncrementFromInput(cur);
                }
              } catch (e) { /* allow submit on error */ }
            });
          }

          // Initialize state and sync with localStorage if appropriate
          updateState();
          try {
            const raw = localStorage.getItem('client_view_settings');
            if (raw && incInput && !fixed.checked) {
              const parsed = JSON.parse(raw);
              if (parsed && typeof parsed.increment === 'number') {
                incInput.value = String(parsed.increment);
              }
            }
          } catch (e) { /* ignore parse errors */ }

          // attach handler to fixed checkbox
          fixed.addEventListener('change', updateState);
        } catch (e) { console.warn('squish-disable and increment sync wiring failed', e); }
      })();
    </script>

    <script>
      // Ensure hidden fallback reflects the actual checkbox state on submit
      (function(){
        try {
          const form = document.querySelector('form.cc-form');
          const chk = form ? form.querySelector('input[type="checkbox"][name="allow_ends_after_availability"]') : null;
          const hidden = form ? form.querySelector('input[type="hidden"][name="allow_ends_after_availability"]') : null;
          if (!form || !chk || !hidden) return;
          form.addEventListener('submit', function(){
            try { hidden.value = chk.checked ? '1' : '0'; } catch(e){}
          });
        } catch(e) { console.warn('sync hidden checkbox failed', e); }
      })();
    </script>

      <script>
      // Hours / minutes helper for duration: keep hidden `duration` in minutes in-sync
      document.addEventListener('DOMContentLoaded', function(){
        try{
          const hidden = document.getElementById('duration_hidden');
          const h = document.getElementById('duration_hours');
          const m = document.getElementById('duration_minutes');
          if (!hidden || !h || !m) return;

          function setFieldsFromHidden(){
            const total = Number(hidden.value) || 0;
            const hours = Math.floor(total / 60);
            const mins = total % 60;
            h.value = hours;
            m.value = mins;
          }

          function updateHidden(){
            const hours = Math.max(0, Number(h.value) || 0);
            const mins = Math.max(0, Number(m.value) || 0);
            const total = (hours * 60) + mins;
            hidden.value = total;
          }

          h.addEventListener('input', updateHidden);
          m.addEventListener('input', updateHidden);

          // initialize
          setFieldsFromHidden();
        } catch(e){ console.warn('duration hours/min wiring failed', e); }
      });
      </script>

    <!-- Group timing + client slot settings into a clear section -->
    <div class="section-card" id="ccClientSlotSettings">
      <div class="text-base font-semibold text-center" style="color: var(--gray-900); margin-bottom: 14px;">Client Slot Settings and Price of Appointment</div>

      <div class="text-center" style="margin-bottom: 14px;">
        <a id="cc-open-day-schedule-from-service" href="{% url 'calendar_app:calendar' org.slug %}"
           class="inline-flex items-center px-3 py-2 rounded-md text-sm font-medium border border-blue-600 text-blue-600 bg-white hover:bg-blue-50">
          Open Day Schedule in Calendar
        </a>
        <div class="mt-2 text-xs text-gray-500">Opens the next available day based on this service’s weekly availability.</div>
      </div>

      <div class="grid grid-cols-2 gap-4">
        <div>
          <label class="block text-sm font-medium text-gray-700">Duration</label>
          <div class="mt-1 flex items-center gap-2">
            <input id="duration_hours" type="number" min="0" class="cc-field w-24" placeholder="Hours">
            <span class="text-sm text-gray-600">Hours</span>
            <input id="duration_minutes" type="number" min="0" max="59" class="cc-field w-24" placeholder="Minutes">
            <span class="text-sm text-gray-600">Minutes</span>
          </div>
          <input type="hidden" name="duration" id="duration_hidden" value="{{ service.duration }}">
          <p class="mt-1 text-xs text-gray-500">Enter Hours and Minutes; they will be saved as total minutes.</p>
        </div>
        <div>
          <label class="block text-sm font-medium text-gray-700">Client slot increment (minutes)</label>
          <input id="time_increment_minutes" name="time_increment_minutes" type="number" value="{{ service.time_increment_minutes|default:30 }}" min="5" class="cc-field mt-1 w-full">
          <p class="mt-1 text-xs text-gray-500">This controls the visible client slot increment. When <em>Use fixed increments</em> is enabled, this value is ignored.</p>
        </div>
      </div>

      <div class="grid grid-cols-2 gap-4 mt-4">
        <div>
          <label class="block text-sm font-medium text-gray-700">Buffer Time Post Service Appointment</label>
          <div class="cc-adv-lock-wrap {% if not can_use_pro_team %}cc-adv-locked{% endif %}" style="display:block;">
            <div class="mt-1 flex items-center gap-2">
              <input id="buffer_hours" type="number" min="0" class="cc-field w-24" placeholder="Hours" {% if not can_use_pro_team %}disabled{% endif %}>
              <span class="text-sm text-gray-600">Hours</span>
              <input id="buffer_minutes" type="number" min="0" max="59" class="cc-field w-24" placeholder="Minutes" {% if not can_use_pro_team %}disabled{% endif %}>
              <span class="text-sm text-gray-600">Minutes</span>
            </div>
            {% if not can_use_pro_team %}<div class="cc-adv-lock-overlay" data-cc-adv-lock role="button" tabindex="0" aria-label="Upgrade required"></div>{% endif %}
          </div>
          <input type="hidden" name="buffer_after" id="buffer_hidden" value="{% if can_use_pro_team %}{{ service.buffer_after }}{% else %}0{% endif %}">
          <p class="mt-1 text-xs text-gray-500">Enter buffer time after appointment; saved as total minutes.</p>

          {% if schedule_compat_services_preview %}
            <div class="mt-2 rounded-lg border border-blue-200 bg-blue-50 px-3 py-2">
              <div class="text-sm font-semibold" style="color:#1e3a8a;">Shares duration/buffer settings</div>
              <div class="mt-1 text-xs" style="color:rgba(30, 58, 138, 0.9); line-height:1.35;">
                These services share the same availability group, so their schedules can overlap:
                {% for s in schedule_compat_services_preview %}
                  <a href="{% url 'calendar_app:edit_service' org.slug s.id %}" class="underline" style="color:#1d4ed8;">
                    {{ s.name }}{% if not s.is_active %} (inactive){% endif %}
                  </a>{% if not forloop.last %}, {% endif %}
                {% endfor %}
                {% if schedule_compat_services_more %} + {{ schedule_compat_services_more }} more{% endif %}.
              </div>
            </div>
          {% endif %}
        </div>
        <div>
          <label class="block text-sm font-medium text-gray-700">Price (USD)</label>
          <input name="price" type="number" step="0.01" value="{{ service.price }}"
                 class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:ring-blue-500 focus:border-blue-500 text-sm">
        </div>
      </div>

      <div class="grid grid-cols-1 gap-3 mt-4">
        <div>
          <div class="cc-adv-lock-wrap {% if not can_use_pro_team %}cc-adv-locked{% endif %}" style="display:block;">
            <label class="inline-flex items-center">
              <input type="checkbox" name="use_fixed_increment" id="use_fixed_increment" {% if service.use_fixed_increment %}checked{% endif %}
                     class="rounded border-gray-300 text-blue-600 focus:ring-blue-500" {% if not can_use_pro_team %}disabled{% endif %}>
              <span class="ml-2 text-sm text-gray-700">Use fixed increments (service duration + buffer)</span>
            </label>
            {% if not can_use_pro_team %}<div class="cc-adv-lock-overlay" data-cc-adv-lock role="button" tabindex="0" aria-label="Upgrade required"></div>{% endif %}
          </div>
          <p class="mt-1 text-xs text-gray-500">When enabled, clients will only see anchors spaced by the service duration plus cleanup buffer.</p>
        </div>

        <div>
          <div class="cc-adv-lock-wrap {% if not can_use_pro_team %}cc-adv-locked{% endif %}" style="display:block;">
            <label class="inline-flex items-center">
              <input type="checkbox" name="allow_squished_bookings" id="allow_squished_bookings" {% if service.allow_squished_bookings %}checked{% endif %}
                     class="rounded border-gray-300 text-blue-600 focus:ring-blue-500" {% if not can_use_pro_team %}disabled{% endif %}>
              <span class="ml-2 text-sm text-gray-700">Allow squished bookings (permit slots that violate buffers)</span>
            </label>
            {% if not can_use_pro_team %}<div class="cc-adv-lock-overlay" data-cc-adv-lock role="button" tabindex="0" aria-label="Upgrade required"></div>{% endif %}
          </div>
          <p class="mt-1 text-xs text-gray-500">When enabled, the system will allow bookings that fit the service duration even if they don't satisfy the configured buffers. Owners will receive a notification when such bookings occur.</p>
        </div>

        <div>
          <label class="block text-sm font-medium text-gray-700">Allow appointment to end after availability?</label>
          <div class="mt-2">
            <div class="cc-adv-lock-wrap {% if not can_use_pro_team %}cc-adv-locked{% endif %}" style="display:block;">
              <label class="inline-flex items-center">
                <!-- hidden fallback ensures a value is always posted even when unchecked -->
                <input type="hidden" name="allow_ends_after_availability" value="0">
                <input type="checkbox" name="allow_ends_after_availability" value="1" {% if service.allow_ends_after_availability %}checked{% endif %}
                       class="rounded border-gray-300 text-blue-600 focus:ring-blue-500" {% if not can_use_pro_team %}disabled{% endif %}>
                <span class="ml-2 text-sm text-gray-700">Allow clients to book slots that start before the availability end even if they finish after it.</span>
              </label>
              {% if not can_use_pro_team %}<div class="cc-adv-lock-overlay" data-cc-adv-lock role="button" tabindex="0" aria-label="Upgrade required"></div>{% endif %}
            </div>
          </div>
          <p class="mt-1 text-xs text-gray-500">Enable to allow the final time slot to finish after your daily availability end.</p>
        </div>
      </div>

      <script>
        // Jump to Calendar with this service preselected and Day Schedule auto-opened.
        (function(){
          try{
            const btn = document.getElementById('cc-open-day-schedule-from-service');
            if (!btn) return;
            btn.addEventListener('click', function(){
              try { localStorage.setItem('cc_selected_member', 'svc:{{ service.id }}'); } catch (e) {}
              try { localStorage.setItem('cc_auto_open_service', '{{ service.id }}'); } catch (e) {}
              try {
                const d = new Date();
                const y = d.getFullYear();
                const m = String(d.getMonth() + 1).padStart(2,'0');
                const dd = String(d.getDate()).padStart(2,'0');
                localStorage.setItem('cc_auto_open_date', `${y}-${m}-${dd}`);
              } catch (e) {}
            });
          } catch(e) {}
        })();
      </script>
    </div>

    <div class="section-card cc-adv-lock-wrap {% if not can_use_pro_team %}cc-adv-locked{% endif %}">
      <h2 class="text-base font-semibold">Payment Methods</h2>
      <div class="mt-3">
        <div class="space-y-3">
          <label class="inline-flex items-start">
            {% if not can_use_pro_team %}
              <input type="hidden" name="allow_stripe_payments" value="1">
            {% endif %}
            <input type="checkbox" name="allow_stripe_payments" id="allow_stripe_payments" value="1"
                   class="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                   {% if svc_allow_stripe or not can_use_pro_team %}checked{% endif %}
                   {% if not can_use_pro_team %}disabled{% endif %}>
            <span class="ml-2 text-sm text-gray-700">Accept card payments (Stripe)</span>
          </label>
          {% if can_use_pro_team %}
            <div class="ml-6 text-xs text-gray-500">Recommended: Stripe enables automatic payment confirmation and refunds.</div>
          {% endif %}

          <div class="ml-6">
            <div class="text-sm font-medium text-gray-700">Different form of payment</div>
            <div class="mt-2 space-y-2">
              <label class="flex items-center text-sm text-gray-700">
                <input type="checkbox" name="offline_methods" value="venmo"
                       class="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                       {% if 'venmo' in svc_offline_methods %}checked{% endif %}
                       {% if not offline_methods_allowed or not can_use_pro_team %}disabled{% endif %}>
                <span class="ml-2">Venmo</span>
              </label>
              <label class="flex items-center text-sm text-gray-700">
                <input type="checkbox" name="offline_methods" value="zelle"
                       class="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                       {% if 'zelle' in svc_offline_methods %}checked{% endif %}
                       {% if not offline_methods_allowed or not can_use_pro_team %}disabled{% endif %}>
                <span class="ml-2">Zelle</span>
              </label>

              <div class="text-sm text-gray-500">Any other payment methods go here</div>

              <label class="flex items-center text-sm text-gray-700">
                <input type="checkbox" name="offline_methods" value="cash"
                       class="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                       {% if 'cash' in svc_offline_methods %}checked{% endif %}
                       {% if not offline_methods_allowed or not can_use_pro_team %}disabled{% endif %}>
                <span class="ml-2">Offline (Cash)</span>
              </label>
            </div>
          </div>
        </div>
      </div>

      {% if not can_use_pro_team %}<div class="cc-adv-lock-overlay" data-cc-adv-lock role="button" tabindex="0" aria-label="Upgrade required" style="border-radius:0.75rem;"></div>{% endif %}

      <p class="mt-2 text-xs text-gray-500">For paid services, you must enable at least one payment method.</p>
    </div>

    <div class="grid grid-cols-2 gap-4">
      <div>
        <label class="block text-sm font-medium text-gray-700">How soon can clients book before the appointment? (In Hours)</label>
      <div class="cc-adv-lock-wrap {% if not can_use_pro_team %}cc-adv-locked{% endif %}">
         <input name="min_notice_hours" type="number" value="{% if can_use_pro_team %}{{ service.min_notice_hours }}{% else %}24{% endif %}" min="0"
           class="cc-field mt-1 w-full" {% if not can_use_pro_team %}disabled{% endif %} />
         {% if not can_use_pro_team %}<div class="cc-adv-lock-overlay" data-cc-adv-lock role="button" tabindex="0" aria-label="Upgrade required"></div>{% endif %}
       </div>
       <p class="mt-2 text-xs text-gray-500">Prevent last‑minute bookings (e.g. 24 = one day).</p>
      </div>
      <div>
        <label class="block text-sm font-medium text-gray-700">How far ahead can clients book? (In Days)</label>
      <div class="cc-adv-lock-wrap {% if not can_use_pro_team %}cc-adv-locked{% endif %}">
         <input name="max_booking_days" type="number" value="{% if can_use_pro_team %}{{ service.max_booking_days }}{% elif is_trialing %}31{% else %}30{% endif %}" min="1"
           class="cc-field mt-1 w-full" {% if not can_use_pro_team %}disabled{% endif %} />
         {% if not can_use_pro_team %}<div class="cc-adv-lock-overlay" data-cc-adv-lock role="button" tabindex="0" aria-label="Upgrade required"></div>{% endif %}
       </div>
       <p class="mt-2 text-xs text-gray-500">Limit how far out clients can book.</p>
       {% if is_trialing %}
         <p class="mt-2 text-xs text-gray-500">
           During your trial, clients can book through the end of your trial{% if trial_end %} ({{ trial_end|date:"M j, Y" }}){% endif %}.
           This setting takes effect after you purchase a subscription.
         </p>
       {% endif %}
      </div>
    </div>

    <!-- active toggle removed (public visibility controlled above) -->

    {% if conflict_services %}
      <div class="mb-4 p-3 rounded bg-yellow-50 border-l-4 border-yellow-400 text-yellow-800">
        <strong>Conflicting services detected</strong>
        <p class="text-sm">The following services have overlapping availability windows: {{ conflict_services|join:", " }}.</p>
        <label class="inline-flex items-center mt-2"><input type="checkbox" name="apply_to_conflicts" value="1" class="rounded border-gray-300"> <span class="ml-2 text-sm">Apply these settings to the listed services as well</span></label>
      </div>
    {% endif %}

    <!-- Refund Policy -->
    <div class="section-card">
      <h2 class="text-base font-semibold">Refund Policy</h2>
        <div class="mt-3">
          <div class="cc-adv-lock-wrap {% if not can_use_pro_team %}cc-adv-locked{% endif %}" style="display:inline-block;">
            <label class="inline-flex items-center">
              <input type="checkbox" name="refunds_allowed" id="refunds_allowed" value="1"
                     class="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                     {% if service.refunds_allowed %}checked{% endif %}
                     {% if not can_use_pro_team %}disabled{% endif %}>
              <span class="ml-2 text-sm text-gray-700">Allow refunds for this service</span>
            </label>
            {% if not can_use_pro_team %}<div class="cc-adv-lock-overlay" data-cc-adv-lock role="button" tabindex="0" aria-label="Upgrade required"></div>{% endif %}
          </div>
        </div>
        <div class="refund-policy-controls mt-3">
          <div>
            <label class="block text-sm font-medium text-gray-700">Refund Cutoff (Hours)</label>
            <div class="cc-adv-lock-wrap {% if not can_use_pro_team %}cc-adv-locked{% endif %}" style="display:block;">
              <input name="refund_cutoff_hours" type="number" value="{% if can_use_pro_team %}{{ service.refund_cutoff_hours }}{% else %}24{% endif %}" min="1"
                     class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:ring-blue-500 focus:border-blue-500 text-sm" {% if not can_use_pro_team %}disabled{% endif %}>
              {% if not can_use_pro_team %}<div class="cc-adv-lock-overlay" data-cc-adv-lock role="button" tabindex="0" aria-label="Upgrade required"></div>{% endif %}
            </div>
            <p class="mt-1 text-xs text-gray-500">Inside this window, refunds are not permitted.</p>
          </div>
          <div class="mt-3">
            <label class="block text-sm font-medium text-gray-700">Custom Refund Policy Text</label>
            <div class="cc-adv-lock-wrap {% if not can_use_pro_team %}cc-adv-locked{% endif %}" style="display:block;">
              <textarea name="refund_policy_text" rows="3"
                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:ring-blue-500 focus:border-blue-500 text-sm" {% if not can_use_pro_team %}disabled{% endif %}>{{ service.refund_policy_text }}</textarea>
              {% if not can_use_pro_team %}<div class="cc-adv-lock-overlay" data-cc-adv-lock role="button" tabindex="0" aria-label="Upgrade required"></div>{% endif %}
            </div>
          </div>
        </div>
    </div>

    <div class="section-card {% if not can_edit_service_availability or service_availability_fully_blocked %}availability-disabled{% endif %}">
      <!-- Service availability editor -->
      <div class="mt-0">
        <h2 class="text-base font-semibold text-center">Service availability</h2>
        {% if can_edit_service_availability %}
          {% if assigned_member_ids|length == 1 and service_availability_member_name %}
            <div class="text-sm text-gray-600 text-center mt-1">Applies to: <span class="font-medium">{{ service_availability_member_name }}</span></div>
            <p class="text-sm text-gray-500 mt-3 text-center">
              This is what clients can book for this service.
              It must fit within the assigned member’s overall weekly availability.
              Other services and per-date overrides can further reduce or open time.
            </p>
          {% elif assigned_member_ids|length > 1 %}
            <div class="text-sm text-gray-600 text-center mt-1">
              Applies to: <span class="font-medium">{{ service_availability_assignee_names|join:", "|default:"Multiple members" }}</span>
            </div>
            <p class="text-sm text-gray-500 mt-3 text-center">
              This is what clients can book for this group service.
              It must fit within <span class="font-medium">all assigned members’</span> overall weekly availability,
              <span class="font-medium">minus</span> time already reserved by those members’ other services.
              Per-date overrides can still open/close time (as long as they stay within member availability).
            </p>
          {% else %}
            <p class="text-sm text-gray-500 mt-3 text-center">Specify which days/times this service is offered. These must be within the organization’s weekly availability shown for each day below.</p>
          {% endif %}

          <div class="mt-3 mx-auto" style="max-width:56rem;">
            <div class="rounded-lg border" style="border-color:#e5e7eb; background:#f9fafb; padding:10px 12px;">
              <div class="text-xs" style="color:#374151; line-height:1.35;">
                <span style="font-weight:700;">How to read this:</span>
                “Allowed” is the time window you can schedule into for that weekday (based on the rules above).
                If a day is locked, there’s no remaining time for this service on that day.
              </div>
            </div>
          </div>
        {% else %}
          <p class="text-sm text-gray-500 mt-3 text-center">Specify which days/times this service is offered. These must be within the organization’s weekly availability shown for each day below.</p>
        {% endif %}

        <div class="mt-2 text-center">
          {% if not can_edit_service_availability %}
            <div class="text-xs text-gray-500">Service availability is available on Pro/Team plans. Upgrade to unlock per-service availability.</div>
          {% else %}
            <div class="text-xs text-gray-500">These weekly service availability settings are interchangeable with the Calendar page (when viewing this service). You can update them in either place.</div>
          {% endif %}
          <a id="cc-open-calendar-from-service" href="{% url 'calendar_app:calendar' org.slug %}"
             class="inline-flex items-center px-3 py-2 mt-2 rounded-md text-sm font-medium border border-blue-600 text-blue-600 bg-white hover:bg-blue-50">
            Open in Calendar
          </a>
        </div>

        <script>
          // When jumping to Calendar from Edit Service, preselect this service scope.
          (function(){
            try{
              const btn = document.getElementById('cc-open-calendar-from-service');
              if (!btn) return;
              btn.addEventListener('click', function(){
                try { localStorage.setItem('cc_selected_member', 'svc:{{ service.id }}'); } catch (e) {}
              });
            }catch(e){}
          })();
        </script>

        {% if not can_edit_service_availability %}
          <div class="availability-overlay" role="status" aria-live="polite">
            <div class="msg">
              <strong class="block mb-1">Service availability disabled</strong>
              <div class="text-sm">{{ service_availability_disabled_reason|default:"Service availability requires a Pro or Team subscription. Upgrade to unlock per-service availability." }}</div>
            </div>
          </div>
        {% elif service_availability_fully_blocked %}
          <div class="availability-overlay" role="status" aria-live="polite">
            <div class="msg">
              <strong class="block mb-1">No remaining availability for this service</strong>
              <div class="text-sm">{{ service_availability_fully_blocked_reason|default:"There’s no remaining time to schedule this service within your overall availability." }}</div>
            </div>
          </div>
        {% endif %}
        <div class="grid grid-cols-1 gap-3 mt-3" id="svcAvailEditor">
          {% for row in weekly_edit_rows %}
            <div class="border rounded-md p-3 bg-white {% if row.hard_lock %}cc-svc-day-locked{% endif %}">
              <div class="flex items-center justify-between gap-3">
                <div class="font-semibold text-gray-800" style="width:64px">{{ row.label }}</div>
                <div class="text-xs text-gray-600 cc-allowed-label" data-ui="{{ row.ui }}">Allowed (client-facing): {{ row.allowed_ranges|default:row.org_ranges|default:'—' }}</div>
              </div>

              <input type="hidden"
                     name="svc_avail_{{ row.ui }}"
                     value="{{ row.svc_ranges }}"
                     class="svc-avail-hidden"
                     data-ui="{{ row.ui }}"
                     {% if not can_edit_service_availability or service_availability_fully_blocked %}disabled aria-disabled="true"{% endif %}>

              <div class="mt-2 svc-day-editor" data-ui="{{ row.ui }}" {% if not can_edit_service_availability or service_availability_fully_blocked %}data-disabled="1"{% endif %}>
                <div class="cc-svc-day-meta"
                     data-ui="{{ row.ui }}"
                     data-allowed-empty="{{ row.allowed_empty|yesno:'1,0' }}"
                     data-hard-lock="{{ row.hard_lock|yesno:'1,0' }}"
                     data-no-remaining="{{ row.no_remaining|yesno:'1,0' }}"
                     style="display:none;"></div>
                <label class="inline-flex items-center text-sm text-gray-700">
                  <input type="checkbox" class="svc-unavail rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                         {% if not row.svc_ranges %}checked{% endif %}
                         {% if not can_edit_service_availability or service_availability_fully_blocked %}disabled aria-disabled="true"{% endif %}>
                  <span class="ml-2">Unavailable</span>
                </label>
                <div class="svc-ranges mt-2" style="display:flex; flex-direction:column; gap:8px;"></div>
                <button type="button" class="svc-add-range mt-2 text-sm text-blue-600 hover:text-blue-700"
                        {% if not can_edit_service_availability or service_availability_fully_blocked %}disabled aria-disabled="true"{% endif %}>+ Add time range</button>
              </div>
            </div>
          {% endfor %}
        </div>
      </div>
    </div>

    <script>
      // Per-day remaining allowed minutes for the service availability editor.
      // Matches calendar.html custom time picker constraint semantics.
      (function(){
        try { window.__ccWeeklyServiceConstraints = {{ svc_constraints_json|default:'null'|safe }}; } catch (e) { window.__ccWeeklyServiceConstraints = null; }
      })();
    </script>

    <script>
      // Service availability editor: time inputs -> hidden svc_avail_* fields
      (function(){
        try{
          // Calendar-like custom time picker (hour/minute scrollers)
          function createCustomTimePicker(inputElement){
            const picker = document.createElement('div');
            picker.className = 'custom-time-picker';

            const [initialHour, initialMinute] = (inputElement.value || '09:00').split(':');
            let selectedHour = initialHour;
            let selectedMinute = initialMinute;

            const isStart = inputElement.classList.contains('range-start') || inputElement.classList.contains('modal-range-start');
            const headerText = isStart ? 'Start Time' : 'End Time';

            function _minutesFromTimeStr(s){
              try{
                const v = String(s || '').trim();
                const parts = v.split(':');
                if (parts.length !== 2) return null;
                const h = parseInt(parts[0], 10);
                const m = parseInt(parts[1], 10);
                if (isNaN(h) || isNaN(m)) return null;
                return (h * 60) + m;
              }catch(e){ return null; }
            }

            function _ccGetAllowedIntervalsForInput(el){
              try {
                const dayIdx = parseInt(String(el?.dataset?.day ?? ''), 10);
                if (isNaN(dayIdx)) return null;
                const c = window.__ccWeeklyServiceConstraints || null;
                if (!c || !c.days || !c.days[dayIdx]) return null;
                const d = c.days[dayIdx];
                if (!d || !Array.isArray(d.remaining)) return null;
                return d.remaining.slice();
              } catch (e) {
                return null;
              }
            }

            function _ccIsMinuteAllowed(min){
              try {
                if (min === null || min === undefined || isNaN(min)) return false;
                const allowed = _ccGetAllowedIntervalsForInput(inputElement);
                if (allowed === null) return true; // unconstrained
                if (!allowed.length) return false;

                const row = inputElement.closest('.svc-range-row');
                const startEl = row ? row.querySelector('.range-start') : null;
                const endEl = row ? row.querySelector('.range-end') : null;
                const startMin = startEl ? _minutesFromTimeStr(startEl.value) : null;
                const endMin = endEl ? _minutesFromTimeStr(endEl.value) : null;

                const inAllowed = allowed.some(r => {
                  try {
                    const s = parseInt(r.start, 10);
                    const e = parseInt(r.end, 10);
                    if (isNaN(s) || isNaN(e)) return false;
                    if (isStart) return (s <= min) && (min < e);
                    return (s < min) && (min <= e);
                  } catch (e) {
                    return false;
                  }
                });
                if (!inAllowed) return false;

                if (isStart && endMin !== null && !isNaN(endMin)) {
                  if (!(min < endMin)) return false;
                }
                if (!isStart && startMin !== null && !isNaN(startMin)) {
                  if (!(min > startMin)) return false;
                }
                return true;
              } catch (e) {
                return true;
              }
            }

            function _ccFirstAllowedMinuteForHour(hour){
              try {
                const h = parseInt(hour, 10);
                if (isNaN(h)) return null;
                const base = h * 60;
                for (let m = 0; m < 60; m++){
                  const min = base + m;
                  if (_ccIsMinuteAllowed(min)) return min;
                }
              } catch (e) {}
              return null;
            }

            function _ccSnapToAllowed(hh, mm){
              try {
                const h = parseInt(hh, 10);
                const m = parseInt(mm, 10);
                if (isNaN(h) || isNaN(m)) return null;
                const cur = h*60 + m;
                if (_ccIsMinuteAllowed(cur)) return cur;
                const firstInHour = _ccFirstAllowedMinuteForHour(h);
                if (firstInHour !== null) return firstInHour;
                for (let t = 0; t < 24*60; t++){
                  if (_ccIsMinuteAllowed(t)) return t;
                }
              } catch (e) {}
              return null;
            }

            picker.innerHTML = `
              <div class="time-picker-header">${headerText}</div>
              <div class="time-picker-display">${formatDisplayTime(selectedHour, selectedMinute)}</div>
              <div class="time-picker-selectors">
                <div class="time-selector">
                  <div class="time-selector-label">Hour</div>
                  <div class="time-scroll-container" data-type="hour"></div>
                </div>
                <div class="time-selector">
                  <div class="time-selector-label">Minute</div>
                  <div class="time-scroll-container" data-type="minute"></div>
                </div>
              </div>
              <div class="time-picker-actions">
                <button class="time-picker-btn cancel" type="button">Cancel</button>
                <button class="time-picker-btn confirm" type="button">Confirm</button>
              </div>
            `;

            const hourContainer = picker.querySelector('[data-type="hour"]');
            for (let h = 0; h < 24; h++){
              const hourStr = String(h).padStart(2, '0');
              const opt = document.createElement('div');
              opt.className = 'time-option';
              try { if (_ccFirstAllowedMinuteForHour(h) === null) opt.classList.add('disabled'); } catch (e) {}
              if (hourStr === selectedHour) opt.classList.add('selected');
              opt.textContent = formatHour(h);
              opt.addEventListener('click', () => {
                hourContainer.querySelectorAll('.time-option').forEach(o => o.classList.remove('selected'));
                opt.classList.add('selected');
                selectedHour = hourStr;
                try {
                  const snapped = _ccSnapToAllowed(selectedHour, selectedMinute);
                  if (snapped !== null) {
                    selectedHour = String(Math.floor(snapped / 60)).padStart(2, '0');
                    selectedMinute = String(snapped % 60).padStart(2, '0');
                  }
                } catch (e) {}
                updateDisplay();
                try { syncMinuteOptions(); } catch (e) {}
                opt.scrollIntoView({ behavior: 'smooth', block: 'center' });
              });
              hourContainer.appendChild(opt);
            }

            const minuteContainer = picker.querySelector('[data-type="minute"]');
            for (let m = 0; m < 60; m++){
              const minStr = String(m).padStart(2, '0');
              const opt = document.createElement('div');
              opt.className = 'time-option';
              if (minStr === selectedMinute) opt.classList.add('selected');
              opt.textContent = minStr;
              opt.addEventListener('click', () => {
                minuteContainer.querySelectorAll('.time-option').forEach(o => o.classList.remove('selected'));
                opt.classList.add('selected');
                selectedMinute = minStr;
                updateDisplay();
                opt.scrollIntoView({ behavior: 'smooth', block: 'center' });
              });
              minuteContainer.appendChild(opt);
            }

            function syncMinuteOptions(){
              try {
                const h = parseInt(selectedHour, 10);
                const opts = Array.from(minuteContainer.querySelectorAll('.time-option'));
                let hasSelected = false;
                for (const o of opts){
                  const mm = parseInt(o.textContent, 10);
                  const min = (isNaN(h) || isNaN(mm)) ? null : (h*60 + mm);
                  const ok = _ccIsMinuteAllowed(min);
                  o.classList.toggle('disabled', !ok);
                  if (ok && o.classList.contains('selected')) hasSelected = true;
                }
                if (!hasSelected){
                  const snap = _ccFirstAllowedMinuteForHour(h);
                  if (snap !== null) {
                    selectedHour = String(Math.floor(snap / 60)).padStart(2, '0');
                    selectedMinute = String(snap % 60).padStart(2, '0');
                    hourContainer.querySelectorAll('.time-option').forEach(o => o.classList.remove('selected'));
                    const hourIdx = parseInt(selectedHour, 10);
                    const hourOpt = hourContainer.querySelectorAll('.time-option')[hourIdx];
                    if (hourOpt) hourOpt.classList.add('selected');
                    minuteContainer.querySelectorAll('.time-option').forEach(o => o.classList.remove('selected'));
                    const minuteOpt = minuteContainer.querySelectorAll('.time-option')[parseInt(selectedMinute,10)];
                    if (minuteOpt) minuteOpt.classList.add('selected');
                    updateDisplay();
                    for (const o of opts){
                      const mm = parseInt(o.textContent, 10);
                      const min = (isNaN(hourIdx) || isNaN(mm)) ? null : (hourIdx*60 + mm);
                      const ok = _ccIsMinuteAllowed(min);
                      o.classList.toggle('disabled', !ok);
                    }
                  }
                }
              } catch (e) { /* ignore */ }
            }

            function updateDisplay(){
              picker.querySelector('.time-picker-display').textContent = formatDisplayTime(selectedHour, selectedMinute);
            }
            function formatHour(h){
              if (h === 0) return '12 AM';
              if (h < 12) return `${h} AM`;
              if (h === 12) return '12 PM';
              return `${h - 12} PM`;
            }
            function formatDisplayTime(h, m){
              const hour = parseInt(h, 10);
              const ampm = hour >= 12 ? 'PM' : 'AM';
              const h12 = hour === 0 ? 12 : (hour > 12 ? hour - 12 : hour);
              return `${h12}:${m} ${ampm}`;
            }

            setTimeout(() => {
              try{ hourContainer.querySelector('.selected')?.scrollIntoView({ block: 'center' }); }catch(e){}
              try{ minuteContainer.querySelector('.selected')?.scrollIntoView({ block: 'center' }); }catch(e){}
            }, 50);

            // Apply constraints immediately (snap initial selection + disable invalid options)
            try {
              const snapped = _ccSnapToAllowed(selectedHour, selectedMinute);
              if (snapped !== null) {
                selectedHour = String(Math.floor(snapped / 60)).padStart(2, '0');
                selectedMinute = String(snapped % 60).padStart(2, '0');
                hourContainer.querySelectorAll('.time-option').forEach(o => o.classList.remove('selected'));
                const hourIdx = parseInt(selectedHour, 10);
                const hourOpt = hourContainer.querySelectorAll('.time-option')[hourIdx];
                if (hourOpt) hourOpt.classList.add('selected');
                minuteContainer.querySelectorAll('.time-option').forEach(o => o.classList.remove('selected'));
                const minuteOpt = minuteContainer.querySelectorAll('.time-option')[parseInt(selectedMinute,10)];
                if (minuteOpt) minuteOpt.classList.add('selected');
                updateDisplay();
              }
              syncMinuteOptions();
            } catch (e) {}

            picker.querySelector('.confirm').addEventListener('click', (e) => {
              e.stopPropagation();
              inputElement.value = `${selectedHour}:${selectedMinute}`;
              try{ inputElement.dispatchEvent(new Event('input', { bubbles: true })); }catch(err){}
              try{ inputElement.dispatchEvent(new Event('change', { bubbles: true })); }catch(err){}
              picker.remove();
            });
            picker.querySelector('.cancel').addEventListener('click', (e) => {
              e.stopPropagation();
              picker.remove();
            });

            setTimeout(() => {
              document.addEventListener('click', function closeOnOutside(ev){
                try{
                  if (!picker.contains(ev.target) && ev.target !== inputElement) {
                    picker.remove();
                    document.removeEventListener('click', closeOnOutside);
                  }
                }catch(e){ /* ignore */ }
              });
            }, 100);

            return picker;
          }

          function normalizeTime(t){
            const s = String(t || '').trim();
            // accept HH:MM
            if (s.length === 5 && s[2] === ':') return s;
            return '';
          }

          function parseRanges(raw){
            const out = [];
            const s = String(raw || '').trim();
            if (!s) return out;
            const parts = s.split(',').map(x => x.trim()).filter(Boolean);
            for (const p of parts){
              const seg = p.split('-').map(x => x.trim());
              if (seg.length !== 2) continue;
              const a = normalizeTime(seg[0]);
              const b = normalizeTime(seg[1]);
              if (!a || !b) continue;
              out.push({start: a, end: b});
            }
            return out;
          }

          function buildRangeRow(startVal, endVal, onChange, onRemove, disabled, dayIdx){
            const row = document.createElement('div');
            row.className = 'svc-range-row';
            row.style.display = 'flex';
            row.style.alignItems = 'center';
            row.style.gap = '10px';

            const startContainer = document.createElement('div');
            startContainer.className = 'time-input-container';
            const start = document.createElement('input');
            start.type = 'time';
            start.value = startVal || '';
            start.className = 'cc-field range-start';
            try{ start.dataset.day = String(dayIdx); }catch(e){}
            start.style.maxWidth = '140px';
            start.readOnly = true;
            start.style.cursor = 'pointer';
            startContainer.appendChild(start);

            const endContainer = document.createElement('div');
            endContainer.className = 'time-input-container';
            const end = document.createElement('input');
            end.type = 'time';
            end.value = endVal || '';
            end.className = 'cc-field range-end';
            try{ end.dataset.day = String(dayIdx); }catch(e){}
            end.style.maxWidth = '140px';
            end.readOnly = true;
            end.style.cursor = 'pointer';
            endContainer.appendChild(end);

            const remove = document.createElement('button');
            remove.type = 'button';
            remove.textContent = 'Remove';
            remove.className = 'text-sm text-gray-600 hover:text-gray-800';

            function fire(){ try{ onChange(); }catch(e){} }

            start.addEventListener('input', fire);
            end.addEventListener('input', fire);

            // Open custom picker on click (matches calendar default availability)
            start.addEventListener('click', function(e){
              e.preventDefault();
              e.stopPropagation();
              try {
                document.querySelectorAll('#svcAvailEditor .custom-time-picker').forEach(p => p.remove());
                const picker = createCustomTimePicker(start);
                picker.classList.add('active');
                startContainer.appendChild(picker);
              } catch (err) { /* ignore */ }
            });
            end.addEventListener('click', function(e){
              e.preventDefault();
              e.stopPropagation();
              try {
                document.querySelectorAll('#svcAvailEditor .custom-time-picker').forEach(p => p.remove());
                const picker = createCustomTimePicker(end);
                picker.classList.add('active');
                endContainer.appendChild(picker);
              } catch (err) { /* ignore */ }
            });
            remove.addEventListener('click', function(){
              try{ onRemove(row); }catch(e){}
              fire();
            });

            if (disabled){
              start.disabled = true;
              end.disabled = true;
              remove.disabled = true;
            }

            row.appendChild(startContainer);
            row.appendChild(endContainer);
            row.appendChild(remove);

            row.__get = function(){
              return { start: normalizeTime(start.value), end: normalizeTime(end.value) };
            };

            return row;
          }

          const editors = Array.from(document.querySelectorAll('.svc-day-editor'));
          for (const ed of editors){
            const ui = ed.getAttribute('data-ui');
            const disabled = ed.getAttribute('data-disabled') === '1';
            const hidden = document.querySelector('.svc-avail-hidden[data-ui="' + ui + '"]');
            const list = ed.querySelector('.svc-ranges');
            const unavail = ed.querySelector('.svc-unavail');
            const addBtn = ed.querySelector('.svc-add-range');
            if (!hidden || !list || !unavail || !addBtn) continue;

            // Lock behavior:
            // - hard-lock: there is no allowed time AND there are no existing ranges for this service on this day.
            // - no-remaining: there is no allowed time BUT the service already has ranges (legacy/conflict); allow editing/removal,
            //   but don't allow adding new ranges.
            const meta = ed.querySelector('.cc-svc-day-meta[data-ui="' + ui + '"]');
            const hardLock = !!(meta && meta.getAttribute('data-hard-lock') === '1');
            const noRemaining = !!(meta && meta.getAttribute('data-no-remaining') === '1');
            if (hardLock){
              try { ed.closest('.border')?.classList.add('cc-svc-day-locked'); } catch (e) {}
              try {
                // Force unavailable and clear any existing rows (they would be invalid under member constraints)
                unavail.checked = true;
                unavail.disabled = true;
                list.textContent = '';
                hidden.value = '';
                addBtn.disabled = true;
                addBtn.style.display = 'none';
              } catch (e) {}
              continue;
            }

            if (noRemaining){
              try { addBtn.disabled = true; } catch (e) {}
              try { addBtn.style.display = 'none'; } catch (e) {}
            }

            function syncHidden(){
              if (unavail.checked){
                hidden.value = '';
                return;
              }
              const ranges = [];
              for (const child of Array.from(list.children)){
                if (!child.__get) continue;
                const r = child.__get();
                if (!r.start || !r.end) continue;
                ranges.push(r.start + '-' + r.end);
              }
              hidden.value = ranges.join(',');
            }

            function setAvailabilityEnabled(){
              const isUnavail = !!unavail.checked;
              list.style.opacity = isUnavail ? '0.6' : '1';
              addBtn.style.opacity = (isUnavail || disabled || noRemaining) ? '0.5' : '1';
              try{ addBtn.disabled = isUnavail || disabled || noRemaining; }catch(e){}
              for (const child of Array.from(list.children)){
                try{
                  const inputs = child.querySelectorAll('input, button');
                  inputs.forEach(i => { i.disabled = disabled || isUnavail; });
                }catch(e){}
              }
              if (isUnavail){
                // Keep existing UI rows but they won't be submitted.
                syncHidden();
              }
            }

            function removeRow(node){
              try{ node.remove(); }catch(e){}

              // If all ranges are removed, automatically mark the day unavailable.
              // This matches backend semantics (no rows => unavailable) and avoids
              // requiring an extra manual checkbox click.
              try{
                const hasAny = !!(list && list.children && list.children.length);
                if (!hasAny){
                  unavail.checked = true;
                  list.textContent = '';
                  if (noRemaining){
                    try { addBtn.disabled = true; } catch (e) {}
                    try { addBtn.style.display = 'none'; } catch (e) {}
                  }
                  setAvailabilityEnabled();
                  syncHidden();
                }
              }catch(e){}
            }

            function addRow(startVal, endVal){
              const row = buildRangeRow(startVal, endVal, syncHidden, removeRow, disabled, ui);
              list.appendChild(row);
            }

            // init from hidden
            const initial = parseRanges(hidden.value);
            if (initial.length){
              unavail.checked = false;
              for (const r of initial) addRow(r.start, r.end);
            } else {
              unavail.checked = true;
            }

            unavail.addEventListener('change', function(){
              if (unavail.checked){
                // clear rows when marking unavailable
                list.textContent = '';
              } else {
                if (noRemaining){
                  // No remaining allowed time; keep day unavailable unless it already has ranges.
                  if (!list.children.length){
                    unavail.checked = true;
                  }
                } else {
                  if (!list.children.length) addRow('09:00','17:00');
                }
              }
              setAvailabilityEnabled();
              syncHidden();
            });

            addBtn.addEventListener('click', function(){
              if (disabled || unavail.checked || noRemaining) return;
              addRow('09:00','17:00');
              setAvailabilityEnabled();
              syncHidden();
            });

            setAvailabilityEnabled();
            syncHidden();
          }
        }catch(e){ console.warn('svc availability editor init failed', e); }
      })();
    </script>

    <!-- Bottom action bar: Cancel (left) and Save (right) -->
    <div class="flex items-center justify-between mt-6 svc-actionbar-bottom">
      <a href="{% url 'calendar_app:dashboard' org.slug %}" class="text-sm text-gray-500 hover:text-gray-700">Cancel</a>
      <div class="flex items-center svc-actionbar-actions-bottom">
        <button type="button" class="svc-save-btn inline-flex items-center px-4 py-2 rounded-md bg-blue-600 text-white text-sm font-medium hover:bg-blue-700">Save Changes</button>
        <a id="svc-view-btn-bottom" data-saved="{{ request.GET.saved|yesno:'1,0' }}" href="{% url 'bookings:public_service_page' org.slug service.slug %}" target="_blank" rel="noopener noreferrer" class="inline-flex items-center px-3 py-2 ml-3 rounded-md text-sm font-medium border border-blue-600 text-blue-600 bg-white hover:bg-blue-50 {% if not request.GET.saved %}opacity-50 cursor-not-allowed{% endif %}">View public page</a>
      </div>
    </div>
  </form>
</div>
<template id="svc-conflict-modal-tpl">
  <div class="cc-modal-backdrop" style="position:fixed;inset:0;background:rgba(0,0,0,0.4);display:flex;align-items:center;justify-content:center;z-index:1200">
    <div style="background:#fff;padding:1rem;border-radius:8px;max-width:760px;width:95%;box-shadow:0 6px 24px rgba(0,0,0,0.2);display:flex;flex-direction:column;max-height:80vh;">
        <h3 style="margin:0 0 0.5rem 0;font-weight:700">Conflicting bookings detected</h3>
        <p style="margin:0 0 0.75rem 0;color:#374151">Some booked days already use previous settings. When you confirm, those dates will keep their frozen settings — the new settings will only apply to days without bookings. Review the preserved settings listed under each affected date before confirming.</p>
      <div id="svc-conflict-list" style="flex:1;overflow:auto;border-radius:8px;margin-bottom:12px;padding:6px 6px 0 6px">
        <!-- Booking rows will be injected here as individual stacked items -->
      </div>
      <style>
        /* Modal list layout */
        #svc-conflict-list { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; font-size:0.95rem; }

        /* Modal actions: default (desktop/tablet) stays right-aligned like before.
           Mobile only: Cancel left + Confirm right, with compact sizing and wrapping. */
        .cc-modal-actions { display:flex; justify-content:flex-end; align-items:center; gap:10px; }
        .cc-modal-actions button { border-radius:6px; font-weight:600; font-size:0.9rem; padding:8px 12px; }
        #svc-conflict-cancel { border:1px solid #cbd5e1; background:#fff; color:#374151; flex:0 0 auto; }
        #svc-conflict-confirm { background:#0ea5e9; color:#fff; border:none; flex:0 0 auto; white-space:nowrap; line-height:1.2; text-align:center; }

        @media (max-width:640px){
          .cc-modal-actions { justify-content:space-between; }
          #svc-conflict-confirm { flex:1 1 auto; margin-left:auto; max-width:72%; white-space:normal; }
        }
        @media (max-width:420px){
          .cc-modal-actions button { font-size:0.82rem; padding:6px 10px; }
          #svc-conflict-confirm { max-width:70%; }
        }

        /* Date heading */
        .conflict-group-heading { font-weight:700; margin:12px 0 8px; color:#0f172a; display:flex; align-items:center; justify-content:space-between; background:#f8fafc; padding:8px 10px; border-radius:8px; border:1px solid #e6eef6 }
        .conflict-group-heading .date-left { font-size:0.98rem; }
        .conflict-group-heading .date-count { font-size:0.88rem; color:#475569; margin-left:8px }

        /* Status pill */
        .conflict-status { font-size:0.85rem; color:#6b7280; font-weight:500; margin-left:8px; }
        .status-pill { font-size:0.78rem; padding:4px 8px; border-radius:999px; background:#f1f5f9; color:#0f172a; font-weight:600; border:1px solid #e2e8f0 }

        /* Preserved (frozen) settings block */
        .changes-wrap { background:#ffffff; border-radius:8px; padding:12px; border:1px solid #e6eef6; margin:10px 6px 14px 6px; box-shadow: 0 1px 2px rgba(16,24,40,0.03) }
        .changes-title { font-weight:700; margin-bottom:6px; color:#0f172a; font-size:0.95rem }
        .changes-note { font-size:0.86rem; color:#475569; margin-bottom:8px }
        .changes-wrap ul { margin:0; padding-left:16px; }
        .changes-wrap li { margin-bottom:6px; color:#0f172a }
        .changes-wrap li strong { display:inline-block; width:180px; font-weight:600; color:#111827 }
        @media (max-width:640px){ .changes-wrap li strong { width: 120px } }

        /* Individual booking rows */
        .conflict-item { display:block; padding:10px 12px; border-radius:8px; background:#ffffff; border:1px solid #eef3f8; margin-bottom:8px; }
        .conflict-item.empty { text-align:center; color:#6b7280; background:transparent; border:none; box-shadow:none; padding:8px; }
        .conflict-main { display:block; color:#0f172a; }
        .conflict-line { display:flex; justify-content:space-between; gap:12px; align-items:center; font-weight:600; color:#111827; }
        .conflict-meta { font-weight:400; color:#374151; font-size:0.92rem }
        .conflict-client { color:#374151; font-weight:600; margin-left:0; }
        .conflict-email { color:#6b7280; font-weight:400; margin-left:6px; }

        @media (max-width:720px){ .conflict-line{flex-direction:column;align-items:flex-start} }
      </style>
      <div class="cc-modal-actions">
          <button id="svc-conflict-cancel" type="button">Cancel</button>
          <button id="svc-conflict-confirm" type="button">Confirm and apply changes</button>
      </div>
    </div>
  </div>
</template>

<script>
    (function(){
    try{
      const btns = Array.from(document.querySelectorAll('.svc-save-btn'));
      // expose current service fields for modal status labels and changes preview
      try{ window.__svc_current = {
        duration: {{ service.duration|default:0 }},
        buffer_after: {{ service.buffer_after|default:0 }},
        time_increment_minutes: {{ service.time_increment_minutes|default:30 }},
        use_fixed_increment: {{ service.use_fixed_increment|yesno:"true,false" }},
        allow_squished_bookings: {{ service.allow_squished_bookings|yesno:"true,false" }},
        allow_ends_after_availability: {{ service.allow_ends_after_availability|yesno:"true,false" }},
        refunds_allowed: {{ service.refunds_allowed|yesno:"true,false" }},
        refund_cutoff_hours: {{ service.refund_cutoff_hours|default:24 }},
        refund_policy_text: "{{ service.refund_policy_text|escapejs }}",
        price: "{{ service.price }}",
        name: "{{ service.name|escapejs }}",
        description: "{{ service.description|escapejs }}",
        min_notice_hours: {{ service.min_notice_hours|default:1 }},
        max_booking_days: {% if can_use_pro_team %}{{ service.max_booking_days|default:30 }}{% elif is_trialing %}31{% else %}30{% endif %},
        show_on_public_calendar: {{ service.show_on_public_calendar|yesno:"true,false" }},
        requires_facility_resources: {{ service.requires_facility_resources|yesno:"true,false" }}
      }; }catch(e){}
    const form = document.querySelector('form.cc-form');
    if (!btns.length || !form) return;

    const savingOverlay = document.getElementById('svc-saving-overlay');
    function setSaving(isSaving){
      try{
        if (!savingOverlay) return;
        if (isSaving){
          savingOverlay.classList.add('active');
          savingOverlay.setAttribute('aria-hidden', 'false');
          try{ document.documentElement.setAttribute('aria-busy', 'true'); }catch(e){}
        } else {
          savingOverlay.classList.remove('active');
          savingOverlay.setAttribute('aria-hidden', 'true');
          try{ document.documentElement.removeAttribute('aria-busy'); }catch(e){}
        }
      }catch(e){}
    }

    function getCsrf(){
      const el = form.querySelector('input[name=csrfmiddlewaretoken]');
      return el ? el.value : '';
    }

    async function postJson(url, payload){
      const res = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': getCsrf()
        },
        body: JSON.stringify(payload || {})
      });
      return res.json();
    }

    function serializeFormToPayload(){
      const fd = new FormData(form);
      const out = {};

      // Collect repeated keys (e.g., assigned_members) as arrays.
      for (const [k, v] of fd.entries()){
        if (Object.prototype.hasOwnProperty.call(out, k)){
          if (!Array.isArray(out[k])) out[k] = [out[k]];
          out[k].push(v);
        } else {
          out[k] = v;
        }
      }

      // Normalize known numeric fields (take last value if repeated).
      const numericNames = ['time_increment_minutes', 'duration', 'buffer_after', 'min_notice_hours', 'max_booking_days', 'refund_cutoff_hours'];
      for (const k of numericNames){
        if (!(k in out)) continue;
        const raw = Array.isArray(out[k]) ? out[k][out[k].length - 1] : out[k];
        out[k] = Number(raw);
      }

      // Stabilize arrays for comparison and predictable payloads.
      for (const k of Object.keys(out)){
        if (Array.isArray(out[k])){
          out[k] = out[k].map(x => String(x)).sort();
        }
      }

      const booleanNames = ['use_fixed_increment', 'allow_squished_bookings', 'show_on_public_calendar', 'requires_facility_resources', 'refunds_allowed', 'allow_ends_after_availability', 'apply_to_conflicts'];
      for (const name of booleanNames){
        try{
          // Prefer the checkbox input (if present) over any hidden fallback input
          let el = form.querySelector(`[name="${name}"][type="checkbox"]`) || form.querySelector(`[name="${name}"]`);
          if (!el) { out[name] = false; }
          else if (el.type === 'checkbox') { out[name] = !!el.checked; }
          else {
            const v = String(el.value || '').toLowerCase();
            out[name] = (v === '1' || v === 'true' || v === 'on');
          }
        } catch (e) {
          out[name] = false;
        }
      }

      // Payment methods: always include explicit values so the JSON save endpoint
      // can persist unchecked/cleared states.
      try{
        const stripeEl = form.querySelector('#allow_stripe_payments');
        out.allow_stripe_payments = !!(stripeEl && stripeEl.checked);
      }catch(e){ out.allow_stripe_payments = false; }

      try{
        const selected = Array.from(form.querySelectorAll('input[name="offline_methods"]:checked'))
          .map(el => String(el.value || ''))
          .filter(v => !!v)
          .sort();
        out.offline_methods = selected;
      }catch(e){ out.offline_methods = []; }

      return out;
    }

    // Shared detector for whether an item uses fixed increments. Placed at
    // top-level so debug code and node builder both call the same logic.
    function detectUsesFixed(item){
      try{
        if (!item) return false;
        function norm(v){
          if (v === true || v === 1 || v === '1') return true;
          if (v === false || v === 0 || v === '0') return false;
          if (typeof v === 'string'){
            const low = v.trim().toLowerCase();
            if (low === 'true' || low === 'yes' || low === 'y') return true;
            if (low === 'false' || low === 'no' || low === 'n') return false;
            if (!isNaN(Number(low))) return Number(low) !== 0;
          }
          return !!v;
        }

        if (item.use_fixed_increment !== undefined) return !!norm(item.use_fixed_increment);
        if (item.uses_fixed_increment !== undefined) return !!norm(item.uses_fixed_increment);
        if (item.service && item.service.use_fixed_increment !== undefined) return !!norm(item.service.use_fixed_increment);
        if (item.service && item.service.uses_fixed_increment !== undefined) return !!norm(item.service.uses_fixed_increment);
        if (item.snapshot && item.snapshot.use_fixed_increment !== undefined) return !!norm(item.snapshot.use_fixed_increment);
        if (item.snapshot && item.snapshot.uses_fixed_increment !== undefined) return !!norm(item.snapshot.uses_fixed_increment);
        if (item.service_snapshot && item.service_snapshot.use_fixed_increment !== undefined) return !!norm(item.service_snapshot.use_fixed_increment);
        if (item.service_snapshot && item.service_snapshot.uses_fixed_increment !== undefined) return !!norm(item.service_snapshot.uses_fixed_increment);
        return false;
      } catch(e){ return false; }
    }

    function buildConflictNodes(conflicts){
      // Render per-date blocks: heading, frozen-settings (if present), then bookings
      const nodes = [];
      const days = Object.keys(conflicts).sort();

      function ordinalSuffix(n){
        const s = ["th","st","nd","rd"], v = n % 100;
        return (s[(v-20)%10] || s[v] || s[0]);
      }
      function fmtTime(d){ try{ return d.toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit',hour12:true}); }catch(e){ return '' } }
      function fmtDateRangeSingle(startD, endD){
        if (!startD) return '';
        try{
          const weekday = startD.toLocaleDateString('en-US',{weekday:'long'});
          const month = startD.toLocaleDateString('en-US',{month:'long'});
          const day = startD.getDate();
          const year = startD.getFullYear();
          const startT = fmtTime(startD);
          const endT = endD ? fmtTime(endD) : '';
          const dayWithOrd = `${day}${ordinalSuffix(day)}`;
          return `${weekday}, ${month} ${dayWithOrd}, ${year}, at ${startT}${endT ? ' - ' + endT : ''}`;
        }catch(e){ return '' }
      }

      for (const d of days){
        const items = conflicts[d] || [];
        // create date heading
        const heading = document.createElement('div');
        heading.className = 'conflict-group-heading';
        const left = document.createElement('div'); left.textContent = `${(new Date(d)).toLocaleDateString('en-US',{weekday:'long',month:'short',day:'numeric',year:'numeric'})} (${items.length})`;
        heading.appendChild(left);
        nodes.push(heading);

        // If a freeze exists for this date, present its preserved settings
        try{
          const first = items[0];
          const freeze = first && first.existing_freeze ? first.existing_freeze : null;
          if (freeze && typeof freeze === 'object'){
            const wrap = document.createElement('div'); wrap.className = 'changes-wrap';
            const title = document.createElement('div'); title.className = 'changes-title'; title.textContent = 'Preserved (frozen) settings for this date:'; wrap.appendChild(title);
            const note = document.createElement('div'); note.className = 'changes-note'; note.textContent = 'These settings will be kept for the booked date — your new settings will not override them.'; wrap.appendChild(note);
            const list = document.createElement('ul'); list.style.margin = '0'; list.style.paddingLeft = '14px';
            const keys = ['use_fixed_increment','time_increment_minutes','allow_squished_bookings','allow_ends_after_availability','duration','buffer_after'];
            for (const k of keys){
              if (!(k in freeze)) continue;
              const li = document.createElement('li'); li.style.marginBottom = '6px';
              const label = k.replace(/_/g,' ');
              let val = freeze[k];
              if (k === 'use_fixed_increment' || k === 'allow_squished_bookings' || k === 'allow_ends_after_availability'){
                val = (val === true || val === 'true' || val === 1 || val === '1') ? 'Yes' : 'No';
              } else if (k === 'time_increment_minutes'){
                val = (val || 0) + ' minutes';
              } else if (k === 'duration' || k === 'buffer_after'){
                val = (val || 0) + ' minutes';
              }
              const lbl = document.createElement('strong'); lbl.textContent = label + ':';
              const vspan = document.createElement('span'); vspan.style.marginLeft = '8px'; vspan.textContent = val;
              li.appendChild(lbl);
              li.appendChild(vspan);
              list.appendChild(li);
            }
            wrap.appendChild(list);
            nodes.push(wrap);
          }
        }catch(e){}

        // Render each booking row for the date
        for (const it of items){
          const name = it.client_name || '(no name)';
          const email = it.client_email || '';
          const start = it.start ? new Date(it.start) : null;
          let end = it.end ? new Date(it.end) : null;
          if (!end && start){
            let dur = null;
            if (it.duration !== undefined && it.duration !== null) dur = Number(it.duration);
            else if (it.duration_minutes !== undefined && it.duration_minutes !== null) dur = Number(it.duration_minutes);
            if (dur) end = new Date(start.getTime() + (Number(dur) || 0) * 60000);
          }
          const desc = fmtDateRangeSingle(start, end);
          const row = document.createElement('div'); row.className = 'conflict-item';
          const main = document.createElement('div'); main.className = 'conflict-main';
          main.innerHTML = `\n+            <div class="conflict-line">${escapeHtml(desc)}&nbsp;&nbsp;&nbsp;&nbsp;Client: ${escapeHtml(name)}${email ? ' &lt;' + escapeHtml(email) + '&gt;' : ''}</div>\n+          `;
          row.appendChild(main);
          nodes.push(row);
        }
      }

      return nodes;
    }

    // Build a DOM node listing other setting changes between current and proposed
    function buildChangesNode(proposed, current){
      try{
        if (!proposed || !current) return null;
        const keys = [
          'name','description','duration','buffer_after','time_increment_minutes','use_fixed_increment',
          'allow_squished_bookings','allow_ends_after_availability','refunds_allowed','refund_cutoff_hours','refund_policy_text',
          'price','min_notice_hours','max_booking_days','show_on_public_calendar','requires_facility_resources'
        ];
        function normVal(k,v){
          if (k === 'use_fixed_increment' || k === 'allow_squished_bookings' || k === 'allow_ends_after_availability' || k === 'refunds_allowed' || k === 'show_on_public_calendar' || k === 'requires_facility_resources'){
            if (v === true || v === 'true' || v === 1 || v === '1') return true;
            return false;
          }
          if (k === 'duration' || k === 'buffer_after' || k === 'time_increment_minutes' || k === 'refund_cutoff_hours' || k === 'min_notice_hours' || k === 'max_booking_days'){
            try{ return Number(v) || 0; }catch(e){ return 0; }
          }
          if (k === 'price') return String(v || '');
          return String(v || '');
        }

        const diffs = [];
        for (const k of keys){
          const cur = normVal(k, current[k]);
          const prop = normVal(k, proposed[k]);
          const changed = (typeof cur === 'boolean') ? (cur !== prop) : (String(cur) !== String(prop));
          if (changed) diffs.push({key:k, current:current[k], proposed:proposed[k]});
        }
        if (!diffs.length) return null;

        const wrap = document.createElement('div');
        wrap.style.margin = '8px 6px';
        wrap.style.padding = '10px';
        wrap.style.borderTop = '1px solid #eef2f7';

        const title = document.createElement('div');
        title.style.fontWeight = '700';
        title.style.marginBottom = '8px';
        title.textContent = 'Service setting changes:';
        wrap.appendChild(title);

        const grid = document.createElement('div');
        grid.style.display = 'grid';
        grid.style.gridTemplateColumns = '1fr 1fr';
        grid.style.gap = '12px';

        const curCol = document.createElement('div');
        const curTitle = document.createElement('div'); curTitle.style.fontWeight='600'; curTitle.textContent='Current:'; curCol.appendChild(curTitle);
        const curList = document.createElement('ul'); curList.style.marginTop='6px'; curCol.appendChild(curList);

        const propCol = document.createElement('div');
        const propTitle = document.createElement('div'); propTitle.style.fontWeight='600'; propTitle.textContent='Will be applied:'; propCol.appendChild(propTitle);
        const propList = document.createElement('ul'); propList.style.marginTop='6px'; propCol.appendChild(propList);

        function renderVal(k,v){
          if (k === 'use_fixed_increment' || k === 'allow_squished_bookings' || k === 'allow_ends_after_availability' || k === 'refunds_allowed'){
            return (v === true || v === 'true' || v === 1 || v === '1') ? '✓' : '✕';
          }
          if (k === 'duration') return (v || 0) + ' minutes';
          if (k === 'buffer_after') return (v || 0) + ' minutes';
          if (k === 'price') return (v !== undefined && v !== null) ? '$' + v : '';
          if (k === 'refund_policy_text') return String(v || '—');
          return String(v === undefined || v === null ? '' : v);
        }

        for (const d of diffs){
          const label = document.createElement('li'); label.style.marginBottom='6px'; label.textContent = (d.key.replace(/_/g,' '));
          const label2 = document.createElement('li'); label2.style.marginBottom='6px'; label2.textContent = (d.key.replace(/_/g,' '));
          const curVal = document.createElement('div'); curVal.style.color='#374151'; curVal.style.fontWeight='400'; curVal.textContent = renderVal(d.key, d.current);
          const propVal = document.createElement('div'); propVal.style.color='#374151'; propVal.style.fontWeight='400'; propVal.textContent = renderVal(d.key, d.proposed);
          label.appendChild(curVal);
          label2.appendChild(propVal);
          curList.appendChild(label);
          propList.appendChild(label2);
        }

        grid.appendChild(curCol); grid.appendChild(propCol);
        wrap.appendChild(grid);
        return wrap;
      }catch(e){ return null; }
    }

    // Basic escaping helper used only for small text pieces
    function escapeHtml(s){
      try{ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }catch(e){ return '' }
    }

    function showModal(conflicts, proposedPayload, currentUseFixed, onConfirm){
      const tpl = document.getElementById('svc-conflict-modal-tpl');
      const clone = tpl.content.cloneNode(true);
      const backdrop = clone.querySelector('.cc-modal-backdrop');
      const list = clone.querySelector('#svc-conflict-list');
      const titleEl = clone.querySelector('h3');
      const descEl = clone.querySelector('p');
      const confirmBtn = clone.querySelector('#svc-conflict-confirm');
      // store small context so buildConflictNodes can show applied/will apply labels
      try{ window.__conflict_ctx = { proposedUseFixed: !!(proposedPayload && proposedPayload.use_fixed_increment), currentUseFixed: !!currentUseFixed, proposedPayload: proposedPayload || {} }; }catch(e){}

      function shouldShowOfflinePaymentWarning(pl){
        try{
          if (!pl) return false;
          const price = Number(pl.price || 0);
          const isPaid = Number.isFinite(price) && price > 0;
          if (!isPaid) return false;
          const offs = Array.isArray(pl.offline_methods) ? pl.offline_methods : [];
          return offs.length > 0;
        }catch(e){ return false; }
      }

      function buildOfflinePaymentWarningNode(){
        try{
          if (!shouldShowOfflinePaymentWarning(proposedPayload)) return null;
          const wrap = document.createElement('div');
          wrap.style.margin = '6px';
          wrap.style.padding = '12px';
          wrap.style.border = '1px solid #fde68a';
          wrap.style.background = '#fffbeb';
          wrap.style.borderRadius = '10px';
          wrap.innerHTML = `
            <div style="font-weight:800; color:#92400e; margin-bottom:6px;">Offline payment warning</div>
            <div style="color:#78350f; font-size:0.95rem; line-height:1.4;">
              You enabled a payment method that is processed outside CircleCal (Venmo/Zelle/Cash). These methods cannot enforce automatic refunds by cutoff and clients can potentially not pay.
              <div style="margin-top:8px;">As the controller of your service, you have the right to refuse or provide service to anyone that fails to follow fair and established rules.</div>
              <div style="margin-top:8px;">It is much easier with only Stripe implemented, but that reduces flexibility for clients who want to pay another way besides card.</div>
            </div>
          `;
          return wrap;
        }catch(e){ return null; }
      }

      const hasConflicts = !!(conflicts && Object.keys(conflicts || {}).length);
      const warnNode = buildOfflinePaymentWarningNode();
      if (!hasConflicts && warnNode){
        try{ if (titleEl) titleEl.textContent = 'Payment method warning'; }catch(e){}
        try{ if (descEl) descEl.textContent = 'Review this note before saving changes.'; }catch(e){}
        try{ if (confirmBtn) confirmBtn.textContent = 'I understand, save changes'; }catch(e){}
      } else {
        // Reset button text in case the template is reused
        try{ if (confirmBtn) confirmBtn.textContent = 'Confirm and apply changes'; }catch(e){}
      }
      // clear and populate with structured rows (one booking per stacked row)
      list.textContent = '';
      const nodes = buildConflictNodes(conflicts || {});
      // Payment warning node should appear at the top when applicable.
      try{ if (warnNode) nodes.unshift(warnNode); }catch(e){}
      // Render a settings diff node (only when there are changes)
      try{
        const changesNode = buildChangesNode(window.__conflict_ctx.proposedPayload, window.__svc_current || {});
        if (changesNode) nodes.push(changesNode);
      }catch(e){}
      
      if (!nodes.length){
        const empty = document.createElement('div');
        empty.className = 'conflict-item empty';
        empty.textContent = 'No bookings found.';
        list.appendChild(empty);
      } else {
        for (const n of nodes) list.appendChild(n);
      }
      document.body.appendChild(backdrop);
      backdrop.querySelector('#svc-conflict-cancel').addEventListener('click', function(){ backdrop.remove(); });
      backdrop.querySelector('#svc-conflict-confirm').addEventListener('click', async function(){
        backdrop.remove();
        try {
          await onConfirm();
        } catch (err) {
          console.warn('apply-confirm failed, falling back to form submit', err);
          try { form.submit(); } catch(e){ window.location.reload(); }
        }
      });
    }

    async function onSaveClick(ev){
      try{
        // If the URL has ?saved=1 from a previous successful save, hide that
        // success banner as soon as the user attempts a new save. If this save
        // fails (e.g. overlap rejection), we should not keep showing success.
        function hideSavedBanner(){
          try{
            const el = document.getElementById('svc-saved-banner');
            if (el) el.style.display = 'none';
          }catch(e){}
        }

        function showErrorBanner(msg){
          try{
            try{ setSaving(false); }catch(e){}
            hideSavedBanner();
            let el = document.getElementById('svc-error-banner');
            if (!el){
              el = document.createElement('div');
              el.id = 'svc-error-banner';
              el.setAttribute('role', 'status');
              el.setAttribute('aria-live', 'polite');
              el.className = 'mb-4 p-3 rounded';
              el.style.borderLeft = '4px solid #dc2626';
              el.style.background = '#fef2f2';
              el.style.color = '#7f1d1d';
              try{
                const form = document.querySelector('form.cc-form');
                if (form) form.insertBefore(el, form.firstChild && form.firstChild.nextSibling ? form.firstChild.nextSibling : form.firstChild);
              }catch(e){ document.body.appendChild(el); }
            }
            const safe = String(msg || '').trim();
            el.innerHTML = `<strong>Couldn't save</strong><div class="text-sm mt-1">${escapeHtml(safe || 'The server rejected these changes.')}</div>`;
            el.style.display = 'block';
            try{ el.scrollIntoView({behavior:'smooth', block:'nearest'}); }catch(e){}
          }catch(e){ try{ alert(msg || 'Unable to save changes.'); }catch(_){ } }
        }

        // Clear any prior error banner on new attempt
        try{ const prior = document.getElementById('svc-error-banner'); if (prior) prior.style.display = 'none'; }catch(e){}
        hideSavedBanner();

        const payload = serializeFormToPayload();

        // Enforce: paid services can't enable Venmo/Zelle unless the org has configured them.
        try{
          const ORG_HAS_VENMO = {{ org_has_venmo|yesno:"true,false" }};
          const ORG_HAS_ZELLE = {{ org_has_zelle|yesno:"true,false" }};
          const price = Number(payload.price || 0);
          const isPaid = Number.isFinite(price) && price > 0;
          const offs = Array.isArray(payload.offline_methods) ? payload.offline_methods : [];
          if (isPaid && offs.includes('venmo') && !ORG_HAS_VENMO){
            showErrorBanner('To enable Venmo for a paid service, add your Venmo info on your Profile page first.');
            return;
          }
          if (isPaid && offs.includes('zelle') && !ORG_HAS_ZELLE){
            showErrorBanner('To enable Zelle for a paid service, add your Zelle info on your Profile page first.');
            return;
          }
        }catch(e){ /* ignore client-side validation errors */ }

        const previewUrl = window.location.pathname.replace('/edit/', '/preview_update/');
        const applyUrl = window.location.pathname.replace('/edit/', '/apply_update/');

        async function applyAndRedirect(pl) {
          try {
            pl.confirm = true;
            const applied = await postJson(applyUrl, pl);
            if (applied && applied.status === 'error'){
              showErrorBanner(applied.error || 'Unable to save changes.');
              return false;
            }
            if (applied && applied.status === 'ok'){
              const base = window.location.pathname;
              // If the user attempted to enable public visibility but the server denied it,
              // redirect with a clear banner explaining what needs to be fixed.
              try{
                if (applied.public_show_denied){
                  const reason = String(applied.public_show_reason || 'This service cannot be shown publicly yet.');
                  window.location.href = base + '?saved=1&public_show_denied=1&public_show_reason=' + encodeURIComponent(reason);
                  return true;
                }
              }catch(e){ /* ignore */ }

              window.location.href = base + '?saved=1';
              return true;
            }
            try{ setSaving(false); }catch(e){}
            return false;
          } catch (err) {
            showErrorBanner((err && err.message) ? err.message : String(err));
            return false;
          }
        }

        const preview = await postJson(previewUrl, payload);
        if (!preview || preview.status !== 'ok'){
          const ok = await applyAndRedirect(payload);
          if (!ok) {
            try{ setSaving(false); }catch(e){}
            form.submit();
          }
          return;
        }

        const conflicts = preview.conflicts || {};
        function needsOfflinePaymentWarning(pl){
          try{
            if (!pl) return false;
            const price = Number(pl.price || 0);
            const isPaid = Number.isFinite(price) && price > 0;
            if (!isPaid) return false;
            const offs = Array.isArray(pl.offline_methods) ? pl.offline_methods : [];
            return offs.length > 0;
          }catch(e){ return false; }
        }

        if (Object.keys(conflicts).length === 0){
          // No conflicts → apply immediately unless we need to warn about offline payments.
          if (needsOfflinePaymentWarning(payload)){
            showModal({}, payload, window.__svc_current && !!window.__svc_current.use_fixed_increment, async function(){
              try{ setSaving(true); }catch(e){}
              const ok = await applyAndRedirect(payload);
              if (!ok) {
                try{ setSaving(false); }catch(e){}
                form.submit();
              }
            });
            return;
          }
          try{ setSaving(true); }catch(e){}
          const ok = await applyAndRedirect(payload);
          if (!ok) {
            try{ setSaving(false); }catch(e){}
            form.submit();
          }
          return;
        }

        showModal(conflicts, payload, window.__svc_current && !!window.__svc_current.use_fixed_increment, async function(){
          // User confirmed in modal → start saving animation now.
          try{ setSaving(true); }catch(e){}
          const ok = await applyAndRedirect(payload);
          if (!ok) {
            try{ setSaving(false); }catch(e){}
            try { form.submit(); } catch(e){ window.location.reload(); }
          }
        });
      } catch (e){
        console.warn('preview failed', e);
        try{ setSaving(false); }catch(_){ }
        try { form.submit(); } catch (err){ window.location.reload(); }
      }
    }

    for (const b of btns){
      b.addEventListener('click', onSaveClick);
    }
  } catch(e){ console.warn('service preview wiring failed', e); }
})();
  // Add handlers to show a short auto-dismissing toast when View button is clicked without saving
  (function(){
    try {
      function showToast(type, message, timeout=3500){
        try{
          const id = 'cc-toast';
          let el = document.getElementById(id);
          if (!el){
            el = document.createElement('div');
            el.id = id;
            el.style.position = 'fixed';
            el.style.right = '20px';
            el.style.bottom = '20px';
            el.style.zIndex = 2000;
            document.body.appendChild(el);
          }
          const itm = document.createElement('div');
          itm.style.marginTop = '8px';
          itm.style.padding = '10px 14px';
          itm.style.borderRadius = '8px';
          itm.style.color = '#fff';
          itm.style.boxShadow = '0 6px 20px rgba(0,0,0,0.12)';
          itm.style.fontSize = '13px';
          itm.style.maxWidth = '320px';
          itm.style.backdropFilter = 'blur(4px)';
          if (type === 'success') { itm.style.background = '#16a34a'; }
          else if (type === 'warn' || type === 'warning') { itm.style.background = '#f59e0b'; }
          else { itm.style.background = '#374151'; }
          itm.textContent = message;
          el.appendChild(itm);
          setTimeout(()=>{ try{ itm.remove(); if (!el.childElementCount) el.remove(); }catch(e){} }, timeout);
        }catch(e){ try{ alert(message); }catch(_){} }
      }

      function attach(btnId){
        const b = document.getElementById(btnId);
        if (!b) return;
        b.addEventListener('click', function(ev){
          try{
            const saved = b.getAttribute('data-saved') === '1';
            if (!saved){
              ev.preventDefault();
              ev.stopPropagation();
              showToast('warning', 'Please save changes before viewing the public booking page.');
              return false;
            }
            // otherwise allow default (open link)
          }catch(e){ /* ignore */ }
        });
      }

      attach('svc-view-btn');
      attach('svc-view-btn-bottom');

      // Prevent clicks on Save when form is not dirty; show toast like View button.
      // Disabled <button> elements do not fire click events in many browsers, so listen
      // at the document level during capture to reliably intercept attempts.
      function attachSaveGuard(){
        // Listen for pointerdown which fires even when a button is disabled in many browsers.
        document.addEventListener('pointerdown', function(ev){
          try{
            const btn = ev.target && ev.target.closest && ev.target.closest('.svc-save-btn');
            if (!btn) return;
            const disabled = btn.disabled || btn.classList.contains('cursor-not-allowed') || btn.classList.contains('opacity-50');
            if (disabled){
              ev.preventDefault();
              ev.stopPropagation();
              try{ showToast('warning', 'Please make changes before saving.'); } catch(e){ alert('Please make changes before saving.'); }
              return false;
            }
          } catch(e) { /* ignore */ }
        }, true);

        // Also capture Enter/Space key attempts when focused on the button (keyboard users).
        document.addEventListener('keydown', function(ev){
          try{
            const active = document.activeElement;
            if (!active) return;
            if (!active.classList || !active.classList.contains('svc-save-btn')) return;
            if (ev.key === 'Enter' || ev.key === ' '){
              const disabled = active.disabled || active.classList.contains('cursor-not-allowed') || active.classList.contains('opacity-50');
              if (disabled){
                ev.preventDefault();
                ev.stopPropagation();
                try{ showToast('warning', 'Please make changes before saving.'); } catch(e){ alert('Please make changes before saving.'); }
                return false;
              }
            }
          } catch(e) { /* ignore */ }
        }, true);
      }

      attachSaveGuard();
    } catch(e) { console.warn('svc view btn wiring failed', e); }
  })();
</script>
<script>
  // Toggle greying/disabled state of refund cutoff & policy when checkbox toggles
  (function(){
    try{
      const CAN_USE_PRO_TEAM = {{ can_use_pro_team|yesno:'true,false' }};
      const chk = document.getElementById('refunds_allowed');
      const wrapper = document.querySelector('.refund-policy-controls');
      if (!chk || !wrapper) return;
      const inputs = wrapper.querySelectorAll('input, textarea');
      function update(){
        // Refunds are always on, but advanced refund settings are Pro+.
        const enabled = CAN_USE_PRO_TEAM && !!chk.checked;
        inputs.forEach(i => {
          try{ i.disabled = !enabled; }catch(e){}
        });
        wrapper.classList.toggle('refund-disabled', !enabled);
      }
      chk.addEventListener('change', update);
      // initialize on load
      update();
    }catch(e){ console.warn('refund toggle wiring failed', e); }
  })();
</script>
<style>
.refund-disabled { opacity: 0.72; }
.refund-disabled input, .refund-disabled textarea { opacity: 0.72; }
</style>
<script>
(function(){
  try{
    const form = document.querySelector('form.cc-form');
    if (!form) return;

    const viewBtns = Array.from(document.querySelectorAll('#svc-view-btn, #svc-view-btn-bottom'));
    if (!viewBtns.length) return;

    // Serialize form into a stable JSON string for comparison with saved snapshot
    function serializeForm(){
      const fd = new FormData(form);
      const out = {};

      // Collect repeated keys (e.g., assigned_members) as arrays.
      for (const [k, v] of fd.entries()){
        const el = form.querySelector(`[name="${k}"]`);
        const normalized = (el && el.type === 'checkbox') ? (el.checked ? '1' : '0') : v;

        if (Object.prototype.hasOwnProperty.call(out, k)){
          if (!Array.isArray(out[k])) out[k] = [out[k]];
          out[k].push(normalized);
        } else {
          out[k] = normalized;
        }
      }

      // Stabilize arrays (order-independent).
      for (const k of Object.keys(out)){
        if (Array.isArray(out[k])){
          out[k] = out[k].map(x => String(x)).sort();
        }
      }
      // Ensure known boolean fields are present even if unchecked (not in FormData)
      const booleanNames = ['use_fixed_increment', 'allow_squished_bookings', 'show_on_public_calendar', 'requires_facility_resources', 'refunds_allowed', 'allow_ends_after_availability', 'apply_to_conflicts'];
      for (const name of booleanNames){
        if (!(name in out)){
          const el = form.querySelector(`[name="${name}"]`);
          if (el && el.type === 'checkbox') out[name] = el.checked ? '1' : '0';
          else if (el) out[name] = el.value;
          else out[name] = '';
        }
      }

      // Sort keys to make stable string
      const keys = Object.keys(out).sort();
      const stable = {};
      for (const k of keys) stable[k] = out[k];
      return JSON.stringify(stable);
    }

    let savedSnapshot = serializeForm();

    function setViewButtonsEnabled(enabled){
      for (const b of viewBtns){
        if (enabled){
          b.classList.remove('opacity-50','cursor-not-allowed');
          b.removeAttribute('aria-disabled');
          b.setAttribute('data-saved', '1');
        } else {
          b.classList.add('opacity-50','cursor-not-allowed');
          b.setAttribute('aria-disabled', 'true');
          b.setAttribute('data-saved', '0');
        }
      }
    }

    function setSaveButtonsEnabled(enabled){
      const saveBtns = Array.from(document.querySelectorAll('.svc-save-btn'));
      for (const s of saveBtns){
        try { s.disabled = !enabled; } catch(e){}
        if (!enabled) {
          s.classList.add('opacity-50','cursor-not-allowed');
        } else {
          s.classList.remove('opacity-50','cursor-not-allowed');
        }
      }
    }

    // Initialize according to whether current form equals saved snapshot
    const isInitiallySaved = (serializeForm() === savedSnapshot);
    setViewButtonsEnabled(isInitiallySaved);
    setSaveButtonsEnabled(!isInitiallySaved);

    // Compare current form to saved snapshot and toggle buttons
    function updateState(){
      try{
        const cur = serializeForm();
        const isSameAsSaved = cur === savedSnapshot;
        setViewButtonsEnabled(isSameAsSaved);
        // Save enabled only when form is dirty
        setSaveButtonsEnabled(!isSameAsSaved);
      } catch (e){ console.warn('svc view compare failed', e); }
    }

    // Add listeners to keep live comparison; debounce to avoid excessive work
    let timer = null;
    function scheduleUpdate(){
      if (timer) clearTimeout(timer);
      timer = setTimeout(()=>{ timer = null; updateState(); }, 120);
    }

    const controls = form.querySelectorAll('input, textarea, select');
    controls.forEach(c => {
      c.addEventListener('input', scheduleUpdate);
      c.addEventListener('change', scheduleUpdate);
    });

    // Also attach delegated listeners on the form so dynamically inserted/updated
    // controls (and some browser edge cases) still trigger dirty-state updates.
    try {
      form.addEventListener('input', scheduleUpdate, true);
      form.addEventListener('change', scheduleUpdate, true);
    } catch (e) { /* ignore */ }

    // Some controls (notably the team member assignment UI) are not native form
    // controls; they add/remove hidden inputs programmatically. Observe DOM changes
    // inside the form so the Save/View buttons still reflect the dirty state.
    try {
      const observer = new MutationObserver(function(mutations){
        try {
          for (const m of mutations){
            if (m.type === 'childList') { scheduleUpdate(); return; }
            if (m.type === 'attributes') { scheduleUpdate(); return; }
          }
        } catch (e) { /* ignore */ }
      });
      observer.observe(form, { subtree: true, childList: true, attributes: true, attributeFilter: ['value', 'checked', 'disabled', 'name'] });
    } catch (e) { /* ignore */ }

    // If a save happens and the page is not reloaded, we can update the savedSnapshot to match current
    // (some code paths redirect; others may update in-place). Listen for successful submit event that
    // results in form submit via existing save button handlers by hooking submit.
    form.addEventListener('submit', function(){
      // update snapshot after short delay to allow any pre-submit handlers to run
      setTimeout(function(){
        try{ savedSnapshot = serializeForm(); setViewButtonsEnabled(true); setSaveButtonsEnabled(false); }catch(e){}
      }, 500);
    });

  } catch (e){ console.warn('svc view btn dirty wiring failed', e); }
})();
</script>

<div id="ccAdvancedUpgradeModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.6); backdrop-filter:blur(4px); justify-content:center; align-items:center; z-index:10050;">
  <div style="background:#fff; border-radius:12px; width:min(520px, 92vw); padding:18px 18px 16px 18px; box-shadow:0 18px 50px rgba(0,0,0,0.25);">
    <div style="font-weight:800; font-size:1.05rem; margin-bottom:8px; color:#111827;">Upgrade required</div>
    <div style="color:#374151; font-size:0.95rem; line-height:1.35; margin-bottom:14px;">
      A Pro subscription or higher is required to have access to the advanced settings features.
    </div>
    <div style="display:flex; justify-content:flex-end; gap:10px;">
      <button id="ccAdvancedUpgradeCancelBtn" type="button" style="background:#e5e7eb; color:#111827; border:none; padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:700;">Cancel</button>
      <button id="ccAdvancedUpgradeGoBtn" type="button" style="background:#2563eb; color:white; border:none; padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:800;">{% if cc_app_mode %}OK{% else %}View pricing{% endif %}</button>
    </div>
  </div>
</div>

<script>
  (function(){
    try{
      const CAN_USE_PRO_TEAM = {{ can_use_pro_team|yesno:'true,false' }};
      if (CAN_USE_PRO_TEAM) return;
      const CC_APP_MODE = {{ cc_app_mode|yesno:'true,false' }};
      const PRICING_URL = "{% url 'calendar_app:pricing_page' org.slug %}";

      function openModal(){
        const modal = document.getElementById('ccAdvancedUpgradeModal');
        const cancelBtn = document.getElementById('ccAdvancedUpgradeCancelBtn');
        const goBtn = document.getElementById('ccAdvancedUpgradeGoBtn');
        if (!modal || !cancelBtn || !goBtn){
          if (CC_APP_MODE) {
            alert('A Pro subscription or higher is required to have access to the advanced settings features.\n\nTo use this feature, please upgrade your plan on circlecal.app (in a browser) first, then return to the app.');
          } else {
            const go = confirm('A Pro subscription or higher is required to have access to the advanced settings features.\n\nPress OK to view pricing, or Cancel to stay here.');
            if (go) { try { window.location.href = PRICING_URL; } catch(e) {} }
          }
          return;
        }
        modal.style.display = 'flex';
        function close(){ try{ modal.style.display = 'none'; }catch(e){} }
        cancelBtn.onclick = function(e){ try{ e.preventDefault(); }catch(err){} close(); };
        goBtn.onclick = function(e){
          try{ e.preventDefault(); }catch(err){}
          if (CC_APP_MODE) {
            close();
            try { alert('Upgrade required. To use this feature, please upgrade your plan on circlecal.app (in a browser) first, then return to the app.'); } catch (err) {}
          } else {
            try{ window.location.href = PRICING_URL; }catch(err){}
          }
        };
        modal.onclick = function(e){ try{ if (e && e.target === modal) close(); }catch(err){} };
        try{
          document.addEventListener('keydown', function onKey(e){
            try{ if (e && e.key === 'Escape') close(); }catch(err){}
          }, { once: true });
        }catch(e){}
      }

      document.querySelectorAll('[data-cc-adv-lock]').forEach(function(el){
        el.addEventListener('click', function(e){
          try{ e.preventDefault(); e.stopPropagation(); }catch(err){}
          openModal();
        });
        el.addEventListener('keydown', function(e){
          try{
            if (!e) return;
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              openModal();
            }
          }catch(err){}
        });
      });
    }catch(e){ /* ignore */ }
  })();
</script>
{% endblock %}
