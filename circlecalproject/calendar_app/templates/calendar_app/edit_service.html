{% extends "calendar_app/base.html" %}

{% block title %}Edit Service • {{ org.name }}{% endblock %}

{% block content %}
{% block extra_head %}
<style>
  /* Page-specific enhanced field styling (aligned with create service) */
  .cc-field {
    border: 1px solid #d1d5db; /* gray-300 */
    background: #ffffff;
    padding: 0.7rem 0.9rem;
    border-radius: 0.5rem;
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.6);
    font-size: 0.97rem;
    width: 100%;
  }
  .cc-field[disabled] { background:#f8fafc; opacity:.9; }
  .cc-field:focus { outline:none; border-color:#2563eb; box-shadow:0 0 0 4px rgba(37,99,235,0.08); }
  .cc-page { max-width:78rem; margin:0 auto; padding:2.5rem 1.5rem; }
  @media (min-width:768px){ .cc-page { padding:3rem 2rem; } }
  .section-card { background:#fff; border:1px solid #c0c7d1; border-radius:0.75rem; padding:1rem 1.25rem; margin-bottom:1rem; }
  .section-title { font-size:1rem; font-weight:600; margin-bottom:0.5rem; }
  /* Inputs inside section cards use a unified light border so areas are obvious */
  .section-card input[type="text"],
  .section-card input[type="number"],
  .section-card input[type="email"],
  .section-card textarea,
  .section-card select,
  .section-card .cc-field,
  .section-card .mt-1.block {
    border: 1px solid #c0c7d1; /* same as card border (darker) */
    background: #ffffff;
    padding: 0.6rem 0.8rem;
    border-radius: 0.5rem;
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.6);
  }
  .section-card input[disabled], .section-card textarea[disabled] { background:#f8fafc; opacity:.95; }
  .section-card input:focus, .section-card textarea:focus, .section-card select:focus, .section-card .cc-field:focus {
    outline: none;
    border-color: #2563eb;
    box-shadow: 0 0 0 4px rgba(37,99,235,0.06);
  }
  /* Availability disabled overlay */
  .availability-disabled { position: relative; opacity: 0.8; }
  .availability-disabled .availability-overlay { position: absolute; inset: 0; background: rgba(255,255,255,0.85); display:flex; align-items:center; justify-content:center; border-radius:0.75rem; z-index:20; }
  .availability-disabled .availability-overlay .msg { max-width:56rem; padding:1rem 1.5rem; text-align:center; color:#374151; }
</style>
{% endblock %}

<div class="cc-page">
  {% if request.GET.saved %}
    <div class="mb-4 p-3 rounded bg-green-50 border-l-4 border-green-400 text-green-800" role="status" aria-live="polite">
      <strong>Changes saved</strong>
      <div class="text-sm mt-1">Your changes were saved successfully.</div>
    </div>
  {% endif %}
  <!-- Top action buttons: Cancel (left) and Save (right) -->
  <div class="flex items-center justify-between mb-4">
    <a href="{% url 'calendar_app:dashboard' org.slug %}" class="text-sm text-gray-500 hover:text-gray-700">Cancel</a>
    <div class="flex items-center">
      <button type="button" class="svc-save-btn inline-flex items-center px-4 py-2 rounded-md bg-blue-600 text-white text-sm font-medium hover:bg-blue-700">Save Changes</button>
      <a id="svc-view-btn" data-saved="{{ request.GET.saved|yesno:'1,0' }}" href="{% url 'bookings:public_service_page' org.slug service.slug %}" target="_blank" rel="noopener noreferrer" class="inline-flex items-center px-3 py-2 ml-3 rounded-md text-sm font-medium border border-blue-600 text-blue-600 bg-white hover:bg-blue-50 {% if not request.GET.saved %}opacity-50 cursor-not-allowed{% endif %}">View public page</a>
    </div>
  </div>

  <h1 class="text-2xl font-semibold mb-2 text-center">Edit Service</h1>
  <p class="text-sm text-gray-500 mb-6 text-center max-w-2xl mx-auto">
    Update your service details.
  </p>

  {% if cc_debug_post %}
    <div class="mb-4 p-3 rounded bg-yellow-50 border-l-4 border-yellow-400 text-yellow-800">
      <strong>DEBUG POST:</strong>
      <div class="text-sm mt-1">
        {% if cc_debug_post.error %}
          {{ cc_debug_post.error }}
        {% else %}
          present={{ cc_debug_post.present|yesno:'true,false' }}, raw={{ cc_debug_post.raw }}, saved={{ cc_debug_post.saved|yesno:'true,false' }}
        {% endif %}
      </div>
    </div>
  {% endif %}
  {% if request.GET.cc_dbg_present %}
    <div class="mb-4 p-3 rounded bg-yellow-50 border-l-4 border-yellow-400 text-yellow-800">
      <strong>DEBUG (from URL):</strong>
      <div class="text-sm mt-1">present={{ request.GET.cc_dbg_present }}, raw={{ request.GET.cc_dbg_raw }}, saved={{ request.GET.cc_dbg_saved }}</div>
    </div>
  {% endif %}


  <form method="post" class="space-y-6 cc-form">
    {% csrf_token %}

    <!-- Prominent active toggle: moved to the top for visibility -->
    <div class="section-card mb-4" style="border:1px solid #2563eb;background:#f0f9ff;box-shadow:0 2px 6px rgba(37,99,235,0.06);">
      <div class="flex items-center justify-between">
        <div>
          <label for="is_active" class="inline-flex items-center">
            {% if is_only_active_service %}
              <input type="hidden" name="is_active" value="on">
            {% endif %}
            <input type="checkbox" name="is_active" id="is_active" {% if service.is_active %}checked{% endif %}
                   class="rounded border-gray-300 text-blue-600 focus:ring-blue-500 {% if is_only_active_service %}opacity-60 cursor-not-allowed{% endif %}"
                   {% if is_only_active_service %}disabled aria-disabled="true"{% endif %}>
            <div class="ml-3">
              <div class="text-lg font-semibold text-gray-800">Service is active</div>
              <div class="text-sm text-gray-600">Visible on the public booking page</div>
            </div>
          </label>
          {% if is_only_active_service %}
            <p class="mt-2 text-sm text-gray-700">You currently have only one active service. To keep your public booking page available to clients, activate another service before disabling this one.</p>
          {% endif %}
        </div>
        <div class="text-sm text-gray-700">
          <span class="inline-flex items-center px-2 py-1 rounded bg-white text-gray-700">Important</span>
        </div>
      </div>
    </div>

    <script>
    // Hours / minutes helper for buffer_after: keep hidden `buffer_after` in minutes in-sync
    document.addEventListener('DOMContentLoaded', function(){
      try{
        const hidden = document.getElementById('buffer_hidden');
        const h = document.getElementById('buffer_hours');
        const m = document.getElementById('buffer_minutes');
        if (!hidden || !h || !m) return;

        function setFieldsFromHidden(){
          const total = Number(hidden.value) || 0;
          const hours = Math.floor(total / 60);
          const mins = total % 60;
          h.value = hours;
          m.value = mins;
        }

        function updateHidden(){
          const hours = Math.max(0, Number(h.value) || 0);
          let mins = Math.max(0, Number(m.value) || 0);
          if (mins > 59) mins = 59;
          const total = (hours * 60) + mins;
          hidden.value = total;
        }

        h.addEventListener('input', updateHidden);
        m.addEventListener('input', updateHidden);

        // initialize
        setFieldsFromHidden();
      } catch(e){ console.warn('buffer hours/min wiring failed', e); }
    });
    </script>

    {% if needs_migration %}
      <div class="mb-4 p-3 rounded bg-yellow-50 border-l-4 border-yellow-400 text-yellow-800">
        <strong>Database migration required:</strong>
        <div class="text-sm">The feature "Allow appointment to end after availability" requires a database migration. Please run <code>python manage.py migrate</code> on the server to enable this setting.</div>
      </div>
    {% endif %}

    <div class="section-card">
      <div class="section-title">Basic Info</div>
      <div class="mb-3">
        <label class="block text-sm font-medium text-gray-700">Name</label>
        <input name="name" type="text" required value="{{ service.name }}" class="cc-field mt-1 w-full">
      </div>
      <div class="mb-3">
        <label class="block text-sm font-medium text-gray-700">Slug (URL-friendly)</label>
        {% if can_edit_slug %}
          <input name="slug" type="text" value="{{ service.slug }}" class="cc-field mt-1 w-full">
          <p class="mt-1 text-xs text-gray-500">You may change the URL slug while no bookings exist for this service. Once a booking exists, the slug becomes immutable to avoid breaking booking links.</p>
        {% else %}
          <input type="text" value="{{ service.slug }}" disabled class="cc-field mt-1 w-full">
          <p class="mt-1 text-xs text-gray-500">Slug cannot be changed because this service already has bookings. To edit the slug, remove all bookings first.</p>
        {% endif %}
      </div>
      <div>
        <label class="block text-sm font-medium text-gray-700">Description</label>
        <textarea name="description" rows="4" class="cc-field mt-1 w-full">{{ service.description }}</textarea>
      </div>
    </div>

    <!-- core timing controls are shown below in a grouped card -->

    <!-- Slot increment settings are configured in the Day Schedule modal (calendar). Removed from edit page to avoid duplication. -->
    <!-- Per-service slot settings (single, cleaned block) -->
    <div class="section-card">
      <div class="grid grid-cols-1 gap-3">
        <div>
          <label class="block text-sm font-medium text-gray-700">Client slot increment (minutes)</label>
          <input id="time_increment_minutes" name="time_increment_minutes" type="number" value="{{ service.time_increment_minutes|default:30 }}" min="5" class="cc-field mt-1 w-40">
          <p class="mt-1 text-xs text-gray-500">This controls the visible client slot increment. When <em>Use fixed increments</em> is enabled, this value is ignored.</p>
        </div>
        <div>
          <label class="inline-flex items-center">
            <input type="checkbox" name="use_fixed_increment" id="use_fixed_increment" {% if service.use_fixed_increment %}checked{% endif %}
                   class="rounded border-gray-300 text-blue-600 focus:ring-blue-500">
            <span class="ml-2 text-sm text-gray-700">Use fixed increments (service duration + buffer)</span>
          </label>
          <p class="mt-1 text-xs text-gray-500">When enabled, clients will only see anchors spaced by the service duration plus cleanup buffer.</p>
        </div>
        <div>
          <label class="inline-flex items-center">
            <input type="checkbox" name="allow_squished_bookings" id="allow_squished_bookings" {% if service.allow_squished_bookings %}checked{% endif %}
                   class="rounded border-gray-300 text-blue-600 focus:ring-blue-500">
            <span class="ml-2 text-sm text-gray-700">Allow squished bookings (permit slots that violate buffers)</span>
          </label>
          <p class="mt-1 text-xs text-gray-500">When enabled, the system will allow bookings that fit the service duration even if they don't satisfy the configured buffers. Owners will receive a notification when such bookings occur.</p>
        </div>
      </div>
    </div>

    <script>
      // When Use Fixed Increments is enabled, disable/grey the Allow Squished and the increment input.
      // Also keep the increment in-sync with the Day Schedule modal via localStorage ('client_view_settings').
      (function(){
        try {
          const fixed = document.getElementById('use_fixed_increment');
          const squish = document.getElementById('allow_squished_bookings');
          const incInput = document.getElementById('time_increment_minutes');
          const form = document.querySelector('form.cc-form');
          if (!fixed) return;

          // Visual helper class
          const style = document.createElement('style');
          style.innerHTML = '.squish-disabled-label { opacity: 0.6; } .inc-disabled { opacity: 0.55; }';
          document.head.appendChild(style);

          const parentLabel = squish ? (squish.closest('label') || squish.parentNode) : null;

          function updateState() {
            const disabled = fixed.checked;
            if (squish) {
              try { squish.disabled = disabled; } catch(e){}
              if (parentLabel) parentLabel.classList.toggle('squish-disabled-label', disabled);
            }
            if (incInput) {
              try { incInput.disabled = disabled; } catch(e){}
              incInput.classList.toggle('inc-disabled', disabled);
            }

            // Propagate the effective client increment to localStorage so the public
            // calendar reflects the change immediately. When fixed increments are
            // enabled, use duration + buffer_after; otherwise use the visible input.
            try {
              const durationEl = document.querySelector('input[name="duration"]');
              const bufferEl = document.querySelector('input[name="buffer_after"]');
              const dur = durationEl ? Number(durationEl.value) : null;
              const buf = bufferEl ? Number(bufferEl.value) : 0;
              if (disabled) {
                // fixed increment
                if (dur != null && !isNaN(dur)) {
                  setClientIncrementFromInput(Number(dur) + Number(buf));
                }
              } else {
                if (incInput) setClientIncrementFromInput(Number(incInput.value) || 30);
              }
            } catch (e) { /* ignore */ }
          }

          // When increment input changes, ask to confirm and propagate to localStorage so modal reads it
          const initialIncVal = incInput ? Number(incInput.value) : null;

          function setClientIncrementFromInput(val) {
            try {
              const raw = localStorage.getItem('client_view_settings') || '{}';
              let parsed = {};
              try { parsed = JSON.parse(raw); } catch(_) { parsed = {}; }
              parsed.increment = Number(val) || 30;
              localStorage.setItem('client_view_settings', JSON.stringify(parsed));
              try { showToast('success', 'Client increment updated for Day Schedule modal.'); } catch(e){}
            } catch (e) { console.warn('setClientIncrement failed', e); }
          }

          if (incInput) {
            incInput.addEventListener('change', function(ev){
              try {
                if (fixed.checked) {
                  // Shouldn't happen because input is disabled, but guard
                  try { showToast('warning', 'Disable Fixed Increments to change the client increment.'); } catch(e){}
                  incInput.value = initialIncVal;
                  return;
                }
                const newVal = Number(incInput.value);
                if (isNaN(newVal) || newVal < 5) {
                  try { showToast('warning', 'Enter a valid increment (5+ minutes).'); } catch(e){}
                  incInput.value = initialIncVal;
                  return;
                }
                const confirmMsg = `Change client increment to ${newVal} minutes? This will update the Day Schedule modal's client view settings.`;
                if (!confirm(confirmMsg)) {
                  // revert
                  incInput.value = initialIncVal;
                    const btns = Array.from(document.querySelectorAll('.svc-save-btn'));
                }
                // propagate to localStorage so calendar modal picks it up
                setClientIncrementFromInput(newVal);
              } catch (e) { console.warn('inc change handler failed', e); }
            });
          }

          // Reflect localStorage changes (from modal or other tabs) into this input
          window.addEventListener('storage', function(e){
            if (e.key === 'client_view_settings') {
              try {
                const parsed = JSON.parse(e.newValue || '{}');
                if (parsed && typeof parsed.increment === 'number' && incInput && !fixed.checked) {
                  incInput.value = String(parsed.increment);
                }
              } catch (err) { /* ignore */ }
            }
          });

          // Before submitting the service edit form, if the increment was changed from the original value,
          // confirm the user wants to persist the change to the server as well.
          if (form && incInput) {
            form.addEventListener('submit', function(ev){
              try {
                const cur = Number(incInput.value);
                if (!isNaN(initialIncVal) && cur !== Number(initialIncVal)) {
                  const ok = confirm(`You changed the slot increment from ${initialIncVal} to ${cur} minutes. Save this change to the service?`);
                  if (!ok) {
                    ev.preventDefault();
                    return false;
                  }
                  // Also update localStorage so modal and other tabs reflect the new value
                  setClientIncrementFromInput(cur);
                }
              } catch (e) { /* allow submit on error */ }
            });
          }

          // Initialize state and sync with localStorage if appropriate
          updateState();
          try {
            const raw = localStorage.getItem('client_view_settings');
            if (raw && incInput && !fixed.checked) {
              const parsed = JSON.parse(raw);
              if (parsed && typeof parsed.increment === 'number') {
                incInput.value = String(parsed.increment);
              }
            }
          } catch (e) { /* ignore parse errors */ }

          // attach handler to fixed checkbox
          fixed.addEventListener('change', updateState);
        } catch (e) { console.warn('squish-disable and increment sync wiring failed', e); }
      })();
    </script>

    <script>
      // Ensure hidden fallback reflects the actual checkbox state on submit
      (function(){
        try {
          const form = document.querySelector('form.cc-form');
          const chk = form ? form.querySelector('input[type="checkbox"][name="allow_ends_after_availability"]') : null;
          const hidden = form ? form.querySelector('input[type="hidden"][name="allow_ends_after_availability"]') : null;
          if (!form || !chk || !hidden) return;
          form.addEventListener('submit', function(){
            try { hidden.value = chk.checked ? '1' : '0'; } catch(e){}
          });
        } catch(e) { console.warn('sync hidden checkbox failed', e); }
      })();
    </script>

      <script>
      // Hours / minutes helper for duration: keep hidden `duration` in minutes in-sync
      document.addEventListener('DOMContentLoaded', function(){
        try{
          const hidden = document.getElementById('duration_hidden');
          const h = document.getElementById('duration_hours');
          const m = document.getElementById('duration_minutes');
          if (!hidden || !h || !m) return;

          function setFieldsFromHidden(){
            const total = Number(hidden.value) || 0;
            const hours = Math.floor(total / 60);
            const mins = total % 60;
            h.value = hours;
            m.value = mins;
          }

          function updateHidden(){
            const hours = Math.max(0, Number(h.value) || 0);
            const mins = Math.max(0, Number(m.value) || 0);
            const total = (hours * 60) + mins;
            hidden.value = total;
          }

          h.addEventListener('input', updateHidden);
          m.addEventListener('input', updateHidden);

          // initialize
          setFieldsFromHidden();
        } catch(e){ console.warn('duration hours/min wiring failed', e); }
      });
      </script>

    <!-- Group core timing settings into a clear section -->
    <div class="section-card">
      <div class="grid grid-cols-2 gap-4">
        <div>
          <label class="block text-sm font-medium text-gray-700">Duration</label>
          <div class="mt-1 flex items-center gap-2">
            <input id="duration_hours" type="number" min="0" class="cc-field w-24" placeholder="Hours">
            <span class="text-sm text-gray-600">Hours</span>
            <input id="duration_minutes" type="number" min="0" max="59" class="cc-field w-24" placeholder="Minutes">
            <span class="text-sm text-gray-600">Minutes</span>
        </div>
          <input type="hidden" name="duration" id="duration_hidden" value="{{ service.duration }}">
          <p class="mt-1 text-xs text-gray-500">Enter Hours and Minutes; they will be saved as total minutes.</p>
        </div>
        <div>
          <label class="block text-sm font-medium text-gray-700">Price (USD)</label>
          <input name="price" type="number" step="0.01" value="{{ service.price }}"
                 class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:ring-blue-500 focus:border-blue-500 text-sm">
        </div>
      </div>

      <div class="grid grid-cols-2 gap-4 mt-4">
         <div>
           <label class="block text-sm font-medium text-gray-700">Buffer Time Post Service Appointment</label>
           <div class="mt-1 flex items-center gap-2">
             <input id="buffer_hours" type="number" min="0" class="cc-field w-24" placeholder="Hours">
             <span class="text-sm text-gray-600">Hours</span>
             <input id="buffer_minutes" type="number" min="0" max="59" class="cc-field w-24" placeholder="Minutes">
             <span class="text-sm text-gray-600">Minutes</span>
           </div>
           <input type="hidden" name="buffer_after" id="buffer_hidden" value="{{ service.buffer_after }}">
           <p class="mt-1 text-xs text-gray-500">Enter buffer time after appointment; saved as total minutes.</p>
         </div>
        <div>
          <label class="block text-sm font-medium text-gray-700">Allow appointment to end after availability?</label>
          <div class="mt-2">
            <label class="inline-flex items-center">
              <!-- hidden fallback ensures a value is always posted even when unchecked -->
              <input type="hidden" name="allow_ends_after_availability" value="0">
              <input type="checkbox" name="allow_ends_after_availability" value="1" {% if service.allow_ends_after_availability %}checked{% endif %}
                     class="rounded border-gray-300 text-blue-600 focus:ring-blue-500">
              <span class="ml-2 text-sm text-gray-700">Allow clients to book slots that start before the availability end even if they finish after it.</span>
            </label>
          </div>
          <p class="mt-1 text-xs text-gray-500">Enable to allow the final time slot to finish after your daily availability end.</p>
        </div>
      </div>
    </div>

    <div class="grid grid-cols-2 gap-4">
      <div>
        <label class="block text-sm font-medium text-gray-700">How soon can clients book? (hours)</label>
       <input name="min_notice_hours" type="number" value="{{ service.min_notice_hours }}" min="0"
         class="cc-field mt-1 w-full" />
       <p class="mt-2 text-xs text-gray-500">Prevent last‑minute bookings (e.g. 24 = one day).</p>
      </div>
      <div>
        <label class="block text-sm font-medium text-gray-700">How far ahead can clients book? (days)</label>
       <input name="max_booking_days" type="number" value="{{ service.max_booking_days }}" min="1"
         class="cc-field mt-1 w-full" />
       <p class="mt-2 text-xs text-gray-500">Limit how far out clients can book.</p>
      </div>
    </div>

    <!-- removed duplicate is_active toggle (moved to top) -->

    {% if conflict_services %}
      <div class="mb-4 p-3 rounded bg-yellow-50 border-l-4 border-yellow-400 text-yellow-800">
        <strong>Conflicting services detected</strong>
        <p class="text-sm">The following services have overlapping availability windows: {{ conflict_services|join:", " }}.</p>
        <label class="inline-flex items-center mt-2"><input type="checkbox" name="apply_to_conflicts" value="1" class="rounded border-gray-300"> <span class="ml-2 text-sm">Apply these settings to the listed services as well</span></label>
      </div>
    {% endif %}

    <!-- Refund Policy -->
    <div class="section-card">
      <h2 class="text-base font-semibold">Refund Policy</h2>
        <div class="flex items-center mt-3">
          <input type="checkbox" name="refunds_allowed" id="refunds_allowed" {% if service.refunds_allowed %}checked{% endif %}
                 class="rounded border-gray-300 text-blue-600 focus:ring-blue-500">
          <label for="refunds_allowed" class="ml-2 text-sm text-gray-700">Allow refunds for this service</label>
        </div>
        <div class="refund-policy-controls mt-3">
          <div>
            <label class="block text-sm font-medium text-gray-700">Refund cutoff (hours)</label>
            <input name="refund_cutoff_hours" type="number" value="{{ service.refund_cutoff_hours }}" min="0"
                   class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:ring-blue-500 focus:border-blue-500 text-sm">
            <p class="mt-1 text-xs text-gray-500">Minimum 1 hour when refunds are enabled. Set to 0 by unchecking "Allow refunds".</p>
          </div>
          <div class="mt-3">
            <label class="block text-sm font-medium text-gray-700">Custom refund policy text</label>
            <textarea name="refund_policy_text" rows="3"
                      class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:ring-blue-500 focus:border-blue-500 text-sm">{{ service.refund_policy_text }}</textarea>
          </div>
        </div>
    </div>

    <div class="section-card {% if is_only_active_service %}availability-disabled{% endif %}">
      <!-- Service availability editor -->
      <div class="mt-0">
        <h2 class="text-base font-semibold">Service availability</h2>
        <p class="text-sm text-gray-500">Specify which days/times this service is offered. These must be within your organization's default weekly availability shown below. Use comma-separated ranges like <code>09:00-12:00,13:00-17:00</code>.</p>
        {% if is_only_active_service %}
          <div class="availability-overlay" role="status" aria-live="polite">
            <div class="msg">
              <strong class="block mb-1">Service availability disabled</strong>
              <div class="text-sm">You must have at least two active services to edit per-service availability. Activate another service to enable these controls.</div>
            </div>
          </div>
        {% endif %}
        <div class="grid grid-cols-1 gap-2 mt-2">
          {% for row in weekly_edit_rows %}
            <div class="flex items-center gap-3">
              <div style="width:64px; font-weight:600">{{ row.label }}</div>
              <div class="text-xs text-gray-600">Default: {{ row.org_ranges|default:'—' }}</div>
            </div>
            <div>
              <input type="text" name="svc_avail_{{ row.ui }}" value="{{ row.svc_ranges }}"
                     class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:ring-blue-500 focus:border-blue-500 text-sm" placeholder="e.g. 09:00-12:00,13:00-17:00"
                     {% if is_only_active_service %}disabled aria-disabled="true"{% endif %}>
            </div>
          {% endfor %}
        </div>
      </div>
    </div>

    <!-- Bottom action bar: Cancel (left) and Save (right) -->
    <div class="flex items-center justify-between mt-6">
      <a href="{% url 'calendar_app:dashboard' org.slug %}" class="text-sm text-gray-500 hover:text-gray-700">Cancel</a>
      <div class="flex items-center">
        <button type="button" class="svc-save-btn inline-flex items-center px-4 py-2 rounded-md bg-blue-600 text-white text-sm font-medium hover:bg-blue-700">Save Changes</button>
        <a id="svc-view-btn-bottom" data-saved="{{ request.GET.saved|yesno:'1,0' }}" href="{% url 'bookings:public_service_page' org.slug service.slug %}" target="_blank" rel="noopener noreferrer" class="inline-flex items-center px-3 py-2 ml-3 rounded-md text-sm font-medium border border-blue-600 text-blue-600 bg-white hover:bg-blue-50 {% if not request.GET.saved %}opacity-50 cursor-not-allowed{% endif %}">View public page</a>
      </div>
    </div>
  </form>
</div>
<template id="svc-conflict-modal-tpl">
  <div class="cc-modal-backdrop" style="position:fixed;inset:0;background:rgba(0,0,0,0.4);display:flex;align-items:center;justify-content:center;z-index:1200">
    <div style="background:#fff;padding:1rem;border-radius:8px;max-width:760px;width:95%;box-shadow:0 6px 24px rgba(0,0,0,0.2);display:flex;flex-direction:column;max-height:80vh;">
      <h3 style="margin:0 0 0.5rem 0;font-weight:700">Conflicting bookings detected</h3>
      <p style="margin:0 0 0.75rem 0;color:#444">The following booked days will keep the previous settings. Confirm to freeze old settings for these dates and apply your changes to all other days.</p>
      <div id="svc-conflict-list" style="flex:1;overflow:auto;border-radius:8px;margin-bottom:12px;padding:6px 6px 0 6px">
        <!-- Booking rows will be injected here as individual stacked items -->
      </div>
      <style>
        #svc-conflict-list { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; font-size:0.95rem; }
        .conflict-group-heading { font-weight:700; margin:8px 0 6px; color:#111827; display:flex; align-items:center; justify-content:space-between; }
        .conflict-status { font-size:0.85rem; color:#6b7280; font-weight:500; margin-left:8px; }
        .conflict-item { display:block; padding:10px 12px; border-radius:8px; background:#ffffff; border:1px solid #eef3f8; box-shadow:0 1px 2px rgba(16,24,40,0.03); margin-bottom:8px; }
        .conflict-item.empty { text-align:center; color:#6b7280; background:transparent; border:none; box-shadow:none; padding:8px; }
        .conflict-main { display:block; color:#0f172a; }
        .conflict-line { display:flex; justify-content:space-between; gap:12px; align-items:center; font-weight:600; color:#111827; }
        .conflict-client { color:#374151; font-weight:400; margin-left:12px; }
        .conflict-email { color:#6b7280; font-weight:400; margin-left:6px; }
        @media (max-width:720px){ .conflict-line{flex-direction:column;align-items:flex-start} }
      </style>
      <div style="text-align:right">
        <button id="svc-conflict-cancel" style="margin-right:8px;padding:6px 10px;border-radius:6px;border:1px solid #ccc;background:#fafafa">Cancel</button>
        <button id="svc-conflict-confirm" style="padding:6px 10px;border-radius:6px;background:#2563eb;color:#fff;border:none">Confirm and Apply</button>
      </div>
    </div>
  </div>
</template>

<script>
    (function(){
    try{
      const btns = Array.from(document.querySelectorAll('.svc-save-btn'));
      // expose current service flags for modal status labels
      try{ window.__svc_current = { use_fixed_increment: {{ service.use_fixed_increment|yesno:"true,false" }} }; }catch(e){}
    const form = document.querySelector('form.cc-form');
    if (!btns.length || !form) return;

    function getCsrf(){
      const el = form.querySelector('input[name=csrfmiddlewaretoken]');
      return el ? el.value : '';
    }

    async function postJson(url, payload){
      const res = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': getCsrf()
        },
        body: JSON.stringify(payload || {})
      });
      return res.json();
    }

    function serializeFormToPayload(){
      const fd = new FormData(form);
      const out = {};
      for (const [k,v] of fd.entries()){
        if (k === 'time_increment_minutes' || k === 'duration' || k === 'buffer_after' || k === 'min_notice_hours' || k === 'max_booking_days' || k === 'refund_cutoff_hours'){
          out[k] = Number(v);
        } else if (k.startsWith('svc_avail_')){
          out[k] = v;
        } else {
          out[k] = v;
        }
      }

      const booleanNames = ['use_fixed_increment', 'allow_squished_bookings', 'is_active', 'refunds_allowed', 'allow_ends_after_availability', 'apply_to_conflicts'];
      for (const name of booleanNames){
        try{
          // Prefer the checkbox input (if present) over any hidden fallback input
          let el = form.querySelector(`[name="${name}"][type="checkbox"]`) || form.querySelector(`[name="${name}"]`);
          if (!el) { out[name] = false; }
          else if (el.type === 'checkbox') { out[name] = !!el.checked; }
          else {
            const v = String(el.value || '').toLowerCase();
            out[name] = (v === '1' || v === 'true' || v === 'on');
          }
        } catch (e) {
          out[name] = false;
        }
      }

      return out;
    }

    // Shared detector for whether an item uses fixed increments. Placed at
    // top-level so debug code and node builder both call the same logic.
    function detectUsesFixed(item){
      try{
        if (!item) return false;
        function norm(v){
          if (v === true || v === 1 || v === '1') return true;
          if (v === false || v === 0 || v === '0') return false;
          if (typeof v === 'string'){
            const low = v.trim().toLowerCase();
            if (low === 'true' || low === 'yes' || low === 'y') return true;
            if (low === 'false' || low === 'no' || low === 'n') return false;
            if (!isNaN(Number(low))) return Number(low) !== 0;
          }
          return !!v;
        }

        if (item.use_fixed_increment !== undefined) return !!norm(item.use_fixed_increment);
        if (item.uses_fixed_increment !== undefined) return !!norm(item.uses_fixed_increment);
        if (item.service && item.service.use_fixed_increment !== undefined) return !!norm(item.service.use_fixed_increment);
        if (item.service && item.service.uses_fixed_increment !== undefined) return !!norm(item.service.uses_fixed_increment);
        if (item.snapshot && item.snapshot.use_fixed_increment !== undefined) return !!norm(item.snapshot.use_fixed_increment);
        if (item.snapshot && item.snapshot.uses_fixed_increment !== undefined) return !!norm(item.snapshot.uses_fixed_increment);
        if (item.service_snapshot && item.service_snapshot.use_fixed_increment !== undefined) return !!norm(item.service_snapshot.use_fixed_increment);
        if (item.service_snapshot && item.service_snapshot.uses_fixed_increment !== undefined) return !!norm(item.service_snapshot.uses_fixed_increment);
        return false;
      } catch(e){ return false; }
    }

    function buildConflictNodes(conflicts){
      // Accept optional flags via outer-scope defaults (will be passed by showModal)
      const nodes = [];
      const days = Object.keys(conflicts).sort();

      // Collect items into groups by whether they use fixed increments
      const fixedGroup = [];
      const customGroup = [];

      for (const d of days){
        const items = conflicts[d];
        for (const it of items){
          const name = it.client_name || '(no name)';
          const email = it.client_email || '';
          // build formatted date/time range
          const start = it.start ? new Date(it.start) : null;
          let end = it.end ? new Date(it.end) : null;
          if (!end && start){
            let dur = null;
            if (it.duration !== undefined && it.duration !== null) dur = Number(it.duration);
            else if (it.duration_minutes !== undefined && it.duration_minutes !== null) dur = Number(it.duration_minutes);
            else if (it.durationMinutes !== undefined && it.durationMinutes !== null) dur = Number(it.durationMinutes);
            else if (it.duration_mins !== undefined && it.duration_mins !== null) dur = Number(it.duration_mins);
            else if (it.duration_seconds !== undefined && it.duration_seconds !== null) dur = Number(it.duration_seconds) / 60;
            if (dur) end = new Date(start.getTime() + (Number(dur) || 0) * 60000);
          }

          function ordinalSuffix(n){
            const s = ["th","st","nd","rd"], v = n % 100;
            return (s[(v-20)%10] || s[v] || s[0]);
          }

          function fmtTime(d){
            try{ return d.toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit',hour12:true}); }catch(e){ return '' }
          }

          function fmtDateRange(startD, endD){
            if (!startD) return '';
            try{
              const weekday = startD.toLocaleDateString('en-US',{weekday:'long'});
              const month = startD.toLocaleDateString('en-US',{month:'long'});
              const day = startD.getDate();
              const year = startD.getFullYear();
              const startT = fmtTime(startD);
              const endT = endD ? fmtTime(endD) : '';
              const dayWithOrd = `${day}${ordinalSuffix(day)}`;
              return `${weekday}, ${month} ${dayWithOrd}, ${year}, at ${startT}${endT ? ' - ' + endT : ''}`;
            }catch(e){ return '' }
          }

          const desc = fmtDateRange(start, end);

          const row = document.createElement('div');
          row.className = 'conflict-item';
          const main = document.createElement('div');
          main.className = 'conflict-main';
          main.innerHTML = `\
            <div class="conflict-line">${escapeHtml(desc)}&nbsp;&nbsp;&nbsp;&nbsp;Client: ${escapeHtml(name)}${email ? ' &lt;' + escapeHtml(email) + '&gt;' : ''}</div>\
          `;
          row.appendChild(main);

          

          // group by fixed-increment flag (server may send several possible shapes)
          const usesFixed = !!detectUsesFixed(it);
          if (usesFixed) fixedGroup.push(row);
          else customGroup.push(row);
        }
      }

      // Helper to append a heading + rows for a group
      // `groupUsesFixed` is boolean indicating whether this group uses fixed increments
      function pushGroup(title, items, groupUsesFixed){
        const heading = document.createElement('div');
        heading.className = 'conflict-group-heading';
        const left = document.createElement('div');
        left.textContent = `${title} (${items.length})`;
        heading.appendChild(left);
        // Determine status label based on current vs proposed use_fixed_increment
        try{
          const statusSpan = document.createElement('div');
          statusSpan.className = 'conflict-status';
          // `__conflict_ctx` may be set by showModal to pass flags
          const ctx = window.__conflict_ctx || {};
          const current = !!ctx.currentUseFixed;
          const proposed = (typeof ctx.proposedUseFixed === 'boolean') ? !!ctx.proposedUseFixed : current;
          let status = '';
          if (groupUsesFixed === current) {
            status = 'currently applied';
          } else if (groupUsesFixed === proposed) {
            status = 'Will apply after saving new changes';
          }
          if (status) statusSpan.textContent = status;
          heading.appendChild(statusSpan);
        }catch(e){}
        nodes.push(heading);
        for (const r of items) nodes.push(r);
      }

      if (fixedGroup.length) pushGroup('Using fixed increments', fixedGroup, true);
      if (customGroup.length) pushGroup('Using Custom Increments', customGroup, false);

      return nodes;
    }

    // Basic escaping helper used only for small text pieces
    function escapeHtml(s){
      try{ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }catch(e){ return '' }
    }

    function showModal(conflicts, proposedUseFixed, currentUseFixed, onConfirm){
      const tpl = document.getElementById('svc-conflict-modal-tpl');
      const clone = tpl.content.cloneNode(true);
      const backdrop = clone.querySelector('.cc-modal-backdrop');
      const list = clone.querySelector('#svc-conflict-list');
      // store small context so buildConflictNodes can show applied/will apply labels
      try{ window.__conflict_ctx = { proposedUseFixed: !!proposedUseFixed, currentUseFixed: !!currentUseFixed }; }catch(e){}
      // clear and populate with structured rows (one booking per stacked row)
      list.textContent = '';
      const nodes = buildConflictNodes(conflicts || {});
      
      if (!nodes.length){
        const empty = document.createElement('div');
        empty.className = 'conflict-item empty';
        empty.textContent = 'No bookings found.';
        list.appendChild(empty);
      } else {
        for (const n of nodes) list.appendChild(n);
      }
      document.body.appendChild(backdrop);
      backdrop.querySelector('#svc-conflict-cancel').addEventListener('click', function(){ backdrop.remove(); });
      backdrop.querySelector('#svc-conflict-confirm').addEventListener('click', async function(){
        backdrop.remove();
        try {
          await onConfirm();
        } catch (err) {
          console.warn('apply-confirm failed, falling back to form submit', err);
          try { form.submit(); } catch(e){ window.location.reload(); }
        }
      });
    }

    async function onSaveClick(ev){
      try{
        const payload = serializeFormToPayload();
        const previewUrl = window.location.pathname.replace('/edit/', '/preview_update/');
        const applyUrl = window.location.pathname.replace('/edit/', '/apply_update/');

        async function applyAndRedirect(pl) {
          try {
            pl.confirm = true;
            const applied = await postJson(applyUrl, pl);
            if (applied && applied.status === 'ok'){
              const base = window.location.pathname;
              window.location.href = base + '?saved=1';
              return true;
            }
            return false;
          } catch (err) {
            return false;
          }
        }

        const preview = await postJson(previewUrl, payload);
        if (!preview || preview.status !== 'ok'){
          const ok = await applyAndRedirect(payload);
          if (!ok) form.submit();
          return;
        }

        const conflicts = preview.conflicts || {};
        if (Object.keys(conflicts).length === 0){
          const ok = await applyAndRedirect(payload);
          if (!ok) form.submit();
          return;
        }

        showModal(conflicts, payload.use_fixed_increment, window.__svc_current && !!window.__svc_current.use_fixed_increment, async function(){
          const ok = await applyAndRedirect(payload);
          if (!ok) {
            try { form.submit(); } catch(e){ window.location.reload(); }
          }
        });
      } catch (e){
        console.warn('preview failed', e);
        try { form.submit(); } catch (err){ window.location.reload(); }
      }
    }

    for (const b of btns){
      b.addEventListener('click', onSaveClick);
    }
  } catch(e){ console.warn('service preview wiring failed', e); }
})();
  // Add handlers to show a short auto-dismissing toast when View button is clicked without saving
  (function(){
    try {
      function showToast(type, message, timeout=3500){
        try{
          const id = 'cc-toast';
          let el = document.getElementById(id);
          if (!el){
            el = document.createElement('div');
            el.id = id;
            el.style.position = 'fixed';
            el.style.right = '20px';
            el.style.bottom = '20px';
            el.style.zIndex = 2000;
            document.body.appendChild(el);
          }
          const itm = document.createElement('div');
          itm.style.marginTop = '8px';
          itm.style.padding = '10px 14px';
          itm.style.borderRadius = '8px';
          itm.style.color = '#fff';
          itm.style.boxShadow = '0 6px 20px rgba(0,0,0,0.12)';
          itm.style.fontSize = '13px';
          itm.style.maxWidth = '320px';
          itm.style.backdropFilter = 'blur(4px)';
          if (type === 'success') { itm.style.background = '#16a34a'; }
          else if (type === 'warn' || type === 'warning') { itm.style.background = '#f59e0b'; }
          else { itm.style.background = '#374151'; }
          itm.textContent = message;
          el.appendChild(itm);
          setTimeout(()=>{ try{ itm.remove(); if (!el.childElementCount) el.remove(); }catch(e){} }, timeout);
        }catch(e){ try{ alert(message); }catch(_){} }
      }

      function attach(btnId){
        const b = document.getElementById(btnId);
        if (!b) return;
        b.addEventListener('click', function(ev){
          try{
            const saved = b.getAttribute('data-saved') === '1';
            if (!saved){
              ev.preventDefault();
              ev.stopPropagation();
              showToast('warning', 'Please save changes before viewing the public booking page.');
              return false;
            }
            // otherwise allow default (open link)
          }catch(e){ /* ignore */ }
        });
      }

      attach('svc-view-btn');
      attach('svc-view-btn-bottom');

      // Prevent clicks on Save when form is not dirty; show toast like View button.
      // Disabled <button> elements do not fire click events in many browsers, so listen
      // at the document level during capture to reliably intercept attempts.
      function attachSaveGuard(){
        // Listen for pointerdown which fires even when a button is disabled in many browsers.
        document.addEventListener('pointerdown', function(ev){
          try{
            const btn = ev.target && ev.target.closest && ev.target.closest('.svc-save-btn');
            if (!btn) return;
            const disabled = btn.disabled || btn.classList.contains('cursor-not-allowed') || btn.classList.contains('opacity-50');
            if (disabled){
              ev.preventDefault();
              ev.stopPropagation();
              try{ showToast('warning', 'Please make changes before saving.'); } catch(e){ alert('Please make changes before saving.'); }
              return false;
            }
          } catch(e) { /* ignore */ }
        }, true);

        // Also capture Enter/Space key attempts when focused on the button (keyboard users).
        document.addEventListener('keydown', function(ev){
          try{
            const active = document.activeElement;
            if (!active) return;
            if (!active.classList || !active.classList.contains('svc-save-btn')) return;
            if (ev.key === 'Enter' || ev.key === ' '){
              const disabled = active.disabled || active.classList.contains('cursor-not-allowed') || active.classList.contains('opacity-50');
              if (disabled){
                ev.preventDefault();
                ev.stopPropagation();
                try{ showToast('warning', 'Please make changes before saving.'); } catch(e){ alert('Please make changes before saving.'); }
                return false;
              }
            }
          } catch(e) { /* ignore */ }
        }, true);
      }

      attachSaveGuard();
    } catch(e) { console.warn('svc view btn wiring failed', e); }
  })();
</script>
<script>
  // Toggle greying/disabled state of refund cutoff & policy when checkbox toggles
  (function(){
    try{
      const chk = document.getElementById('refunds_allowed');
      const wrapper = document.querySelector('.refund-policy-controls');
      if (!chk || !wrapper) return;
      const inputs = wrapper.querySelectorAll('input, textarea');
      function update(){
        const enabled = !!chk.checked;
        inputs.forEach(i => {
          try{ i.disabled = !enabled; }catch(e){}
        });
        wrapper.classList.toggle('refund-disabled', !enabled);
      }
      chk.addEventListener('change', update);
      // initialize on load
      update();
    }catch(e){ console.warn('refund toggle wiring failed', e); }
  })();
</script>
<style>
.refund-disabled { opacity: 0.72; }
.refund-disabled input, .refund-disabled textarea { opacity: 0.72; }
</style>
<script>
(function(){
  try{
    const form = document.querySelector('form.cc-form');
    if (!form) return;

    const viewBtns = Array.from(document.querySelectorAll('#svc-view-btn, #svc-view-btn-bottom'));
    if (!viewBtns.length) return;

    // Serialize form into a stable JSON string for comparison with saved snapshot
    function serializeForm(){
      const fd = new FormData(form);
      const out = {};
      for (const [k,v] of fd.entries()){
        const el = form.querySelector(`[name="${k}"]`);
        if (el && el.type === 'checkbox'){
          out[k] = el.checked ? '1' : '0';
        } else {
          out[k] = v;
        }
      }
      // Ensure known boolean fields are present even if unchecked (not in FormData)
      const booleanNames = ['use_fixed_increment', 'allow_squished_bookings', 'is_active', 'refunds_allowed', 'allow_ends_after_availability', 'apply_to_conflicts'];
      for (const name of booleanNames){
        if (!(name in out)){
          const el = form.querySelector(`[name="${name}"]`);
          if (el && el.type === 'checkbox') out[name] = el.checked ? '1' : '0';
          else if (el) out[name] = el.value;
          else out[name] = '';
        }
      }

      // Sort keys to make stable string
      const keys = Object.keys(out).sort();
      const stable = {};
      for (const k of keys) stable[k] = out[k];
      return JSON.stringify(stable);
    }

    const savedSnapshot = serializeForm();

    function setViewButtonsEnabled(enabled){
      for (const b of viewBtns){
        if (enabled){
          b.classList.remove('opacity-50','cursor-not-allowed');
          b.removeAttribute('aria-disabled');
          b.setAttribute('data-saved', '1');
        } else {
          b.classList.add('opacity-50','cursor-not-allowed');
          b.setAttribute('aria-disabled', 'true');
          b.setAttribute('data-saved', '0');
        }
      }
    }

    function setSaveButtonsEnabled(enabled){
      const saveBtns = Array.from(document.querySelectorAll('.svc-save-btn'));
      for (const s of saveBtns){
        try { s.disabled = !enabled; } catch(e){}
        if (!enabled) {
          s.classList.add('opacity-50','cursor-not-allowed');
        } else {
          s.classList.remove('opacity-50','cursor-not-allowed');
        }
      }
    }

    // Initialize according to whether current form equals saved snapshot
    const isInitiallySaved = (serializeForm() === savedSnapshot);
    setViewButtonsEnabled(isInitiallySaved);
    setSaveButtonsEnabled(!isInitiallySaved);

    // Compare current form to saved snapshot and toggle buttons
    function updateState(){
      try{
        const cur = serializeForm();
        const isSameAsSaved = cur === savedSnapshot;
        setViewButtonsEnabled(isSameAsSaved);
        // Save enabled only when form is dirty
        setSaveButtonsEnabled(!isSameAsSaved);
      } catch (e){ console.warn('svc view compare failed', e); }
    }

    // Add listeners to keep live comparison; debounce to avoid excessive work
    let timer = null;
    function scheduleUpdate(){
      if (timer) clearTimeout(timer);
      timer = setTimeout(()=>{ timer = null; updateState(); }, 120);
    }

    const controls = form.querySelectorAll('input, textarea, select');
    controls.forEach(c => {
      c.addEventListener('input', scheduleUpdate);
      c.addEventListener('change', scheduleUpdate);
    });

    // If a save happens and the page is not reloaded, we can update the savedSnapshot to match current
    // (some code paths redirect; others may update in-place). Listen for successful submit event that
    // results in form submit via existing save button handlers by hooking submit.
    form.addEventListener('submit', function(){
      // update snapshot after short delay to allow any pre-submit handlers to run
      setTimeout(function(){
        try{ savedSnapshot = serializeForm(); setViewButtonsEnabled(true); setSaveButtonsEnabled(false); }catch(e){}
      }, 500);
    });

  } catch (e){ console.warn('svc view btn dirty wiring failed', e); }
})();
</script>
{% endblock %}
