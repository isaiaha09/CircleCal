{% extends "calendar_app/base.html" %}

{% block title %}Edit Service • {{ org.name }}{% endblock %}

{% block content %}
{% block extra_head %}
<style>
  /* Page-specific enhanced field styling (aligned with create service) */
  .cc-field {
    border: 1px solid #d1d5db; /* gray-300 */
    background: #ffffff;
    padding: 0.7rem 0.9rem;
    border-radius: 0.5rem;
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.6);
    font-size: 0.97rem;
    width: 100%;
  }
  .cc-field[disabled] { background:#f8fafc; opacity:.9; }
  .cc-field:focus { outline:none; border-color:#2563eb; box-shadow:0 0 0 4px rgba(37,99,235,0.08); }
  .cc-page { max-width:78rem; margin:0 auto; padding:2.5rem 1.5rem; }
  @media (min-width:768px){ .cc-page { padding:3rem 2rem; } }
  .section-card { background:#fff; border:1px solid #c0c7d1; border-radius:0.75rem; padding:1rem 1.25rem; margin-bottom:1rem; }
  /* Make all section cards fill the page content area so they align with other sections */
  .section-card { box-sizing: border-box; width: 100%; max-width: none; margin-left: 0; margin-right: 0; }
  .section-title { font-size:1rem; font-weight:600; margin-bottom:0.5rem; }
  /* Inputs inside section cards use a unified light border so areas are obvious */
  .section-card input[type="text"],
  .section-card input[type="number"],
  .section-card input[type="email"],
  .section-card textarea,
  .section-card select,
  .section-card .cc-field,
  .section-card .mt-1.block {
    border: 1px solid #c0c7d1; /* same as card border (darker) */
    background: #ffffff;
    padding: 0.6rem 0.8rem;
    border-radius: 0.5rem;
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.6);
  }
  .section-card input[disabled], .section-card textarea[disabled] { background:#f8fafc; opacity:.95; }
  .section-card input:focus, .section-card textarea:focus, .section-card select:focus, .section-card .cc-field:focus {
    outline: none;
    border-color: #2563eb;
    box-shadow: 0 0 0 4px rgba(37,99,235,0.06);
  }
  /* Availability disabled overlay */
  .availability-disabled { position: relative; opacity: 0.8; }
  .availability-disabled .availability-overlay { position: absolute; inset: 0; background: rgba(255,255,255,0.85); display:flex; align-items:center; justify-content:center; border-radius:0.75rem; z-index:20; }
  .availability-disabled .availability-overlay .msg { max-width:56rem; padding:1rem 1.5rem; text-align:center; color:#374151; }
  /* Selected member chips shown in the dropdown label */
  .member-chip { display:inline-block; background:#eef6ff; color:#0b5cff; padding:6px 10px; border-radius:999px; font-size:0.95rem; margin-right:6px; margin-bottom:2px; }
  .member-chip .member-chip-remove { display:inline-block; margin-left:8px; color:#0840c6; background:transparent; border-radius:999px; padding:0 6px; cursor:pointer; font-weight:700; line-height:1; }
  .member-chip .member-chip-remove:hover { background:rgba(11,92,255,0.08); }
</style>
{% endblock %}

<div class="cc-page">
  <form class="cc-form" method="post">
    {% csrf_token %}
  {% if request.GET.saved %}
    <div class="mb-4 p-3 rounded bg-green-50 border-l-4 border-green-400 text-green-800" role="status" aria-live="polite">
      <strong>Changes saved</strong>
      <div class="text-sm mt-1">Your changes were saved successfully.</div>
    </div>
  {% endif %}
  <!-- Top action buttons: Cancel (left) and Save (right) -->
  <div class="flex items-center justify-between mb-4">
    <a href="{% url 'calendar_app:dashboard' org.slug %}" class="text-sm text-gray-500 hover:text-gray-700">Cancel</a>
    <div class="flex items-center">
      <button type="button" class="svc-save-btn inline-flex items-center px-4 py-2 rounded-md bg-blue-600 text-white text-sm font-medium hover:bg-blue-700">Save Changes</button>
      <a id="svc-view-btn" data-saved="{{ request.GET.saved|yesno:'1,0' }}" href="{% url 'bookings:public_service_page' org.slug service.slug %}" target="_blank" rel="noopener noreferrer" class="inline-flex items-center px-3 py-2 ml-3 rounded-md text-sm font-medium border border-blue-600 text-blue-600 bg-white hover:bg-blue-50 {% if not request.GET.saved %}opacity-50 cursor-not-allowed{% endif %}">View public page</a>
    </div>
  </div>

  <h1 class="text-2xl font-semibold mb-2 text-center">Edit Service</h1>
  <p class="text-sm text-gray-500 mb-6 text-center max-w-2xl mx-auto">
    Update your service details.
  </p>

    <!-- Prominent active toggle: moved to the top for visibility -->
    <div class="section-card mb-4" style="border:1px solid #2563eb;background:#f0f9ff;box-shadow:0 2px 6px rgba(37,99,235,0.06);">
      <div class="flex items-center justify-between">
        <div>
          <label for="is_active" class="inline-flex items-center">
            {% if is_only_active_service %}
              <input type="hidden" name="is_active" value="on">
            {% endif %}
            <input type="checkbox" name="is_active" id="is_active" {% if service.is_active %}checked{% endif %}
                   class="rounded border-gray-300 text-blue-600 focus:ring-blue-500 {% if is_only_active_service %}opacity-60 cursor-not-allowed{% endif %}"
                   {% if is_only_active_service %}disabled aria-disabled="true"{% endif %}>
            <div class="ml-3">
              <div class="text-lg font-semibold text-gray-800">Service is active</div>
              <div class="text-sm text-gray-600">Visible on the public booking page</div>
            </div>
          </label>
          {% if is_only_active_service %}
            <p class="mt-2 text-sm text-gray-700">You currently have only one active service. To keep your public booking page available to clients, activate another service before disabling this one.</p>
          {% endif %}
        </div>
        <div class="text-sm text-gray-700">
          <span class="inline-flex items-center px-2 py-1 rounded bg-white text-gray-700">Important</span>
        </div>
      </div>
    </div>

    <script>
    // Hours / minutes helper for buffer_after: keep hidden `buffer_after` in minutes in-sync
    document.addEventListener('DOMContentLoaded', function(){
      try{
        const hidden = document.getElementById('buffer_hidden');
        const h = document.getElementById('buffer_hours');
        const m = document.getElementById('buffer_minutes');
        if (!hidden || !h || !m) return;

        function setFieldsFromHidden(){
          const total = Number(hidden.value) || 0;
          const hours = Math.floor(total / 60);
          const mins = total % 60;
          h.value = hours;
          m.value = mins;
        }

        function updateHidden(){
          const hours = Math.max(0, Number(h.value) || 0);
          let mins = Math.max(0, Number(m.value) || 0);
          if (mins > 59) mins = 59;
          const total = (hours * 60) + mins;
          hidden.value = total;
        }

        h.addEventListener('input', updateHidden);
        m.addEventListener('input', updateHidden);

        // initialize
        setFieldsFromHidden();
      } catch(e){ console.warn('buffer hours/min wiring failed', e); }
    });
    </script>

    {% if needs_migration %}
      <div class="mb-4 p-3 rounded bg-yellow-50 border-l-4 border-yellow-400 text-yellow-800">
        <strong>Database migration required:</strong>
        <div class="text-sm">The feature "Allow appointment to end after availability" requires a database migration. Please run <code>python manage.py migrate</code> on the server to enable this setting.</div>
      </div>
    {% endif %}

    <div class="section-card">
      <div class="section-title">Basic Info</div>
      <div class="mb-3">
        <label class="block text-sm font-medium text-gray-700">Name</label>
        <input name="name" type="text" required value="{{ service.name }}" class="cc-field mt-1 w-full">
      </div>
      <div class="mb-3">
        <label class="block text-sm font-medium text-gray-700">Slug (URL-friendly)</label>
        {% if can_edit_slug %}
          <input name="slug" type="text" value="{{ service.slug }}" class="cc-field mt-1 w-full">
          <p class="mt-1 text-xs text-gray-500">You may change the URL slug while no bookings exist for this service. Once a booking exists, the slug becomes immutable to avoid breaking booking links.</p>
        {% else %}
          <input type="text" value="{{ service.slug }}" disabled class="cc-field mt-1 w-full">
          <p class="mt-1 text-xs text-gray-500">Slug cannot be changed because this service already has bookings. To edit the slug, remove all bookings first.</p>
        {% endif %}
      </div>
      <div>
        <label class="block text-sm font-medium text-gray-700">Description</label>
        <textarea name="description" rows="4" class="cc-field mt-1 w-full">{{ service.description }}</textarea>
      </div>
    </div>

    <!-- core timing controls are shown below in a grouped card -->

    <!-- Assign service to one or more team members -->
    <div class="section-card">
      <div class="section-title">Assign to team members</div>
      <p class="text-sm text-gray-600 mb-3">Select which team member(s) can deliver this service. Leave empty to make the service unassigned.</p>

      <div class="mb-3">
        <div id="member-dropdown" class="relative">
          <button type="button" id="member-dropdown-toggle" class="cc-field text-left w-full flex items-center justify-between" aria-haspopup="listbox" aria-expanded="false">
            <span id="member-dropdown-label">Select team members...</span>
            <span style="font-size:0.9rem;color:#6b7280">▾</span>
          </button>

          <div id="member-dropdown-panel" role="listbox" aria-multiselectable="true" style="display:none;position:absolute;z-index:60;left:0;right:0;margin-top:6px;background:#fff;border:1px solid #e6eef6;border-radius:6px;max-height:320px;overflow:auto;box-shadow:0 6px 18px rgba(16,24,40,0.06);">
            <div style="padding:8px;border-bottom:1px solid #eef3f8">
              <input id="member-search" type="search" placeholder="Search team members..." class="cc-field" style="margin:0;" />
            </div>
            <div id="member-list" style="padding:8px;">
              {% if org.members.all %}
                {% for m in org.members.all %}
                  {% if m.is_active %}
                    {% with user=m.user %}
                      <div class="member-item flex items-center justify-between py-2 px-2 rounded hover:bg-gray-50" data-name="{% if user.first_name or user.last_name %}{{ user.first_name }} {{ user.last_name }}{% else %}{{ user.email }}{% endif %}" data-id="{{ m.id }}">
                        <div>
                          <div class="text-sm text-gray-800">{% if user.first_name or user.last_name %}{{ user.first_name }} {{ user.last_name }}{% else %}{{ user.email }}{% endif %}</div>
                          <div class="text-xs text-gray-500">{{ m.role|title }}</div>
                        </div>
                        <div class="select-indicator text-sm text-blue-600" aria-hidden="true">&nbsp;</div>
                      </div>
                    {% endwith %}
                  {% endif %}
                {% endfor %}
              {% else %}
                <div class="text-sm text-gray-500">No team members found for this business.</div>
              {% endif %}
            </div>
          </div>
        </div>
      </div>

      <script>
        (function(){
          try{
            const toggle = document.getElementById('member-dropdown-toggle');
            const panel = document.getElementById('member-dropdown-panel');
            const input = document.getElementById('member-search');
            const list = document.getElementById('member-list');
            const label = document.getElementById('member-dropdown-label');

            if (!toggle || !panel || !input || !list) return;

            const selected = new Set();
            try{
              const initial = {{ assigned_member_ids|default:'[]'|safe }};
              for (const v of initial){ selected.add(String(v)); }
            }catch(e){ }

            function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
            function updateLabel(){
              if (!selected.size){ label.textContent = 'Select team members...'; return; }
              const items = [];
              for (const it of list.querySelectorAll('.member-item')){
                const id = it.getAttribute('data-id');
                if (selected.has(id)) {
                  const nameEl = it.querySelector('.text-sm');
                  const name = nameEl ? nameEl.textContent.trim() : (it.getAttribute('data-name')||'');
                  items.push({id: String(id), name: name});
                }
              }
              if (!items.length){ label.textContent = 'Select team members...'; return; }
              // render chips with a small remove affordance
              label.innerHTML = items.map(function(itm){
                return '<span class="member-chip" data-id="' + escapeHtml(itm.id) + '">' + escapeHtml(itm.name) + ' <span class="member-chip-remove" data-id="' + escapeHtml(itm.id) + '" title="Remove" aria-hidden="true">&times;</span></span>';
              }).join(' ');
            }

            function syncHiddenInputs(){
              Array.from(document.querySelectorAll('input[name="assigned_members"][data-generated]')).forEach(i => i.remove());
              const form = toggle.closest('form');
              if (!form) return;
              for (const id of selected){
                const inp = document.createElement('input');
                inp.type = 'hidden';
                inp.name = 'assigned_members';
                inp.value = id;
                inp.setAttribute('data-generated','1');
                form.appendChild(inp);
              }
            }

            for (const it of list.querySelectorAll('.member-item')){
              const id = it.getAttribute('data-id');
              const indicator = it.querySelector('.select-indicator');
              if (selected.has(id)) { indicator.textContent = '✓'; it.classList.add('bg-blue-50'); }
              it.addEventListener('click', function(){
                  if (selected.has(id)){
                    selected.delete(id); indicator.textContent = '\u00A0'; it.classList.remove('bg-blue-50');
                  } else { selected.add(id); indicator.textContent = '✓'; it.classList.add('bg-blue-50'); }
                updateLabel();
                syncHiddenInputs();
              });
            }

            input.addEventListener('input', function(){
              const q = (input.value || '').toLowerCase().trim();
              for (const it of list.querySelectorAll('.member-item')){
                const name = (it.getAttribute('data-name')||'').toLowerCase();
                it.style.display = name.indexOf(q) === -1 ? 'none' : '';
              }
            });

            toggle.addEventListener('click', function(){
              const open = panel.style.display !== 'none';
              panel.style.display = open ? 'none' : 'block';
              toggle.setAttribute('aria-expanded', String(!open));
              if (!open) input.focus();
            });

            document.addEventListener('click', function(e){
              if (!toggle.contains(e.target) && !panel.contains(e.target)){
                panel.style.display = 'none';
                toggle.setAttribute('aria-expanded','false');
              }
            });

            // Allow clicking the small remove "×" inside a rendered chip to deselect that member
                label.addEventListener('click', function(e){
              try{
                const rem = e.target && (e.target.closest ? e.target.closest('.member-chip-remove') : null);
                if (!rem) return;
                const id = rem.getAttribute('data-id');
                if (!id) return;
                if (selected.has(id)){
                  selected.delete(id);
                  const it = list.querySelector('.member-item[data-id="' + id + '"]');
                  if (it){
                    const indicator = it.querySelector('.select-indicator');
                    if (indicator) indicator.textContent = '\u00A0';
                    it.classList.remove('bg-blue-50');
                  }
                  updateLabel();
                  syncHiddenInputs();
                  e.stopPropagation();
                  e.preventDefault();
                }
              }catch(err){ /* ignore */ }
            });

            updateLabel();
            syncHiddenInputs();
          }catch(e){ console.warn('member dropdown failed', e); }
        })();
      </script>
    </div>


    <!-- Slot increment settings are configured in the Day Schedule modal (calendar). Removed from edit page to avoid duplication. -->
    <!-- Per-service slot settings (single, cleaned block) -->
    <div class="section-card">
      <div class="grid grid-cols-1 gap-3">
        <div>
          <label class="block text-sm font-medium text-gray-700">Client slot increment (minutes)</label>
          <input id="time_increment_minutes" name="time_increment_minutes" type="number" value="{{ service.time_increment_minutes|default:30 }}" min="5" class="cc-field mt-1 w-40">
          <p class="mt-1 text-xs text-gray-500">This controls the visible client slot increment. When <em>Use fixed increments</em> is enabled, this value is ignored.</p>
        </div>
        <div>
          <label class="inline-flex items-center">
            <input type="checkbox" name="use_fixed_increment" id="use_fixed_increment" {% if service.use_fixed_increment %}checked{% endif %}
                   class="rounded border-gray-300 text-blue-600 focus:ring-blue-500">
            <span class="ml-2 text-sm text-gray-700">Use fixed increments (service duration + buffer)</span>
          </label>
          <p class="mt-1 text-xs text-gray-500">When enabled, clients will only see anchors spaced by the service duration plus cleanup buffer.</p>
        </div>
        <div>
          <label class="inline-flex items-center">
            <input type="checkbox" name="allow_squished_bookings" id="allow_squished_bookings" {% if service.allow_squished_bookings %}checked{% endif %}
                   class="rounded border-gray-300 text-blue-600 focus:ring-blue-500">
            <span class="ml-2 text-sm text-gray-700">Allow squished bookings (permit slots that violate buffers)</span>
          </label>
          <p class="mt-1 text-xs text-gray-500">When enabled, the system will allow bookings that fit the service duration even if they don't satisfy the configured buffers. Owners will receive a notification when such bookings occur.</p>
        </div>
      </div>
    </div>

    <script>
      // When Use Fixed Increments is enabled, disable/grey the Allow Squished and the increment input.
      // Also keep the increment in-sync with the Day Schedule modal via localStorage ('client_view_settings').
      (function(){
        try {
          const fixed = document.getElementById('use_fixed_increment');
          const squish = document.getElementById('allow_squished_bookings');
          const incInput = document.getElementById('time_increment_minutes');
          const form = document.querySelector('form.cc-form');
          if (!fixed) return;

          // Visual helper class
          const style = document.createElement('style');
          style.innerHTML = '.squish-disabled-label { opacity: 0.6; } .inc-disabled { opacity: 0.55; }';
          document.head.appendChild(style);

          const parentLabel = squish ? (squish.closest('label') || squish.parentNode) : null;

          function updateState() {
            const disabled = fixed.checked;
            if (squish) {
              try { squish.disabled = disabled; } catch(e){}
              if (parentLabel) parentLabel.classList.toggle('squish-disabled-label', disabled);
            }
            if (incInput) {
              try { incInput.disabled = disabled; } catch(e){}
              incInput.classList.toggle('inc-disabled', disabled);
            }

            // Propagate the effective client increment to localStorage so the public
            // calendar reflects the change immediately. When fixed increments are
            // enabled, use duration + buffer_after; otherwise use the visible input.
            try {
              const durationEl = document.querySelector('input[name="duration"]');
              const bufferEl = document.querySelector('input[name="buffer_after"]');
              const dur = durationEl ? Number(durationEl.value) : null;
              const buf = bufferEl ? Number(bufferEl.value) : 0;
              if (disabled) {
                // fixed increment
                if (dur != null && !isNaN(dur)) {
                  setClientIncrementFromInput(Number(dur) + Number(buf));
                }
              } else {
                if (incInput) setClientIncrementFromInput(Number(incInput.value) || 30);
              }
            } catch (e) { /* ignore */ }
          }

          // When increment input changes, ask to confirm and propagate to localStorage so modal reads it
          const initialIncVal = incInput ? Number(incInput.value) : null;

          function setClientIncrementFromInput(val) {
            try {
              const raw = localStorage.getItem('client_view_settings') || '{}';
              let parsed = {};
              try { parsed = JSON.parse(raw); } catch(_) { parsed = {}; }
              parsed.increment = Number(val) || 30;
              localStorage.setItem('client_view_settings', JSON.stringify(parsed));
              try { showToast('success', 'Client increment updated for Day Schedule modal.'); } catch(e){}
            } catch (e) { console.warn('setClientIncrement failed', e); }
          }

          if (incInput) {
            incInput.addEventListener('change', function(ev){
              try {
                if (fixed.checked) {
                  // Shouldn't happen because input is disabled, but guard
                  try { showToast('warning', 'Disable Fixed Increments to change the client increment.'); } catch(e){}
                  incInput.value = initialIncVal;
                  return;
                }
                const newVal = Number(incInput.value);
                if (isNaN(newVal) || newVal < 5) {
                  try { showToast('warning', 'Enter a valid increment (5+ minutes).'); } catch(e){}
                  incInput.value = initialIncVal;
                  return;
                }
                const confirmMsg = `Change client increment to ${newVal} minutes? This will update the Day Schedule modal's client view settings.`;
                if (!confirm(confirmMsg)) {
                  // revert
                  incInput.value = initialIncVal;
                    const btns = Array.from(document.querySelectorAll('.svc-save-btn'));
                }
                // propagate to localStorage so calendar modal picks it up
                setClientIncrementFromInput(newVal);
              } catch (e) { console.warn('inc change handler failed', e); }
            });
          }

          // Reflect localStorage changes (from modal or other tabs) into this input
          window.addEventListener('storage', function(e){
            if (e.key === 'client_view_settings') {
              try {
                const parsed = JSON.parse(e.newValue || '{}');
                if (parsed && typeof parsed.increment === 'number' && incInput && !fixed.checked) {
                  incInput.value = String(parsed.increment);
                }
              } catch (err) { /* ignore */ }
            }
          });

          // Before submitting the service edit form, if the increment was changed from the original value,
          // confirm the user wants to persist the change to the server as well.
          if (form && incInput) {
            form.addEventListener('submit', function(ev){
              try {
                const cur = Number(incInput.value);
                if (!isNaN(initialIncVal) && cur !== Number(initialIncVal)) {
                  const ok = confirm(`You changed the slot increment from ${initialIncVal} to ${cur} minutes. Save this change to the service?`);
                  if (!ok) {
                    ev.preventDefault();
                    return false;
                  }
                  // Also update localStorage so modal and other tabs reflect the new value
                  setClientIncrementFromInput(cur);
                }
              } catch (e) { /* allow submit on error */ }
            });
          }

          // Initialize state and sync with localStorage if appropriate
          updateState();
          try {
            const raw = localStorage.getItem('client_view_settings');
            if (raw && incInput && !fixed.checked) {
              const parsed = JSON.parse(raw);
              if (parsed && typeof parsed.increment === 'number') {
                incInput.value = String(parsed.increment);
              }
            }
          } catch (e) { /* ignore parse errors */ }

          // attach handler to fixed checkbox
          fixed.addEventListener('change', updateState);
        } catch (e) { console.warn('squish-disable and increment sync wiring failed', e); }
      })();
    </script>

    <script>
      // Ensure hidden fallback reflects the actual checkbox state on submit
      (function(){
        try {
          const form = document.querySelector('form.cc-form');
          const chk = form ? form.querySelector('input[type="checkbox"][name="allow_ends_after_availability"]') : null;
          const hidden = form ? form.querySelector('input[type="hidden"][name="allow_ends_after_availability"]') : null;
          if (!form || !chk || !hidden) return;
          form.addEventListener('submit', function(){
            try { hidden.value = chk.checked ? '1' : '0'; } catch(e){}
          });
        } catch(e) { console.warn('sync hidden checkbox failed', e); }
      })();
    </script>

      <script>
      // Hours / minutes helper for duration: keep hidden `duration` in minutes in-sync
      document.addEventListener('DOMContentLoaded', function(){
        try{
          const hidden = document.getElementById('duration_hidden');
          const h = document.getElementById('duration_hours');
          const m = document.getElementById('duration_minutes');
          if (!hidden || !h || !m) return;

          function setFieldsFromHidden(){
            const total = Number(hidden.value) || 0;
            const hours = Math.floor(total / 60);
            const mins = total % 60;
            h.value = hours;
            m.value = mins;
          }

          function updateHidden(){
            const hours = Math.max(0, Number(h.value) || 0);
            const mins = Math.max(0, Number(m.value) || 0);
            const total = (hours * 60) + mins;
            hidden.value = total;
          }

          h.addEventListener('input', updateHidden);
          m.addEventListener('input', updateHidden);

          // initialize
          setFieldsFromHidden();
        } catch(e){ console.warn('duration hours/min wiring failed', e); }
      });
      </script>

    <!-- Group core timing settings into a clear section -->
    <div class="section-card">
      <div class="grid grid-cols-2 gap-4">
        <div>
          <label class="block text-sm font-medium text-gray-700">Duration</label>
          <div class="mt-1 flex items-center gap-2">
            <input id="duration_hours" type="number" min="0" class="cc-field w-24" placeholder="Hours">
            <span class="text-sm text-gray-600">Hours</span>
            <input id="duration_minutes" type="number" min="0" max="59" class="cc-field w-24" placeholder="Minutes">
            <span class="text-sm text-gray-600">Minutes</span>
        </div>
          <input type="hidden" name="duration" id="duration_hidden" value="{{ service.duration }}">
          <p class="mt-1 text-xs text-gray-500">Enter Hours and Minutes; they will be saved as total minutes.</p>
        </div>
        <div>
          <label class="block text-sm font-medium text-gray-700">Price (USD)</label>
          <input name="price" type="number" step="0.01" value="{{ service.price }}"
                 class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:ring-blue-500 focus:border-blue-500 text-sm">
        </div>
      </div>

      <div class="grid grid-cols-2 gap-4 mt-4">
         <div>
           <label class="block text-sm font-medium text-gray-700">Buffer Time Post Service Appointment</label>
           <div class="mt-1 flex items-center gap-2">
             <input id="buffer_hours" type="number" min="0" class="cc-field w-24" placeholder="Hours">
             <span class="text-sm text-gray-600">Hours</span>
             <input id="buffer_minutes" type="number" min="0" max="59" class="cc-field w-24" placeholder="Minutes">
             <span class="text-sm text-gray-600">Minutes</span>
           </div>
           <input type="hidden" name="buffer_after" id="buffer_hidden" value="{{ service.buffer_after }}">
           <p class="mt-1 text-xs text-gray-500">Enter buffer time after appointment; saved as total minutes.</p>
         </div>
        <div>
          <label class="block text-sm font-medium text-gray-700">Allow appointment to end after availability?</label>
          <div class="mt-2">
            <label class="inline-flex items-center">
              <!-- hidden fallback ensures a value is always posted even when unchecked -->
              <input type="hidden" name="allow_ends_after_availability" value="0">
              <input type="checkbox" name="allow_ends_after_availability" value="1" {% if service.allow_ends_after_availability %}checked{% endif %}
                     class="rounded border-gray-300 text-blue-600 focus:ring-blue-500">
              <span class="ml-2 text-sm text-gray-700">Allow clients to book slots that start before the availability end even if they finish after it.</span>
            </label>
          </div>
          <p class="mt-1 text-xs text-gray-500">Enable to allow the final time slot to finish after your daily availability end.</p>
        </div>
      </div>
    </div>

    <div class="grid grid-cols-2 gap-4">
      <div>
        <label class="block text-sm font-medium text-gray-700">How soon can clients book before the appointment? (In Hours)</label>
       <input name="min_notice_hours" type="number" value="{{ service.min_notice_hours }}" min="0"
         class="cc-field mt-1 w-full" />
       <p class="mt-2 text-xs text-gray-500">Prevent last‑minute bookings (e.g. 24 = one day).</p>
      </div>
      <div>
        <label class="block text-sm font-medium text-gray-700">How far ahead can clients book? (In Days)</label>
       <input name="max_booking_days" type="number" value="{{ service.max_booking_days }}" min="1"
         class="cc-field mt-1 w-full" />
       <p class="mt-2 text-xs text-gray-500">Limit how far out clients can book.</p>
      </div>
    </div>

    <!-- removed duplicate is_active toggle (moved to top) -->

    {% if conflict_services %}
      <div class="mb-4 p-3 rounded bg-yellow-50 border-l-4 border-yellow-400 text-yellow-800">
        <strong>Conflicting services detected</strong>
        <p class="text-sm">The following services have overlapping availability windows: {{ conflict_services|join:", " }}.</p>
        <label class="inline-flex items-center mt-2"><input type="checkbox" name="apply_to_conflicts" value="1" class="rounded border-gray-300"> <span class="ml-2 text-sm">Apply these settings to the listed services as well</span></label>
      </div>
    {% endif %}

    <!-- Refund Policy -->
    <div class="section-card">
      <h2 class="text-base font-semibold">Refund Policy</h2>
        <div class="flex items-center mt-3">
          <input type="checkbox" name="refunds_allowed" id="refunds_allowed" {% if service.refunds_allowed %}checked{% endif %}
                 class="rounded border-gray-300 text-blue-600 focus:ring-blue-500">
          <label for="refunds_allowed" class="ml-2 text-sm text-gray-700">Allow refunds for this service</label>
        </div>
        <div class="refund-policy-controls mt-3">
          <div>
            <label class="block text-sm font-medium text-gray-700">Refund Cutoff (Hours)</label>
            <input name="refund_cutoff_hours" type="number" value="{{ service.refund_cutoff_hours }}" min="0"
                   class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:ring-blue-500 focus:border-blue-500 text-sm">
            <p class="mt-1 text-xs text-gray-500">Minimum 1 hour when refunds are enabled. Set to 0 by unchecking "Allow refunds".</p>
          </div>
          <div class="mt-3">
            <label class="block text-sm font-medium text-gray-700">Custom Refund Policy Text</label>
            <textarea name="refund_policy_text" rows="3"
                      class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:ring-blue-500 focus:border-blue-500 text-sm">{{ service.refund_policy_text }}</textarea>
          </div>
        </div>
    </div>

    <div class="section-card {% if not can_edit_service_availability %}availability-disabled{% endif %}">
      <!-- Service availability editor -->
      <div class="mt-0">
        <h2 class="text-base font-semibold text-center">Service availability</h2>
        {% if can_edit_service_availability and service_availability_member_name %}
          <div class="text-sm text-gray-600 text-center mt-1">Applies to: <span class="font-medium">{{ service_availability_member_name }}</span></div>
        {% endif %}
        <p class="text-sm text-gray-500 mt-3">Specify which days/times this service is offered. These must be within your organization's default weekly availability shown below. Use comma-separated ranges like <code>09:00-12:00,13:00-17:00</code>.</p>
        {% if not can_edit_service_availability %}
          <div class="availability-overlay" role="status" aria-live="polite">
            <div class="msg">
              <strong class="block mb-1">Service availability disabled</strong>
              <div class="text-sm">{{ service_availability_disabled_reason|default:"Service availability is only available for services assigned to exactly one team member when that team member offers multiple solo services." }}</div>
            </div>
          </div>
        {% endif %}
        <div class="grid grid-cols-1 gap-2 mt-2">
          {% for row in weekly_edit_rows %}
            <div class="flex items-center gap-3">
              <div style="width:64px; font-weight:600">{{ row.label }}</div>
              <div class="text-xs text-gray-600">Default: {{ row.org_ranges|default:'—' }}</div>
            </div>
            <div>
              <input type="text" name="svc_avail_{{ row.ui }}" value="{{ row.svc_ranges }}"
                     class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:ring-blue-500 focus:border-blue-500 text-sm" placeholder="e.g. 09:00-12:00,13:00-17:00"
                     {% if not can_edit_service_availability %}disabled aria-disabled="true"{% endif %}>
            </div>
          {% endfor %}
        </div>
      </div>
    </div>

    <!-- Bottom action bar: Cancel (left) and Save (right) -->
    <div class="flex items-center justify-between mt-6">
      <a href="{% url 'calendar_app:dashboard' org.slug %}" class="text-sm text-gray-500 hover:text-gray-700">Cancel</a>
      <div class="flex items-center">
        <button type="button" class="svc-save-btn inline-flex items-center px-4 py-2 rounded-md bg-blue-600 text-white text-sm font-medium hover:bg-blue-700">Save Changes</button>
        <a id="svc-view-btn-bottom" data-saved="{{ request.GET.saved|yesno:'1,0' }}" href="{% url 'bookings:public_service_page' org.slug service.slug %}" target="_blank" rel="noopener noreferrer" class="inline-flex items-center px-3 py-2 ml-3 rounded-md text-sm font-medium border border-blue-600 text-blue-600 bg-white hover:bg-blue-50 {% if not request.GET.saved %}opacity-50 cursor-not-allowed{% endif %}">View public page</a>
      </div>
    </div>
  </form>
</div>
<template id="svc-conflict-modal-tpl">
  <div class="cc-modal-backdrop" style="position:fixed;inset:0;background:rgba(0,0,0,0.4);display:flex;align-items:center;justify-content:center;z-index:1200">
    <div style="background:#fff;padding:1rem;border-radius:8px;max-width:760px;width:95%;box-shadow:0 6px 24px rgba(0,0,0,0.2);display:flex;flex-direction:column;max-height:80vh;">
        <h3 style="margin:0 0 0.5rem 0;font-weight:700">Conflicting bookings detected</h3>
        <p style="margin:0 0 0.75rem 0;color:#374151">Some booked days already use previous settings. When you confirm, those dates will keep their frozen settings — the new settings will only apply to days without bookings. Review the preserved settings listed under each affected date before confirming.</p>
      <div id="svc-conflict-list" style="flex:1;overflow:auto;border-radius:8px;margin-bottom:12px;padding:6px 6px 0 6px">
        <!-- Booking rows will be injected here as individual stacked items -->
      </div>
      <style>
        /* Modal list layout */
        #svc-conflict-list { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; font-size:0.95rem; }

        /* Date heading */
        .conflict-group-heading { font-weight:700; margin:12px 0 8px; color:#0f172a; display:flex; align-items:center; justify-content:space-between; background:#f8fafc; padding:8px 10px; border-radius:8px; border:1px solid #e6eef6 }
        .conflict-group-heading .date-left { font-size:0.98rem; }
        .conflict-group-heading .date-count { font-size:0.88rem; color:#475569; margin-left:8px }

        /* Status pill */
        .conflict-status { font-size:0.85rem; color:#6b7280; font-weight:500; margin-left:8px; }
        .status-pill { font-size:0.78rem; padding:4px 8px; border-radius:999px; background:#f1f5f9; color:#0f172a; font-weight:600; border:1px solid #e2e8f0 }

        /* Preserved (frozen) settings block */
        .changes-wrap { background:#ffffff; border-radius:8px; padding:12px; border:1px solid #e6eef6; margin:10px 6px 14px 6px; box-shadow: 0 1px 2px rgba(16,24,40,0.03) }
        .changes-title { font-weight:700; margin-bottom:6px; color:#0f172a; font-size:0.95rem }
        .changes-note { font-size:0.86rem; color:#475569; margin-bottom:8px }
        .changes-wrap ul { margin:0; padding-left:16px; }
        .changes-wrap li { margin-bottom:6px; color:#0f172a }
        .changes-wrap li strong { display:inline-block; width:180px; font-weight:600; color:#111827 }
        @media (max-width:640px){ .changes-wrap li strong { width: 120px } }

        /* Individual booking rows */
        .conflict-item { display:block; padding:10px 12px; border-radius:8px; background:#ffffff; border:1px solid #eef3f8; margin-bottom:8px; }
        .conflict-item.empty { text-align:center; color:#6b7280; background:transparent; border:none; box-shadow:none; padding:8px; }
        .conflict-main { display:block; color:#0f172a; }
        .conflict-line { display:flex; justify-content:space-between; gap:12px; align-items:center; font-weight:600; color:#111827; }
        .conflict-meta { font-weight:400; color:#374151; font-size:0.92rem }
        .conflict-client { color:#374151; font-weight:600; margin-left:0; }
        .conflict-email { color:#6b7280; font-weight:400; margin-left:6px; }

        @media (max-width:720px){ .conflict-line{flex-direction:column;align-items:flex-start} }
      </style>
      <div style="text-align:right">
          <button id="svc-conflict-cancel" style="margin-right:8px;padding:8px 12px;border-radius:6px;border:1px solid #cbd5e1;background:#fff;color:#374151">Cancel</button>
          <button id="svc-conflict-confirm" style="padding:8px 14px;border-radius:6px;background:#0ea5e9;color:#fff;border:none">Confirm and apply changes</button>
      </div>
    </div>
  </div>
</template>

<script>
    (function(){
    try{
      const btns = Array.from(document.querySelectorAll('.svc-save-btn'));
      // expose current service fields for modal status labels and changes preview
      try{ window.__svc_current = {
        duration: {{ service.duration|default:0 }},
        buffer_after: {{ service.buffer_after|default:0 }},
        time_increment_minutes: {{ service.time_increment_minutes|default:30 }},
        use_fixed_increment: {{ service.use_fixed_increment|yesno:"true,false" }},
        allow_squished_bookings: {{ service.allow_squished_bookings|yesno:"true,false" }},
        allow_ends_after_availability: {{ service.allow_ends_after_availability|yesno:"true,false" }},
        refunds_allowed: {{ service.refunds_allowed|yesno:"true,false" }},
        refund_cutoff_hours: {{ service.refund_cutoff_hours|default:24 }},
        refund_policy_text: "{{ service.refund_policy_text|escapejs }}",
        price: "{{ service.price }}",
        name: "{{ service.name|escapejs }}",
        description: "{{ service.description|escapejs }}",
        min_notice_hours: {{ service.min_notice_hours|default:1 }},
        max_booking_days: {{ service.max_booking_days|default:30 }},
        is_active: {{ service.is_active|yesno:"true,false" }}
      }; }catch(e){}
    const form = document.querySelector('form.cc-form');
    if (!btns.length || !form) return;

    function getCsrf(){
      const el = form.querySelector('input[name=csrfmiddlewaretoken]');
      return el ? el.value : '';
    }

    async function postJson(url, payload){
      const res = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': getCsrf()
        },
        body: JSON.stringify(payload || {})
      });
      return res.json();
    }

    function serializeFormToPayload(){
      const fd = new FormData(form);
      const out = {};

      // Collect repeated keys (e.g., assigned_members) as arrays.
      for (const [k, v] of fd.entries()){
        if (Object.prototype.hasOwnProperty.call(out, k)){
          if (!Array.isArray(out[k])) out[k] = [out[k]];
          out[k].push(v);
        } else {
          out[k] = v;
        }
      }

      // Normalize known numeric fields (take last value if repeated).
      const numericNames = ['time_increment_minutes', 'duration', 'buffer_after', 'min_notice_hours', 'max_booking_days', 'refund_cutoff_hours'];
      for (const k of numericNames){
        if (!(k in out)) continue;
        const raw = Array.isArray(out[k]) ? out[k][out[k].length - 1] : out[k];
        out[k] = Number(raw);
      }

      // Stabilize arrays for comparison and predictable payloads.
      for (const k of Object.keys(out)){
        if (Array.isArray(out[k])){
          out[k] = out[k].map(x => String(x)).sort();
        }
      }

      const booleanNames = ['use_fixed_increment', 'allow_squished_bookings', 'is_active', 'refunds_allowed', 'allow_ends_after_availability', 'apply_to_conflicts'];
      for (const name of booleanNames){
        try{
          // Prefer the checkbox input (if present) over any hidden fallback input
          let el = form.querySelector(`[name="${name}"][type="checkbox"]`) || form.querySelector(`[name="${name}"]`);
          if (!el) { out[name] = false; }
          else if (el.type === 'checkbox') { out[name] = !!el.checked; }
          else {
            const v = String(el.value || '').toLowerCase();
            out[name] = (v === '1' || v === 'true' || v === 'on');
          }
        } catch (e) {
          out[name] = false;
        }
      }

      return out;
    }

    // Shared detector for whether an item uses fixed increments. Placed at
    // top-level so debug code and node builder both call the same logic.
    function detectUsesFixed(item){
      try{
        if (!item) return false;
        function norm(v){
          if (v === true || v === 1 || v === '1') return true;
          if (v === false || v === 0 || v === '0') return false;
          if (typeof v === 'string'){
            const low = v.trim().toLowerCase();
            if (low === 'true' || low === 'yes' || low === 'y') return true;
            if (low === 'false' || low === 'no' || low === 'n') return false;
            if (!isNaN(Number(low))) return Number(low) !== 0;
          }
          return !!v;
        }

        if (item.use_fixed_increment !== undefined) return !!norm(item.use_fixed_increment);
        if (item.uses_fixed_increment !== undefined) return !!norm(item.uses_fixed_increment);
        if (item.service && item.service.use_fixed_increment !== undefined) return !!norm(item.service.use_fixed_increment);
        if (item.service && item.service.uses_fixed_increment !== undefined) return !!norm(item.service.uses_fixed_increment);
        if (item.snapshot && item.snapshot.use_fixed_increment !== undefined) return !!norm(item.snapshot.use_fixed_increment);
        if (item.snapshot && item.snapshot.uses_fixed_increment !== undefined) return !!norm(item.snapshot.uses_fixed_increment);
        if (item.service_snapshot && item.service_snapshot.use_fixed_increment !== undefined) return !!norm(item.service_snapshot.use_fixed_increment);
        if (item.service_snapshot && item.service_snapshot.uses_fixed_increment !== undefined) return !!norm(item.service_snapshot.uses_fixed_increment);
        return false;
      } catch(e){ return false; }
    }

    function buildConflictNodes(conflicts){
      // Render per-date blocks: heading, frozen-settings (if present), then bookings
      const nodes = [];
      const days = Object.keys(conflicts).sort();

      function ordinalSuffix(n){
        const s = ["th","st","nd","rd"], v = n % 100;
        return (s[(v-20)%10] || s[v] || s[0]);
      }
      function fmtTime(d){ try{ return d.toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit',hour12:true}); }catch(e){ return '' } }
      function fmtDateRangeSingle(startD, endD){
        if (!startD) return '';
        try{
          const weekday = startD.toLocaleDateString('en-US',{weekday:'long'});
          const month = startD.toLocaleDateString('en-US',{month:'long'});
          const day = startD.getDate();
          const year = startD.getFullYear();
          const startT = fmtTime(startD);
          const endT = endD ? fmtTime(endD) : '';
          const dayWithOrd = `${day}${ordinalSuffix(day)}`;
          return `${weekday}, ${month} ${dayWithOrd}, ${year}, at ${startT}${endT ? ' - ' + endT : ''}`;
        }catch(e){ return '' }
      }

      for (const d of days){
        const items = conflicts[d] || [];
        // create date heading
        const heading = document.createElement('div');
        heading.className = 'conflict-group-heading';
        const left = document.createElement('div'); left.textContent = `${(new Date(d)).toLocaleDateString('en-US',{weekday:'long',month:'short',day:'numeric',year:'numeric'})} (${items.length})`;
        heading.appendChild(left);
        nodes.push(heading);

        // If a freeze exists for this date, present its preserved settings
        try{
          const first = items[0];
          const freeze = first && first.existing_freeze ? first.existing_freeze : null;
          if (freeze && typeof freeze === 'object'){
            const wrap = document.createElement('div'); wrap.className = 'changes-wrap';
            const title = document.createElement('div'); title.className = 'changes-title'; title.textContent = 'Preserved (frozen) settings for this date:'; wrap.appendChild(title);
            const note = document.createElement('div'); note.className = 'changes-note'; note.textContent = 'These settings will be kept for the booked date — your new settings will not override them.'; wrap.appendChild(note);
            const list = document.createElement('ul'); list.style.margin = '0'; list.style.paddingLeft = '14px';
            const keys = ['use_fixed_increment','time_increment_minutes','allow_squished_bookings','allow_ends_after_availability','duration','buffer_after'];
            for (const k of keys){
              if (!(k in freeze)) continue;
              const li = document.createElement('li'); li.style.marginBottom = '6px';
              const label = k.replace(/_/g,' ');
              let val = freeze[k];
              if (k === 'use_fixed_increment' || k === 'allow_squished_bookings' || k === 'allow_ends_after_availability'){
                val = (val === true || val === 'true' || val === 1 || val === '1') ? 'Yes' : 'No';
              } else if (k === 'time_increment_minutes'){
                val = (val || 0) + ' minutes';
              } else if (k === 'duration' || k === 'buffer_after'){
                val = (val || 0) + ' minutes';
              }
              const lbl = document.createElement('strong'); lbl.textContent = label + ':';
              const vspan = document.createElement('span'); vspan.style.marginLeft = '8px'; vspan.textContent = val;
              li.appendChild(lbl);
              li.appendChild(vspan);
              list.appendChild(li);
            }
            wrap.appendChild(list);
            nodes.push(wrap);
          }
        }catch(e){}

        // Render each booking row for the date
        for (const it of items){
          const name = it.client_name || '(no name)';
          const email = it.client_email || '';
          const start = it.start ? new Date(it.start) : null;
          let end = it.end ? new Date(it.end) : null;
          if (!end && start){
            let dur = null;
            if (it.duration !== undefined && it.duration !== null) dur = Number(it.duration);
            else if (it.duration_minutes !== undefined && it.duration_minutes !== null) dur = Number(it.duration_minutes);
            if (dur) end = new Date(start.getTime() + (Number(dur) || 0) * 60000);
          }
          const desc = fmtDateRangeSingle(start, end);
          const row = document.createElement('div'); row.className = 'conflict-item';
          const main = document.createElement('div'); main.className = 'conflict-main';
          main.innerHTML = `\n+            <div class="conflict-line">${escapeHtml(desc)}&nbsp;&nbsp;&nbsp;&nbsp;Client: ${escapeHtml(name)}${email ? ' &lt;' + escapeHtml(email) + '&gt;' : ''}</div>\n+          `;
          row.appendChild(main);
          nodes.push(row);
        }
      }

      return nodes;
    }

    // Build a DOM node listing other setting changes between current and proposed
    function buildChangesNode(proposed, current){
      try{
        if (!proposed || !current) return null;
        const keys = [
          'name','description','duration','buffer_after','time_increment_minutes','use_fixed_increment',
          'allow_squished_bookings','allow_ends_after_availability','refunds_allowed','refund_cutoff_hours','refund_policy_text',
          'price','min_notice_hours','max_booking_days','is_active'
        ];
        function normVal(k,v){
          if (k === 'use_fixed_increment' || k === 'allow_squished_bookings' || k === 'allow_ends_after_availability' || k === 'refunds_allowed' || k === 'is_active'){
            if (v === true || v === 'true' || v === 1 || v === '1') return true;
            return false;
          }
          if (k === 'duration' || k === 'buffer_after' || k === 'time_increment_minutes' || k === 'refund_cutoff_hours' || k === 'min_notice_hours' || k === 'max_booking_days'){
            try{ return Number(v) || 0; }catch(e){ return 0; }
          }
          if (k === 'price') return String(v || '');
          return String(v || '');
        }

        const diffs = [];
        for (const k of keys){
          const cur = normVal(k, current[k]);
          const prop = normVal(k, proposed[k]);
          const changed = (typeof cur === 'boolean') ? (cur !== prop) : (String(cur) !== String(prop));
          if (changed) diffs.push({key:k, current:current[k], proposed:proposed[k]});
        }
        if (!diffs.length) return null;

        const wrap = document.createElement('div');
        wrap.style.margin = '8px 6px';
        wrap.style.padding = '10px';
        wrap.style.borderTop = '1px solid #eef2f7';

        const title = document.createElement('div');
        title.style.fontWeight = '700';
        title.style.marginBottom = '8px';
        title.textContent = 'Service setting changes:';
        wrap.appendChild(title);

        const grid = document.createElement('div');
        grid.style.display = 'grid';
        grid.style.gridTemplateColumns = '1fr 1fr';
        grid.style.gap = '12px';

        const curCol = document.createElement('div');
        const curTitle = document.createElement('div'); curTitle.style.fontWeight='600'; curTitle.textContent='Current:'; curCol.appendChild(curTitle);
        const curList = document.createElement('ul'); curList.style.marginTop='6px'; curCol.appendChild(curList);

        const propCol = document.createElement('div');
        const propTitle = document.createElement('div'); propTitle.style.fontWeight='600'; propTitle.textContent='Will be applied:'; propCol.appendChild(propTitle);
        const propList = document.createElement('ul'); propList.style.marginTop='6px'; propCol.appendChild(propList);

        function renderVal(k,v){
          if (k === 'use_fixed_increment' || k === 'allow_squished_bookings' || k === 'allow_ends_after_availability' || k === 'refunds_allowed' || k === 'is_active'){
            return (v === true || v === 'true' || v === 1 || v === '1') ? '✓' : '✕';
          }
          if (k === 'duration') return (v || 0) + ' minutes';
          if (k === 'buffer_after') return (v || 0) + ' minutes';
          if (k === 'price') return (v !== undefined && v !== null) ? '$' + v : '';
          if (k === 'refund_policy_text') return String(v || '—');
          return String(v === undefined || v === null ? '' : v);
        }

        for (const d of diffs){
          const label = document.createElement('li'); label.style.marginBottom='6px'; label.textContent = (d.key.replace(/_/g,' '));
          const label2 = document.createElement('li'); label2.style.marginBottom='6px'; label2.textContent = (d.key.replace(/_/g,' '));
          const curVal = document.createElement('div'); curVal.style.color='#374151'; curVal.style.fontWeight='400'; curVal.textContent = renderVal(d.key, d.current);
          const propVal = document.createElement('div'); propVal.style.color='#374151'; propVal.style.fontWeight='400'; propVal.textContent = renderVal(d.key, d.proposed);
          label.appendChild(curVal);
          label2.appendChild(propVal);
          curList.appendChild(label);
          propList.appendChild(label2);
        }

        grid.appendChild(curCol); grid.appendChild(propCol);
        wrap.appendChild(grid);
        return wrap;
      }catch(e){ return null; }
    }

    // Basic escaping helper used only for small text pieces
    function escapeHtml(s){
      try{ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }catch(e){ return '' }
    }

    function showModal(conflicts, proposedPayload, currentUseFixed, onConfirm){
      const tpl = document.getElementById('svc-conflict-modal-tpl');
      const clone = tpl.content.cloneNode(true);
      const backdrop = clone.querySelector('.cc-modal-backdrop');
      const list = clone.querySelector('#svc-conflict-list');
      // store small context so buildConflictNodes can show applied/will apply labels
      try{ window.__conflict_ctx = { proposedUseFixed: !!(proposedPayload && proposedPayload.use_fixed_increment), currentUseFixed: !!currentUseFixed, proposedPayload: proposedPayload || {} }; }catch(e){}
      // clear and populate with structured rows (one booking per stacked row)
      list.textContent = '';
      const nodes = buildConflictNodes(conflicts || {});
      // Render a settings diff node (only when there are changes)
      try{
        const changesNode = buildChangesNode(window.__conflict_ctx.proposedPayload, window.__svc_current || {});
        if (changesNode) nodes.push(changesNode);
      }catch(e){}
      
      if (!nodes.length){
        const empty = document.createElement('div');
        empty.className = 'conflict-item empty';
        empty.textContent = 'No bookings found.';
        list.appendChild(empty);
      } else {
        for (const n of nodes) list.appendChild(n);
      }
      document.body.appendChild(backdrop);
      backdrop.querySelector('#svc-conflict-cancel').addEventListener('click', function(){ backdrop.remove(); });
      backdrop.querySelector('#svc-conflict-confirm').addEventListener('click', async function(){
        backdrop.remove();
        try {
          await onConfirm();
        } catch (err) {
          console.warn('apply-confirm failed, falling back to form submit', err);
          try { form.submit(); } catch(e){ window.location.reload(); }
        }
      });
    }

    async function onSaveClick(ev){
      try{
        const payload = serializeFormToPayload();
        const previewUrl = window.location.pathname.replace('/edit/', '/preview_update/');
        const applyUrl = window.location.pathname.replace('/edit/', '/apply_update/');

        async function applyAndRedirect(pl) {
          try {
            pl.confirm = true;
            const applied = await postJson(applyUrl, pl);
            if (applied && applied.status === 'ok'){
              const base = window.location.pathname;
              window.location.href = base + '?saved=1';
              return true;
            }
            return false;
          } catch (err) {
            return false;
          }
        }

        const preview = await postJson(previewUrl, payload);
        if (!preview || preview.status !== 'ok'){
          const ok = await applyAndRedirect(payload);
          if (!ok) form.submit();
          return;
        }

        const conflicts = preview.conflicts || {};
        if (Object.keys(conflicts).length === 0){
          const ok = await applyAndRedirect(payload);
          if (!ok) form.submit();
          return;
        }

        showModal(conflicts, payload, window.__svc_current && !!window.__svc_current.use_fixed_increment, async function(){
          const ok = await applyAndRedirect(payload);
          if (!ok) {
            try { form.submit(); } catch(e){ window.location.reload(); }
          }
        });
      } catch (e){
        console.warn('preview failed', e);
        try { form.submit(); } catch (err){ window.location.reload(); }
      }
    }

    for (const b of btns){
      b.addEventListener('click', onSaveClick);
    }
  } catch(e){ console.warn('service preview wiring failed', e); }
})();
  // Add handlers to show a short auto-dismissing toast when View button is clicked without saving
  (function(){
    try {
      function showToast(type, message, timeout=3500){
        try{
          const id = 'cc-toast';
          let el = document.getElementById(id);
          if (!el){
            el = document.createElement('div');
            el.id = id;
            el.style.position = 'fixed';
            el.style.right = '20px';
            el.style.bottom = '20px';
            el.style.zIndex = 2000;
            document.body.appendChild(el);
          }
          const itm = document.createElement('div');
          itm.style.marginTop = '8px';
          itm.style.padding = '10px 14px';
          itm.style.borderRadius = '8px';
          itm.style.color = '#fff';
          itm.style.boxShadow = '0 6px 20px rgba(0,0,0,0.12)';
          itm.style.fontSize = '13px';
          itm.style.maxWidth = '320px';
          itm.style.backdropFilter = 'blur(4px)';
          if (type === 'success') { itm.style.background = '#16a34a'; }
          else if (type === 'warn' || type === 'warning') { itm.style.background = '#f59e0b'; }
          else { itm.style.background = '#374151'; }
          itm.textContent = message;
          el.appendChild(itm);
          setTimeout(()=>{ try{ itm.remove(); if (!el.childElementCount) el.remove(); }catch(e){} }, timeout);
        }catch(e){ try{ alert(message); }catch(_){} }
      }

      function attach(btnId){
        const b = document.getElementById(btnId);
        if (!b) return;
        b.addEventListener('click', function(ev){
          try{
            const saved = b.getAttribute('data-saved') === '1';
            if (!saved){
              ev.preventDefault();
              ev.stopPropagation();
              showToast('warning', 'Please save changes before viewing the public booking page.');
              return false;
            }
            // otherwise allow default (open link)
          }catch(e){ /* ignore */ }
        });
      }

      attach('svc-view-btn');
      attach('svc-view-btn-bottom');

      // Prevent clicks on Save when form is not dirty; show toast like View button.
      // Disabled <button> elements do not fire click events in many browsers, so listen
      // at the document level during capture to reliably intercept attempts.
      function attachSaveGuard(){
        // Listen for pointerdown which fires even when a button is disabled in many browsers.
        document.addEventListener('pointerdown', function(ev){
          try{
            const btn = ev.target && ev.target.closest && ev.target.closest('.svc-save-btn');
            if (!btn) return;
            const disabled = btn.disabled || btn.classList.contains('cursor-not-allowed') || btn.classList.contains('opacity-50');
            if (disabled){
              ev.preventDefault();
              ev.stopPropagation();
              try{ showToast('warning', 'Please make changes before saving.'); } catch(e){ alert('Please make changes before saving.'); }
              return false;
            }
          } catch(e) { /* ignore */ }
        }, true);

        // Also capture Enter/Space key attempts when focused on the button (keyboard users).
        document.addEventListener('keydown', function(ev){
          try{
            const active = document.activeElement;
            if (!active) return;
            if (!active.classList || !active.classList.contains('svc-save-btn')) return;
            if (ev.key === 'Enter' || ev.key === ' '){
              const disabled = active.disabled || active.classList.contains('cursor-not-allowed') || active.classList.contains('opacity-50');
              if (disabled){
                ev.preventDefault();
                ev.stopPropagation();
                try{ showToast('warning', 'Please make changes before saving.'); } catch(e){ alert('Please make changes before saving.'); }
                return false;
              }
            }
          } catch(e) { /* ignore */ }
        }, true);
      }

      attachSaveGuard();
    } catch(e) { console.warn('svc view btn wiring failed', e); }
  })();
</script>
<script>
  // Toggle greying/disabled state of refund cutoff & policy when checkbox toggles
  (function(){
    try{
      const chk = document.getElementById('refunds_allowed');
      const wrapper = document.querySelector('.refund-policy-controls');
      if (!chk || !wrapper) return;
      const inputs = wrapper.querySelectorAll('input, textarea');
      function update(){
        const enabled = !!chk.checked;
        inputs.forEach(i => {
          try{ i.disabled = !enabled; }catch(e){}
        });
        wrapper.classList.toggle('refund-disabled', !enabled);
      }
      chk.addEventListener('change', update);
      // initialize on load
      update();
    }catch(e){ console.warn('refund toggle wiring failed', e); }
  })();
</script>
<style>
.refund-disabled { opacity: 0.72; }
.refund-disabled input, .refund-disabled textarea { opacity: 0.72; }
</style>
<script>
(function(){
  try{
    const form = document.querySelector('form.cc-form');
    if (!form) return;

    const viewBtns = Array.from(document.querySelectorAll('#svc-view-btn, #svc-view-btn-bottom'));
    if (!viewBtns.length) return;

    // Serialize form into a stable JSON string for comparison with saved snapshot
    function serializeForm(){
      const fd = new FormData(form);
      const out = {};

      // Collect repeated keys (e.g., assigned_members) as arrays.
      for (const [k, v] of fd.entries()){
        const el = form.querySelector(`[name="${k}"]`);
        const normalized = (el && el.type === 'checkbox') ? (el.checked ? '1' : '0') : v;

        if (Object.prototype.hasOwnProperty.call(out, k)){
          if (!Array.isArray(out[k])) out[k] = [out[k]];
          out[k].push(normalized);
        } else {
          out[k] = normalized;
        }
      }

      // Stabilize arrays (order-independent).
      for (const k of Object.keys(out)){
        if (Array.isArray(out[k])){
          out[k] = out[k].map(x => String(x)).sort();
        }
      }
      // Ensure known boolean fields are present even if unchecked (not in FormData)
      const booleanNames = ['use_fixed_increment', 'allow_squished_bookings', 'is_active', 'refunds_allowed', 'allow_ends_after_availability', 'apply_to_conflicts'];
      for (const name of booleanNames){
        if (!(name in out)){
          const el = form.querySelector(`[name="${name}"]`);
          if (el && el.type === 'checkbox') out[name] = el.checked ? '1' : '0';
          else if (el) out[name] = el.value;
          else out[name] = '';
        }
      }

      // Sort keys to make stable string
      const keys = Object.keys(out).sort();
      const stable = {};
      for (const k of keys) stable[k] = out[k];
      return JSON.stringify(stable);
    }

    let savedSnapshot = serializeForm();

    function setViewButtonsEnabled(enabled){
      for (const b of viewBtns){
        if (enabled){
          b.classList.remove('opacity-50','cursor-not-allowed');
          b.removeAttribute('aria-disabled');
          b.setAttribute('data-saved', '1');
        } else {
          b.classList.add('opacity-50','cursor-not-allowed');
          b.setAttribute('aria-disabled', 'true');
          b.setAttribute('data-saved', '0');
        }
      }
    }

    function setSaveButtonsEnabled(enabled){
      const saveBtns = Array.from(document.querySelectorAll('.svc-save-btn'));
      for (const s of saveBtns){
        try { s.disabled = !enabled; } catch(e){}
        if (!enabled) {
          s.classList.add('opacity-50','cursor-not-allowed');
        } else {
          s.classList.remove('opacity-50','cursor-not-allowed');
        }
      }
    }

    // Initialize according to whether current form equals saved snapshot
    const isInitiallySaved = (serializeForm() === savedSnapshot);
    setViewButtonsEnabled(isInitiallySaved);
    setSaveButtonsEnabled(!isInitiallySaved);

    // Compare current form to saved snapshot and toggle buttons
    function updateState(){
      try{
        const cur = serializeForm();
        const isSameAsSaved = cur === savedSnapshot;
        setViewButtonsEnabled(isSameAsSaved);
        // Save enabled only when form is dirty
        setSaveButtonsEnabled(!isSameAsSaved);
      } catch (e){ console.warn('svc view compare failed', e); }
    }

    // Add listeners to keep live comparison; debounce to avoid excessive work
    let timer = null;
    function scheduleUpdate(){
      if (timer) clearTimeout(timer);
      timer = setTimeout(()=>{ timer = null; updateState(); }, 120);
    }

    const controls = form.querySelectorAll('input, textarea, select');
    controls.forEach(c => {
      c.addEventListener('input', scheduleUpdate);
      c.addEventListener('change', scheduleUpdate);
    });

    // Also attach delegated listeners on the form so dynamically inserted/updated
    // controls (and some browser edge cases) still trigger dirty-state updates.
    try {
      form.addEventListener('input', scheduleUpdate, true);
      form.addEventListener('change', scheduleUpdate, true);
    } catch (e) { /* ignore */ }

    // Some controls (notably the team member assignment UI) are not native form
    // controls; they add/remove hidden inputs programmatically. Observe DOM changes
    // inside the form so the Save/View buttons still reflect the dirty state.
    try {
      const observer = new MutationObserver(function(mutations){
        try {
          for (const m of mutations){
            if (m.type === 'childList') { scheduleUpdate(); return; }
            if (m.type === 'attributes') { scheduleUpdate(); return; }
          }
        } catch (e) { /* ignore */ }
      });
      observer.observe(form, { subtree: true, childList: true, attributes: true, attributeFilter: ['value', 'checked', 'disabled', 'name'] });
    } catch (e) { /* ignore */ }

    // If a save happens and the page is not reloaded, we can update the savedSnapshot to match current
    // (some code paths redirect; others may update in-place). Listen for successful submit event that
    // results in form submit via existing save button handlers by hooking submit.
    form.addEventListener('submit', function(){
      // update snapshot after short delay to allow any pre-submit handlers to run
      setTimeout(function(){
        try{ savedSnapshot = serializeForm(); setViewButtonsEnabled(true); setSaveButtonsEnabled(false); }catch(e){}
      }, 500);
    });

  } catch (e){ console.warn('svc view btn dirty wiring failed', e); }
})();
</script>
{% endblock %}
