{% extends 'calendar_app/base.html' %}
{% load tz static %}
{% block title %}Calendar{% endblock %}
{% block extra_head %}
<!-- Select2 + FullCalendar (self-hosted to avoid third-party CDN warnings) -->
<meta name="viewport" content="width=device-width, initial-scale=1">

<link href="{% static 'vendor/select2/4.1.0-rc.0/css/select2.min.css' %}" rel="stylesheet" />
<link href="{% static 'vendor/fullcalendar/5.11.3/css/main.min.css' %}" rel="stylesheet" />

<script src="{% static 'vendor/jquery/jquery-3.6.0.min.js' %}"></script>
<script src="{% static 'vendor/select2/4.1.0-rc.0/js/select2.min.js' %}"></script>
<script src="{% static 'vendor/fullcalendar/5.11.3/js/main.min.js' %}"></script>
{% endblock %}

{% block content %}

<div style="margin-bottom:32px;">
    <div style="display:flex; justify-content:center; align-items:center; margin-bottom:12px; flex-direction:column;">
        <div style="text-align:center;">
            <h1 class="calendar-title" style="font-size:32px; font-weight:800; margin:0 0 8px 0; letter-spacing:-0.5px;">Calendar</h1>
            <p style="color:var(--gray-600); font-size:15px; margin:0;">Manage your availability and view bookings</p>
        </div>
        {% if is_team_plan or is_pro_plan %}
            <div id="ccScopeWrap" style="width:min(460px, 92vw); margin-top:12px; text-align:center;">
                <label for="memberSelect" style="display:block;font-size:12px;color:var(--gray-600);margin-bottom:6px;">Showing calendar for</label>
                <!-- Keep a hidden select in the DOM for legacy initialization code that enumerates members. -->
                {% if is_team_plan %}
                <select id="memberSelect" style="display:none" aria-hidden="true">
                    {% for m in members_list %}
                        {% with fname=m.user__first_name lname=m.user__last_name email=m.user__email %}
                            <option value="{{ m.id }}">{% if fname or lname %}{{ fname }} {{ lname }}{% else %}{{ email }}{% endif %}</option>
                        {% endwith %}
                    {% endfor %}
                </select>
                {% else %}
                <select id="memberSelect" style="display:none" aria-hidden="true"></select>
                {% endif %}

                <!-- Scope menu:
                     - Team plan: Members -> Personal Services
                     - Pro plan: Overall availability -> Services -->
                <div id="ccScopeMenuRoot" style="position:relative; display:inline-block; width:100%; text-align:left;">
                    <button id="ccScopeMenuButton" type="button" style="width:100%; padding:10px 12px; border-radius:10px; border:1px solid var(--gray-200); background:white; box-shadow: 0 1px 2px rgba(16,24,40,0.04); font-size:14px; color:var(--gray-900); display:flex; align-items:center; justify-content:space-between; gap:10px;">
                        <span id="ccScopeMenuButtonLabel" style="flex:1; min-width:0; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">{% if is_pro_plan and not is_team_plan %}Overall availability{% else %}Select member{% endif %}</span>
                        <span style="color:var(--gray-600); font-size:16px; line-height:1;">▾</span>
                    </button>

                    <div id="ccScopeMenu" style="display:none; position:absolute; left:0; top:calc(100% + 6px); width:100%; background:white; border:1px solid var(--gray-200); border-radius:12px; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15), 0 4px 10px rgba(0, 0, 0, 0.1); z-index:10001; overflow:hidden;">
                        <div id="ccScopeMenuMembers" style="max-height:280px; overflow:auto;"></div>
                    </div>

                    {% if is_team_plan %}
                    <div id="ccScopeSubmenu" style="display:none; position:absolute; left:100%; top:calc(100% + 6px); width:100%; background:white; border:1px solid var(--gray-200); border-radius:12px; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15), 0 4px 10px rgba(0, 0, 0, 0.1); z-index:10002; overflow:hidden;">
                        <div id="ccScopeSubmenuInner" style="max-height:280px; overflow:auto;"></div>
                    </div>
                    {% endif %}
                </div>

                <!-- Duration/buffer overlap groups (Team is conditional; Pro can be always visible) -->
                <div id="ccSharedSignatureSummary" role="note" aria-live="polite" style="margin-top:10px; padding:10px 12px; border:1px solid var(--gray-200); border-radius:12px; background: rgba(249, 250, 251, 0.95);">
                    <div id="ccSharedSignatureTitle" style="font-weight:800; font-size:13px; color:var(--gray-900); margin-bottom:4px;">Duration/buffer overlap groups</div>
                    <div id="ccSharedSignatureDesc" style="font-size:13px; color:var(--gray-700); line-height:1.35;">
                        Services with the same duration and buffer settings share the same availability group, so their schedules can overlap.
                    </div>
                    <div id="ccSharedSignatureList" style="margin-top:8px; font-size:13px; color:var(--gray-700);"></div>

                    {% if not is_team_plan %}
                        {# Non-Team: keep the simple server-rendered listing #}
                        <script>
                            (function(){
                                try {
                                    const list = document.getElementById('ccSharedSignatureList');
                                    if (!list) return;
                                    const groups = {{ shared_signature_groups|default:'[]'|safe }} || [];
                                    if (!groups.length) {
                                        list.textContent = 'No services share the same duration/buffer settings right now.';
                                        return;
                                    }
                                    for (const g of groups) {
                                        try {
                                            const names = (g || []).map(x => x && x.name ? String(x.name) : 'Service').filter(Boolean);
                                            const row = document.createElement('div');
                                            row.style.marginTop = '4px';
                                            row.textContent = `• ${names.join(', ')}`;
                                            list.appendChild(row);
                                        } catch (e) {}
                                    }
                                } catch (e) {}
                            })();
                        </script>
                    {% endif %}
                </div>

                    <!-- Mobile tweaks: make the "Set Available Time" modal smaller and scale contents down -->
                    <style>
                    @media (max-width: 480px) {
                        /* Shrink the modal card to fit narrow viewports while keeping proportions */
                        #timeModal > div {
                            width: 95vw !important;
                            max-width: 95vw !important;
                            padding: 14px !important;
                            border-radius: 12px !important;
                            box-shadow: 0 14px 20px rgba(0,0,0,0.12) !important;
                            max-height: 86vh !important;
                            overflow: auto !important;
                            -webkit-overflow-scrolling: touch !important;
                            font-size: 0.92rem !important; /* slightly reduce base text size inside modal */
                        }
                        #timeModal h3 { font-size: 18px !important; margin-bottom:8px !important; }
                        #timeModal p { font-size: 13px !important; margin-bottom:12px !important; }
                        /* Reduce padding on action buttons so they fit on one line when possible */
                        #timeModal button {
                            padding: 8px 12px !important;
                            border-radius: 8px !important;
                            font-size: 13px !important;
                        }
                        /* Make inputs and selects a bit smaller and responsive */
                        #timeModal input, #timeModal select {
                            font-size: 13px !important;
                            padding: 6px 8px !important;
                            box-sizing: border-box !important;
                        }
                        /* Tighten ranges container spacing */
                        #modalRangesContainer { gap:6px !important; margin-top:8px !important; }
                        #addModalRangeBtn { padding:6px 10px !important; font-size:13px !important; }

                        /* Ensure modal range rows shrink correctly and inputs do not overflow */
                        #timeModal .modal-range-row { gap:6px !important; justify-content:flex-start !important; align-items:center !important; }
                        #timeModal .modal-range-row label { min-width: 40px !important; width: auto !important; font-size:11px !important; text-align:right !important; white-space:nowrap !important; }
                        /* Give more horizontal room to time inputs while keeping them responsive */
                        #timeModal .modal-range-row .time-input-container { flex: 1 1 0 !important; min-width: 0 !important; }
                        #timeModal .modal-range-row input[type="time"],
                        #timeModal .modal-range-row .modal-range-start,
                        #timeModal .modal-range-row .modal-range-end {
                            width: 100% !important;
                            max-width: none !important;
                            padding: 4px 6px !important;
                            font-size: 14px !important;
                            line-height: 20px !important;
                            box-sizing: border-box !important;
                            text-align: center !important;
                        }
                        /* Make the remove and action buttons smaller to save space */
                        #timeModal .modal-range-row button,
                        #timeModal button {
                            padding:6px 8px !important;
                            font-size:11px !important;
                            border-radius:8px !important;
                        }
                        /* Ensure the remove button doesn't push inputs off-screen */
                        #timeModal .modal-range-row button.remove-range-btn, #timeModal .modal-range-row > button {
                            flex: 0 0 auto !important;
                            margin-left: 8px !important;
                        }

                        /* Mobile-only: make modal remove control a compact X button */
                        #timeModal .modal-range-row .remove-range-btn {
                            width: 32px !important;
                            height: 32px !important;
                            padding: 0 !important;
                            display: inline-flex !important;
                            align-items: center !important;
                            justify-content: center !important;
                            gap: 0 !important;
                        }
                        #timeModal .modal-range-row .remove-range-btn .remove-text { display: none !important; }
                        #timeModal .modal-range-row .remove-range-btn .remove-icon { font-size: 16px !important; line-height: 1 !important; }
                        /* Tweak webkit datetime fields to match smaller font/line-height */
                        #timeModal input[type="time"]::-webkit-datetime-edit-hour-field,
                        #timeModal input[type="time"]::-webkit-datetime-edit-minute-field,
                        #timeModal input[type="time"]::-webkit-datetime-edit-text {
                            font-size: 12px !important;
                            line-height: 20px !important;
                        }
                    }
                    </style>

                    <!-- Additional mobile fix: ensure time input values are not clipped (line-height/appearance) -->
                    <style>
                    @media (max-width:480px) {
                        #timeModal input[type="time"] {
                            height: 36px !important;
                            line-height: 36px !important;
                            font-size: 14px !important;
                            color: var(--gray-900) !important;
                            padding: 6px 8px !important;
                            box-sizing: border-box !important;
                            -webkit-appearance: none !important;
                            appearance: none !important;
                            text-align: center !important;
                            overflow: visible !important;
                        }
                        /* WebKit internal fields for time inputs */
                        #timeModal input[type="time"]::-webkit-datetime-edit,
                        #timeModal input[type="time"]::-webkit-datetime-edit-fields-wrapper,
                        #timeModal input[type="time"]::-webkit-datetime-edit-hour-field,
                        #timeModal input[type="time"]::-webkit-datetime-edit-minute-field,
                        #timeModal input[type="time"]::-webkit-datetime-edit-text {
                            color: var(--gray-900) !important;
                            font-size: 14px !important;
                            line-height: 36px !important;
                            padding: 0 !important;
                        }
                    }
                    </style>

                <style>
                /* Mobile: make the scope submenu open beneath the menu (full-width)
                   instead of off to the right where it can overflow the viewport. */
                @media (max-width: 480px) {
                    #ccScopeMenu, #ccScopeSubmenu {
                        left: 0 !important;
                        right: auto !important;
                        top: calc(100% + 6px) !important;
                        width: 100% !important;
                        box-shadow: 0 8px 20px rgba(0,0,0,0.12) !important;
                        border-radius: 10px !important;
                        position: absolute !important;
                        transform: none !important;
                    }
                    /* Ensure inner scroll areas fit the mobile viewport comfortably */
                    #ccScopeSubmenuInner, #ccScopeMenuMembers { max-height: 320px !important; overflow:auto !important; }
                }
                </style>

                <div style="margin-top:6px; display:flex; justify-content:center;">
                    <span id="memberScopeBadge" style="font-size:12px;color:var(--gray-600);padding:6px 10px;border-radius:999px;border:1px solid var(--gray-200);background:transparent;">{% if is_pro_plan and not is_team_plan %}Showing overall availability{% else %}Showing org defaults{% endif %}</span>
                </div>

                <style>
                    /* Mobile: center scope dropdown + overlap box, 95% width */
                    @media (max-width: 768px) {
                        #ccScopeWrap { width: 100% !important; }
                        #ccScopeMenuRoot,
                        #ccSharedSignatureSummary {
                            width: 95% !important;
                            margin-left: auto !important;
                            margin-right: auto !important;
                        }
                    }
                </style>
            </div>
        {% endif %}
    </div>
        <!-- Inline Audit Modal -->
        <div id="inlineAuditModal" style="display:none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); justify-content: center; align-items: center; z-index: 10000; padding: 20px;">
            <div style="background: white; padding: 18px; border-radius: 10px; max-width: 640px; width: 100%;">
                <button onclick="closeInlineAudit()" style="position: absolute; right: 18px; top: 14px; border: none; background: none; font-size: 22px; cursor: pointer;">×</button>
                <h4 style="margin:0 0 10px 0;">Audit Details</h4>
                <div id="inlineAuditContent" style="white-space:pre-wrap; background:#f8f9fa; padding:12px; border-radius:6px; max-height:60vh; overflow:auto;"></div>
                <div style="display:flex; justify-content:flex-end; margin-top:12px;"><button onclick="closeInlineAudit()" style="padding:8px 12px; background:#6c757d; color:white; border:none; border-radius:6px;">Close</button></div>
            </div>
        </div>
  </div>
</div>
<script>
// Wire bookings visible-rows select for calendar page after DOM is ready
document.addEventListener('DOMContentLoaded', function(){
    const key = 'cc_bookings_visible_rows';
    const sel = document.getElementById('bookingsVisibleRowsSelect');
    const customInput = document.getElementById('bookingsVisibleRowsCustomInput');
    const container = document.getElementById('bookingsInlineSection');
    const scrollWrapper = document.getElementById('bookingsScrollWrapper');
    const auditWrapper = container ? container.querySelector('.inline-audit-wrapper') : null;

    function apply(v){
        try{
            const defaultVal = Number(getComputedStyle(container || document.documentElement).getPropertyValue('--bookings-visible-default')) || 10;
            if (!scrollWrapper) return;
            if (v === 'all'){
                scrollWrapper.classList.add('cc-visible-all');
                if (auditWrapper) auditWrapper.classList.add('cc-visible-all');
                scrollWrapper.style.removeProperty('--bookings-visible-rows');
            } else {
                scrollWrapper.classList.remove('cc-visible-all');
                if (auditWrapper) auditWrapper.classList.remove('cc-visible-all');
                const n = Number(v) || defaultVal;
                scrollWrapper.style.setProperty('--bookings-visible-rows', String(n));
                if (auditWrapper) auditWrapper.style.setProperty('--bookings-visible-rows', String(n));
            }
            if (sel) sel.value = String(v);
            if (customInput){
                if (sel && sel.value === 'custom'){ customInput.style.display = 'inline-block'; customInput.focus(); } else { customInput.style.display = 'none'; }
            }
        }catch(e){ console.error(e); }
    }

    function setAndStore(v){ try{ window.localStorage.setItem(key, String(v)); }catch(e){} apply(v); }

    try{
        const stored = window.localStorage.getItem(key);
        if (stored) apply(stored); else apply(sel ? sel.value : String(Number(getComputedStyle(container || document.documentElement).getPropertyValue('--bookings-visible-default')) || 10));
    }catch(e){ apply(sel ? sel.value : '10'); }

    if (sel){
        sel.addEventListener('change', function(){
            const v = this.value;
            if (v === 'custom'){
                if (customInput){ customInput.style.display = 'inline-block'; customInput.focus(); }
                return;
            }
            setAndStore(v);
        });
    }

    if (customInput){
        customInput.addEventListener('change', function(){
            const n = Math.max(1, Number(this.value) || 10);
            setAndStore(String(n));
                if (sel) sel.value = 'custom';
        });
        customInput.addEventListener('keyup', function(e){ if (e.key === 'Enter') this.dispatchEvent(new Event('change')); });
    }
});
</script>

<!-- Assets moved to extra_head -->

<style>
/* Modern color palette */
:root {
    --primary-500: #3b82f6;
    --primary-600: #2563eb;
    --primary-700: #1d4ed8;
    --success-500: #10b981;
    --success-600: #059669;
    --danger-500: #ef4444;
    --danger-600: #dc2626;
    --gray-50: #f9fafb;
    --gray-100: #f3f4f6;
    --gray-200: #e5e7eb;
    --gray-300: #d1d5db;
    --gray-600: #4b5563;
    --gray-700: #374151;
    --gray-900: #111827;
    --cc-wave-duration: 14s;
    --cc-page-gutter: 16px; /* default page gutter for consistent side padding */
    --cc-inner-max: 1180px;
}

/* Calendar base styling with modern card design */
#calendar {
    width: 100%;
    margin: auto;
    height: auto;
    border: none !important;
    background-color: white;
    padding: 24px;
    border-radius: 16px;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
}

/* Calendar loading overlay (service-scope parity) */
#calendar.cc-calendar-loading .fc {
    opacity: 0.45;
    filter: grayscale(1);
    pointer-events: none;
}
#calendar .cc-calendar-loading-overlay {
    position: absolute;
    inset: 0;
    display: none;
    z-index: 120;
    background: rgba(255, 255, 255, 0.72);
    backdrop-filter: blur(2px);
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: 10px;
    text-align: center;
    pointer-events: auto;
}
#calendar.cc-calendar-loading .cc-calendar-loading-overlay {
    display: flex;
}
.cc-calendar-spinner {
    width: 40px;
    height: 40px;
    border-radius: 999px;
    border: 4px solid var(--gray-200);
    border-top-color: var(--primary-500);
    animation: cc-calendar-spin 0.8s linear infinite;
}
@keyframes cc-calendar-spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}
.cc-calendar-loading-text {
    color: var(--gray-700);
    font-weight: 600;
    font-size: 14px;
}

/* Calendar disabled overlay (service scope: no remaining availability) */
#calendar.cc-svc-no-availability .fc-view-harness {
    opacity: 0.55;
    pointer-events: none;
}
#calendar.cc-svc-no-availability .cc-svc-no-availability-overlay {
    display: flex;
}
.cc-svc-no-availability-overlay {
    display: none;
    position: absolute;
    left: 0;
    right: 0;
    /* Leave space for the FullCalendar header toolbar */
    top: 72px;
    bottom: 0;
    z-index: 10050;
    pointer-events: auto;
    align-items: center;
    justify-content: center;
    background: rgba(255, 255, 255, 0.72);
    backdrop-filter: blur(2px);
}
.cc-svc-no-availability-overlay .panel {
    max-width: 520px;
    width: calc(100% - 28px);
    background: rgba(255,255,255,0.96);
    border: 1px solid rgba(226,232,240,0.9);
    border-radius: 14px;
    padding: 14px 14px;
    box-shadow: 0 18px 35px rgba(15, 23, 42, 0.18);
    color: var(--gray-900);
}
.cc-svc-no-availability-overlay .title {
    font-weight: 800;
    font-size: 14px;
}
.cc-svc-no-availability-overlay .body {
    margin-top: 6px;
    font-size: 13px;
    line-height: 1.35;
    color: var(--gray-700);
}
.cc-svc-no-availability-overlay .actions {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    margin-top: 12px;
}
.cc-svc-no-availability-overlay .btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 9px 12px;
    border-radius: 10px;
    font-weight: 700;
    font-size: 13px;
    cursor: pointer;
    border: 1px solid rgba(59,130,246,0.25);
    background: rgba(59,130,246,0.08);
    color: var(--primary-700);
}
.cc-svc-no-availability-overlay .btn.secondary {
    border: 1px solid rgba(148,163,184,0.35);
    background: rgba(148,163,184,0.10);
    color: var(--gray-800);
}

#calendar-controls.cc-disabled {
    opacity: 0.55;
    pointer-events: none;
}

/* Improved member/service select styling */
#memberSelect {
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    background: white url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="%23343a40" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"/></svg>') no-repeat right 10px center/12px 12px;
    padding: 10px 36px 10px 12px;
    border-radius: 10px;
    border: 1px solid var(--gray-200);
    box-shadow: 0 1px 2px rgba(16,24,40,0.04);
    font-size: 14px;
    color: var(--gray-900);
}

#memberSelect option {
    padding: 6px 8px;
}

#memberSelect.optgroup-service {
    font-weight: 600;
}

/* Remove all calendar borders/grid lines */
.fc-scrollgrid { border-color: transparent !important; }
.fc-scrollgrid td:last-of-type { border-right-color: transparent !important; }
.fc-scrollgrid-section.fc-scrollgrid-section-body td[role='presentation'] { border-bottom-color: transparent !important; }
[role='row']:last-of-type td { border-bottom-color: transparent !important; }
th[role='presentation'] { border-right-color: transparent !important; }
.fc { border: none !important; }
.fc .fc-daygrid-day,
.fc .fc-daygrid-body,
.fc .fc-scrollgrid,
.fc .fc-col-header-cell,
.fc .fc-daygrid-day-frame { border: none !important; }

/* Hide extra frame cells that appear below the last week */
.fc-daygrid-day-frame {
    background: transparent !important;
}

/* Hide day cells that are outside the current month */
.fc-day-other {
    display: none !important;
}

/* Ensure grid sections have no grey background */
.fc .fc-daygrid-body,
.fc .fc-scrollgrid-section-body,
.fc .fc-scrollgrid {
    background: transparent !important;
}

/* Push calendar grid down while keeping header/title at top */
.fc .fc-view-harness { margin-top: 100px; }

/* Day number circle */
.fc-daygrid-day-frame {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
}

/* Top border color wave for section cards */
.section-card, .cc-page > .section-card, .border.rounded-lg, .section-card .section-title {
    position: relative;
}
.section-card::before, .border.rounded-lg::before {
    content: '';
    display: block;
    position: absolute;
    left: 0;
    right: 0;
    top: -6px;
    height: 6px;
    border-top-left-radius: 12px;
    border-top-right-radius: 12px;
    /* Use the canonical per-date overrides gradient */
    background: linear-gradient(to right, var(--primary-500), var(--success-500), var(--danger-500));
    background-size: 400% 100%;
    /* smooth oscillation using multi-stop keyframes (no alternate) */
    animation: cc-wave var(--cc-wave-duration, 14s) ease-in-out infinite;
    animation-delay: var(--cc-wave-offset, 0s);
    z-index: 0;
}
@keyframes cc-wave {
    0% { background-position: 0% 50%; }
    25% { background-position: 50% 50%; }
    50% { background-position: 100% 50%; }
    75% { background-position: 50% 50%; }
    100% { background-position: 0% 50%; }
}

/* Apply animated top-border gradient to main sections at all screen sizes */
/* Make top gradient part of each container's rounded top by clipping
   the pseudo-element to the container and using the container's radius. */
#defaultAvailabilityContainer,
#bookingsInlineSection,
#calendar,
#timeModal,
#timeCirclesModal {
    position: relative;
    overflow: hidden; /* clip the ::before gradient to container border-radius */
}

#defaultAvailabilityContainer::before,
#bookingsInlineSection::before,
#calendar::before,
#timeModal::before,
#timeCirclesModal::before {
    content: '';
    display: block;
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    height: 6px;
    /* inherit the container's top border radius so the gradient visually
       appears as part of the container (prevents the 'hat' effect). */
    border-top-left-radius: inherit;
    border-top-right-radius: inherit;
    background: linear-gradient(to right, var(--primary-500), var(--success-500), var(--danger-500));
    background-size: 400% 100%;
    animation: cc-wave var(--cc-wave-duration, 14s) ease-in-out infinite;
    animation-delay: var(--cc-wave-offset, 0s);
    z-index: 0;
    pointer-events: none;
}

/* Mobile-friendly adjustments */
@media (max-width: 768px) {
        --cc-page-gutter: 16px; 
        Default Weekly Availability keeps desktop baseline styles */
    #bookingsInlineSection,
    #calendar,
    #timeModal,
    #timeCirclesModal {
        position: relative; /* ensure pseudo-element positions relative to container */
    }

    /* Place the gradient inside the container (top:0) so it's not clipped on desktop.
       Use a CSS var for animation-delay so we can sync multiple elements from JS. */
    #bookingsInlineSection::before,
    #calendar::before,
    #timeModal::before,
    #timeCirclesModal::before {
        content: '';
        display: block;
        position: absolute;
        right: 0;
        top: 0; /* inside the container to avoid being clipped by overflow */
        height: 6px;
        border-top-left-radius: 12px;
        border-top-right-radius: 12px;
            background: linear-gradient(to right, var(--primary-500), var(--success-500), var(--danger-500));
            background-size: 400% 100%;
            animation: cc-wave var(--cc-wave-duration, 14s) ease-in-out infinite;
            /* allow external sync via --cc-wave-offset */
            animation-delay: var(--cc-wave-offset, 0s);
        z-index: 0;
        pointer-events: none;
    }
    #calendar { padding: 12px; }
    .fc .fc-view-harness { margin-top: 80px; }
    /* Slightly smaller day circles on mobile to fit narrow columns */
    .fc-daygrid-day-number { width: 36px; height: 36px; font-size: 14px !important; }
    /* Ensure past / unavailable / today variants honor mobile sizing */
    .fc-daygrid-day-number.past-day,
    .fc-daygrid-day-number.unavailable-number,
    .fc .fc-day-today .fc-daygrid-day-number {
        width: 36px !important;
        height: 36px !important;
        line-height: 36px !important;
        font-size: 14px !important;
    }
    /* Nav buttons: enforce square buttons and center icon */
    .fc .fc-prev-button, .fc .fc-next-button {
        width: 40px;
        height: 40px;
        padding: 0;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border-radius: 8px;
        box-sizing: border-box;
    }
    /* Reset button line-height to avoid baseline offset (don't zero font-size) */
    .fc .fc-button { line-height: 0; }
    .fc .fc-button svg, .fc .fc-button .fc-icon { width: 14px; height: 14px; display: block; margin: 0; transform: none; }
    /* Ensure any inner wrapper/span fills the button and centers its contents */
    .fc .fc-prev-button > *,
    .fc .fc-next-button > *,
    .fc .fc-prev-button > .fc-icon, .fc .fc-next-button > .fc-icon,
    .fc .fc-prev-button svg, .fc .fc-next-button svg {
        width: 100%;
        height: 100%;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        margin: 0 !important;
        padding: 0 !important;
    }
    .time-circle { width: 56px !important; height: 56px !important; font-size: 12px !important; }
}
.fc-daygrid-day-number {
    position: absolute;
    margin-top: 100%;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: flex;
    align-items: center;
    justify-content: center;
    width: 50px;
    height: 50px;
    font-size: 1.5rem;
    border-radius: 50% !important;
    font-weight: 600;
    transition: transform 0.2s ease, background-color 0.2s ease;
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
}

/* Ensure time-circle elements remain circular */
.time-circle { border-radius: 50% !important; overflow: visible; }

/* Pointer for available day numbers */
.fc-day-available .fc-daygrid-day-number { cursor: pointer !important; }
.fc-day-unavailable .fc-daygrid-day-number { cursor: pointer !important; }

/* Available day number - modern gradient */
.fc-day-available .fc-daygrid-day-number {
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(37, 99, 235, 0.15));
    border: 2px solid var(--primary-500);
    color: var(--primary-600);
    box-shadow: 0 2px 4px rgba(59, 130, 246, 0.1);
}

/* Hover effect - enhanced */
.fc-day-available .fc-daygrid-day-number:hover {
    transform: translate(-50%, -50%) scale(1.15);
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(37, 99, 235, 0.25));
    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
}

/* Selected day number - vibrant */
.fc-daygrid-day-number.selected {
    background: linear-gradient(135deg, var(--primary-500), var(--primary-600));
    color: white;
    transform: translate(-50%, -50%) scale(1.25);
    box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4);
    border-color: var(--primary-700);
}

/* Mobile Safari can leave :hover “stuck” after a tap. Make selected available days always win. */
.fc-day-available .fc-daygrid-day-number.selected,
.fc-day-available .fc-daygrid-day-number.selected:hover {
    background: linear-gradient(135deg, var(--primary-500), var(--primary-600)) !important;
    color: white !important;
    border-color: var(--primary-700) !important;
    box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4) !important;
}

/* Prevent frame highlighting */
  .fc-daygrid-day.fc-day-available {
      background: transparent !important;
  }

    /* Hover effect */
  .fc-daygrid-day-number:hover {
      transform: translate(-50%, -50%) scale(1.2);
  }

  /* Temporary highlight during drag - available days */
.fc-day-available .fc-daygrid-day-number.temp-highlight {
    background-color: rgba(0, 123, 255, 0.5);
    color: white;
    transform: translate(-50%, -50%) scale(1.3);
}

/* Temporary highlight during drag - unavailable days */
    .fc-day-unavailable .fc-daygrid-day-number.temp-highlight {
        background: linear-gradient(135deg, rgba(45, 45, 45, 0.8), rgba(26, 26, 26, 0.9));
        color: white;
        transform: translate(-50%, -50%) scale(1.3);
        border-color: #000000;
}

/* Removed: centralized mobile rules for availability UI — will be replaced with scoped media below */
/* (rules targeting .availability-ui removed) */


/* Current day styling - highlighted */
.fc-day-today { background-color: transparent !important; }
.fc .fc-day-today .fc-daygrid-day-number {
    background: linear-gradient(135deg, var(--primary-500), var(--primary-600));
    color: white;
    font-weight: bold;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    line-height: 28px;
    text-align: center;
    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.35);
    animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
    0%, 100% { box-shadow: 0 4px 12px rgba(59, 130, 246, 0.35); }
    50% { box-shadow: 0 6px 16px rgba(59, 130, 246, 0.5); }
}

/* Modern calendar buttons */
#calendar-controls {
    display: flex;
    justify-content: center;
    gap: 12px;
    margin-bottom: 20px;
    background: linear-gradient(to bottom, rgba(255,255,255,0.95), rgba(255,255,255,0.9));
    backdrop-filter: blur(8px);
    padding: 16px;
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.08), 0 0 1px rgba(0,0,0,0.05);
}
.calendar-btn {
    background-color: var(--primary-500);
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
.calendar-btn:hover { 
    background-color: var(--primary-600); 
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
}
.calendar-btn:active { transform: translateY(0); }
.calendar-btn:disabled { 
    background-color: var(--gray-300); 
    cursor: not-allowed; 
    transform: none;
    box-shadow: none;
}

/* Nav button shared style (kept minimal since inline styles are applied) */
#topNav .nav-btn:hover { 
    transform: translateY(-1px);
    background: var(--primary-600);
}
#topNav .nav-btn:active { transform: translateY(0); }

.fc-daygrid-day-number.selected::after,
.fc-daygrid-day-number.temp-highlight::after {
    content: none !important; /* removes any text overlay */
}
.fc-daygrid-event {
  display: none !important;  /* hides event text labels from calendar cells */
}
#timeModal, #bookingModal {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.6);
  backdrop-filter: blur(4px);
  justify-content: center;
  align-items: center;
  z-index: 9999;
  animation: fadeIn 0.2s ease-out;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes modalSlideUp {
  from { 
    opacity: 0;
    transform: translateY(20px);
  }
  to { 
    opacity: 1;
    transform: translateY(0);
  }
}

/* Button hover effects */
button:not(:disabled):hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.15) !important;
}
button:not(:disabled):active {
  transform: translateY(0);
}
#timeCirclesContainer > div {
  border-bottom: 1px solid #ccc;  
  padding-bottom: 40px;

}

#timeCirclesContainer > div:first-child {
  padding-top: 20px;
}

/* Remove line from the last row */
#timeCirclesContainer > div:last-child {
  border-bottom: none;
}

.fc-daygrid-day-number.selected.past-day {
    background-color: #ccc !important; /* grey circle for real past-day + selected */
    color: #fff !important;
    border: 2px solid #999 !important;
    
}

.fc-daygrid-day-number.past-day {
    /* show a circular outline for past days rather than a filled block */
    background-color: #7d7d7d28 !important;
    color: #4f4b4bff !important; /* muted text color */
    font-weight: 600;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    line-height: 46px;
    text-align: center;
    border: 2px solid #dcdcdc; /* subtle circle outline */
}

/* Unavailable day number (distinct from past-day) */
.fc-daygrid-day-number.unavailable-number {
    /* Grey circular outline for unavailable future days, number stays visible */
    background-color: #69696990 !important;
    color: #393535ff !important; /* visible but muted */
    font-weight: 600;
    border: 2px solid #454545ff;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    line-height: 46px;
    text-align: center;
}

/* Selected unavailable day - dark grey/black with white numbers */
.fc-daygrid-day-number.unavailable-number.selected {
    background: linear-gradient(135deg, #2d2d2d, #1a1a1a) !important;
    color: white !important;
    border-color: #000000 !important;
    transform: translate(-50%, -50%) scale(1.25) !important;
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.5) !important;
}

/* When an unavailable day is selected via fc-day-unavailable class */
.fc-day-unavailable .fc-daygrid-day-number.selected {
    background: linear-gradient(135deg, #2d2d2d, #1a1a1a) !important;
    color: white !important;
    transform: translate(-50%, -50%) scale(1.25) !important;
    border: 2px solid #000000 !important;
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.5) !important;
}

/* Overrides header styling */
.overrides-header { text-align:center; margin:0 0 10px; }
.overrides-base { font-weight:500; }
.overrides-month { font-weight:700; font-size:1.25em; }

/* Modern select and input styling */
select, input[type="time"], input[type="number"] {
    padding: 6px 10px;
    border: 2px solid var(--gray-300);
    border-radius: 6px;
    font-size: 13px;
    color: var(--gray-900);
    background: white;
    transition: all 0.2s ease;
    outline: none;
}

select:focus, input[type="time"]:focus, input[type="number"]:focus {
  border-color: var(--primary-500);
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

select:hover, input[type="time"]:hover, input[type="number"]:hover {
  border-color: var(--gray-400);
}

/* Time input wrapper for relative positioning */
.time-input-container {
  position: relative;
  display: inline-block;
}


/* Range row layout adjustments to prevent action buttons overlapping inputs on small screens */
.range-row {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: nowrap;
}
.range-row .time-input-container {
    flex: 0 0 auto;
    min-width: 0; /* allow mobile overrides to control width; avoid forcing large widths on desktop */
}
.range-start, .range-end, .modal-range-start, .modal-range-end {
    text-align: center;
    padding: 6px 8px;
    border-radius: 8px;
    border: 1px solid var(--gray-300);
    background: white;
    font-weight: 600;
    min-width: 0; /* allow responsive rules to set exact widths per breakpoint */
}
.remove-range-btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 3px 6px;
    border: none;
    background: #dc3545;
    color: white;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 600;
    font-size: 12px;
}
.remove-range-btn .remove-icon { font-size: 14px; line-height: 1; }
    .remove-range-btn .remove-text { display: none; }
/* Position the unavailable checkbox slightly lower and to the right
   so it visually aligns near the remove button across all devices. */
.unavailable-checkbox {
    position: relative;
    top: 6px; /* move down */
    left: 6px; /* move right */
    width: 18px;
    height: 18px;
}
.add-range-btn {
    padding: 6px 10px !important;
    background: #007bff !important;
    color: white !important;
    border: none !important;
    border-radius: 6px !important;
    cursor: pointer !important;
    font-weight: 600;
    font-size: 13px;
}

/* When a day is marked unavailable, Add range becomes disabled. Make it look disabled. */
.add-range-btn:disabled {
    opacity: 0.45;
    cursor: not-allowed !important;
    filter: grayscale(1);
}

/* Removed mobile @media rules that targeted availability-specific classes so
   Default Weekly Availability keeps desktop baseline styles. */


/* Custom Time Picker Dropdown */
.custom-time-picker {
  position: absolute;
  top: calc(100% + 5px);
  left: 0;
  background: white;
  border: 1px solid var(--gray-300);
  border-radius: 12px;
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15), 0 4px 10px rgba(0, 0, 0, 0.1);
  z-index: 1000;
  padding: 16px;
  min-width: 280px;
  display: none;
  animation: slideDown 0.2s ease-out;
}

@keyframes slideDown {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.custom-time-picker.active {
  display: block;
}

/* Center the custom time picker on small screens for better UX */
@media (max-width: 480px) {
    .custom-time-picker {
        position: fixed !important;
        left: 50% !important;
        top: 50% !important;
        transform: translate(-50%, -50%) !important;
        width: calc(100% - 32px) !important;
        max-width: 420px !important;
        min-width: auto !important;
        padding: 12px !important;
        z-index: 20000 !important;
        box-shadow: 0 16px 35px rgba(0,0,0,0.25) !important;
    }
}

.time-picker-header {
  font-size: 13px;
  font-weight: 600;
  color: var(--gray-700);
  margin-bottom: 12px;
  text-align: center;
}

.time-picker-display {
  font-size: 32px;
  font-weight: 700;
  text-align: center;
  color: var(--primary-600);
  margin-bottom: 16px;
  font-variant-numeric: tabular-nums;
  letter-spacing: 0.05em;
}

.time-picker-selectors {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
}

.time-selector {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.time-selector-label {
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  color: var(--gray-600);
  text-align: center;
  letter-spacing: 0.5px;
}

.time-scroll-container {
  height: 180px;
  overflow-y: auto;
  border: 1px solid var(--gray-200);
  border-radius: 8px;
  background: var(--gray-50);
  padding: 4px;
}

.time-scroll-container::-webkit-scrollbar {
  width: 6px;
}

.time-scroll-container::-webkit-scrollbar-track {
  background: transparent;
}

.time-scroll-container::-webkit-scrollbar-thumb {
  background: var(--gray-300);
  border-radius: 3px;
}

.time-option {
  padding: 10px;
  text-align: center;
  cursor: pointer;
  border-radius: 6px;
  font-size: 15px;
  font-weight: 500;
  transition: all 0.15s ease;
  color: var(--gray-700);
}

.time-option:hover {
  background: white;
  color: var(--primary-600);
}

.time-option.selected {
  background: var(--primary-500);
  color: white;
  font-weight: 600;
}

.time-option.disabled {
    opacity: 0.35;
    filter: grayscale(1);
    cursor: not-allowed;
    pointer-events: none;
}

.time-picker-actions {
  display: flex;
  gap: 8px;
  margin-top: 12px;
}

.time-picker-btn {
  flex: 1;
  padding: 10px;
  border: none;
  border-radius: 8px;
  font-weight: 600;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.15s ease;
}

.time-picker-btn.confirm {
  background: var(--primary-500);
  color: white;
}

.time-picker-btn.confirm:hover {
  background: var(--primary-600);
  transform: translateY(-1px);
  box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
}

.time-picker-btn.cancel {
  background: var(--gray-200);
  color: var(--gray-700);
}

.time-picker-btn.cancel:hover {
  background: var(--gray-300);
}

/* Keep default browser scrollbars for the main page.
     Note: We still style only the time picker scrollers via .time-scroll-container::-webkit-scrollbar above. */

/* Improved table row hover */
#overridesTable tbody tr:hover {
  background: var(--gray-50);
  transition: background 0.15s ease;
}

#defaultAvailabilityTable tr:hover {
  background: var(--gray-50);
  transition: background 0.15s ease;
}

/* Weekly editor constraint bar (service scope) */
.cc-constraints-wrap {
    display: none;
    margin-top: 8px;
    padding-top: 6px;
    border-top: 1px dashed var(--gray-200);
}
.cc-constraints-bar {
    position: relative;
    height: 10px;
    border-radius: 999px;
    border: 1px solid rgba(148, 163, 184, 0.7); /* slate-400 */
    background: rgba(241, 245, 249, 0.98);      /* slate-50 */
    overflow: hidden;
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.8);
}
.cc-constraints-bar:hover {
    border-color: rgba(59, 130, 246, 0.55);
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.12), inset 0 1px 0 rgba(255,255,255,0.85);
}
.cc-constraints-seg {
    position: absolute;
    top: 0;
    height: 100%;
}
.cc-constraints-seg .cc-constraints-label {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    font-weight: 800;
    letter-spacing: 0.3px;
    text-transform: uppercase;
    white-space: nowrap;
    pointer-events: none;
    user-select: none;
    opacity: 0.95;
}
.cc-constraints-seg.member .cc-constraints-label {
    color: rgba(17, 24, 39, 0.88);
    text-shadow: 0 1px 0 rgba(255,255,255,0.65);
}
.cc-constraints-seg.other .cc-constraints-label {
    color: rgba(255,255,255,0.98);
    text-shadow: 0 1px 1px rgba(0,0,0,0.25);
}
.cc-constraints-seg.member {
    /* Outside member availability (warm/attention but not "error") */
    background: rgba(245, 158, 11, 0.62); /* amber-500 */
    box-shadow: inset 0 0 0 1px rgba(180, 83, 9, 0.25);
}
.cc-constraints-seg.other {
    /* Reserved by other services (cool + striped for color-blind clarity) */
    background: rgba(59, 130, 246, 0.82); /* CircleCal blue (primary-500) */
    background-image: repeating-linear-gradient(
        45deg,
        rgba(255,255,255,0.25) 0px,
        rgba(255,255,255,0.25) 6px,
        rgba(255,255,255,0.00) 6px,
        rgba(255,255,255,0.00) 12px
    );
    box-shadow: inset 0 0 0 1px rgba(30, 64, 175, 0.28);
}

.cc-constraints-caption {
    margin-top: 6px;
    font-size: 12px;
    line-height: 1.25;
    color: var(--gray-700);
}

/* Mobile-only: tighten the explanatory text under Time Ranges (service scope) */
@media (max-width: 768px) {
    /* Make all text inside the constraints container smaller on mobile */
    #defaultAvailabilityContainer .cc-constraints-wrap {
        font-size: 9px;
    }

    /* Inline segment labels */
    #defaultAvailabilityContainer .cc-constraints-wrap .cc-constraints-seg .cc-constraints-label {
        font-size: 7px;
        letter-spacing: 0.25px;
    }

    #defaultAvailabilityContainer .cc-constraints-caption {
        font-size: 9px;
        line-height: 1.2;
        margin-top: 5px;
    }
}

/* Service-scope explainer (client-facing mental model) */
.cc-scope-explainer {
    display: none;
    margin: 10px 0 14px 0;
    padding: 10px 12px;
    border: 1px solid var(--gray-200);
    border-radius: 12px;
    background: rgba(249, 250, 251, 0.95);
}
.cc-scope-explainer .title {
    font-weight: 800;
    font-size: 13px;
    color: var(--gray-900);
    margin-bottom: 4px;
}
.cc-scope-explainer .body {
    font-size: 13px;
    color: var(--gray-700);
    line-height: 1.35;
}
.cc-scope-explainer .cc-scope-compat {
    margin-top: 8px;
    padding: 8px 10px;
    border-left: 3px solid var(--primary-500);
    background: rgba(59, 130, 246, 0.06);
    border-radius: 10px;
    font-size: 12px;
    color: var(--gray-800);
}
.cc-scope-explainer .cc-scope-compat .label {
    font-weight: 800;
    color: var(--gray-900);
}
.cc-scope-explainer .cc-scope-compat .names {
    margin-top: 2px;
    color: var(--gray-700);
}
.cc-scope-legend {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    margin-top: 8px;
}
.cc-scope-legend .item {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    font-size: 12px;
    color: var(--gray-700);
}
.cc-scope-legend .swatch {
    width: 18px;
    height: 10px;
    border-radius: 999px;
    border: 1px solid rgba(148, 163, 184, 0.7);
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.8);
}
.cc-scope-legend .swatch.member { background: rgba(245, 158, 11, 0.62); }
.cc-scope-legend .swatch.other {
    background: rgba(59, 130, 246, 0.82);
    background-image: repeating-linear-gradient(
        45deg,
        rgba(255,255,255,0.25) 0px,
        rgba(255,255,255,0.25) 6px,
        rgba(255,255,255,0.00) 6px,
        rgba(255,255,255,0.00) 12px
    );
}

/* Fully blocked day (service scope): make row non-interactive */
.cc-weekly-row-locked {
    opacity: 0.55;
}
.cc-weekly-row-locked input,
.cc-weekly-row-locked button {
    pointer-events: none;
}
.cc-weekly-row-locked .add-range-btn,
.cc-weekly-row-locked .remove-range-btn {
    filter: grayscale(1);
}
.cc-weekly-row-locked td {
    background: rgba(243, 244, 246, 0.55);
}


/* Per-date Overrides: enhanced card styling */
#overridesContainer {
    position: relative;
    overflow: hidden;
    font-family: "Inter", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
}
#overridesContainer::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 6px;
    /* Use the canonical per-date overrides gradient and animate it (in sync) */
    background: linear-gradient(to right, var(--primary-500), var(--success-500), var(--danger-500));
    background-size: 400% 100%;
    animation: cc-wave var(--cc-wave-duration, 14s) ease-in-out infinite;
    animation-delay: var(--cc-wave-offset, 0s);
    z-index: 50;
    pointer-events: none;
}

/* Quick attention flash when an override save is denied */
.cc-overrides-flash {
    outline: 3px solid rgba(239, 68, 68, 0.35);
    outline-offset: 3px;
}

/* Pro/Team-only feature: when locked, keep visible but greyed out */
.cc-overrides-disabled {
    opacity: 0.55;
}
.cc-overrides-disabled * {
    pointer-events: none;
}
.cc-overrides-lock-overlay {
    position: absolute;
    inset: 0;
    z-index: 60;
    background: transparent;
    /* Default: do not block interaction when overrides are enabled */
    display: none;
    pointer-events: none;
}
.cc-overrides-disabled .cc-overrides-lock-overlay {
    /* Locked state: capture clicks to show the upgrade prompt */
    display: block;
    pointer-events: auto;
}
.cc-overrides-disabled button,
.cc-overrides-disabled a {
    cursor: not-allowed;
}

/* Overrides table visuals */
#overridesTable {
    border-collapse: separate;
    border-spacing: 0;
}
#overridesTable thead tr {
    background: linear-gradient(to right, rgba(59, 130, 246, 0.08), rgba(16, 185, 129, 0.08));
}
#overridesTable th {
    padding: 10px;
    text-align: left;
    font-weight: 700;
    font-size: 12.5px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--gray-700);
}
#overridesTable td {
    padding: 10px;
    border-bottom: 1px solid var(--gray-100);
    font-size: 13px;
    color: var(--gray-700);
}

/* Reset All Overrides button: shift left more on wide screens */
#resetAllOverridesBtn {
    transform: translateX(-16px);
}
@media (min-width: 1025px) {
    #resetAllOverridesBtn {
        transform: translateX(-36px);
    }
}

/* Default Weekly Availability: prevent overflow and keep content visible */
#defaultAvailabilityContainer table { table-layout: fixed; width: 100%; }
#defaultAvailabilityContainer th, #defaultAvailabilityContainer td { white-space: nowrap; overflow: visible; }
/* Allow time range cells to wrap naturally but keep day names intact */
#defaultAvailabilityContainer tbody td:first-child { white-space: nowrap; }
#defaultAvailabilityContainer tbody td:not(:first-child) { white-space: normal; }
/* Subtle borders between day rows with padding for spacing */
#defaultAvailabilityContainer tbody tr { border-bottom: 1px solid var(--gray-200); }
#defaultAvailabilityContainer tbody tr:last-child { border-bottom: none; }
#defaultAvailabilityContainer tbody td { padding-top: 16px; padding-bottom: 16px; }


/* Type badges */
.type-badge {
    display: inline-block;
    padding: 6px 10px;
    border-radius: 999px;
    font-weight: 600;
    font-size: 12px;
}
.type-badge.available {
    background: rgba(16, 185, 129, 0.15);
    color: var(--success-600);
    border: 1px solid rgba(16, 185, 129, 0.25);
}
.type-badge.blocked {
    background: rgba(239, 68, 68, 0.15);
    color: var(--danger-600);
    border: 1px solid rgba(239, 68, 68, 0.25);
}

/* Action buttons */
#overridesTable button.overrides-btn {
    padding: 8px 12px;
    border-radius: 8px;          /* slightly smaller buttons */
    background: var(--primary-500);
    color: white;
    border: none;
    font-weight: 600;
    cursor: pointer;
    transition: transform 0.15s ease, box-shadow 0.2s ease, background-color 0.2s ease;
    box-shadow: 0 1px 3px rgba(0,0,0,0.12);
}
#overridesTable button.overrides-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 6px 12px rgba(59, 130, 246, 0.30);
    background: var(--primary-600);
}
#overridesTable button.overrides-btn:active {
    transform: translateY(0);
}

/* Loading state for overrides buttons */
#overridesTable button.overrides-btn.cc-btn-loading,
#resetAllOverridesBtn.cc-btn-loading {
    opacity: 0.85;
    cursor: wait;
}
.cc-inline-spinner {
    width: 14px;
    height: 14px;
    border-radius: 999px;
    border: 2px solid rgba(59, 130, 246, 0.25);
    border-top-color: rgba(59, 130, 246, 0.95);
    display: inline-block;
    vertical-align: middle;
    animation: cc-inline-spin 0.7s linear infinite;
}
@keyframes cc-inline-spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}
.cc-btn-loading-content {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}

/* Fallback: if a button in overrides table has no inner text, show its data-label */
#overridesTable button.overrides-btn:empty::after {
    content: attr(data-label);
}

</style>

<style>
/* Very small phones: keep title + actions on single line and shrink buttons to fit */
@media (max-width: 480px) {
    /* prevent the header row from wrapping so title and actions remain inline;
       allow wrapping only to push the controls to a second row */
    #bookingsInlineSection > div:first-child {
        display: flex !important;
        align-items: center !important;
        justify-content: space-between !important;
        gap: 8px !important;
        flex-wrap: wrap !important;
    }

    /* allow the heading to shrink so the actions can fit and ensure it stays first */
    #bookingsInlineSection > div:first-child h3 {
        flex: 1 1 auto !important;
        min-width: 0 !important;
        margin: 0 8px 0 0 !important;
        font-size: 16px !important;
        line-height: 1.1 !important;
        order: 1 !important;
    }

    /* keep the two action buttons grouped and small, and place them after the title */
    #bookingsInlineSection > div:first-child .bookings-top-actions {
        display: flex !important;
        gap: 6px !important;
        flex: 0 0 auto !important;
        align-items: center !important;
        order: 2 !important;
        margin-left: auto !important;
    }

    /* Make both buttons compact and equal height */
    #bookingsInlineSection > div:first-child a#bookingsViewAllBtn,
    #bookingsInlineSection > div:first-child button#bookingsRefreshBtn {
        padding: 4px 6px !important;
        font-size: 12px !important;
        height: 32px !important;
        min-width: 56px !important;
        border-radius: 6px !important;
        line-height: 1 !important;
        white-space: nowrap !important;
    }

    /* Ensure search + rows controls drop to a second row but keep inputs aligned */
    #bookingsInlineSection > div:first-child .bookings-controls {
        order: 3 !important;
        flex: 1 1 100% !important;
        width: 100% !important;
        margin-top: 8px !important;
        gap: 8px !important;
        align-items: center !important;
        justify-content: flex-start !important;
    }

    /* Slightly reduce select/input height to match compact buttons */
    #bookingsInlineSection > div:first-child .bookings-controls input,
    #bookingsInlineSection > div:first-child .bookings-controls select {
        height: 32px !important;
        padding: 6px 8px !important;
        font-size: 13px !important;
    }
}
</style>

<style>
/* Mobile-specific container height to ensure availability card has enough room */
@media (max-width: 768px) {
    #defaultAvailabilityContainer {
        /* Let the card grow with content (ranges + Save button) */
        min-height: unset !important;
        height: auto !important;
        max-height: none !important;
        overflow: hidden !important;
    }
}
</style>
<style>
/* Animated, stylish calendar title */
.calendar-title {
    /* Match available day circle highlight (primary blue gradient) */
    background: linear-gradient(135deg, var(--primary-500), var(--primary-600));
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    background-size: 200% auto;
    animation: titleGradientShift 8s ease-in-out infinite, titleFloatIn 600ms ease-out both;
    filter: drop-shadow(0 1px 0 rgba(0,0,0,0.06));
}
/* Per-date overrides month label: match available day circle highlight */
#overridesHeaderMonth {
    background: linear-gradient(135deg, var(--primary-500), var(--primary-600));
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent !important; /* override inline color */
    background-size: 200% auto;
    animation: titleGradientShift 8s ease-in-out infinite;
}
@keyframes titleGradientShift {
    0% { background-position: 0% center; }
    50% { background-position: 100% center; }
    100% { background-position: 0% center; }
}
@keyframes titleFloatIn {
    0% { opacity: 0; transform: translateY(6px); }
    100% { opacity: 1; transform: translateY(0); }
}

/* Mobile Responsive Styles */
@media (max-width: 768px) {
    /* Title adjustments */
    .calendar-title {
        font-size: 24px !important;
        margin-top: 20px !important;
    }

    /* Per-date overrides header: shrink title text on mobile (overrides inline styles) */
    #overridesHeader {
        font-size: 15px !important;
        line-height: 1.25 !important;
    }
    /* Remove extra top offset on mobile since controls are not overlaid */
    .fc .fc-view-harness { margin-top: 0 !important; }

    /* Slightly smaller day circles on mobile */
    .fc-daygrid-day-number,
    .fc .fc-day-today .fc-daygrid-day-number,
    .fc-daygrid-day-number.past-day,
    .fc-daygrid-day-number.unavailable-number {
        width: 40px !important;
        height: 40px !important;
        font-size: 1.25rem !important;
        line-height: 36px !important;
    }
    /* Reduce hover/selected scale to match smaller size */
    .fc-daygrid-day-number:hover { transform: translate(-50%, -50%) scale(1.1) !important; }
    .fc-daygrid-day-number.selected { transform: translate(-50%, -50%) scale(1.15) !important; }
    
    /* Per-date Overrides Table */
    #overridesContainer {
        padding: 16px !important;
        margin-top: 16px !important;
        overflow-x: auto;
    }
    
    #overridesTable {
        font-size: 11px;
        min-width: 600px;
    }
    
    #overridesTable th {
        padding: 8px !important;
        font-size: 10px !important;
    }
    
    #overridesTable td {
        padding: 8px !important;
        font-size: 11px !important;
    }
    
    #overridesTable button {
        padding: 6px 8px !important;
        font-size: 11px !important;
    }

    /* Removed nested desktop @media that touched .range-row to avoid
       any accidental mobile/medium interactions. */

    /* Default Weekly Availability: responsive rules removed per request. */
    /* (Removed mobile/medium @media blocks and small-screen overrides that targeted
       #defaultAvailabilityContainer, .range-row, .range-start, .range-end,
       .remove-range-btn, .unavailable-checkbox so desktop styles are the baseline.) */
    
    /* Calendar Container */
    div[style*="flex:2 1 640px"] {
        flex: 1 1 100% !important;
        min-width: 100% !important;
        margin-bottom: 16px !important;
    }
    
    #calendar {
        padding: 12px !important;
        height: auto !important;
        min-height: 420px !important;
    }
    
    /* Calendar Controls */
    /* Place controls inline under month title; simplified styling */
    #calendar-controls {
        position: static !important;
        transform: none !important;
        margin-bottom: 12px;
        flex-wrap: wrap;
        justify-content: center;
        background: transparent !important;
        box-shadow: none !important;
        padding: 8px !important;
    }
    
    .calendar-btn {
        padding: 8px 12px !important;
        font-size: 12px !important;
    }
    
    /* Main flex container */
    #weeklyCalendarRow { gap: 16px !important; flex-wrap: wrap !important; }
}

/* Landscape Mobile (tablets in landscape, large phones) */
@media (max-width: 1200px) and (min-width: 769px) {
    #weeklyCalendarRow { flex-wrap: wrap !important; }
    /* Default availability responsive settings removed */
    
    div[style*="flex:2 1 640px"] {
        flex: 1 1 500px !important;
        min-width: 500px !important;
    }
}

/* Small phones (portrait) */
@media (max-width: 480px) {
    #overridesContainer,
    #calendar {
        border-radius: 12px !important;
    }
    
    .calendar-title {
        font-size: 20px !important;
    }
    
    /* Default availability time input mobile sizing removed */
    
    #calendar-controls {
        gap: 6px !important;
    }
    
    .calendar-btn {
        padding: 6px 10px !important;
        font-size: 11px !important;
    }
}

/* Full width on mobile - override base.html max-width containers */
@media (max-width: 768px) {
    /* Prevent horizontal scrolling */
    html, body {
        overflow-x: hidden;
        width: 100%;
        max-width: 100vw;
    }
    
    body {
        padding: 0;
        margin: 0;
    }
    
    /* Mobile: use a 95% width column (centered) */
    main.max-w-6xl,
    main.max-w-7xl,
    main {
        max-width: 95vw !important;
        width: 95vw !important;
        margin: 0 auto !important;
        padding: 0 !important;
        box-sizing: border-box !important;
    }

    /* Scope dropdown: match the 95vw mobile column even if the header is centered/narrow */
    #ccScopeMenuRoot {
        width: 95vw !important;
        max-width: 95vw !important;
        margin-left: auto !important;
        margin-right: auto !important;
    }
    #ccScopeMenu,
    #ccScopeSubmenu {
        width: 100% !important;
        max-width: 100% !important;
        box-sizing: border-box !important;
    }
    

    
    /* Cards: fill the 95vw column */
    #overridesContainer,
    #defaultAvailabilityContainer,
    #calendar,
    #bookingsInlineSection {
        margin-left: 0 !important;
        margin-right: 0 !important;
        width: 100% !important;
        max-width: 100% !important;
        box-sizing: border-box !important;
        overflow-x: visible !important;
    }
    
    /* Title stays fixed, only table wrapper scrolls */
    #overridesTableWrapper {
        overflow-x: auto !important;
        -webkit-overflow-scrolling: touch !important;
    }
    
    #overridesTable {
        min-width: 600px !important;
    }
    
    /* Full width page title container */
    div[style*="margin-bottom:32px; text-align:center"] {
        margin-bottom: 16px !important;
        padding: 0 !important;
        width: 100% !important;
        box-sizing: border-box !important;
    }
    
    /* Default availability media rules removed */
}

/* Widen layout on desktop: use more of the screen width */
@media (min-width: 1025px) {
    /* Expand base containers from base.html */
    main.max-w-6xl,
    main.max-w-7xl,
    main {
        max-width: 95vw !important;
        width: 95vw !important;
        padding-left: 16px !important;
        padding-right: 16px !important;
        box-sizing: border-box !important;
    }

    /* Increase gap between weekly availability and calendar on wide screens */
    #weeklyCalendarRow { gap: 60px !important; }
    /* Make calendar fill column height */
    #calendar { height: 100% !important; }
}

/* Keep a consistent horizontal gutter (side padding) for medium viewports
   so content doesn't touch the right edge as the layout narrows. This
   preserves the current visual spacing until the availability column must
   wrap on small screens. */
@media (min-width: 481px) and (max-width: 1200px) {
    main.max-w-6xl,
    main.max-w-7xl,
    main {
        padding-left: 12px !important;
        padding-right: 12px !important;
        box-sizing: border-box !important;
    }

    /* Add a small inner gutter for the two-column calendar/availability row */
    #weeklyCalendarRow {
        padding-left: 12px !important;
        padding-right: 12px !important;
        box-sizing: border-box !important;
    }
}


</style>

<style>
/* Removed: minimal mobile-only availability rules targeting .availability-ui */
</style>

<style>
/* Center content column and prevent edge leakage across wide and medium viewports */
@media (min-width: 900px) {
    :root { 
        --cc-page-gutter: 16px; 
        --cc-inner-max: 1180px; 
    }

    main.max-w-6xl,
    main.max-w-7xl,
    main {
        width: 100% !important;
        margin-left: auto !important;
        margin-right: auto !important;
        padding-left: var(--cc-page-gutter) !important;
        padding-right: var(--cc-page-gutter) !important;
        box-sizing: border-box !important;
    }



    /* Align the main cards to the centered column and allow them to shrink */
    #overridesContainer,
    #weeklyCalendarRow,
    #defaultAvailabilityContainer,
    #calendar,
    #bookingsInlineSection {
        max-width: 100% !important;
        margin-left: 0 !important;
        margin-right: 0 !important;
        box-sizing: border-box !important;
    }

    /* Override inline min-widths (set on elements via style attributes) so they
       don't push past the centered column and leak to the viewport edge. */
    #defaultAvailabilityContainer, div[style*="flex:2 1 640px"] {
        min-width: 0 !important;
        max-width: 100% !important;
        box-sizing: border-box !important;
    }

    /* Keep weekly row aligned with the centered column */
    #weeklyCalendarRow { padding-left: 0 !important; padding-right: 0 !important; box-sizing: border-box !important; }
}
</style>

 <!-- Mobile responsive fixes for View Day Schedule / Time Circles modal -->
<style>
    @media (max-width: 480px) {
        /* Shrink the modal wrapper so it fits within the viewport */
        #timeCirclesModal { padding: 6px !important; }
        #timeCirclesModalPanel {
            width: calc(100% - 20px) !important;
            max-width: 96vw !important;
            padding: 12px !important;
            box-sizing: border-box !important;
            border-radius: 12px !important;
            max-height: 92vh !important;
            overflow-y: auto !important;
        }

        /* Title should never collide with the close button */
        #circleModalTitle {
            font-size: 14px !important;
            line-height: 1.15 !important;
            word-break: break-word !important;
        }

        /* Keep header actions compact on small screens */
        #ccChangeInEditServiceBtn { padding: 10px 10px !important; font-size: 12px !important; border-radius: 12px !important; }
        #closeCirclesBtn { font-size: 20px !important; padding: 4px !important; }

        /* Make any tables or grids inside responsive */
        #timeCirclesModal table, #timeCirclesModal .time-circles-grid, #timeCirclesModal .time-circles-table {
            width: 100% !important;
            max-width: 100% !important;
            table-layout: auto !important;
            overflow-wrap: break-word !important;
        }

        /* Prevent fixed-width children from overflowing */
        #timeCirclesModal * { box-sizing: border-box !important; }
        #timeCirclesModal img, #timeCirclesModal svg { max-width: 100% !important; height: auto !important; }

        /* If there is a horizontal scroller, make it touch friendly */
        #timeCirclesModal .horizontal-scroll, #timeCirclesModal .time-scroll-container {
            overflow-x: auto !important;
            -webkit-overflow-scrolling: touch !important;
            width: 100% !important;
        }

        /* Reduce inner spacing and keep action buttons readable */
        #timeCirclesModal .tc-actions button, #timeCirclesModal button {
            padding: 8px 10px !important;
            font-size: 13px !important;
        }
    }
</style>

<!-- Controls will be overlaid inside the calendar area -->
<!-- Removed mobile/medium @media rules that targeted the Default Weekly Availability UI -->
<!-- Per-date Overrides Table - Modern Card (moved to top) -->
<div id="overridesContainer" class="{% if not can_use_overrides %}cc-overrides-disabled{% endif %}" style="margin-top:24px; padding:24px; background:white; border:none; border-radius:16px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);">
    {% if not can_use_overrides %}
        <div class="cc-overrides-lock-overlay" aria-hidden="true"></div>
    {% endif %}
    <div id="cc-overrides-save-banner" role="status" aria-live="polite" style="display:none; margin:0 auto 14px auto; width:100%; max-width:920px; padding:12px 12px; border-radius:12px; border:1px solid #fecaca; background:#fef2f2; color:#7f1d1d; font-size:14px; line-height:1.35; text-align:center;">
        <div style="display:flex; align-items:flex-start; justify-content:space-between; gap:12px;">
            <div id="cc-overrides-save-banner-body" style="flex:1; text-align:center;"></div>
            <button type="button" id="cc-overrides-save-banner-close" onclick="try{window.ccDismissOverrideBanner&&window.ccDismissOverrideBanner();}catch(e){}" style="border:0; background:transparent; color:#7f1d1d; font-weight:700; cursor:pointer; padding:2px 6px; border-radius:8px;">×</button>
        </div>
    </div>
    <h3 id="overridesHeader" class="overrides-header" style="margin:0 0 20px 0; font-size:18px; font-weight:700; color:var(--gray-900);">
        <span class="overrides-base" style="font-weight:600;">Per-date Overrides for </span>
                {% if is_team_plan or is_pro_plan %}
                    <span id="overridesHeaderSelection" class="overrides-month" style="color:var(--primary-600); font-size:inherit;"></span>
                    <span style="color:var(--gray-600);"> in </span>
                {% else %}
                    <span id="overridesHeaderSelection" style="display:none;"></span>
                {% endif %}
        <span id="overridesHeaderMonth" class="overrides-month" style="color:var(--primary-600);"></span>
    </h3>
    <div id="overridesTableWrapper" style="overflow-x:auto; -webkit-overflow-scrolling:touch;">
        <table id="overridesTable" style="width:100%; border-collapse:collapse;">
            <thead>
                <tr style="text-align:left; border-bottom:2px solid var(--gray-200); background:var(--gray-50);">
                    <th style="padding:12px; width:16%; font-weight:600; font-size:13px; text-transform:uppercase; letter-spacing:0.5px; color:var(--gray-600);">Date</th>
                    <th style="padding:12px; width:16%; font-weight:600; font-size:13px; text-transform:uppercase; letter-spacing:0.5px; color:var(--gray-600);">Type</th>
                    <th style="padding:12px; width:38%; font-weight:600; font-size:13px; text-transform:uppercase; letter-spacing:0.5px; color:var(--gray-600);">Time Ranges</th>
                    <th style="padding:12px; width:15%; font-weight:600; font-size:13px; text-transform:uppercase; letter-spacing:0.5px; color:var(--gray-600); text-align:center;">Reset All</th>
                    <th style="padding:12px; width:15%; font-weight:600; font-size:13px; text-transform:uppercase; letter-spacing:0.5px; color:var(--gray-600);">Group Actions</th>
                </tr>
            </thead>
            <tbody id="overridesTableBody">
                <tr><td colspan="5" style="text-align:center; color:var(--gray-600); padding:24px; font-style:italic;">No per-date overrides</td></tr>
            </tbody>
        </table>
    </div>
</div>

<div id="weeklyCalendarRow" style="display:flex; gap:40px; align-items:stretch; flex-wrap:nowrap; margin-top:24px; width:100%;">
        <div id="defaultAvailabilityContainer" class="availability-ui" style="flex:1 1 540px; min-width:540px; margin-bottom:32px; padding:24px; background:white; border:none; border-radius:16px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);">
                <div style="display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; margin:0 0 10px 0;">
                    <div style="display:flex; flex-direction:column; gap:4px;">
                        <h3 id="cc-weekly-availability-title" style="margin:0; font-size:18px; font-weight:700; color:var(--gray-900);">Default Weekly Availability</h3>
                        <div id="cc-weekly-availability-desc" style="display:none; font-size:13px; color:var(--gray-600); line-height:1.4; max-width:640px;">
                            This is the staff member's overall weekly availability. Services that are assigned to this specific staff must fit within their overall weekly availability.
                        </div>
                    </div>
                    <a id="cc-open-edit-service-from-calendar"
                       href="#"
                       style="display:none; padding:10px 12px; border-radius:10px; background:white; border:1px solid var(--primary-500); color:var(--primary-600); font-weight:700; cursor:pointer; text-decoration:none;">

        <!-- Compact bookings header controls for mobile so they fit comfortably -->
        <style>
        @media (max-width: 768px) {
            #bookingsInlineSection .booking-controls,
            #bookingsInlineSection .bookings-top,
            #bookingsInlineSection .bookings-actions {
                display: flex;
                gap: 8px;
                align-items: center;
                justify-content: flex-start;
                flex-wrap: nowrap;
            }

            #bookingsInlineSection .booking-controls .calendar-btn,
            #bookingsInlineSection .bookings-top .calendar-btn {
                padding: 8px 10px !important;
                font-size: 13px !important;
                border-radius: 8px !important;
                line-height: 1 !important;
                white-space: nowrap !important;
            }

            /* Make search input compact and allow it to shrink */
            #bookingsInlineSection .booking-controls input[type="search"],
            #bookingsInlineSection input.search,
            #bookingsInlineSection .search-input {
                padding: 8px 10px !important;
                font-size: 13px !important;
                min-width: 0 !important;
                flex: 1 1 auto !important;
                max-width: 280px !important;
            }

            /* Small square refresh/icon buttons */
            #bookingsInlineSection .refresh-btn,
            #bookingsInlineSection .refresh-button,
            #bookingsInlineSection button.refresh {
                width: 36px !important;
                height: 36px !important;
                padding: 6px !important;
                border-radius: 8px !important;
                display: inline-flex !important;
                align-items: center !important;
                justify-content: center !important;
            }
        }

        @media (max-width: 420px) {
            #bookingsInlineSection .booking-controls,
            #bookingsInlineSection .bookings-top {
                gap: 6px;
            }

            #bookingsInlineSection .booking-controls .calendar-btn,
            #bookingsInlineSection .bookings-top .calendar-btn {
                padding: 6px 8px !important;
                font-size: 12px !important;
            }

            #bookingsInlineSection .booking-controls input[type="search"],
            #bookingsInlineSection input.search {
                font-size: 12px !important;
                padding: 6px 8px !important;
                max-width: 180px !important;
            }
        }
        </style>
                        Open Edit Service
                    </a>
                </div>
                {% if is_team_plan or is_pro_plan %}
                    <div id="cc-weekly-interchange-note" style="margin:0 0 14px 0; font-size:13px; color:var(--gray-600); line-height:1.4;">
                        Tip: When you select a service scope, this weekly schedule is interchangeable with that service’s availability on the Edit Service page.
                    </div>
                {% endif %}

                <div id="ccServiceScopeExplainer" class="cc-scope-explainer" role="note" aria-live="polite">
                    <div class="title" id="ccServiceScopeExplainerTitle">Client-facing availability</div>
                    <div class="body" id="ccServiceScopeExplainerBody">
                        Select a service to preview what clients can actually book.
                    </div>
                    <div class="cc-scope-legend">
                        <span class="item"><span class="swatch member"></span>Outside overall availability</span>
                        <span class="item"><span class="swatch other"></span>Reserved by other services</span>
                    </div>
                </div>
    <table style="width:100%; border-collapse:collapse;">
        <thead>
        <tr style="border-bottom:2px solid var(--gray-200); background:var(--gray-50);">
            <th style="padding:12px; text-align:left; font-weight:700; font-size:13px; text-transform:uppercase; letter-spacing:0.5px; color:var(--gray-900); width:20%;">Day</th>
            <th style="padding:12px; text-align:center; font-weight:700; font-size:13px; text-transform:uppercase; letter-spacing:0.5px; color:var(--gray-900); width:55%;" colspan="2">Time Ranges</th>
            <th style="padding:12px; text-align:center; font-weight:700; font-size:13px; text-transform:uppercase; letter-spacing:0.5px; color:var(--gray-900); width:25%;">Unavailable</th>
        </tr>
        </thead>
        <tbody id="defaultAvailabilityTable"></tbody>
    </table>
    <button id="saveDefaultAvailabilityBtn" 
            style="display:none; margin-top:20px; padding:12px 24px; background:var(--primary-500); color:white; border:none; border-radius:8px; font-weight:600; cursor:pointer; transition:all 0.2s ease; box-shadow:0 1px 3px rgba(0,0,0,0.1);">
        Save Changes
    </button>
    </div>

        <!-- === Your Calendar === -->
        <div style="position:relative; flex:2 1 640px; min-width:640px; margin-bottom:32px; display:flex; flex-direction:column;">
            <div id="calendar" style="position:relative;"></div>
            <div id="calendar-controls" style="position:absolute; left:50%; transform:translateX(-50%); top:80px; display:flex; gap:10px; z-index:10;">
                <button id="selectDaysBtn" class="calendar-btn">Select Day</button>
                <button id="selectAllBtn" class="calendar-btn" style="background:var(--success-500);">Highlight All</button>
                <button id="clearSelectionBtn" class="calendar-btn" style="background:var(--danger-500);">Clear</button>
                <button id="retryInitCalendarBtn" class="calendar-btn" style="background:transparent; color:var(--primary-500); border:1px solid var(--primary-500);">Retry</button>
            </div>
        </div>
</div>
<!-- Inline Bookings Section -->
<style>
/* Apply horizontal scrolling for bookings only on small–medium screens */
@media (max-width: 1200px) {
    #bookingsScrollWrapper { overflow-x: auto; -webkit-overflow-scrolling: touch; }
    #bookingsScrollWrapper table { min-width: 720px; width: 100%; }
}
</style>

<style>
/* Small screens: match default availability gutters to other cards (safe, mobile-only) */
@media (max-width: 768px) {
    /* Match the inline padding used by other cards (24px) so edges align */
    #defaultAvailabilityContainer {
        width: 100% !important;
        box-sizing: border-box !important;
        padding-left: 24px !important;
        padding-right: 24px !important;
        margin-left: 0 !important;
        margin-right: 0 !important;
    }

    /* Ensure the inner table respects card padding and doesn't add extra left offset */
    #defaultAvailabilityContainer table {
        width: 100% !important;
        table-layout: fixed !important;
        margin-left: 0 !important;
        margin-right: 0 !important;
        box-sizing: border-box !important;
    }

    /* When the weekly row stacks, remove any row-level padding so cards line up */
    #weeklyCalendarRow {
        padding-left: 0 !important;
        padding-right: 0 !important;
        box-sizing: border-box !important;
    }
}
</style>

<style>
/* Emergency mobile overrides to prevent right-edge overflow caused by inline min-widths
     Only active on small viewports so desktop styles remain untouched. */
@media (max-width: 768px) {
    /* Force the weekly row to stack vertically so columns don't push past viewport */
    #weeklyCalendarRow {
        flex-direction: column !important;
        gap: 16px !important;
        padding-left: 0 !important;
        padding-right: 0 !important;
        box-sizing: border-box !important;
    }

    /* IMPORTANT: when stacked (flex-direction: column), inline flex-basis values become HEIGHT.
       The desktop inline styles use flex-basis for widths (540px/640px), but on mobile that
       can effectively pin card heights and clip the weekly table. Force natural sizing. */
    #defaultAvailabilityContainer {
        flex: 0 0 auto !important;
    }
    #weeklyCalendarRow > div[style*="flex:2 1 640px"] {
        flex: 0 0 auto !important;
        height: auto !important;
        max-height: none !important;
    }

    /* Allow both columns to shrink and fit the viewport */
    #defaultAvailabilityContainer,
    div[style*="flex:2 1 640px"],
    #calendar {
        min-width: 0 !important;
        width: 100% !important;
        box-sizing: border-box !important;
        margin-left: 0 !important;
        margin-right: 0 !important;
    }

    /* Ensure the table inside the availability card doesn't add extra width */
    #defaultAvailabilityContainer table {
        width: 100% !important;
        table-layout: fixed !important;
        margin-left: 0 !important;
        margin-right: 0 !important;
        box-sizing: border-box !important;
    }

    /* Reduce any large fixed min-widths applied elsewhere to prevent overflow */
    [style*="min-width:540px"], [style*="min-width:640px"], [style*="min-width:600px"] {
        min-width: 0 !important;
        max-width: 100% !important;
    }
}
</style>

<style>
/* Mobile-only: compact and left-align contents inside Default Weekly Availability */
@media (max-width: 768px) {
    /* Make the card contents align left and use slightly smaller spacing */
    #defaultAvailabilityContainer {
        text-align: left !important;
        padding-left: 16px !important;
        padding-right: 16px !important;
        box-sizing: border-box !important;
        /* base font-size for the card so everything is smaller */
        font-size: 12px !important;
    }

    /* Headings and table text smaller */
    #defaultAvailabilityContainer h3 {
        font-size: 14px !important;
        margin-bottom: 10px !important;
        text-align: left !important;
    }
    /* day label and other tds slightly smaller */
    #defaultAvailabilityContainer table th,
    #defaultAvailabilityContainer table td {
        font-size: 10px !important;
        padding: 6px 6px !important;
        vertical-align: middle !important;
    }
    /* specifically reduce the first column (day name) padding and size */
    #defaultAvailabilityContainer tbody td:first-child {
        font-size: 10px !important;
        padding-top: 6px !important;
        padding-bottom: 6px !important;
        white-space: nowrap !important;
    }

    /* Compact range rows and inputs */
    #defaultAvailabilityContainer .range-row {
        gap: 6px !important;
        align-items: center !important;
        justify-content: flex-start !important;
        flex-wrap: nowrap !important;
    }
    #defaultAvailabilityContainer .range-row .time-input-container {
        display: inline-block !important;
    }
    #defaultAvailabilityContainer .range-start,
    #defaultAvailabilityContainer .range-end {
        padding: 2px !important;
        font-size: 11px !important;
        border-radius: 6px !important;
        min-width: 0 !important;
        width: 86px !important; /* compact width to help layout on narrow phones */
        box-sizing: border-box !important;
    }

    /* Smaller action buttons */
    #defaultAvailabilityContainer .add-range-btn {
        padding: 3px 6px !important;
        font-size: 10px !important;
        border-radius: 6px !important;
        min-height: 26px !important;
        line-height: 1 !important;
    }
    #defaultAvailabilityContainer .remove-range-btn {
        font-size: 10px !important;
        border-radius: 4px !important;
        height: 24px !important;
        line-height: 24px !important;
        min-width: 32px !important;
    }

    /* Nudge the checkbox a bit less on small screens */
    #defaultAvailabilityContainer .unavailable-checkbox {
        top: 3px !important;
        left: 3px !important;
        width: 14px !important;
        height: 14px !important;
    }

    /* Ensure the time-picker appended to body doesn't overflow the card visually */
    #defaultAvailabilityContainer .time-input-container .custom-time-picker { max-width: 240px !important; }
}
</style>

<style>
/* Extra compact adjustments for very small phones (narrow portrait devices) */
@media (max-width: 420px) {
    /* Tighten spacing so both time inputs + actions fit on one line */
    #defaultAvailabilityContainer .range-row {
        gap: 4px !important;
    }
    #defaultAvailabilityContainer .range-start,
    #defaultAvailabilityContainer .range-end {
        width: 68px !important;
        padding: 2px !important;
        font-size: 7.5px !important;
    }

    /* Make the Add button extra compact on very small phones */
    #defaultAvailabilityContainer .add-range-btn {
        padding: 2px 5px !important;
        font-size: 9px !important;
        min-height: 22px !important;
        line-height: 1 !important;
    }

    /* Make the Remove button extra small and square on very small phones */
    #defaultAvailabilityContainer .remove-range-btn {
        font-size: 9px !important;
        height: 20px !important;
        line-height: 20px !important;
        border-radius: 6px !important;
        gap: 6px !important;
        min-width: 28px !important;
        justify-content: center !important;
    }

    /* Smaller unavailable checkbox */
    #defaultAvailabilityContainer .unavailable-checkbox {
        width: 12px !important;
        height: 12px !important;
        top: 2px !important;
        left: 2px !important;
    }

    /* Slightly reduce the time-picker width on very small viewports */
    #defaultAvailabilityContainer .time-input-container .custom-time-picker { max-width: 200px !important; }
    /* Extra-small phones: make day circles and nav arrows even smaller */
    .fc-daygrid-day-number { width: 32px !important; height: 32px !important; font-size: 13px !important; }
    .fc-daygrid-day-number.past-day,
    .fc-daygrid-day-number.unavailable-number,
    .fc .fc-day-today .fc-daygrid-day-number {
        width: 32px !important;
        height: 32px !important;
        line-height: 32px !important;
        font-size: 13px !important;
    }
    .fc .fc-prev-button, .fc .fc-next-button {
        width: 36px !important;
        height: 36px !important;
        padding: 0 !important;
        display: inline-flex !important;
        align-items: center !important;
        justify-content: center !important;
        border-radius: 6px !important;
        box-sizing: border-box !important;
    }
    .fc .fc-button { line-height: 0 !important; }
    .fc .fc-button svg, .fc .fc-button .fc-icon { width: 12px !important; height: 12px !important; display: block !important; margin: 0 !important; transform: none !important; }
    .fc .fc-prev-button > *,
    .fc .fc-next-button > *,
    .fc .fc-prev-button > .fc-icon, .fc .fc-next-button > .fc-icon,
    .fc .fc-prev-button svg, .fc .fc-next-button svg {
        width: 100% !important;
        height: 100% !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        margin: 0 !important;
        padding: 0 !important;
    }
    /* Tighten calendar controls spacing on very small phones */
    #calendar-controls { padding: 10px !important; gap: 8px !important; }
}
</style>

<!-- Tight, specific mobile rules for the bookings header controls (targets inline IDs) -->
<style>
@media (max-width: 768px) {
    /* make the control row non-wrapping and allow the search to shrink */
    #bookingsInlineSection > div:first-child {
        display: flex !important;
        gap: 8px !important;
        align-items: center !important;
        justify-content: space-between !important;
        flex-wrap: wrap !important;
    }

    /* compact the primary 'View all bookings' link and match Refresh size */
    #bookingsInlineSection > div:first-child a#bookingsViewAllBtn,
    #bookingsInlineSection > div:first-child button#bookingsRefreshBtn {
        padding: 6px 12px !important;
        font-size: 13px !important;
        min-width: 86px !important;
        height: 36px !important;
        border-radius: 8px !important;
        white-space: nowrap !important;
        display: inline-flex !important;
        align-items: center !important;
        justify-content: center !important;
    }

    /* allow search to flex and shrink so it doesn't force overflow; align inputs/selects */
    #bookingsInlineSection > div:first-child .bookings-controls input[type="search"],
    #bookingsInlineSection > div:first-child .bookings-controls input#bookingsSearchInline,
    #bookingsInlineSection > div:first-child .bookings-controls select,
    #bookingsInlineSection > div:first-child .bookings-controls input[type="number"] {
        padding: 6px 8px !important;
        font-size: 13px !important;
        min-width: 0 !important;
        flex: 1 1 auto !important;
        max-width: 220px !important;
        height: 36px !important;
        line-height: normal !important;
    }

    /* place controls (search + rows) on their own row beneath the title/actions */
    #bookingsInlineSection > div:first-child .bookings-controls {
        order: 3 !important;
        flex: 1 1 100% !important;
        width: 100% !important;
        margin-top: 8px !important;
        justify-content: flex-start !important;
        gap: 8px !important;
        align-items: center !important;
    }

    #bookingsInlineSection > div:first-child h3 {
        order: 1 !important;
        flex: 0 0 auto !important;
    }

    #bookingsInlineSection > div:first-child button#bookingsRefreshBtn {
        order: 2 !important;
        flex: 0 0 auto !important;
        margin-left: 8px !important;
    }
}

@media (max-width: 420px) {
    #bookingsInlineSection > div:first-child {
        gap: 6px !important;
    }
    #bookingsInlineSection > div:first-child a#bookingsViewAllBtn {
        padding: 6px 6px !important;
        font-size: 12px !important;
    }
    #bookingsInlineSection > div:first-child input#bookingsSearchInline {
        padding: 6px 8px !important;
        font-size: 12px !important;
        max-width: 140px !important;
    }
    #bookingsInlineSection > div:first-child button#bookingsRefreshBtn {
        min-width: 72px !important;
        height: 34px !important;
        padding: 6px 10px !important;
    }
}
</style>

<div id="bookingsInlineSection" style="margin-top:24px; padding:24px; background:white; border:none; border-radius:16px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);">
<style>
/* Final mobile overrides for bookings header (placed immediately before markup to beat earlier rules) */
@media (max-width: 480px) {
    #bookingsInlineSection > div:first-child a#bookingsViewAllBtn,
    #bookingsInlineSection > div:first-child button#bookingsRefreshBtn {
        padding: 3px 6px !important;
        font-size: 12px !important;
        height: 30px !important;
        min-width: 40px !important;
        border-radius: 6px !important;
        box-sizing: border-box !important;
    }
    #bookingsInlineSection > div:first-child .bookings-top-actions { margin-left: auto !important; }
    /* prefer full labels on slightly larger mobile widths */
    #bookingsInlineSection > div:first-child a#bookingsViewAllBtn .btn-full,
    #bookingsInlineSection > div:first-child button#bookingsRefreshBtn .btn-full { display: inline !important; }
    #bookingsInlineSection > div:first-child a#bookingsViewAllBtn .btn-short,
    #bookingsInlineSection > div:first-child button#bookingsRefreshBtn .btn-short { display: none !important; }
}

@media (max-width: 360px) {
    /* show short labels and compress buttons further */
    #bookingsInlineSection > div:first-child a#bookingsViewAllBtn .btn-full,
    #bookingsInlineSection > div:first-child button#bookingsRefreshBtn .btn-full { display: none !important; }
    #bookingsInlineSection > div:first-child a#bookingsViewAllBtn .btn-short,
    #bookingsInlineSection > div:first-child button#bookingsRefreshBtn .btn-short { display: inline !important; }
    #bookingsInlineSection > div:first-child a#bookingsViewAllBtn,
    #bookingsInlineSection > div:first-child button#bookingsRefreshBtn {
        padding: 2px 6px !important;
        min-width: 36px !important;
        height: 28px !important;
        font-size: 12px !important;
    }
}
</style>
    <div style="display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap; margin-bottom:12px;">
        <h3 style="margin:0; font-size:18px; font-weight:700; color:var(--gray-900);">Bookings</h3>
        <div class="bookings-top-actions" style="display:flex; gap:8px; align-items:center;">
            <a id="bookingsViewAllBtn" href="{% url 'calendar_app:bookings_list' organization.slug %}" style="padding:8px 12px; background:var(--primary-500); color:white; border:none; border-radius:8px; font-weight:600; text-decoration:none; display:inline-flex; align-items:center; justify-content:center;">View all bookings</a>
            <button id="bookingsRefreshBtn" type="button" style="padding:8px 12px; background:var(--primary-500); color:white; border:none; border-radius:8px; font-weight:600; cursor:pointer; display:inline-flex; align-items:center; justify-content:center;">Refresh</button>
        </div>
        <div class="bookings-controls" style="display:flex; gap:8px; align-items:center; flex:1 1 100%; width:100%; margin-top:8px;">
            <input id="bookingsSearchInline" type="text" placeholder="Search name or email" style="padding:8px 10px; border:1px solid var(--gray-300); border-radius:6px; font-size:13px; flex:1 1 auto; min-width:0;" />
            <label for="bookingsVisibleRowsSelect" style="margin-left:6px; font-size:13px; color:var(--gray-700);">Rows:</label>
            <select id="bookingsVisibleRowsSelect" style="padding:6px 8px; border-radius:6px; font-size:13px;">
                <option value="5">5</option>
                <option value="10">10</option>
                <option value="15">15</option>
                <option value="20">20</option>
                <option value="all">All</option>
                <option value="custom">Custom</option>
            </select>
            <input id="bookingsVisibleRowsCustomInput" type="number" min="1" placeholder="Rows" style="display:none; margin-left:6px; padding:6px 8px; width:90px; border-radius:6px;" />
        </div>
    </div>
    <style>
    /* bookings scroll sizing using CSS variables so JS can control visible rows */
    #bookingsInlineSection { --bookings-row-height: 56px; --bookings-visible-default: 10; }
    #bookingsScrollWrapper { --bookings-visible-rows: var(--bookings-visible, var(--bookings-visible-default)); max-height: calc(var(--bookings-row-height) * var(--bookings-visible-rows)); overflow:auto; }
    #bookingsScrollWrapper.cc-visible-all { max-height: none !important; }
    #bookingsInlineSection .inline-audit-wrapper { --bookings-visible-rows: var(--bookings-visible, var(--bookings-visible-default)); max-height: calc(var(--bookings-row-height) * var(--bookings-visible-rows)); overflow:auto; margin-top:8px; }
    #bookingsInlineSection .inline-audit-wrapper.cc-visible-all { max-height: none !important; }
    </style>
    <div id="bookingsScrollWrapper">
    <table style="width:100%; border-collapse:collapse;">
        <thead>
            <tr style="border-bottom:2px solid var(--gray-200); background:var(--gray-50);">
                <th style="padding:10px; text-align:left; font-size:13px; font-weight:700; color:var(--gray-900);">Date & Time</th>
                <th style="padding:10px; text-align:left; font-size:13px; font-weight:700; color:var(--gray-900);">Client</th>
                <th style="padding:10px; text-align:left; font-size:13px; font-weight:700; color:var(--gray-900);">Service</th>
                <th style="padding:10px; text-align:left; font-size:13px; font-weight:700; color:var(--gray-900);">Status</th>
                <th style="padding:10px; text-align:left; font-size:13px; font-weight:700; color:var(--gray-900);">Actions</th>
            </tr>
        </thead>
        <tbody id="bookingsInlineTBody">
            <tr><td colspan="5" style="text-align:center; color:var(--gray-600); padding:16px;">Loading…</td></tr>
        </tbody>
    </table>
    </div>
    <!-- Inline Audit Feed (recently deleted/cancelled) -->
    <div style="margin-top:16px;">
        <h4 style="margin:6px 0 8px 0; font-size:14px; font-weight:700; color:var(--gray-900);">Recent Deleted / Cancelled</h4>
        <div class="inline-audit-wrapper" style="font-size:13px; color:var(--gray-700);">
                {% if audit_entries %}
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; gap:8px;">
                    <label style="font-size:13px;"><input type="checkbox" id="auditInlineSelectAll"> Select all</label>
                    <div style="display:flex;gap:8px;"><button class="btn-sm btn-view" id="exportAuditInlineBtn">Export Selected (PDF)</button><button class="btn-sm btn-delete" id="deleteAuditInlineBtn">Delete Selected</button></div>
                </div>
                <ul style="list-style:none; padding:0; margin:0; display:flex; flex-direction:column; gap:8px;">
                {% for a in audit_entries %}
                    <li class="cc-inline-audit-row" data-service-id="{{ a.service.id|default:'' }}" style="display:flex; justify-content:space-between; align-items:center; gap:12px; padding:8px; border-radius:8px; background:var(--gray-50);">
                        <input type="checkbox" class="auditRowCbInline" value="{{ a.id }}" style="margin-right:8px;">
                    <div style="flex:1;">
                        <div style="font-weight:600;">{{ a.get_event_type_display|capfirst }}{% if a.booking_id %} — #{{ a.booking_id }}{% endif %}</div>
                        <div style="font-size:13px; color:var(--gray-600);">{{ a.service.name|default:'-' }} &middot; {% if a.start %}{% timezone organization.timezone %}{{ a.start|date:'M d, Y g:i A' }}{% endtimezone %}{% else %}-{% endif %}</div>
                    </div>
                    <div style="display:flex; gap:8px; align-items:center;">
                        <button class="btn-sm btn-view" onclick="openAuditInline(this)" data-snapshot='{{ a.booking_snapshot|escapejs }}'>View</button>
                    </div>
                </li>
                {% endfor %}
            </ul>
            <div id="inlineAuditEmptyScoped" style="color:var(--gray-600); display:none; padding:8px 0;">No recent audited deletions for this member/service.</div>
            {% else %}
                <div style="color:var(--gray-600);">No recent audited deletions.</div>
            {% endif %}
        </div>
    </div>
</div>
<!-- Time Frame Modal -->
<!-- ========================= -->
<!-- TIME MODAL (Availability) -->
<!-- ========================= -->
<div id="timeModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.6); backdrop-filter:blur(4px);
    justify-content:center; align-items:center; z-index:9999;">
  <div style="background:white; padding:32px; border-radius:20px; width:440px; text-align:center; box-shadow:0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04); animation:modalSlideUp 0.3s ease-out;">
    <h3 style="margin:0 0 12px 0; font-size:22px; font-weight:700; color:var(--gray-900);">Set Available Time</h3>
    <p id="selectedDaysSummary" style="font-size:14px; color:var(--gray-600); margin-bottom:24px; line-height:1.5;"></p>

                <!-- Per-date ranges UI (each row shows Start / End on the left) -->
        <!-- Multiple ranges container for per-date overrides -->
        <div id="modalRangesContainer" class="availability-ui" style="display:flex; flex-direction:column; gap:8px; margin-top:12px;"></div>
        <div style="display:flex; justify-content:center; gap:8px; margin-top:8px;">
            <button type="button" id="addModalRangeBtn" style="padding:6px 10px; background:#007bff; color:white; border:none; border-radius:6px; cursor:pointer;">Add Range</button>
        </div>

    <div style="margin-top:24px; display:flex; justify-content:center; gap:10px; flex-wrap:wrap;">
      <button id="saveTimeBtn" 
              style="background:var(--primary-500); color:white; border:none; padding:12px 24px; 
                      border-radius:10px; cursor:pointer; font-weight:600; transition:all 0.2s ease; box-shadow:0 1px 3px rgba(0,0,0,0.1);">Save</button>
          <button id="resetToDefaultBtn" 
              style="background:var(--gray-600); color:white; border:none; padding:12px 24px; 
                  border-radius:10px; cursor:pointer; font-weight:600; transition:all 0.2s ease; box-shadow:0 1px 3px rgba(0,0,0,0.1);">Reset to default</button>
              <button id="makeUnavailableBtn"
                  style="background:var(--gray-700); color:white; border:none; padding:12px 24px; 
                         border-radius:10px; cursor:pointer; font-weight:600; transition:all 0.2s ease; box-shadow:0 1px 3px rgba(0,0,0,0.1); display:none;">Make Unavailable</button>
              <button id="makeAvailableBtn"
                  style="background:#06b6d4; color:white; border:none; padding:12px 24px; 
                         border-radius:10px; cursor:pointer; font-weight:600; transition:all 0.2s ease; box-shadow:0 1px 3px rgba(0,0,0,0.1); display:none;">Make Available</button>
      <button id="viewDayBtn" 
              style="background:var(--success-500); color:white; border:none; padding:12px 24px; 
                      border-radius:10px; cursor:pointer; font-weight:600; transition:all 0.2s ease; box-shadow:0 1px 3px rgba(0,0,0,0.1); display:none;">View Day Schedule</button>
      <button id="closeTimeBtn" 
              style="background:var(--gray-200); color:var(--gray-700); border:none; padding:12px 24px; border-radius:10px; cursor:pointer; font-weight:600; transition:all 0.2s ease;">Cancel</button>
    </div>    
  </div>
</div>

<!-- =============================== -->
<!-- Overrides Upgrade Required Modal -->
<!-- =============================== -->
<div id="ccOverridesUpgradeModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.6); backdrop-filter:blur(4px); justify-content:center; align-items:center; z-index:10050;">
    <div style="background:white; padding:28px; border-radius:20px; width:440px; max-width:92vw; text-align:left; box-shadow:0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04); animation:modalSlideUp 0.3s ease-out;">
        <h3 style="margin:0 0 10px 0; font-size:20px; font-weight:800; color:var(--gray-900);">Upgrade required</h3>
        <p style="margin:0; font-size:14px; color:var(--gray-600); line-height:1.5;">Upgrade to at least the Pro plan to override days (per-date availability).</p>
        <div style="margin-top:20px; display:flex; justify-content:flex-end; gap:10px; flex-wrap:wrap;">
            <button id="ccOverridesUpgradeCancelBtn" type="button" style="background:var(--gray-200); color:var(--gray-700); border:none; padding:10px 16px; border-radius:10px; cursor:pointer; font-weight:700; transition:all 0.2s ease;">Cancel</button>
            <button id="ccOverridesUpgradeGoBtn" type="button" style="background:var(--primary-500); color:white; border:none; padding:10px 16px; border-radius:10px; cursor:pointer; font-weight:700; transition:all 0.2s ease; box-shadow:0 1px 3px rgba(0,0,0,0.1);">{% if cc_app_mode %}OK{% else %}View pricing{% endif %}</button>
        </div>
    </div>
</div>

<!-- Focused mobile modal CSS (non-stacking): keep time inputs inline and use full width) -->
<style>
@media (max-width: 480px) {
    /* Expand modal to most of viewport so inputs can grow horizontally */
    #timeModal > div {
        width: 95vw !important;
        max-width: 95vw !important;
        padding: 16px !important;
        box-sizing: border-box !important;
    }

    /* Keep each range row inline — label + inputs + remove button */
    #modalRangesContainer .modal-range-row {
        display: flex !important;
        align-items: center !important;
        gap: 3px !important;
        justify-content: flex-start !important;
        width: 100% !important;
        box-sizing: border-box !important;
        flex-wrap: nowrap !important;
    }

    /* Fixed (small) label width so inputs can take remaining space */
    #modalRangesContainer .range-label {
        flex: 0 0 42px !important;
        min-width: 42px !important;
        text-align: right !important;
        font-size: 13px !important;
        white-space: nowrap !important;
    }

    /* Let time input container expand to fill available horizontal space */
    #modalRangesContainer .time-input-container {
        flex: 1 1 auto !important;
        min-width: 0 !important; /* allow flex child to shrink when needed */
    }

    /* Make time inputs occupy full width of their container and remove restrictive max-widths */
    #modalRangesContainer input[type="time"],
    #modalRangesContainer input.modal-range-start,
    #modalRangesContainer input.modal-range-end {
        width: 90% !important;
        max-width: none !important;
        padding: 5px 0px !important;
        font-size: 14px !important;
        box-sizing: border-box !important;
        line-height: 1.2 !important;
    }

    /* Keep remove button compact and not growing */
    #modalRangesContainer .remove-range-btn {
        flex: 0 0 auto !important;
        margin-left: 8px !important;
    }

    /* Slightly reduce modal actions to free horizontal room */
    #timeModal > div > div button,
    #timeModal button {
        padding: 9px 12px !important;
        font-size: 13px !important;
    }
}

@media (max-width: 360px) {
    /* Keep rows inline (no stacking) but tighten label and input sizing on very narrow screens */
    #timeModal > div {
        width: 95vw !important;
        max-width: 95vw !important;
        padding: 12px !important;
    }
    #modalRangesContainer .range-label {
        flex: 0 0 23px !important;
        min-width: 23px !important;
        font-size: 11px !important;
    }
    #modalRangesContainer input[type="time"] {
        font-size: 9px !important;
        padding: 6px 1px !important;
    }
    #timeModal button { padding: 8px 10px !important; font-size: 12px !important; }
}
</style>


<!--==========================-->
<!--TIME CIRCLES-->
<!--==========================-->
<div id="timeCirclesModal" style="display:none; flex-direction:column; padding:10px; position:fixed; inset:0; 
    background:rgba(0,0,0,0.6); backdrop-filter:blur(4px); justify-content:center; align-items:center; z-index:200000; animation:fadeIn 0.2s ease-out; overscroll-behavior:contain;">
    <div id="timeCirclesModalPanel" style="background:white; padding:32px; border-radius:20px; width:min(640px, 92vw); max-width:92vw; max-height:calc(100vh - 24px); box-sizing:border-box; overflow-y:auto; position:relative; box-shadow:0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04); animation:modalSlideUp 0.3s ease-out;">

        <!-- Header: Title + close, then a prominent Edit Service button -->
        <div id="ccTimeCirclesHeader" style="display:flex; flex-direction:column; gap:10px; margin-bottom:18px;">
            <div style="display:flex; align-items:flex-start; justify-content:space-between; gap:12px;">
                <div id="circleModalTitle" style="font-weight:800; font-size:16px; color:var(--gray-900); line-height:1.2; flex:1 1 auto; min-width:0;"></div>
                <button id="closeCirclesBtn" type="button" aria-label="Close" style="background:none; border:none; font-size:22px; line-height:1; cursor:pointer; color:#6b7280; padding:6px;">✖</button>
            </div>
            <a id="ccChangeInEditServiceBtn" href="#" style="display:none; padding:10px 12px; border-radius:12px; background:var(--primary-500); color:white; text-decoration:none; font-weight:900; width:100%; text-align:center;">Edit Service: Client Slot Settings &amp; Price</a>
        </div>

        <!-- Member-scope entry flow (shown only when a member is selected) -->
        <div id="ccDayScheduleMemberChooser" style="display:none; margin-bottom:18px; padding:20px; border-radius:12px; background:var(--gray-50);">
            <h3 style="margin:0 0 10px 0; font-size:16px; font-weight:700; color:var(--gray-900);">View Day Schedule</h3>
            <div id="ccDayScheduleChooserDesc" style="font-size:13px; color:var(--gray-700); margin-bottom:14px;">Choose what to view for this member on this day:</div>
            <div style="display:flex; flex-direction:column; gap:10px;">
                <button id="ccDayScheduleChooseServicesBtn" type="button" style="padding:10px 14px; border-radius:10px; border:1px solid var(--gray-200); background:white; font-weight:600; cursor:pointer; text-align:left;">
                    View services assigned to this member
                </button>
                <button id="ccDayScheduleChooseAppointmentsBtn" type="button" style="padding:10px 14px; border-radius:10px; border:1px solid var(--gray-200); background:white; font-weight:600; cursor:pointer; text-align:left;">
                    View all appointments for this day
                </button>
            </div>
        </div>

        <div id="ccDayScheduleMemberServices" style="display:none; margin-bottom:18px; padding:20px; border-radius:12px; background:var(--gray-50);">
            <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
                <h3 style="margin:0; font-size:16px; font-weight:700; color:var(--gray-900);">Services</h3>
                <button id="ccDayScheduleBackToChooserFromServices" type="button" style="padding:8px 10px; border-radius:8px; border:1px solid var(--gray-200); background:white; cursor:pointer;">Back</button>
            </div>
            <div id="ccDayScheduleMemberServicesList" style="margin-top:12px; display:flex; flex-direction:column; gap:8px;"></div>
        </div>

        <div id="ccDayScheduleMemberAppointments" style="display:none; margin-bottom:18px; padding:20px; border-radius:12px; background:var(--gray-50);">
            <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
                <h3 style="margin:0; font-size:16px; font-weight:700; color:var(--gray-900);">Appointments</h3>
                <button id="ccDayScheduleBackToChooserFromAppointments" type="button" style="padding:8px 10px; border-radius:8px; border:1px solid var(--gray-200); background:white; cursor:pointer;">Back</button>
            </div>
            <div id="ccDayScheduleMemberAppointmentsList" style="margin-top:12px; display:flex; flex-direction:column; gap:10px;"></div>
        </div>

        <!-- Fixed settings (service scope) -->
        <div id="clientTimeSettings" style="margin-bottom: 24px; padding:20px; border-radius:12px; background:var(--gray-50);">
            <h3 style="margin:0 0 12px 0; font-size:16px; font-weight:700; color:var(--gray-900);">Day Schedule Settings</h3>
            <div style="display:flex; gap:16px; align-items:flex-end; flex-wrap:wrap;">
                <div>
                    <div style="font-size:12px; color:var(--gray-600);">Duration</div>
                    <div id="ccDayScheduleHourBlockValue" style="font-weight:700; color:var(--gray-900);">—</div>
                </div>
                <div>
                    <div style="font-size:12px; color:var(--gray-600);">Increment</div>
                    <div id="ccDayScheduleIncrementValue" style="font-weight:700; color:var(--gray-900);">—</div>
                </div>
            </div>
            <div id="ccDayScheduleSettingsNote" style="margin-top:10px; font-size:13px; color:var(--gray-600);">
                Duration and increment are fixed based on the service’s settings.
            </div>
        </div>

    <div id="timeCirclesContainer" style="display:flex; flex-direction:column; gap:40px;"></div>

  </div>
</div>

<!-- ========================= -->
<!-- BOOKING MODAL (Client Info) -->
<!-- ========================= -->
<div id="bookingModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.6); backdrop-filter:blur(4px); justify-content:center; align-items:center; z-index:10000; animation:fadeIn 0.2s ease-out;">
  <div style="background:white; padding:32px; border-radius:20px; width:480px; box-shadow:0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04); animation:modalSlideUp 0.3s ease-out;">
    <h3 id="bookingTitle" style="margin:0 0 20px 0; font-size:22px; font-weight:700; color:var(--gray-900);">Booking Details</h3>
    <div style="margin-bottom:16px; padding:16px; background:var(--gray-50); border-radius:12px;">
      <p style="margin:8px 0; color:var(--gray-700);"><strong style="color:var(--gray-900); font-weight:600;">Client:</strong> <span id="clientName"></span></p>
      <p style="margin:8px 0; color:var(--gray-700);"><strong style="color:var(--gray-900); font-weight:600;">Lesson Type:</strong> <span id="lessonType"></span></p>
      <p style="margin:8px 0; color:var(--gray-700);"><strong style="color:var(--gray-900); font-weight:600;">Time:</strong> <span id="lessonTime"></span></p>
      <p style="margin:8px 0; color:var(--gray-700);"><strong style="color:var(--gray-900); font-weight:600;">Payment:</strong> <span id="paymentMethod"></span></p>
    </div>

    <div style="margin-top:24px; display:flex; justify-content:space-between; gap:12px;">
      <button id="viewClientBookingsBtn" 
              style="flex:1; background:var(--primary-500); color:white; border:none; padding:12px 20px; border-radius:10px; cursor:pointer; font-weight:600; transition:all 0.2s ease; box-shadow:0 1px 3px rgba(0,0,0,0.1);">
        View All Bookings
      </button>
      <button id="closeBookingBtn" 
              style="background:var(--gray-200); color:var(--gray-700); border:none; padding:12px 20px; border-radius:10px; cursor:pointer; font-weight:600; transition:all 0.2s ease;">
        Close
      </button>
    </div>
  </div>
</div>


{% endblock %}

<!-- -------------------------
     Calendar JS
------------------------- -->
{% block extra_scripts %}
<script>
document.addEventListener('DOMContentLoaded', function() {
        // Helper to read CSRF token from cookie (used by fetch calls)
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }
        const csrftoken = getCookie('csrftoken');

        // Ensure any fetch calls to our authenticated endpoints include
        // credentials by default so the session cookie is sent. Many existing
        // calls in this template call `fetch('/bus/...')` without options.
        // Monkeypatch window.fetch to inject `credentials: 'same-origin'`
        // for same-origin relative `/bus/` paths.
        (function ensureBusFetchCredentials(){
            try {
                const _origFetch = window.fetch.bind(window);
                window.fetch = function(input, init){
                    try{
                        // Resolve URL string when provided
                        const urlStr = (typeof input === 'string') ? input : (input && input.url) || '';
                        if (typeof urlStr === 'string' && urlStr.startsWith('/bus/')) {
                            init = init || {};
                            if (!('credentials' in init)) init.credentials = 'same-origin';
                        }
                    } catch(e) { /* non-fatal */ }
                    return _origFetch(input, init);
                };
            } catch(e) {
                // If monkeypatching fails, fall back to leaving fetch as-is.
                console.warn('Could not monkeypatch fetch for /bus/ credentials', e);
            }
        })();
        // -----------------------------
        // 1️⃣ Initialize default availability from server (fall back to sensible defaults)
        // -----------------------------
        const serverAvail = {{ coach_availability_json|default:"{}"|safe }} || {};
        // Per-member availability map (membership_id -> availability payload)
        const memberAvailMap = {{ member_availability_map|default:"{}"|safe }} || {};
        const weekdayNames = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];

        // Helper to build availability map from a server payload (same shape as coach_availability_json)
        function buildAvailabilityFromPayload(payload) {
            const out = {};
            for (let i = 0; i < 7; i++) out[i] = { start: '09:00', end: '17:00', unavailable: true, ranges: [] };

            if (Array.isArray(payload)) {
                    // Detect two common array shapes:
                    // 1) array of per-day objects: [{ day_of_week: 0, ranges: [...], unavailable: bool }, ...]
                    // 2) weekly-array: [ ['09:00-12:00'], [], ['10:00-11:00'], ... ] (index=0 => Sunday)
                    if (payload.length === 7 && (Array.isArray(payload[0]) || typeof payload[0] === 'string' || payload[0] === null)) {
                        // weekly-array shape
                        payload.forEach((slots, idx) => {
                            let ranges = [];
                            if (Array.isArray(slots)) ranges = slots.slice();
                            else if (typeof slots === 'string' && slots.trim() !== '') ranges = [slots];
                            out[idx].unavailable = !(ranges && ranges.length);
                            out[idx].ranges = ranges || [];
                            if (out[idx].ranges && out[idx].ranges.length) {
                                const first = out[idx].ranges[0];
                                if (first && first.includes('-')) {
                                    const [s,e] = first.split('-');
                                    out[idx].start = s.trim();
                                    out[idx].end = e.trim();
                                }
                            }
                        });
                    } else {
                        payload.forEach(item => {
                            let dayIndex = null;
                            if (typeof item.day_of_week === 'number') dayIndex = item.day_of_week;
                            else if (typeof item.day_of_week === 'string' && item.day_of_week.trim() !== '') dayIndex = parseInt(item.day_of_week, 10);
                            if (isNaN(dayIndex) || dayIndex === null) return;
                            dayIndex = ((dayIndex % 7) + 7) % 7;
                            out[dayIndex].unavailable = !!item.unavailable;
                            out[dayIndex].ranges = item.ranges || [];
                            if (item.ranges?.length > 0) {
                                const [start, end] = item.ranges[0].split('-');
                                out[dayIndex].start = start;
                                out[dayIndex].end = end;
                            }
                        });
                    }
                } else if (payload && typeof payload === 'object') {
                Object.entries(payload).forEach(([dayName, slots]) => {
                    try {
                        const dn = String(dayName).trim();
                        const idx = weekdayNames.indexOf(dn);
                        if (idx === -1) return;
                        if (!Array.isArray(slots) || slots.length === 0) {
                            out[idx].unavailable = true;
                            out[idx].ranges = [];
                        } else {
                            out[idx].unavailable = false;
                            out[idx].ranges = slots;
                            const first = slots[0];
                            if (first && first.includes('-')) {
                                const [s,e] = first.split('-');
                                out[idx].start = s.trim();
                                out[idx].end = e.trim();
                            }
                        }
                    } catch (e) { }
                });
            }
            return out;
        }

        // Helper: produce a server-format availability array marking all days unavailable
        function makeAllUnavailablePayload() {
            const names = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
            return names.map(n => ({ day: n, ranges: [], unavailable: true }));
        }

        // Build the canonical org-wide availability once
        const orgDefaultAvailability = buildAvailabilityFromPayload(serverAvail);

        // Build per-member availability map (membership_id -> availability)
        const memberDefaultAvailability = {};
        try {
            // First convert any server-provided member maps
            for (const k of Object.keys(memberAvailMap || {})) {
                try { memberDefaultAvailability[String(k)] = buildAvailabilityFromPayload(memberAvailMap[k]); } catch(e){ /* fallthrough */ }
            }
        } catch(e){ /* ignore */ }

        // Ensure every membership present in the selector has an entry (new members default to all-unavailable)
        try {
            const sel = document.getElementById('memberSelect');
            if (sel) {
                Array.from(sel.options).forEach(opt => {
                    try{
                        const val = opt.value;
                        if (!val) return;
                        // skip service pseudo-options
                        if (String(val).startsWith('svc:')) return;
                        if (!memberDefaultAvailability[String(val)]){
                            memberDefaultAvailability[String(val)] = buildAvailabilityFromPayload(makeAllUnavailablePayload());
                        }
                    }catch(e){}
                });
            } else {
                // fallback: ensure known MEMBERS have entries
                if (Array.isArray(MEMBERS)){
                    for (const m of MEMBERS){
                        const mid = String(m.id);
                        if (!memberDefaultAvailability[mid]) memberDefaultAvailability[mid] = buildAvailabilityFromPayload(makeAllUnavailablePayload());
                    }
                }
            }
        } catch(e){ /* ignore */ }

        // The live defaultAvailability object used by the UI. Initialized to org defaults.
        const defaultAvailability = JSON.parse(JSON.stringify(orgDefaultAvailability));

        // -----------------------------
        // Default range helper for per-date “Make Available”
        // -----------------------------
        function _ccParseTimeToMinutes(t) {
            try {
                if (!t || typeof t !== 'string') return null;
                const parts = t.split(':');
                const h = parseInt((parts[0] || '0').trim(), 10);
                const m = parseInt((parts[1] || '0').trim(), 10);
                if (isNaN(h) || isNaN(m)) return null;
                return (h * 60) + m;
            } catch (e) { return null; }
        }

        function _ccMinutesToTime(mins) {
            try {
                const m = Math.max(0, Math.min(24 * 60, parseInt(mins, 10)));
                const hh = String(Math.floor(m / 60)).padStart(2, '0');
                const mm = String(m % 60).padStart(2, '0');
                return `${hh}:${mm}`;
            } catch (e) { return '09:00'; }
        }

        function _ccIntervalsFromAvailabilityMap(avMap, dow) {
            const out = [];
            try {
                if (!avMap) return out;
                const info = avMap[dow] || {};
                const ranges = (info.ranges && info.ranges.length)
                    ? info.ranges
                    : ((info.start && info.end) ? [`${info.start}-${info.end}`] : []);
                (ranges || []).forEach(r => {
                    try {
                        if (!r || !String(r).includes('-')) return;
                        const parts = String(r).split('-');
                        const s = (parts[0] || '').trim();
                        const e = (parts[1] || '').trim();
                        const sm = _ccParseTimeToMinutes(s);
                        const em = _ccParseTimeToMinutes(e);
                        if (sm === null || em === null) return;
                        if (em <= sm) return;
                        out.push([sm, em]);
                    } catch (e) { /* ignore */ }
                });
                out.sort((a, b) => a[0] - b[0]);
            } catch (e) { /* ignore */ }
            return out;
        }

        function _ccIntersectIntervals(a, b) {
            const out = [];
            try {
                const aa = Array.isArray(a) ? a : [];
                const bb = Array.isArray(b) ? b : [];
                for (const ia of aa) {
                    for (const ib of bb) {
                        const s = Math.max(ia[0], ib[0]);
                        const e = Math.min(ia[1], ib[1]);
                        if (e > s) out.push([s, e]);
                    }
                }
                out.sort((x, y) => x[0] - y[0]);
            } catch (e) { /* ignore */ }
            return out;
        }

        function ccDefaultRangeForTargetDate(target, dateStr) {
            try {
                const d = parseYMD(dateStr);
                const dow = d.getDay();

                // Service-scope: prefer the service’s effective weekly_map (may be inherited)
                // but always fall back to member-overall (solo) or overlap (group) windows.
                if (target && String(target).startsWith('svc:')) {
                    const svcId = String(target).slice(4);
                    const svc = SERVICES.find(s => String(s.id) === String(svcId)) || null;
                    if (svc && svc.weekly_map) {
                        try {
                            const svcBuilt = buildAvailabilityFromPayload(svc.weekly_map);
                            const svcIntervals = _ccIntervalsFromAvailabilityMap(svcBuilt, dow);
                            if (svcIntervals.length) {
                                return { start: _ccMinutesToTime(svcIntervals[0][0]), end: _ccMinutesToTime(svcIntervals[0][1]) };
                            }
                        } catch (e) { /* ignore */ }
                    }

                    const assigned = (svc && typeof getAssignedMembersForService === 'function')
                        ? (getAssignedMembersForService(svc) || [])
                        : [];

                    if (assigned.length === 1) {
                        const mid = String(assigned[0]);
                        // Match backend semantics: member overall availability = member weekly if set, else org weekly.
                        const memberMap = memberDefaultAvailability[mid] || null;
                        let ints = _ccIntervalsFromAvailabilityMap(memberMap, dow);
                        if (!ints.length) ints = _ccIntervalsFromAvailabilityMap(orgDefaultAvailability, dow);
                        if (ints.length) return { start: _ccMinutesToTime(ints[0][0]), end: _ccMinutesToTime(ints[0][1]) };
                        return null;
                    }

                    if (assigned.length >= 2) {
                        // Match backend semantics for group services: each member falls back to org weekly.
                        const effectiveIntervals = assigned.map(mid => {
                            try {
                                const m = memberDefaultAvailability[String(mid)] || null;
                                let iv = _ccIntervalsFromAvailabilityMap(m, dow);
                                if (!iv.length) iv = _ccIntervalsFromAvailabilityMap(orgDefaultAvailability, dow);
                                return iv;
                            } catch (e) { return []; }
                        });

                        if (effectiveIntervals.some(iv => !iv || !iv.length)) return null;
                        let overlap = effectiveIntervals[0];
                        for (let i = 1; i < effectiveIntervals.length; i++) {
                            overlap = _ccIntersectIntervals(overlap, effectiveIntervals[i]);
                            if (!overlap.length) break;
                        }
                        if (overlap.length) return { start: _ccMinutesToTime(overlap[0][0]), end: _ccMinutesToTime(overlap[0][1]) };
                        return null;
                    }

                    // Unassigned service: default within org overall weekly windows
                    const orgInts = _ccIntervalsFromAvailabilityMap(orgDefaultAvailability, dow);
                    if (orgInts.length) return { start: _ccMinutesToTime(orgInts[0][0]), end: _ccMinutesToTime(orgInts[0][1]) };
                    return null;
                }

                // Member-scope
                if (target && memberDefaultAvailability[String(target)]) {
                    // Match backend semantics: member overall availability falls back to org weekly.
                    let ints = _ccIntervalsFromAvailabilityMap(memberDefaultAvailability[String(target)], dow);
                    if (!ints.length) ints = _ccIntervalsFromAvailabilityMap(orgDefaultAvailability, dow);
                    if (ints.length) return { start: _ccMinutesToTime(ints[0][0]), end: _ccMinutesToTime(ints[0][1]) };
                    return null;
                }

                // Org-scope
                const orgInts = _ccIntervalsFromAvailabilityMap(orgDefaultAvailability, dow);
                if (orgInts.length) return { start: _ccMinutesToTime(orgInts[0][0]), end: _ccMinutesToTime(orgInts[0][1]) };
                return null;
            } catch (e) {
                return null;
            }
        }

    // -----------------------------
    // 2️⃣ Helper: is date in the past
    // -----------------------------
    function isPastDate(dateStr) {
        const today = new Date();
        const date = parseYMD(dateStr);
        const todayMidnight = new Date(today.getFullYear(), today.getMonth(), today.getDate());
        return date < todayMidnight;
    }

    
    function updateUnavailableDays() {
        // Service-scope parity: when a specific service is selected (svc:<id>),
        // use the same backend availability computation as the public booking page.
        // This ensures month visuals reflect *bookable* starts after applying bookings,
        // buffers, min notice, max booking days, overrides, resources, and freezes.
        try {
            if (typeof refreshServiceScopeMonthParity === 'function' && SELECTED_MEMBER && String(SELECTED_MEMBER).startsWith('svc:')) {
                // Only short-circuit to parity mode if we can resolve the selected service.
                // If a stale selection exists in localStorage (deleted service, etc.),
                // falling through ensures org/week-based month classes still update.
                const _svc = (typeof _svcForSelectedScope === 'function') ? _svcForSelectedScope() : null;
                if (_svc) {
                    refreshServiceScopeMonthParity();
                    // Still keep the overrides table updated (it lists per-date overrides regardless
                    // of whether a day has remaining slots).
                    try { renderOverridesTable(); } catch (e) { /* ignore */ }
                    return;
                }
            }
        } catch (e) { /* fall through to legacy */ }

        // Compute per-date full-day blocks from background events (so per-date overrides take precedence)
        const blockedDates = new Set();
        const availableOverrideDates = new Set();
        try {
            calendar.getEvents().forEach(ev => {
                try {
                    const props = ev.extendedProps || {};
                    if (props.override_type === 'blocked') {
                        blockedDates.add(ev.startStr.split('T')[0]);
                    } else if (props.override_type === 'available') {
                        availableOverrideDates.add(ev.startStr.split('T')[0]);
                    }
                } catch (e) { /* ignore per-event parse errors */ }
            });
        } catch (e) { /* ignore if calendar.getEvents fails */ }

        document.querySelectorAll('.fc-daygrid-day').forEach(dayCell => {
            const dateStr = dayCell.dataset.date; // e.g., "2025-11-19"
            if (!dateStr) return;
            const dayIndex = parseYMD(dateStr).getDay(); // 0=Sunday..6=Saturday (local parse)
            const isPast = isPastDate(dateStr);

            // Past dates should be visually distinct (greyed circle) but NOT treated as
            // "unavailable" in the sense of future availability settings. Unavailable
            // is a future-facing user setting and should not be applied retroactively.
            if (isPast) {
                dayCell.classList.remove('fc-day-unavailable');
                dayCell.classList.remove('fc-day-available');
                dayCell.classList.add('fc-day-past');
                const num = dayCell.querySelector('.fc-daygrid-day-number');
                if (num) {
                    num.classList.add('past-day');
                    num.classList.remove('unavailable-number');
                    num.style.cursor = 'default';
                }
                return; // skip further unavailable/available processing for past dates
            }

            // Use classes to indicate available/unavailable so styles remain consistent
            // Precedence: per-date full-day blocks (unavailable) > per-date available overrides > weekly defaults
            if (blockedDates.has(dateStr)) {
                dayCell.classList.add('fc-day-unavailable');
                dayCell.classList.remove('fc-day-available');
                const num = dayCell.querySelector('.fc-daygrid-day-number');
                if (num) {
                    num.classList.add('unavailable-number');
                    num.style.cursor = 'pointer';
                }
            } else if (availableOverrideDates.has(dateStr)) {
                dayCell.classList.add('fc-day-available');
                dayCell.classList.remove('fc-day-unavailable');
                const num = dayCell.querySelector('.fc-daygrid-day-number');
                if (num) {
                    num.classList.remove('unavailable-number');
                    num.style.cursor = 'pointer';
                }
            } else if (defaultAvailability[dayIndex]?.unavailable) {
                dayCell.classList.add('fc-day-unavailable');
                dayCell.classList.remove('fc-day-available');
                const num = dayCell.querySelector('.fc-daygrid-day-number');
                if (num) {
                    num.classList.add('unavailable-number');
                    num.style.cursor = 'pointer';
                }
            } else {
                dayCell.classList.add('fc-day-available');
                dayCell.classList.remove('fc-day-unavailable');
                const num = dayCell.querySelector('.fc-daygrid-day-number');
                if (num) {
                    num.classList.remove('unavailable-number');
                    num.style.cursor = 'pointer';
                }
            }
        });
        // After updating day classes, refresh the overrides table so it reflects per-date overrides
        try { renderOverridesTable(); } catch (e) { console.warn('renderOverridesTable failed', e); }
    }

    // -----------------------------
    // Service-scope parity (month)
    // -----------------------------
    let __svcParityToken = 0;
    let __svcParityLastKey = null;
    let __svcParityLastMap = null;
    let __svcParityReadyRetries = 0;
    let __svcParityReadyLastAttempt = null;

    function _invalidateServiceScopeParityCache() {
        // Any per-date override creation/deletion can change real bookable availability.
        // When service scope is selected we must force a re-computation so day circles
        // flip immediately (and don't get stuck on a cached month map).
        try { __svcParityLastKey = null; } catch (e) {}
        try { __svcParityLastMap = null; } catch (e) {}
        // Bump token to cancel any in-flight background verification
        try { __svcParityToken = (__svcParityToken || 0) + 1; } catch (e) {}
    }

    function _svcForSelectedScope() {
        try {
            if (!SELECTED_MEMBER) return null;
            const raw = String(SELECTED_MEMBER);
            if (!raw.startsWith('svc:')) return null;
            const svcId = Number(raw.slice(4)) || null;
            if (!svcId) return null;
            const svc = (typeof svcById === 'function') ? svcById(svcId) : null;
            if (!svc || !svc.slug) return null;
            return svc;
        } catch (e) {
            return null;
        }
    }

    function _visibleDayDates() {
        const out = [];
        try {
            // Only include in-month cells; FullCalendar still renders out-of-month cells
            // even if we hide them via CSS.
            document.querySelectorAll('.fc-daygrid-day[data-date]:not(.fc-day-other)').forEach(el => {
                const d = el.getAttribute('data-date');
                if (d) out.push(d);
            });
        } catch (e) {}
        // De-dupe while preserving order
        try { return Array.from(new Set(out)); } catch (e) { return out; }
    }

    function _toIsoLocal(dateStr, hh, mm, ss) {
        // dateStr: YYYY-MM-DD
        try {
            const parts = String(dateStr).split('-');
            const y = Number(parts[0]);
            const m = Number(parts[1]);
            const d = Number(parts[2]);
            const pad = n => String(n).padStart(2, '0');
            return `${y}-${pad(m)}-${pad(d)}T${pad(hh)}:${pad(mm)}:${pad(ss || 0)}`;
        } catch (e) {
            return `${dateStr}T${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:00`;
        }
    }

    function _applyServiceScopeDayClasses(dayHasSlots) {
        try {
            document.querySelectorAll('.fc-daygrid-day').forEach(dayCell => {
                const dateStr = dayCell.dataset.date;
                if (!dateStr) return;
                const isPast = isPastDate(dateStr);
                if (isPast) {
                    dayCell.classList.remove('fc-day-unavailable');
                    dayCell.classList.remove('fc-day-available');
                    dayCell.classList.add('fc-day-past');
                    const num = dayCell.querySelector('.fc-daygrid-day-number');
                    if (num) {
                        num.classList.add('past-day');
                        num.classList.remove('unavailable-number');
                        num.style.cursor = 'default';
                    }
                    return;
                }

                const enabled = !!(dayHasSlots && dayHasSlots[dateStr]);
                if (enabled) {
                    dayCell.classList.add('fc-day-available');
                    dayCell.classList.remove('fc-day-unavailable');
                } else {
                    dayCell.classList.add('fc-day-unavailable');
                    dayCell.classList.remove('fc-day-available');
                }

                dayCell.style.background = 'transparent';
                const num = dayCell.querySelector('.fc-daygrid-day-number');
                if (num) {
                    // Keep clickable for override editing even when unavailable
                    num.style.cursor = 'pointer';
                    if (enabled) num.classList.remove('unavailable-number');
                    else num.classList.add('unavailable-number');
                }
            });
            // Now that service-scope parity has updated the month UI, recompute the
            // fully-booked protection set (this is async relative to events refetch).
            try { if (typeof _recomputeFullyBookedOutDates === 'function') _recomputeFullyBookedOutDates(); } catch (e) {}
        } catch (e) { console.warn('applyServiceScopeDayClasses failed', e); }
    }

    // -----------------------------
    // Service-scope calendar loading UX
    // -----------------------------
    function _ensureCalendarLoadingOverlay() {
        try {
            const calEl = document.getElementById('calendar');
            if (!calEl) return null;
            let overlay = calEl.querySelector('.cc-calendar-loading-overlay');
            if (overlay) return overlay;
            overlay = document.createElement('div');
            overlay.className = 'cc-calendar-loading-overlay';
            overlay.innerHTML = `
                <div class="cc-calendar-spinner" aria-hidden="true"></div>
                <div class="cc-calendar-loading-text">Loading availability…</div>
            `;
            calEl.appendChild(overlay);
            return overlay;
        } catch (e) {
            return null;
        }
    }

    function _setCalendarLoading(isLoading, message) {
        try {
            const calEl = document.getElementById('calendar');
            if (!calEl) return;
            const overlay = _ensureCalendarLoadingOverlay();
            if (overlay) {
                const textEl = overlay.querySelector('.cc-calendar-loading-text');
                if (textEl && typeof message === 'string' && message.trim()) {
                    textEl.textContent = message;
                } else if (textEl) {
                    textEl.textContent = 'Loading availability…';
                }
            }
            if (isLoading) calEl.classList.add('cc-calendar-loading');
            else calEl.classList.remove('cc-calendar-loading');
        } catch (e) { /* ignore */ }
    }

    // -----------------------------
    // Service-scope: no remaining availability (click-triggered modal)
    // -----------------------------
    function _ccSelectedServiceNameForNoAvailUI() {
        try {
            const svc = (typeof _svcForSelectedScope === 'function') ? _svcForSelectedScope() : null;
            const name = svc ? String((svc.name || svc.title || '')).trim() : '';
            if (name) return name;

            // Fallback 1: use the current scope label shown in the UI.
            try {
                const lbl = document.getElementById('ccScopeMenuButtonLabel');
                const t = lbl ? String(lbl.textContent || '').trim() : '';
                if (t) {
                    // Team labels can be "Member - Service"; we only want the service part.
                    const parts = t.split(' - ').map(s => String(s || '').trim()).filter(Boolean);
                    return parts.length ? parts[parts.length - 1] : t;
                }
            } catch (e) {}

            // Fallback 2: compute label from current selection.
            try {
                if (typeof getSelectionLabel === 'function') {
                    const t = String(getSelectionLabel() || '').trim();
                    if (t) {
                        const parts = t.split(' - ').map(s => String(s || '').trim()).filter(Boolean);
                        return parts.length ? parts[parts.length - 1] : t;
                    }
                }
            } catch (e) {}

            return 'This service';
        } catch (e) {
            return 'This service';
        }
    }

    function _ccShouldShowNoAvailModalForSelection() {
        try {
            const isSvcScope = !!(SELECTED_MEMBER && String(SELECTED_MEMBER).startsWith('svc:'));
            if (!isSvcScope) return false;
            // Only applies to Pro (non-Team) where services partition overall availability.
            if (!(IS_PRO && !IS_TEAM)) return false;
            return !!window.__ccServiceScopeNoAvailability;
        } catch (e) {
            return false;
        }
    }

    function _ensureSvcNoAvailabilityClickModal() {
        try {
            let modal = document.getElementById('ccSvcNoAvailabilityClickModal');
            if (modal) return modal;

            modal = document.createElement('div');
            modal.id = 'ccSvcNoAvailabilityClickModal';
            modal.style.display = 'none';
            modal.style.position = 'fixed';
            modal.style.inset = '0';
            modal.style.background = 'rgba(0,0,0,0.58)';
            modal.style.backdropFilter = 'blur(3px)';
            modal.style.zIndex = '300000';
            modal.style.alignItems = 'center';
            modal.style.justifyContent = 'center';
            modal.style.padding = '18px';
            modal.style.pointerEvents = 'auto';

            modal.innerHTML = `
                <div style="width:min(560px, 92vw); background: rgba(255,255,255,0.98); border: 1px solid rgba(226,232,240,0.95); border-radius: 16px; box-shadow: 0 22px 50px rgba(15,23,42,0.35); padding: 16px; position: relative;">
                    <button type="button" id="ccSvcNoAvailabilityClickModalX" aria-label="Close" style="position:absolute; right:12px; top:10px; width:34px; height:34px; border-radius:999px; border:1px solid rgba(148,163,184,0.35); background: rgba(148,163,184,0.10); color: #0f172a; cursor:pointer; font-size:18px; line-height:1;">×</button>
                    <div id="ccSvcNoAvailabilityClickModalTitle" style="font-weight: 800; font-size: 15px; color: var(--gray-900); padding-right: 44px;"></div>
                    <div id="ccSvcNoAvailabilityClickModalBody" style="margin-top: 8px; font-size: 13px; line-height: 1.4; color: var(--gray-700);"></div>
                </div>
            `;

            document.body.appendChild(modal);

            const closeX = document.getElementById('ccSvcNoAvailabilityClickModalX');
            if (closeX) {
                closeX.addEventListener('click', function(){
                    try {
                        modal.style.display = 'none';
                        document.body.style.overflow = '';
                    } catch (e) {}
                });
            }
            return modal;
        } catch (e) {
            return null;
        }
    }

    function ccShowSvcNoAvailabilityClickModal() {
        try {
            const modal = _ensureSvcNoAvailabilityClickModal();
            if (!modal) return;
            const titleEl = document.getElementById('ccSvcNoAvailabilityClickModalTitle');
            const bodyEl = document.getElementById('ccSvcNoAvailabilityClickModalBody');

            const svcName = _ccSelectedServiceNameForNoAvailUI();
            const prefix = (svcName && svcName !== 'This service') ? svcName : 'This service';
            const human = (prefix === 'This service') ? 'this service' : svcName;

            if (titleEl) titleEl.textContent = `${prefix} has no remaining availability`;
            if (bodyEl) {
                bodyEl.innerHTML = '';
                const line1 = document.createElement('div');
                line1.textContent = `There’s no open time left in your schedule for ${human}.`;
                bodyEl.appendChild(line1);
                const line2 = document.createElement('div');
                line2.style.marginTop = '8px';
                line2.textContent = 'To make room, remove days/times from other services (reduce their weekly availability) so this service has open space.';
                bodyEl.appendChild(line2);
                const line3 = document.createElement('div');
                line3.style.marginTop = '8px';
                line3.textContent = 'Or add more day(s)/time(s) to your overall availability so that the service has space to open.';
                bodyEl.appendChild(line3);
            }

            modal.style.display = 'flex';
            try { document.body.style.overflow = 'hidden'; } catch (e) {}
        } catch (e) { /* ignore */ }
    }

    function ccHideSvcNoAvailabilityClickModal() {
        try {
            const modal = document.getElementById('ccSvcNoAvailabilityClickModal');
            if (!modal) return;
            modal.style.display = 'none';
            document.body.style.overflow = '';
        } catch (e) { /* ignore */ }
    }

    function _ccUpdateSvcNoAvailabilityOverlayContent() {
        try {
            const titleEl = document.getElementById('ccSvcNoAvailabilityTitle');
            const bodyEl = document.getElementById('ccSvcNoAvailabilityBody');
            if (!titleEl || !bodyEl) return;

            const svcName = _ccSelectedServiceNameForNoAvailUI();
            const prefix = (svcName && svcName !== 'This service') ? svcName : 'This service';

            titleEl.textContent = `${prefix} has no remaining availability`;
            bodyEl.innerHTML = '';

            const line1 = document.createElement('div');
            line1.textContent = `There’s no open time left in your schedule for ${prefix === 'This service' ? 'this service' : svcName}. Weekly availability and date overrides are disabled for this service scope.`;
            bodyEl.appendChild(line1);

            const line2 = document.createElement('div');
            line2.style.marginTop = '8px';
            line2.textContent = 'To make room, remove days/times from other services (reduce their weekly availability) so this service has open space.';
            bodyEl.appendChild(line2);

            const line3 = document.createElement('div');
            line3.style.marginTop = '8px';
            line3.textContent = 'Or add more day(s)/time(s) to your overall availability so that the service has space to open.';
            bodyEl.appendChild(line3);
        } catch (e) { /* ignore */ }
    }

    function _ensureSvcNoAvailabilityOverlay() {
        try {
            const calEl = document.getElementById('calendar');
            if (!calEl) return null;

            let overlay = document.getElementById('ccSvcNoAvailabilityOverlay');
            if (overlay) return overlay;

            overlay = document.createElement('div');
            overlay.id = 'ccSvcNoAvailabilityOverlay';
            overlay.className = 'cc-svc-no-availability-overlay';
            overlay.innerHTML = `
                <div class="panel">
                    <div class="title" id="ccSvcNoAvailabilityTitle">This service has no remaining availability</div>
                    <div class="body" id="ccSvcNoAvailabilityBody"></div>
                    <div class="actions">
                        <button type="button" class="btn" id="ccSvcNoAvailabilityGoOverall">Go to Overall Availability</button>
                        <button type="button" class="btn secondary" id="ccSvcNoAvailabilityClose">Close</button>
                    </div>
                </div>
            `;
            calEl.appendChild(overlay);

            try { _ccUpdateSvcNoAvailabilityOverlayContent(); } catch (e) {}

            // Wire buttons once
            try {
                const goBtn = document.getElementById('ccSvcNoAvailabilityGoOverall');
                if (goBtn) {
                    goBtn.addEventListener('click', function(){
                        try {
                            if (typeof applySelection === 'function') applySelection(null);
                            overlay.style.display = 'none';
                        } catch (e) {}
                    });
                }
                const closeBtn = document.getElementById('ccSvcNoAvailabilityClose');
                if (closeBtn) {
                    closeBtn.addEventListener('click', function(){
                        try { overlay.style.display = 'none'; } catch (e) {}
                    });
                }
            } catch (e) {}

            return overlay;
        } catch (e) {
            return null;
        }
    }

    function _ccSelectedServiceScopeIsFullyBlockedAllWeek() {
        try {
            const isSvcScope = !!(SELECTED_MEMBER && String(SELECTED_MEMBER).startsWith('svc:'));
            if (!isSvcScope) return false;
            const svcId = String(SELECTED_MEMBER).slice(4);

            // Only hard-disable the calendar for Pro (non-Team) service scopes where services
            // partition overall availability. Team/member-based services should remain editable.
            try {
                if (!(IS_PRO && !IS_TEAM)) return false;
            } catch (e) {
                return false;
            }

            // Recompute constraints on-demand so we don't accidentally keep a stale
            // "fully blocked" state when the user switches services.
            let c = null;
            try {
                if (typeof _ccGetWeeklyEditorConstraints === 'function') {
                    c = _ccGetWeeklyEditorConstraints() || null;
                    try { window.__ccWeeklyServiceConstraints = c || null; } catch (e) {}
                }
            } catch (e) {
                c = null;
            }
            // Only fall back to cached constraints if they match the current service.
            if (!c) {
                const cached = window.__ccWeeklyServiceConstraints || null;
                try {
                    if (cached && String(cached.serviceId || '') === String(svcId)) c = cached;
                } catch (e) { c = null; }
            } else {
                try {
                    if (String(c.serviceId || '') !== String(svcId)) c = null;
                } catch (e) { c = null; }
            }
            if (!c || !Array.isArray(c.days) || c.days.length < 7) return false;

            // If this service is tied to staff availability (has assigned members), do not treat
            // it as globally read-only even if remaining is currently 0.
            try {
                if (Array.isArray(c.assignedMembers) && c.assignedMembers.length) return false;
            } catch (e) {}

            // Fully blocked when every weekday has no remaining time.
            return c.days.every(d => !!(d && d.fullyBlocked));
        } catch (e) {
            return false;
        }
    }

    function ccUpdateServiceScopeDisabledUI() {
        try {
            const calEl = document.getElementById('calendar');
            if (!calEl) return;
            const controlsEl = document.getElementById('calendar-controls');

            const noAvail = _ccSelectedServiceScopeIsFullyBlockedAllWeek();
            try { window.__ccServiceScopeNoAvailability = !!noAvail; } catch (e) {}

            // If the service has no remaining availability, make sure the month view reflects it:
            // - clear any existing selection highlight
            // - ensure month circles refresh for the current selection
            try {
                if (noAvail) {
                    try { if (typeof selectedDates !== 'undefined' && selectedDates && typeof selectedDates.clear === 'function') selectedDates.clear(); } catch (e) {}
                    try { document.querySelectorAll('.fc-daygrid-day-number.selected').forEach(el => el.classList.remove('selected')); } catch (e) {}
                    try { if (typeof updateUnavailableDays === 'function') updateUnavailableDays(); } catch (e) {}
                    try { setTimeout(function(){ try { if (typeof updateUnavailableDays === 'function') updateUnavailableDays(); } catch (e) {} }, 120); } catch (e) {}
                }
            } catch (e) { /* ignore */ }

            // Do NOT auto-disable or overlay the calendar. The calendar should still render
            // (it will show grey day circles when there are no bookable times). We only show
            // a full-screen modal when the user interacts with the calendar.
            try { calEl.classList.remove('cc-svc-no-availability'); } catch (e) {}
            try { if (controlsEl) controlsEl.classList.remove('cc-disabled'); } catch (e) {}
            try { const overlay = document.getElementById('ccSvcNoAvailabilityOverlay'); if (overlay) overlay.style.display = 'none'; } catch (e) {}
            try { if (!noAvail) ccHideSvcNoAvailabilityClickModal(); } catch (e) {}
        } catch (e) {
            /* ignore */
        }
    }

    async function refreshServiceScopeMonthParity() {
        const svc = _svcForSelectedScope();
        if (!svc) return;

        // If this service has no explicitly saved weekly availability windows, it must
        // remain unavailable until the user manually enables days/ranges and saves.
        // We still allow explicit per-date availability overrides to show as available.
        const svcHasExplicitWeekly = !!(svc && (svc.has_service_weekly_windows || false));
        const blockedDates = new Set();
        const availableOverrideDates = new Set();
        try {
            calendar.getEvents().forEach(ev => {
                try {
                    const props = ev.extendedProps || {};
                    if (props.override_type === 'blocked') {
                        blockedDates.add(ev.startStr.split('T')[0]);
                    } else if (props.override_type === 'available') {
                        availableOverrideDates.add(ev.startStr.split('T')[0]);
                    }
                } catch (e) { /* ignore */ }
            });
        } catch (e) { /* ignore */ }
        const dates = _visibleDayDates();
        if (!dates || dates.length === 0) {
            // FullCalendar sometimes hasn't attached month day cells yet (or is mid-rerender)
            // when we try to compute parity. Retry a few times so initial-load and scope-switch
            // don't require a hard refresh.
            try {
                const attemptKey = `${svc.slug}|${String(SELECTED_MEMBER || '')}`;
                if (__svcParityReadyLastAttempt !== attemptKey) {
                    __svcParityReadyLastAttempt = attemptKey;
                    __svcParityReadyRetries = 0;
                }
                if (__svcParityReadyRetries < 10) {
                    __svcParityReadyRetries += 1;
                    setTimeout(function(){
                        try { refreshServiceScopeMonthParity(); } catch (e) {}
                    }, 60);
                }
            } catch (e) {}
            return;
        }

        // If the service has no explicit weekly windows, treat the month as unavailable.
        // Only show explicit per-date availability overrides as available.
        if (!svcHasExplicitWeekly) {
            try {
                const today = new Date();
                const todayMidnight = new Date(today.getFullYear(), today.getMonth(), today.getDate());
                const dayHasSlots = {};
                for (const dateStr of dates) {
                    let enabled = false;
                    try {
                        const d = parseYMD(dateStr);
                        if (d < todayMidnight) {
                            enabled = false;
                        } else if (blockedDates.has(dateStr)) {
                            enabled = false;
                        } else if (availableOverrideDates.has(dateStr)) {
                            enabled = true;
                        } else {
                            enabled = false;
                        }
                    } catch (e) {
                        enabled = false;
                    }
                    dayHasSlots[dateStr] = enabled;
                }

                _applyServiceScopeDayClasses(dayHasSlots);
                try { renderOverridesTable(); } catch (e) { /* ignore */ }
            } finally {
                try { _setCalendarLoading(false); } catch (e) {}
            }
            return;
        }

        const token = ++__svcParityToken;
        const sorted = dates.slice().sort();
        const minDate = sorted[0];
        const maxDate = sorted[sorted.length - 1];
        const key = `${svc.slug}|${minDate}|${maxDate}`;

        // Fast path: re-apply cached results for the same visible month/service
        if (__svcParityLastKey === key && __svcParityLastMap) {
            _applyServiceScopeDayClasses(__svcParityLastMap);
            try { _setCalendarLoading(false); } catch (e) {}
            return;
        }

        // Grey out calendar until parity finishes (prevents confusing partial render)
        try { _setCalendarLoading(true, 'Loading availability…'); } catch (e) {}

        const today = new Date();
        const todayMidnight = new Date(today.getFullYear(), today.getMonth(), today.getDate());

        // Fetch server-effective settings (once) + batch summary in parallel.
        const cacheBuster = `&_t=${Date.now()}`;
        let eff = null;
        let summary = {};
        let batchOk = false;
        const startIsoRange = _toIsoLocal(minDate, 0, 0, 0);
        const endIsoRange = _toIsoLocal(maxDate, 23, 59, 59);
        try {
            const effUrl = `/bus/${orgSlug}/services/${svc.slug}/effective/?date=${encodeURIComponent(minDate)}`;
            const batchUrl = `/bus/${orgSlug}/services/${svc.slug}/availability/batch/?start=${encodeURIComponent(startIsoRange)}&end=${encodeURIComponent(endIsoRange)}${cacheBuster}`;
            const [effResp, batchResp] = await Promise.all([
                fetch(effUrl, { credentials: 'same-origin' }).catch(() => null),
                fetch(batchUrl, { credentials: 'same-origin' }).catch(() => null),
            ]);
            try { if (effResp && effResp.ok) eff = await effResp.json(); } catch (e) { eff = null; }
            try {
                if (batchResp && batchResp.ok) {
                    batchOk = true;
                    summary = await batchResp.json();
                }
            } catch (e) {
                batchOk = false;
                summary = {};
            }
        } catch (e) {
            eff = null;
            summary = {};
            batchOk = false;
        }

        // If the parity batch endpoint is unavailable (network error, 403/404, etc.),
        // fall back to the weekly_map-based month styling instead of greying out the
        // entire month as "no slots".
        if (!batchOk) {
            try {
                const weekly = Array.isArray(svc.weekly_map) ? svc.weekly_map : [[],[],[],[],[],[],[]];
                const dayHasSlots = {};
                for (const dateStr of dates) {
                    let enabled = false;
                    try {
                        if (blockedDates.has(dateStr)) enabled = false;
                        else if (availableOverrideDates.has(dateStr)) enabled = true;
                        else if (!svcHasExplicitWeekly) {
                            enabled = false;
                        } else {
                            const d = parseYMD(dateStr);
                            const dow = d.getDay();
                            enabled = !!(weekly && weekly[dow] && Array.isArray(weekly[dow]) && weekly[dow].length > 0);
                        }
                    } catch (e) {
                        enabled = false;
                    }
                    dayHasSlots[dateStr] = enabled;
                }

                // If this service has no remaining availability (Pro, non-Team), force all-grey.
                try {
                    const forceAllGrey = (typeof _ccSelectedServiceScopeIsFullyBlockedAllWeek === 'function')
                        ? _ccSelectedServiceScopeIsFullyBlockedAllWeek()
                        : false;
                    if (forceAllGrey) {
                        for (const dateStr of dates) {
                            try {
                                const d = parseYMD(dateStr);
                                if (d < todayMidnight) continue;
                            } catch (e) {}
                            dayHasSlots[dateStr] = false;
                        }
                    }
                } catch (e) { /* ignore */ }
                if (token !== __svcParityToken) return;
                _applyServiceScopeDayClasses(dayHasSlots);
                try { renderOverridesTable(); } catch (e) { /* ignore */ }
            } finally {
                try { _setCalendarLoading(false); } catch (e) {}
            }
            return;
        }

        // Cache effective settings for the selected service so other logic (fully-booked gating)
        // can distinguish policy-window unavailability (min notice / max booking days).
        try {
            if (!window.__ccServiceEffective) window.__ccServiceEffective = {};
            if (eff && svc && svc.slug) window.__ccServiceEffective[String(svc.slug)] = eff;
        } catch (e) { /* ignore */ }

        const useFixed = (eff && typeof eff.use_fixed_increment === 'boolean') ? !!eff.use_fixed_increment : !!svc.use_fixed_increment;
        const incVal = Math.max(5, Number((eff && eff.time_increment_minutes) || svc.time_increment_minutes || 30));
        let allowEndsForAvail = false;
        try {
            allowEndsForAvail = (eff && typeof eff.allow_ends_after_availability === 'boolean') ? !!eff.allow_ends_after_availability : !!svc.allow_ends_after_availability;
        } catch (e) { allowEndsForAvail = false; }

        const edgeVal = (function(){
            try {
                const raw = localStorage.getItem('edge_buffers_' + svc.slug);
                if (raw === '1' || raw === 'true') return 1;
                if (raw === '0' || raw === 'false') return 0;
            } catch (e) {}
            return 0;
        })();

        // Fast paint (matches public month behavior): apply batch summary immediately.
        // This makes circles appear quickly instead of waiting for per-day verification.
        const dayHasSlots = {};
        for (const dateStr of dates) {
            dayHasSlots[dateStr] = false;
            try {
                const d = parseYMD(dateStr);
                if (d < todayMidnight) continue;
            } catch (e) {}
            dayHasSlots[dateStr] = !!(summary && summary[dateStr]);
        }

        // If the service has no explicitly saved weekly windows, do NOT let it
        // "inherit" or auto-take newly freed overall availability. Keep the month
        // grey unless there is an explicit per-date availability override.
        try {
            if (!svcHasExplicitWeekly) {
                for (const dateStr of dates) {
                    try {
                        const d = parseYMD(dateStr);
                        if (d < todayMidnight) continue;
                    } catch (e) { /* ignore */ }
                    if (blockedDates.has(dateStr)) {
                        dayHasSlots[dateStr] = false;
                    } else if (availableOverrideDates.has(dateStr)) {
                        // Keep true if server says there are slots on this override day.
                        // (If server summary says false, leave false.)
                        dayHasSlots[dateStr] = !!dayHasSlots[dateStr];
                    } else {
                        dayHasSlots[dateStr] = false;
                    }
                }
            }
        } catch (e) { /* ignore */ }

        // If this service has *no remaining availability* (Pro, non-Team service scope),
        // force the entire month to display as unavailable (grey). This prevents
        // stale/global state from making the wrong service appear grey or blue.
        try {
            const forceAllGrey = (typeof _ccSelectedServiceScopeIsFullyBlockedAllWeek === 'function')
                ? _ccSelectedServiceScopeIsFullyBlockedAllWeek()
                : false;
            if (forceAllGrey) {
                for (const dateStr of dates) {
                    try {
                        const d = parseYMD(dateStr);
                        if (d < todayMidnight) continue;
                    } catch (e) { /* ignore */ }
                    dayHasSlots[dateStr] = false;
                }
            }
        } catch (e) { /* ignore */ }

        if (token !== __svcParityToken) return;
        _applyServiceScopeDayClasses(dayHasSlots);
        try { renderOverridesTable(); } catch (e) { /* ignore */ }
        // Remove the overlay once we've painted the month; refine in background.
        try { _setCalendarLoading(false); } catch (e) {}

        // Background verification: for days batch marked true, confirm slots exist.
        // This mirrors the public page's "verify detailed availability" idea, but
        // does NOT block rendering.
        const candidates = [];
        for (const dateStr of dates) {
            try {
                const d = parseYMD(dateStr);
                if (d < todayMidnight) continue;
            } catch (e) {}
            if (dayHasSlots[dateStr]) candidates.push(dateStr);
        }

        if (candidates.length === 0) {
            __svcParityLastKey = key;
            __svcParityLastMap = dayHasSlots;
            return;
        }

        (async () => {
            const incQueryBase = useFixed ? '' : `&inc=${incVal}`;
            const concurrency = 4;
            let idx = 0;
            let pendingApply = null;
            const scheduleApply = () => {
                if (pendingApply) return;
                pendingApply = setTimeout(() => {
                    pendingApply = null;
                    if (token !== __svcParityToken) return;
                    _applyServiceScopeDayClasses(dayHasSlots);
                }, 75);
            };

            async function worker() {
                while (true) {
                    const my = idx++;
                    if (my >= candidates.length) return;
                    const dateStr = candidates[my];
                    try {
                        const startIso = _toIsoLocal(dateStr, 0, 0, 0);
                        const endIso = _toIsoLocal(dateStr, 23, 59, 59);
                        const availUrl = `/bus/${orgSlug}/services/${svc.slug}/availability/?start=${encodeURIComponent(startIso)}&end=${encodeURIComponent(endIso)}${incQueryBase}&edge_buffers=${edgeVal}&allow_ends_after_availability=${allowEndsForAvail?1:0}${cacheBuster}`;
                        const r = await fetch(availUrl, { credentials: 'same-origin' });
                        const slots = r.ok ? await r.json() : [];
                        dayHasSlots[dateStr] = Array.isArray(slots) && slots.length > 0;
                    } catch (e) {
                        dayHasSlots[dateStr] = false;
                    }
                    scheduleApply();
                }
            }

            try {
                await Promise.all(Array.from({ length: Math.min(concurrency, candidates.length) }, () => worker()));
            } catch (e) { /* ignore */ }
            if (token !== __svcParityToken) return;

            if (pendingApply) {
                try { clearTimeout(pendingApply); } catch (e) {}
                pendingApply = null;
            }

            __svcParityLastKey = key;
            __svcParityLastMap = dayHasSlots;
            _applyServiceScopeDayClasses(dayHasSlots);
            try { renderOverridesTable(); } catch (e) { /* ignore */ }
        })();
    }

    // -----------------------------
    // 3️⃣ Render default availability table
    // -----------------------------
    // Global Custom Time Picker accessible across contexts
    function createCustomTimePickerGlobal(inputElement) {
        const picker = document.createElement('div');
        picker.className = 'custom-time-picker';

        const [initialHour, initialMinute] = (inputElement.value || '09:00').split(':');
        let selectedHour = initialHour;
        let selectedMinute = initialMinute;

        const isStart = inputElement.classList.contains('modal-range-start') || inputElement.classList.contains('range-start');
        const headerText = isStart ? 'Start Time' : 'End Time';

        function _ccGetAllowedIntervalsForInput(el){
            try {
                // Only constrain weekly editor rows for service scope selections.
                const dayIdx = parseInt(String(el?.dataset?.day ?? ''), 10);
                if (isNaN(dayIdx)) return null;
                const c = window.__ccWeeklyServiceConstraints || null;
                if (!c || !c.days || !c.days[dayIdx]) return null;
                const d = c.days[dayIdx];
                // Remaining = memberAllowed minus otherBlocked (mixed signature).
                if (!d || !Array.isArray(d.remaining)) return null;
                return d.remaining.slice();
            } catch (e) {
                return null;
            }
        }

        function _ccMinutesFromHHMM(v){
            try { return _minutesFromTimeStr(String(v || '00:00')); } catch (e) { return null; }
        }

        function _ccIsMinuteAllowed(min){
            try {
                if (min === null || min === undefined || isNaN(min)) return false;

                const allowed = _ccGetAllowedIntervalsForInput(inputElement);
                if (allowed === null) return true; // unconstrained
                if (!allowed.length) return false;

                // Also respect the other bound in the current row, if present.
                const row = inputElement.closest('.range-row, .modal-range-row');
                const startEl = row ? row.querySelector('.range-start, .modal-range-start') : null;
                const endEl = row ? row.querySelector('.range-end, .modal-range-end') : null;
                const startMin = startEl ? _ccMinutesFromHHMM(startEl.value) : null;
                const endMin = endEl ? _ccMinutesFromHHMM(endEl.value) : null;

                // Determine membership in allowed intervals.
                const inAllowed = allowed.some(r => {
                    try {
                        const s = parseInt(r.start, 10);
                        const e = parseInt(r.end, 10);
                        if (isNaN(s) || isNaN(e)) return false;
                        // Start: [s, e)
                        // End: (s, e]
                        if (isStart) return (s <= min) && (min < e);
                        return (s < min) && (min <= e);
                    } catch (e) {
                        return false;
                    }
                });
                if (!inAllowed) return false;

                // Enforce start < end within row.
                if (isStart && endMin !== null && !isNaN(endMin)) {
                    if (!(min < endMin)) return false;
                }
                if (!isStart && startMin !== null && !isNaN(startMin)) {
                    if (!(min > startMin)) return false;
                }

                return true;
            } catch (e) {
                return true;
            }
        }

        function _ccFirstAllowedMinuteForHour(hour){
            try {
                const h = parseInt(hour, 10);
                if (isNaN(h)) return null;
                const base = h * 60;
                for (let m = 0; m < 60; m++){
                    const min = base + m;
                    if (_ccIsMinuteAllowed(min)) return min;
                }
            } catch (e) {}
            return null;
        }

        function _ccSnapToAllowed(hh, mm){
            try {
                const h = parseInt(hh, 10);
                const m = parseInt(mm, 10);
                if (isNaN(h) || isNaN(m)) return null;
                const cur = h*60 + m;
                if (_ccIsMinuteAllowed(cur)) return cur;
                // Try first allowed in this hour
                const firstInHour = _ccFirstAllowedMinuteForHour(h);
                if (firstInHour !== null) return firstInHour;
                // Otherwise, scan forward for the next allowed minute in the day.
                for (let t = 0; t < 24*60; t++){
                    if (_ccIsMinuteAllowed(t)) return t;
                }
            } catch (e) {}
            return null;
        }

        picker.innerHTML = `
            <div class="time-picker-header">${headerText}</div>
            <div class="time-picker-display">${formatDisplayTime(selectedHour, selectedMinute)}</div>
            <div class="time-picker-selectors">
                <div class="time-selector">
                    <div class="time-selector-label">Hour</div>
                    <div class="time-scroll-container" data-type="hour"></div>
                </div>
                <div class="time-selector">
                    <div class="time-selector-label">Minute</div>
                    <div class="time-scroll-container" data-type="minute"></div>
                </div>
            </div>
            <div class="time-picker-actions">
                <button class="time-picker-btn cancel">Cancel</button>
                <button class="time-picker-btn confirm">Confirm</button>
            </div>
        `;

        const hourContainer = picker.querySelector('[data-type="hour"]');
        for (let h = 0; h < 24; h++) {
            const hourStr = String(h).padStart(2, '0');
            const opt = document.createElement('div');
            opt.className = 'time-option';
            // Disable hours that have no valid minutes under constraints.
            try {
                if (_ccFirstAllowedMinuteForHour(h) === null) opt.classList.add('disabled');
            } catch (e) {}
            if (hourStr === selectedHour) opt.classList.add('selected');
            opt.textContent = formatHour(h);
            opt.addEventListener('click', () => {
                hourContainer.querySelectorAll('.time-option').forEach(o => o.classList.remove('selected'));
                opt.classList.add('selected');
                selectedHour = hourStr;
                // If current minute is no longer allowed, snap to first allowed minute in this hour.
                try {
                    const snapped = _ccSnapToAllowed(selectedHour, selectedMinute);
                    if (snapped !== null) {
                        selectedHour = String(Math.floor(snapped / 60)).padStart(2, '0');
                        selectedMinute = String(snapped % 60).padStart(2, '0');
                    }
                } catch (e) {}
                updateDisplay();
                try { syncMinuteOptions(); } catch (e) {}
                opt.scrollIntoView({ behavior: 'smooth', block: 'center' });
            });
            hourContainer.appendChild(opt);
        }

        const minuteContainer = picker.querySelector('[data-type="minute"]');
        for (let m = 0; m < 60; m++) {
            const minStr = String(m).padStart(2, '0');
            const opt = document.createElement('div');
            opt.className = 'time-option';
            if (minStr === selectedMinute) opt.classList.add('selected');
            opt.textContent = minStr;
            opt.addEventListener('click', () => {
                minuteContainer.querySelectorAll('.time-option').forEach(o => o.classList.remove('selected'));
                opt.classList.add('selected');
                selectedMinute = minStr;
                updateDisplay();
                opt.scrollIntoView({ behavior: 'smooth', block: 'center' });
            });
            minuteContainer.appendChild(opt);
        }

        function syncMinuteOptions(){
            try {
                const h = parseInt(selectedHour, 10);
                const opts = Array.from(minuteContainer.querySelectorAll('.time-option'));
                let hasSelected = false;
                for (const o of opts){
                    const mm = parseInt(o.textContent, 10);
                    const min = (isNaN(h) || isNaN(mm)) ? null : (h*60 + mm);
                    const ok = _ccIsMinuteAllowed(min);
                    o.classList.toggle('disabled', !ok);
                    if (ok && o.classList.contains('selected')) hasSelected = true;
                }
                if (!hasSelected){
                    const snap = _ccFirstAllowedMinuteForHour(h);
                    if (snap !== null) {
                        selectedHour = String(Math.floor(snap / 60)).padStart(2, '0');
                        selectedMinute = String(snap % 60).padStart(2, '0');
                        // Update selections
                        hourContainer.querySelectorAll('.time-option').forEach(o => o.classList.remove('selected'));
                        hourContainer.querySelectorAll('.time-option').forEach(o => {
                            if (String(o.textContent || '').includes(formatHour(parseInt(selectedHour,10)).split(' ')[0])) {
                                // no-op: we'll set selected by hourStr match below
                            }
                        });
                        hourContainer.querySelectorAll('.time-option').forEach(o => {
                            // hour options store hourStr, but only via closure; re-select by index
                        });
                        const hourIdx = parseInt(selectedHour, 10);
                        const hourOpt = hourContainer.querySelectorAll('.time-option')[hourIdx];
                        if (hourOpt) hourOpt.classList.add('selected');

                        minuteContainer.querySelectorAll('.time-option').forEach(o => o.classList.remove('selected'));
                        const minuteOpt = minuteContainer.querySelectorAll('.time-option')[parseInt(selectedMinute,10)];
                        if (minuteOpt) minuteOpt.classList.add('selected');
                        updateDisplay();
                        // Recompute disabled state for the now-selected hour
                        for (const o of opts){
                            const mm = parseInt(o.textContent, 10);
                            const min = (isNaN(hourIdx) || isNaN(mm)) ? null : (hourIdx*60 + mm);
                            const ok = _ccIsMinuteAllowed(min);
                            o.classList.toggle('disabled', !ok);
                        }
                    }
                }
            } catch (e) { /* ignore */ }
        }

        function updateDisplay() {
            picker.querySelector('.time-picker-display').textContent = formatDisplayTime(selectedHour, selectedMinute);
        }
        function formatHour(h) {
            if (h === 0) return '12 AM';
            if (h < 12) return `${h} AM`;
            if (h === 12) return '12 PM';
            return `${h - 12} PM`;
        }
        function formatDisplayTime(h, m) {
            const hour = parseInt(h);
            const ampm = hour >= 12 ? 'PM' : 'AM';
            const h12 = hour === 0 ? 12 : (hour > 12 ? hour - 12 : hour);
            return `${h12}:${m} ${ampm}`;
        }

        setTimeout(() => {
            hourContainer.querySelector('.selected')?.scrollIntoView({ block: 'center' });
            minuteContainer.querySelector('.selected')?.scrollIntoView({ block: 'center' });
        }, 50);

        // Apply constraints immediately (snap initial selection + disable invalid options)
        try {
            const snapped = _ccSnapToAllowed(selectedHour, selectedMinute);
            if (snapped !== null) {
                selectedHour = String(Math.floor(snapped / 60)).padStart(2, '0');
                selectedMinute = String(snapped % 60).padStart(2, '0');
                // Apply selection state
                hourContainer.querySelectorAll('.time-option').forEach(o => o.classList.remove('selected'));
                const hourIdx = parseInt(selectedHour, 10);
                const hourOpt = hourContainer.querySelectorAll('.time-option')[hourIdx];
                if (hourOpt) hourOpt.classList.add('selected');
                minuteContainer.querySelectorAll('.time-option').forEach(o => o.classList.remove('selected'));
                const minuteOpt = minuteContainer.querySelectorAll('.time-option')[parseInt(selectedMinute,10)];
                if (minuteOpt) minuteOpt.classList.add('selected');
                updateDisplay();
            }
            syncMinuteOptions();
        } catch (e) {}

        picker.querySelector('.confirm').addEventListener('click', (e) => {
            e.stopPropagation();
            inputElement.value = `${selectedHour}:${selectedMinute}`;
            try { inputElement.dispatchEvent(new Event('input', { bubbles: true })); } catch (err) {}
            try { inputElement.dispatchEvent(new Event('change', { bubbles: true })); } catch (err) {}
            picker.remove();
        });
        picker.querySelector('.cancel').addEventListener('click', (e) => {
            e.stopPropagation();
            picker.remove();
        });
        setTimeout(() => {
            document.addEventListener('click', function closeOnOutside(e) {
                if (!picker.contains(e.target) && e.target !== inputElement) {
                    picker.remove();
                    document.removeEventListener('click', closeOnOutside);
                }
            });
        }, 100);

        return picker;
    }

    // Weekly availability save button: show only when there are unsaved changes.
    // Baseline is tracked per current selection (member/service/org target).
    const __ccWeeklyBaselineByTarget = {};
    let __ccWeeklyIniting = false;

    function __ccWeeklyTargetKey(){
        // Non-Team plans set SELECTED_MEMBER = null, but org-wide weekly defaults
        // still need dirty-tracking. Use a stable fallback key for org scope.
        try { return String((typeof ccOverrideTarget === 'function' ? ccOverrideTarget() : null) || 'org'); } catch (e) { return 'org'; }
    }

    function __ccWeeklySetSaveVisible(visible){
        const btn = document.getElementById('saveDefaultAvailabilityBtn');
        if (!btn) return;
        btn.style.display = visible ? 'inline-block' : 'none';
    }

    function displayDefaultAvailability() {
        const container = document.getElementById("defaultAvailabilityTable");
        container.innerHTML = "";
        const days = ["Sunday", "Monday","Tuesday","Wednesday","Thursday","Friday", "Saturday"];

        // Recompute service-scope constraint overlays each time we render the weekly editor.
        // This ensures changes to *other* services (freeing/reserving time) are reflected
        // immediately without requiring a full page refresh.
        try { if (typeof _ccRefreshConstraints === 'function') _ccRefreshConstraints(); } catch (e) { /* ignore */ }

        // Safety: if some other code path triggers a weekly re-render after the user
        // switched scopes/services, ensure `defaultAvailability` is re-sourced from
        // the currently selected target before we build DOM rows.
        try {
            const desiredKey = __ccWeeklyTargetKey();
            if (desiredKey && window.__ccWeeklyRenderedTargetKey !== desiredKey) {
                if (typeof window.__ccSelectDefaultAvailabilityFor === 'function') {
                    try {
                        __ccWeeklyIniting = true;
                        window.__ccSelectDefaultAvailabilityFor(SELECTED_MEMBER);
                    } finally {
                        __ccWeeklyIniting = false;
                    }
                }
                window.__ccWeeklyRenderedTargetKey = desiredKey;
            }
        } catch (e) { /* ignore */ }

        // Critical rule: an unconfigured service (no explicitly saved weekly windows)
        // must NOT auto-take newly freed availability. Keep it fully unavailable
        // until the user manually enables days/ranges and saves.
        //
        // Only apply this forced reset when we have no baseline yet for this target,
        // so we don't wipe unsaved user edits during the current session.
        try {
            const key = __ccWeeklyTargetKey();
            const sel = SELECTED_MEMBER;
            if (key && !Object.prototype.hasOwnProperty.call(__ccWeeklyBaselineByTarget, key)) {
                if (sel && String(sel).startsWith('svc:')) {
                    const svcId = String(sel).slice(4);
                    const svc = (Array.isArray(SERVICES) ? SERVICES.find(s => String(s.id) === String(svcId)) : null);
                    const hasExplicit = !!(svc && (svc.has_service_weekly_windows || false));
                    if (svc && !hasExplicit) {
                        const built = buildAvailabilityFromPayload([[],[],[],[],[],[],[]]);
                        for (const k of Object.keys(built)) defaultAvailability[k] = built[k];
                    }
                }
            }
        } catch (e) { /* ignore */ }

        function _ccWeeklyValidateDay(dayIndex, changedInputEl) {
            try {
                const cb = document.querySelector(`.unavailable-checkbox[data-day='${dayIndex}']`);
                if (cb && cb.checked) return true;
                const containerEl = document.getElementById(`ranges-container-${dayIndex}`);
                const rows = containerEl ? Array.from(containerEl.querySelectorAll('.range-row')) : [];
                const verdict = _ccValidateRangeRowsNoOverlap(rows, '.range-start', '.range-end');
                if (!verdict.ok) {
                    _ccToastRangeError(verdict.message);
                    _ccRevertToPrevValue(changedInputEl);
                    return false;
                }
                // Update prev snapshot for all inputs once valid
                for (const r of rows) {
                    try { _ccSetPrevValue(r.querySelector('.range-start')); } catch (e) {}
                    try { _ccSetPrevValue(r.querySelector('.range-end')); } catch (e) {}
                }
                return true;
            } catch (e) {
                return true;
            }
        }

        function _ccNormalizeWeeklyStateFromUI(){
            // Read the current UI state (not in-memory defaultAvailability) so the time picker is included.
            const out = [];
            for (let day = 0; day < 7; day++) {
                const containerEl = document.getElementById(`ranges-container-${day}`);
                const rows = containerEl ? Array.from(containerEl.querySelectorAll('.range-row')) : [];
                const ranges = [];
                for (const r of rows) {
                    const s = (r.querySelector('.range-start')?.value || '').trim();
                    const e = (r.querySelector('.range-end')?.value || '').trim();
                    if (!s || !e) continue;
                    ranges.push(`${s}-${e}`);
                }
                const cb = document.querySelector(`.unavailable-checkbox[data-day='${day}']`);
                const unavailableChecked = !!(cb && cb.checked);
                const unavailable = unavailableChecked || ranges.length === 0;

                // Normalize + sort ranges for stable comparison
                const normRanges = (unavailable ? [] : ranges)
                    .map(x => String(x).trim())
                    .filter(Boolean)
                    .map(x => {
                        const parts = x.split('-');
                        const a = (parts[0] || '').trim();
                        const b = (parts[1] || '').trim();
                        return { a, b, raw: `${a}-${b}` };
                    })
                    .filter(r => r.a && r.b)
                    .sort((r1, r2) => (r1.a === r2.a ? (r1.b < r2.b ? -1 : (r1.b > r2.b ? 1 : 0)) : (r1.a < r2.a ? -1 : 1)))
                    .map(r => r.raw);

                out.push({ unavailable: !!unavailable, ranges: normRanges });
            }
            return JSON.stringify(out);
        }

        function _ccUpdateWeeklySaveVisibility(){
            if (__ccWeeklyIniting) return;
            const key = __ccWeeklyTargetKey();
            if (!key) {
                __ccWeeklySetSaveVisible(false);
                return;
            }
            const cur = _ccNormalizeWeeklyStateFromUI();
            if (!Object.prototype.hasOwnProperty.call(__ccWeeklyBaselineByTarget, key)) {
                __ccWeeklyBaselineByTarget[key] = cur;
                __ccWeeklySetSaveVisible(false);
                return;
            }
            __ccWeeklySetSaveVisible(cur !== __ccWeeklyBaselineByTarget[key]);
        }

        function _ccSigKey(svc){
            try {
                if (svc && Array.isArray(svc.schedule_signature) && svc.schedule_signature.length) {
                    return svc.schedule_signature.map(x => String(x)).join('|');
                }
                // Fallback (older payloads)
                return [
                    String(svc?.duration ?? ''),
                    String(svc?.buffer_after ?? ''),
                    String(svc?.time_increment_minutes ?? ''),
                    String(!!svc?.use_fixed_increment),
                    String(!!svc?.allow_squished_bookings),
                    String(!!svc?.allow_ends_after_availability),
                    String(svc?.min_notice_hours ?? ''),
                    String(svc?.max_booking_days ?? ''),
                ].join('|');
            } catch (e) {
                return '';
            }
        }

        function _ccMinutes(hhmm){
            try { return _minutesFromTimeStr(String(hhmm || '00:00')); } catch (e) { return 0; }
        }

        function _ccMergeRanges(ranges){
            const out = [];
            const sorted = (ranges || []).slice().filter(r => r && r.start < r.end).sort((a,b) => a.start - b.start);
            for (const r of sorted){
                if (!out.length){ out.push({start:r.start,end:r.end}); continue; }
                const last = out[out.length-1];
                if (r.start <= last.end){ last.end = Math.max(last.end, r.end); }
                else out.push({start:r.start,end:r.end});
            }
            return out;
        }

        function _ccSubtractRanges(allowed, blocked){
            // Return segments in allowed that are not covered by blocked
            const A = _ccMergeRanges(allowed);
            const B = _ccMergeRanges(blocked);
            const out = [];
            let j = 0;
            for (const a of A){
                let cur = a.start;
                while (j < B.length && B[j].end <= cur) j++;
                let k = j;
                while (k < B.length && B[k].start < a.end){
                    const b = B[k];
                    if (b.start > cur) out.push({start: cur, end: Math.min(b.start, a.end)});
                    cur = Math.max(cur, b.end);
                    if (cur >= a.end) break;
                    k++;
                }
                if (cur < a.end) out.push({start: cur, end: a.end});
            }
            return _ccMergeRanges(out);
        }

        function _ccInvertRanges(allowed){
            const merged = _ccMergeRanges(allowed);
            const blocked = [];
            let cur = 0;
            for (const r of merged){
                if (cur < r.start) blocked.push({start:cur, end:r.start});
                cur = Math.max(cur, r.end);
            }
            if (cur < 24*60) blocked.push({start:cur, end:24*60});
            return blocked;
        }

        function _ccIntersectRanges(a, b){
            const A = _ccMergeRanges(a);
            const B = _ccMergeRanges(b);
            const out = [];
            let i=0, j=0;
            while (i < A.length && j < B.length){
                const s = Math.max(A[i].start, B[j].start);
                const e = Math.min(A[i].end, B[j].end);
                if (s < e) out.push({start:s,end:e});
                if (A[i].end < B[j].end) i++; else j++;
            }
            return out;
        }

        function _ccRangesFromWeeklyMap(weeklyMap, uiDayIdx){
            const out = [];
            try {
                const dayArr = (weeklyMap && Array.isArray(weeklyMap) && weeklyMap.length === 7) ? weeklyMap[uiDayIdx] : null;
                const ranges = Array.isArray(dayArr) ? dayArr : [];
                for (const r of ranges){
                    const parts = String(r || '').split('-');
                    const s = (parts[0] || '').trim();
                    const e = (parts[1] || '').trim();
                    if (!s || !e) continue;
                    const sm = _ccMinutes(s);
                    const em = _ccMinutes(e);
                    if (sm < em) out.push({start:sm,end:em});
                }
            } catch (e) {}
            return _ccMergeRanges(out);
        }

        function _ccGetWeeklyEditorConstraints(){
            // Applies when editing a service scope. For solo services: member availability minus
            // other solo services (mixed signature). For shared/group services: intersection of
            // member availability minus ALL members' other services.
            try {
                if (!SELECTED_MEMBER || !String(SELECTED_MEMBER).startsWith('svc:')) return null;
                const svcId = String(SELECTED_MEMBER).slice(4);
                const svc = SERVICES.find(s => String(s.id) === String(svcId));
                if (!svc) return null;

                // Pro (solo) scope: overall availability minus all other services.
                // This matches the mental model: you can't do two services at once.
                if (IS_PRO && !IS_TEAM) {
                    const daysOut = [];
                    const mySig = _ccSigKey(svc);

                    // Convert orgDefaultAvailability (defaultAvailability-like) to weeklyMap-style array.
                    const overallWeeklyMap = [[],[],[],[],[],[],[]];
                    for (let d=0; d<7; d++){
                        const info = orgDefaultAvailability[d] || {};
                        let ranges = [];
                        if (info && info.unavailable) {
                            ranges = [];
                        } else if (info.ranges && info.ranges.length) {
                            ranges = info.ranges;
                        } else if (info.start && info.end) {
                            ranges = [`${info.start}-${info.end}`];
                        }
                        overallWeeklyMap[d] = Array.isArray(ranges) ? ranges.slice() : [];
                    }

                    for (let d=0; d<7; d++){
                        const overallAllowed = _ccRangesFromWeeklyMap(overallWeeklyMap, d);

                        // Union of other services' weekly windows.
                        let otherRaw = [];
                        for (const os of (Array.isArray(SERVICES) ? SERVICES : [])) {
                            try {
                                if (!os) continue;
                                // Inactive services should not reserve time.
                                if (!os.is_active) continue;
                                if (String(os.id) === String(svcId)) continue;
                                // Same-signature services can share the same windows.
                                if (_ccSigKey(os) === mySig) continue;
                                otherRaw = otherRaw.concat(_ccRangesFromWeeklyMap(os.weekly_map, d));
                            } catch (e) {}
                        }

                        const otherBlocked = _ccIntersectRanges(_ccMergeRanges(otherRaw), overallAllowed);
                        const remaining = _ccSubtractRanges(overallAllowed, otherBlocked);
                        const fullyBlocked = (overallAllowed.length === 0) || (remaining.length === 0);
                        const shouldShow = fullyBlocked || (otherBlocked && otherBlocked.length > 0);

                        daysOut[d] = {
                            memberAllowed: overallAllowed,
                            memberBlocked: (overallAllowed.length ? _ccInvertRanges(overallAllowed) : [{start:0,end:24*60}]),
                            otherBlocked,
                            remaining,
                            fullyBlocked,
                            shouldShow,
                        };
                    }

                    return { serviceId: svcId, membershipId: null, assignedMembers: [], days: daysOut };
                }

                const assigned = (typeof getAssignedMembersForService === 'function') ? (getAssignedMembersForService(svc) || []) : (svc.assigned_members || []);
                const daysOut = [];

                if (!assigned || !assigned.length) return null;

                function _memberWeeklyMapFor(mid){
                    const memberPayload = (memberAvailMap && memberAvailMap[mid]) ? memberAvailMap[mid] : null;
                    const memberBuilt = memberPayload ? buildAvailabilityFromPayload(memberPayload) : orgDefaultAvailability;

                    // Convert memberBuilt (defaultAvailability-like) to a weeklyMap style for parsing.
                    const memberWeeklyMap = [[],[],[],[],[],[],[]];
                    for (let d=0; d<7; d++){
                        const info = memberBuilt[d] || {};
                        let ranges = [];
                        if (info && info.unavailable) {
                            ranges = [];
                        } else if (info.ranges && info.ranges.length) {
                            ranges = info.ranges;
                        } else if (info.start && info.end) {
                            ranges = [`${info.start}-${info.end}`];
                        }
                        memberWeeklyMap[d] = Array.isArray(ranges) ? ranges.slice() : [];
                    }
                    return memberWeeklyMap;
                }

                if (assigned.length === 1){
                    const mid = String(assigned[0]);
                    const memberWeeklyMap = _memberWeeklyMapFor(mid);
                    const mySig = _ccSigKey(svc);
                    const others = (typeof personalServicesForMember === 'function') ? (personalServicesForMember(mid) || []) : [];
                    const otherSvcs = others.filter(os => String(os.id) !== String(svcId) && !!(os && os.is_active));

                    for (let d=0; d<7; d++){
                        const memberAllowed = _ccRangesFromWeeklyMap(memberWeeklyMap, d);
                        // Block other solo services only when signatures differ (align with backend rule).
                        let otherRaw = [];
                        for (const os of otherSvcs){
                            try {
                                if (_ccSigKey(os) === mySig) continue;
                                otherRaw = otherRaw.concat(_ccRangesFromWeeklyMap(os.weekly_map, d));
                            } catch (e) {}
                        }
                        const otherBlocked = _ccIntersectRanges(_ccMergeRanges(otherRaw), memberAllowed);
                        const remaining = _ccSubtractRanges(memberAllowed, otherBlocked);
                        const fullyBlocked = (memberAllowed.length === 0) || (remaining.length === 0);
                        const shouldShow = fullyBlocked || (otherBlocked && otherBlocked.length > 0);
                        daysOut[d] = {
                            memberAllowed,
                            memberBlocked: (memberAllowed.length ? _ccInvertRanges(memberAllowed) : [{start:0,end:24*60}]),
                            otherBlocked,
                            remaining,
                            fullyBlocked,
                            shouldShow,
                        };
                    }
                    return { serviceId: svcId, membershipId: mid, assignedMembers: [mid], days: daysOut };
                }

                // Shared/group service: common member availability minus ALL members' other services.
                const memberWeeklyMaps = assigned.map(m => ({ mid: String(m), map: _memberWeeklyMapFor(String(m)) }));

                function _servicesForMember(mid){
                    try {
                        const idStr = String(mid);
                        return (Array.isArray(SERVICES) ? SERVICES : []).filter(s => {
                            if (!s || !s.is_active) return false;
                            const a = getAssignedMembersForService(s);
                            return a && a.some(x => String(x) === idStr);
                        });
                    } catch (e) { return []; }
                }

                for (let d=0; d<7; d++){
                    // Intersect memberAllowed across all assigned members
                    let commonAllowed = null;
                    for (const mm of memberWeeklyMaps){
                        const allowed = _ccRangesFromWeeklyMap(mm.map, d);
                        commonAllowed = (commonAllowed === null) ? allowed : _ccIntersectRanges(commonAllowed, allowed);
                        if (!commonAllowed.length) break;
                    }

                    // Union of all other services (any signature) across all members
                    let otherRaw = [];
                    for (const mm of memberWeeklyMaps){
                        const svcs = _servicesForMember(mm.mid);
                        for (const os of (svcs || [])){
                            try {
                                if (String(os.id) === String(svcId)) continue;
                                otherRaw = otherRaw.concat(_ccRangesFromWeeklyMap(os.weekly_map, d));
                            } catch (e) {}
                        }
                    }

                    const otherBlocked = _ccIntersectRanges(_ccMergeRanges(otherRaw), (commonAllowed || []));
                    const remaining = _ccSubtractRanges((commonAllowed || []), otherBlocked);
                    const fullyBlocked = (!commonAllowed || !commonAllowed.length) || (!remaining.length);
                    const shouldShow = fullyBlocked || (otherBlocked && otherBlocked.length > 0);

                    daysOut[d] = {
                        memberAllowed: (commonAllowed || []),
                        memberBlocked: ((commonAllowed && commonAllowed.length) ? _ccInvertRanges(commonAllowed) : [{start:0,end:24*60}]),
                        otherBlocked,
                        remaining,
                        fullyBlocked,
                        shouldShow,
                    };
                }

                return { serviceId: svcId, membershipId: null, assignedMembers: assigned.map(String), days: daysOut };
            } catch (e) {
                return null;
            }
        }

        function _ccFirstRemainingInterval(dayIndex){
            try {
                if (!_ccConstraints || !_ccConstraints.days || !_ccConstraints.days[dayIndex]) return null;
                const d = _ccConstraints.days[dayIndex];
                const rem = (d && Array.isArray(d.remaining)) ? d.remaining : [];
                if (!rem.length) return null;
                return { start: rem[0].start, end: rem[0].end };
            } catch (e) {
                return null;
            }
        }

        function _ccRenderConstraintsForDay(dayIndex, constraints){
            try {
                const wrap = document.querySelector(`.cc-constraints-wrap[data-day='${dayIndex}']`);
                const bar = document.querySelector(`.cc-constraints-bar[data-day='${dayIndex}']`);
                if (!wrap || !bar) return;
                if (!constraints || !constraints.days || !constraints.days[dayIndex]) {
                    wrap.style.display = 'none';
                    bar.innerHTML = '';
                    return;
                }

                const d = constraints.days[dayIndex];
                if (!d.shouldShow) {
                    wrap.style.display = 'none';
                    bar.innerHTML = '';
                    return;
                }

                wrap.style.display = 'block';
                bar.innerHTML = '';
                const toPct = (min) => (Math.max(0, Math.min(24*60, min)) / (24*60)) * 100;
                const fmtMin = (mins) => {
                    const m = Math.max(0, Math.round(Number(mins) || 0));
                    const h = Math.floor(m / 60);
                    const r = m % 60;
                    if (h <= 0) return `${r}m`;
                    if (r === 0) return `${h}h`;
                    return `${h}h ${r}m`;
                };
                const sumMins = (ranges) => {
                    try {
                        return (Array.isArray(ranges) ? ranges : []).reduce((acc, seg) => {
                            const s = Number(seg && seg.start);
                            const e = Number(seg && seg.end);
                            if (!isFinite(s) || !isFinite(e)) return acc;
                            return acc + Math.max(0, e - s);
                        }, 0);
                    } catch (e) { return 0; }
                };
                const addSeg = (seg, cls) => {
                    const div = document.createElement('div');
                    div.className = `cc-constraints-seg ${cls}`;
                    const left = toPct(seg.start);
                    const width = Math.max(0, toPct(seg.end) - left);
                    div.style.left = left + '%';
                    div.style.width = width + '%';

                    // Tooltips: help user understand what the color means.
                    try {
                        const mins = Math.max(0, (Number(seg.end) || 0) - (Number(seg.start) || 0));
                        if (cls === 'member') div.title = (IS_PRO && !IS_TEAM) ? `Outside overall availability (${fmtMin(mins)})` : `Outside member availability (${fmtMin(mins)})`;
                        else if (cls === 'other') div.title = `Reserved by other services (${fmtMin(mins)})`;
                    } catch (e) {}

                    // Inline labels (only when there's enough room to avoid clutter).
                    try {
                        if (width >= 18) {
                            const label = document.createElement('span');
                            label.className = 'cc-constraints-label';
                            label.textContent = (cls === 'member') ? ((IS_PRO && !IS_TEAM) ? 'Overall' : 'Member') : (cls === 'other' ? 'Other' : '');
                            if (label.textContent) div.appendChild(label);
                        }
                    } catch (e) {}

                    bar.appendChild(div);
                };

                // Member blocked is the baseline constraint; other-service blocks overlay.
                for (const seg of (d.memberBlocked || [])) addSeg(seg, 'member');
                for (const seg of (d.otherBlocked || [])) addSeg(seg, 'other');

                // Add/refresh a short caption that explains what's blocking.
                try {
                    let cap = wrap.querySelector('.cc-constraints-caption');
                    if (!cap) {
                        cap = document.createElement('div');
                        cap.className = 'cc-constraints-caption';
                        wrap.appendChild(cap);
                    }
                    const allowedM = sumMins(d.memberAllowed || []);
                    const otherM = sumMins(d.otherBlocked || []);
                    const remainingM = sumMins(d.remaining || []);

                    if (!allowedM) {
                        cap.textContent = (IS_PRO && !IS_TEAM)
                            ? 'Blocked: outside overall availability (no overlap).'
                            : 'Blocked: outside member availability (no overlap).';
                    } else if (!remainingM && otherM) {
                        cap.textContent = 'Blocked: reserved by other services (no bookable time left).';
                    } else if (!remainingM) {
                        cap.textContent = 'Blocked: no bookable time left for this service.';
                    } else if (otherM) {
                        cap.textContent = `Bookable: ${fmtMin(remainingM)} (some time reserved by other services).`;
                    } else {
                        // If shouldShow but no other blocks, it's usually a fully-blocked day.
                        cap.textContent = `Bookable: ${fmtMin(remainingM)}.`;
                    }
                } catch (e) {}
            } catch (e) { /* ignore */ }
        }

        // Constraints are derived from SERVICES + current selection. They must be refreshed
        // whenever availability changes or the selection changes.
        let _ccConstraints = null;
        function _ccRefreshConstraints(){
            try { _ccConstraints = _ccGetWeeklyEditorConstraints(); } catch (e) { _ccConstraints = null; }
            try { window.__ccWeeklyServiceConstraints = _ccConstraints || null; } catch (e) {}
            return _ccConstraints;
        }

        _ccRefreshConstraints();

        // Custom Time Picker Creator
        function createCustomTimePicker(inputElement) {
            const picker = document.createElement('div');
            picker.className = 'custom-time-picker';
            
            const [initialHour, initialMinute] = (inputElement.value || '09:00').split(':');
            let selectedHour = initialHour;
            let selectedMinute = initialMinute;
            
            picker.innerHTML = `
                <div class="time-picker-header">Select Time</div>
                <div class="time-picker-display">${formatDisplayTime(selectedHour, selectedMinute)}</div>
                <div class="time-picker-selectors">
                    <div class="time-selector">
                        <div class="time-selector-label">Hour</div>
                        <div class="time-scroll-container" data-type="hour"></div>
                    </div>
                    <div class="time-selector">
                        <div class="time-selector-label">Minute</div>
                        <div class="time-scroll-container" data-type="minute"></div>
                    </div>
                </div>
                <div class="time-picker-actions">
                    <button class="time-picker-btn cancel">Cancel</button>
                    <button class="time-picker-btn confirm">Confirm</button>
                </div>
            `;
            
            // Populate hours (0-23)
            const hourContainer = picker.querySelector('[data-type="hour"]');
            for (let h = 0; h < 24; h++) {
                const hourStr = String(h).padStart(2, '0');
                const opt = document.createElement('div');
                opt.className = 'time-option';
                if (hourStr === selectedHour) opt.classList.add('selected');
                opt.textContent = formatHour(h);
                opt.addEventListener('click', () => {
                    hourContainer.querySelectorAll('.time-option').forEach(o => o.classList.remove('selected'));
                    opt.classList.add('selected');
                    selectedHour = hourStr;
                    updateDisplay();
                    opt.scrollIntoView({ behavior: 'smooth', block: 'center' });
                });
                hourContainer.appendChild(opt);
            }
            
            // Populate minutes (00-59)
            const minuteContainer = picker.querySelector('[data-type="minute"]');
            for (let m = 0; m < 60; m++) {
                const minStr = String(m).padStart(2, '0');
                const opt = document.createElement('div');
                opt.className = 'time-option';
                if (minStr === selectedMinute) opt.classList.add('selected');
                opt.textContent = minStr;
                opt.addEventListener('click', () => {
                    minuteContainer.querySelectorAll('.time-option').forEach(o => o.classList.remove('selected'));
                    opt.classList.add('selected');
                    selectedMinute = minStr;
                    updateDisplay();
                    opt.scrollIntoView({ behavior: 'smooth', block: 'center' });
                });
                minuteContainer.appendChild(opt);
            }
            
            function updateDisplay() {
                picker.querySelector('.time-picker-display').textContent = formatDisplayTime(selectedHour, selectedMinute);
            }
            
            function formatHour(h) {
                if (h === 0) return '12 AM';
                if (h < 12) return `${h} AM`;
                if (h === 12) return '12 PM';
                return `${h - 12} PM`;
            }
            
            function formatDisplayTime(h, m) {
                const hour = parseInt(h);
                const ampm = hour >= 12 ? 'PM' : 'AM';
                const h12 = hour === 0 ? 12 : (hour > 12 ? hour - 12 : hour);
                return `${h12}:${m} ${ampm}`;
            }
            
            // Scroll selected items into view
            setTimeout(() => {
                hourContainer.querySelector('.selected')?.scrollIntoView({ block: 'center' });
                minuteContainer.querySelector('.selected')?.scrollIntoView({ block: 'center' });
            }, 50);
            
            // Confirm button
            picker.querySelector('.confirm').addEventListener('click', (e) => {
                e.stopPropagation();
                inputElement.value = `${selectedHour}:${selectedMinute}`;
                try { inputElement.dispatchEvent(new Event('input', { bubbles: true })); } catch (err) {}
                try { inputElement.dispatchEvent(new Event('change', { bubbles: true })); } catch (err) {}
                picker.remove();
            });
            
            // Cancel button
            picker.querySelector('.cancel').addEventListener('click', (e) => {
                e.stopPropagation();
                picker.remove();
            });
            
            // Close on outside click
            setTimeout(() => {
                document.addEventListener('click', function closeOnOutside(e) {
                    if (!picker.contains(e.target) && e.target !== inputElement) {
                        picker.remove();
                        document.removeEventListener('click', closeOnOutside);
                    }
                });
            }, 100);
            
            return picker;
        }

        // Helper to create a single range row (start/end + remove)
        function createRangeRow(dayIndex, startVal = '', endVal = '') {
            const row = document.createElement('div');
            row.className = 'range-row';

            // Wrap start input in positioned container
            const startContainer = document.createElement('div');
            startContainer.className = 'time-input-container';
            
            const start = document.createElement('input');
            start.type = 'time';
            start.className = 'range-start';
            start.value = startVal || '09:00';
            start.dataset.day = String(dayIndex);
            start.readOnly = true;
            start.style.cursor = 'pointer';
            start.addEventListener('change', function(){
                try { _ccUpdateWeeklySaveVisibility(); } catch (e) {}
                try { _ccWeeklyValidateDay(dayIndex, start); } catch (e) {}
            });
            
            function _ccOpenWeeklyPicker(inputEl, containerEl) {
                // Remove any existing pickers
                document.querySelectorAll('.custom-time-picker').forEach(p => p.remove());
                const picker = (typeof createCustomTimePickerGlobal === 'function' ? createCustomTimePickerGlobal : createCustomTimePicker)(inputEl);
                picker.classList.add('active');
                containerEl.appendChild(picker);
            }

            start.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                _ccOpenWeeklyPicker(start, startContainer);
            });
            // Mobile Safari: prevent the native time picker from opening.
            start.addEventListener('touchstart', function(e) {
                try { e.preventDefault(); } catch (_) {}
                e.stopPropagation();
                _ccOpenWeeklyPicker(start, startContainer);
            }, { passive: false });
            start.addEventListener('focus', function() {
                try {
                    const isTouch = ('ontouchstart' in window) || (navigator && navigator.maxTouchPoints > 0);
                    if (isTouch) start.blur();
                } catch (_) {}
            });
            
            startContainer.appendChild(start);

            // Wrap end input in positioned container
            const endContainer = document.createElement('div');
            endContainer.className = 'time-input-container';
            
            const end = document.createElement('input');
            end.type = 'time';
            end.className = 'range-end';
            end.value = endVal || '17:00';
            end.dataset.day = String(dayIndex);
            end.readOnly = true;
            end.style.cursor = 'pointer';
            end.addEventListener('change', function(){
                try { _ccUpdateWeeklySaveVisibility(); } catch (e) {}
                try { _ccWeeklyValidateDay(dayIndex, end); } catch (e) {}
            });
            
            end.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                _ccOpenWeeklyPicker(end, endContainer);
            });
            // Mobile Safari: prevent the native time picker from opening.
            end.addEventListener('touchstart', function(e) {
                try { e.preventDefault(); } catch (_) {}
                e.stopPropagation();
                _ccOpenWeeklyPicker(end, endContainer);
            }, { passive: false });
            end.addEventListener('focus', function() {
                try {
                    const isTouch = ('ontouchstart' in window) || (navigator && navigator.maxTouchPoints > 0);
                    if (isTouch) end.blur();
                } catch (_) {}
            });
            
            endContainer.appendChild(end);

            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'remove-range-btn';
            removeBtn.setAttribute('aria-label', 'Remove range');
            removeBtn.innerHTML = '<span class="remove-icon" aria-hidden="true">✖</span>';
            removeBtn.addEventListener('click', () => {
                try { row.remove(); } catch (e) {}
                // If the user removed the last range for a day, treat that day as unavailable.
                // This matches backend semantics (no rows => unavailable) and prevents the UI
                // from auto-adding a default range on re-render after save.
                try {
                    const containerEl = document.getElementById(`ranges-container-${dayIndex}`);
                    const hasAny = containerEl ? containerEl.querySelectorAll('.range-row').length > 0 : false;
                    if (!hasAny) {
                        const cb = document.querySelector(`.unavailable-checkbox[data-day='${dayIndex}']`);
                        if (cb && !cb.checked) {
                            cb.checked = true;
                            cb.dispatchEvent(new Event('change'));
                        } else {
                            // Ensure in-memory state still reflects the removal
                            defaultAvailability[dayIndex].unavailable = true;
                            defaultAvailability[dayIndex].ranges = [];
                        }
                    }
                } catch (e) {}
                try { _ccUpdateWeeklySaveVisibility(); } catch (e) {}
            });

            row.appendChild(startContainer);
            row.appendChild(endContainer);
            row.appendChild(removeBtn);

            // Initialize prev snapshot (used to revert invalid overlap edits)
            try { _ccSetPrevValue(start); } catch (e) {}
            try { _ccSetPrevValue(end); } catch (e) {}

            return row;
        }

        days.forEach((dayName, i) => {
            const dayIndex = i;
            const row = document.createElement('tr');

            row.innerHTML = `
                <td style="vertical-align:top; padding-top:10px; white-space:nowrap;">${dayName}</td>
                <td colspan="2" style="vertical-align:top; padding-left:24px;">
                    <div id="ranges-container-${dayIndex}" style="display:flex; flex-direction:column; gap:4px;"></div>
                    <div style="margin-top:6px;"><button type="button" class="add-range-btn" data-day="${dayIndex}" style="padding:6px 10px; background:#007bff; color:white; border:none; border-radius:6px; cursor:pointer;">Add range</button></div>
                    <div class="cc-constraints-wrap" data-day="${dayIndex}">
                        <div class="cc-constraints-bar" data-day="${dayIndex}"></div>
                    </div>
                </td>
                <td style="text-align:right; vertical-align:top; padding-top:18px; padding-right:8px;"><input type="checkbox" class="unavailable-checkbox" data-day="${dayIndex}" ${defaultAvailability[dayIndex].unavailable ? "checked" : ""}></td>
            `;

            container.appendChild(row);

            const rangesContainer = document.getElementById(`ranges-container-${dayIndex}`);
            const existing = defaultAvailability[dayIndex].ranges || [];
            if (existing.length) {
                existing.forEach(r => {
                    const parts = r.split('-');
                    const s = parts[0] ? parts[0].trim() : '09:00';
                    const e = parts[1] ? parts[1].trim() : '17:00';
                    rangesContainer.appendChild(createRangeRow(dayIndex, s, e));
                });
            } else {
                // if not unavailable, add a single blank row
                if (!defaultAvailability[dayIndex].unavailable) {
                    rangesContainer.appendChild(createRangeRow(dayIndex, defaultAvailability[dayIndex].start || '09:00', defaultAvailability[dayIndex].end || '17:00'));
                }
            }

            // Add button handler
            const addBtn = row.querySelector('.add-range-btn');
            addBtn.addEventListener('click', () => {
                // Add a new non-overlapping range. If service-scope constraints exist, fit within them.
                try {
                    const existingRows = Array.from(rangesContainer.querySelectorAll('.range-row'));
                    const existing = _ccCollectIntervalsFromRows(existingRows, '.range-start', '.range-end');
                    existing.sort((a,b) => (a.startMin === b.startMin ? a.endMin - b.endMin : a.startMin - b.startMin));
                    const lastEnd = existing.length ? existing[existing.length - 1].endMin : null;

                    let candidate = null;
                    try {
                        const first = _ccFirstRemainingInterval(dayIndex);
                        if (first) {
                            const startMin = Math.max(first.start, (lastEnd != null ? lastEnd : first.start));
                            const endMin = Math.min(first.end, startMin + 60);
                            if (endMin > startMin) candidate = { start: _ccHHMMFromMinutes(startMin), end: _ccHHMMFromMinutes(endMin) };
                        }
                    } catch (e) {}

                    if (!candidate) {
                        candidate = _ccSuggestNextNonOverlappingRange(existing, 60);
                    }

                    if (!candidate) {
                        _ccToastRangeError('No room to add another time range without overlapping.');
                        return;
                    }

                    rangesContainer.appendChild(createRangeRow(dayIndex, candidate.start, candidate.end));
                    try { _ccUpdateWeeklySaveVisibility(); } catch (e) {}
                    try { _ccWeeklyValidateDay(dayIndex, null); } catch (e) {}
                } catch (e) {
                    rangesContainer.appendChild(createRangeRow(dayIndex, '09:00', '10:00'));
                    try { _ccUpdateWeeklySaveVisibility(); } catch (e2) {}
                }
            });

            // Render constraint bar (service scope only)
            try { _ccRenderConstraintsForDay(dayIndex, _ccConstraints); } catch (e) {}

            // If this day is fully blocked in service scope, grey out and prevent editing.
            try {
                const dayInfo = (_ccConstraints && _ccConstraints.days) ? _ccConstraints.days[dayIndex] : null;
                // Only hard-lock when there's truly nothing the service can do on this day
                // AND the day currently has no ranges (so we don't deadlock the UI if legacy
                // data ever contains overlaps).
                const hasAnyUiRanges = (() => {
                    try { return !!(rangesContainer && rangesContainer.querySelectorAll('.range-row').length); } catch (e) { return false; }
                })();

                if (dayInfo && dayInfo.fullyBlocked && !hasAnyUiRanges) {
                    row.classList.add('cc-weekly-row-locked');
                    // Force UI to show unavailable + non-clickable
                    const cb = row.querySelector(`.unavailable-checkbox[data-day='${dayIndex}']`);
                    if (cb) {
                        cb.checked = true;
                        cb.disabled = true;
                    }
                    try {
                        if (addBtn) {
                            addBtn.disabled = true;
                            addBtn.style.display = 'none';
                        }
                    } catch (e) {}
                    // Remove any existing range rows in UI for this day (can't be valid anyway).
                    try { rangesContainer.innerHTML = ''; } catch (e) {}
                    try {
                        defaultAvailability[dayIndex].unavailable = true;
                        defaultAvailability[dayIndex].ranges = [];
                    } catch (e) {}
                } else if (dayInfo && dayInfo.fullyBlocked && hasAnyUiRanges) {
                    // Rare safety: fully blocked but the UI has ranges (shouldn't happen with valid data).
                    // Keep ranges editable so the user can fix it, but disable adding new ranges.
                    try {
                        if (addBtn) {
                            addBtn.disabled = true;
                        }
                    } catch (e) {}
                }
            } catch (e) {}
        });

        // During initial render, suppress dirty detection while we sync checkbox UI state.
        __ccWeeklyIniting = true;

        // Handle unavailable checkbox toggles (disable ranges UI when unavailable)
        // NOTE: do NOT apply changes to the calendar immediately here. Changes should
        // be saved by clicking the Save Defaults button. This prevents premature
        // application of availability while the user is still editing the defaults.
        document.querySelectorAll('.unavailable-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', function() {
                const day = this.dataset.day;
                // Update the in-memory defaultAvailability but do not mutate calendar yet
                defaultAvailability[day].unavailable = this.checked;
                const containerEl = document.getElementById(`ranges-container-${day}`);
                const addBtn = document.querySelector(`.add-range-btn[data-day='${day}']`);
                if (this.checked) {
                    // hide/disable ranges
                    containerEl.style.opacity = '0.5';
                    containerEl.querySelectorAll('input').forEach(i => i.disabled = true);
                    addBtn.disabled = true;
                } else {
                    containerEl.style.opacity = '1';
                    // If there are no existing range rows (user just toggled available), add a default range row
                    if (!containerEl.querySelectorAll('.range-row').length) {
                        const start = defaultAvailability[day].start || '09:00';
                        const end = defaultAvailability[day].end || '17:00';
                        containerEl.appendChild(createRangeRow(day, start, end));
                    }
                    containerEl.querySelectorAll('input').forEach(i => i.disabled = false);
                    addBtn.disabled = false;
                }
                // Do not call updateUnavailableDays() here; wait for Save Defaults to apply
                try { _ccUpdateWeeklySaveVisibility(); } catch (e) {}
            });
            // Trigger initial state (this will only set UI inputs; calendar not updated until save)
            checkbox.dispatchEvent(new Event('change'));
        });

        // End init: set baseline for this target to the freshly rendered state.
        __ccWeeklyIniting = false;
        try {
            const k = __ccWeeklyTargetKey();
            if (k) __ccWeeklyBaselineByTarget[k] = _ccNormalizeWeeklyStateFromUI();
        } catch (e) {}
        __ccWeeklySetSaveVisible(false);

        // Save handler (use onclick to avoid duplicate listeners)
        const saveBtn = document.getElementById('saveDefaultAvailabilityBtn');

        function _ensureAvailabilitySaveBanner(){
            let el = document.getElementById('cc-availability-save-banner');
            if (el) return el;
            el = document.createElement('div');
            el.id = 'cc-availability-save-banner';
            el.setAttribute('role', 'status');
            el.setAttribute('aria-live', 'polite');
            el.style.display = 'none';
            el.style.margin = '0 auto 10px auto';
            el.style.width = '100%';
            el.style.maxWidth = '920px';
            el.style.padding = '10px 12px';
            el.style.borderRadius = '10px';
            el.style.border = '1px solid #e5e7eb';
            el.style.background = '#f9fafb';
            el.style.color = '#111827';
            el.style.fontSize = '14px';
            el.style.lineHeight = '1.35';
            el.style.textAlign = 'center';
            // Place banner right above the Save button if possible.
            try {
                const parent = saveBtn && saveBtn.parentElement ? saveBtn.parentElement : null;
                if (parent) parent.insertBefore(el, saveBtn);
                else document.body.appendChild(el);
            } catch (e) {
                document.body.appendChild(el);
            }
            return el;
        }

        function _availabilitySaveHint(msg){
            const m = String(msg || '').toLowerCase();
            if (m.includes('overlaps another solo service')) {
                return "Tip: Either make the services' scheduling settings identical, or move one service to a non-overlapping day/time.";
            }
            if (m.includes("within the assigned member's weekly availability")) {
                return "Tip: Expand the member's overall availability first (or shrink the service window).";
            }
            if (m.includes('overall availability cannot exclude existing service availability')) {
                return 'Tip: Expand overall availability first, then save.';
            }
            return '';
        }

        function _ccFormatTime12h(hour24, minute){
            const h = Number(hour24);
            const m = String(minute == null ? '' : minute).padStart(2, '0');
            if (!Number.isFinite(h) || h < 0 || h > 23) return `${hour24}:${m}`;

            const suffix = h >= 12 ? 'PM' : 'AM';
            const h12 = (h % 12) === 0 ? 12 : (h % 12);
            return `${h12}:${m} ${suffix}`;
        }

        function _ccHumanize24hTimesInText(text){
            const s = String(text == null ? '' : text);
            // Convert any 24h-like time tokens (e.g. 9:00, 09:00, 17:30) to 12h with AM/PM.
            return s.replace(/\b([01]?\d|2[0-3]):([0-5]\d)\b/g, (match, hh, mm) => {
                return _ccFormatTime12h(hh, mm);
            });
        }

        function _showAvailabilitySaveBanner(kind, message, meta){
            const el = _ensureAvailabilitySaveBanner();
            const hint = _availabilitySaveHint(message);
            const safeMsg = String(message || '').trim();
            const friendlyMsg = _ccHumanize24hTimesInText(safeMsg);

            let scopeLabel = '';
            try {
                if (meta && meta.scopeLabel) scopeLabel = String(meta.scopeLabel || '').trim();
            } catch (e) { scopeLabel = ''; }

            // If the banner is shown repeatedly, avoid stacking multiple timers.
            try {
                if (window.__ccAvailabilitySaveBannerTimer) {
                    clearTimeout(window.__ccAvailabilitySaveBannerTimer);
                    window.__ccAvailabilitySaveBannerTimer = null;
                }
            } catch (e) {}

            el.style.display = 'block';
            if (kind === 'success') {
                el.style.border = '1px solid #86efac';
                el.style.background = '#ecfdf5';
                el.style.color = '#065f46';
                el.innerHTML = `<div style="font-weight:700">Saved</div><div style="margin-top:2px">${friendlyMsg || 'Weekly availability saved.'}</div>${scopeLabel ? `<div style="margin-top:6px; font-size:12px; opacity:0.95;">Scope: ${_ccEscapeHtml(scopeLabel)}</div>` : ''}`;

                // Auto-dismiss success after 5 seconds.
                try {
                    window.__ccAvailabilitySaveBannerTimer = setTimeout(() => {
                        try { _clearAvailabilitySaveBanner(); } catch (e) {}
                    }, 5000);
                } catch (e) {}
            } else {
                el.style.border = '1px solid #fecaca';
                el.style.background = '#fef2f2';
                el.style.color = '#7f1d1d';
                el.innerHTML = `<div style="font-weight:700">Couldn't save</div><div style="margin-top:2px">${friendlyMsg || 'The server rejected these changes.'}</div>${scopeLabel ? `<div style="margin-top:6px; font-size:12px; opacity:0.95;">Scope: ${_ccEscapeHtml(scopeLabel)}</div>` : ''}${hint ? `<div style="margin-top:6px;color:#991b1b"><strong>\u2022</strong> ${hint}</div>` : ''}`;
            }
            try { el.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); } catch (e) {}
        }

        function _clearAvailabilitySaveBanner(){
            const el = document.getElementById('cc-availability-save-banner');
            if (!el) return;
            el.style.display = 'none';
            el.textContent = '';
        }

        function _ccEscapeHtml(s){
            try {
                return String(s == null ? '' : s)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;');
            } catch (e) {
                return '';
            }
        }

        function _ensureOverridesSaveBanner(){
            const el = document.getElementById('cc-overrides-save-banner');
            const body = document.getElementById('cc-overrides-save-banner-body');
            const closeBtn = document.getElementById('cc-overrides-save-banner-close');
            if (!el || !body) return null;

            if (!el.__ccBound) {
                el.__ccBound = true;

                // Close button
                try {
                    if (closeBtn) {
                        closeBtn.addEventListener('click', (e) => {
                            try { e.preventDefault(); } catch (err) {}
                            _clearOverridesSaveBanner();
                        });
                    }
                } catch (e) {}

                // Action buttons inside banner
                try {
                    el.addEventListener('click', (e) => {
                        const btn = e && e.target && e.target.closest ? e.target.closest('button[data-cc-selection]') : null;
                        if (!btn) return;
                        try { e.preventDefault(); } catch (err) {}
                        const sel = btn.getAttribute('data-cc-selection');
                        if (!sel) return;
                        try {
                            if (typeof applySelection === 'function') applySelection(sel);
                            _clearOverridesSaveBanner();
                        } catch (err) { console.warn('Failed to switch selection', err); }
                    }, true);
                } catch (e) {}
            }

            return el;
        }

        function _ensureOverridesSaveBannerFloating(){
            try {
                const existing = document.getElementById('cc-overrides-save-banner-floating');
                if (existing) {
                    try {
                        try { existing.style.zIndex = '1000001'; } catch (e) {}
                        try { existing.style.pointerEvents = 'auto'; } catch (e) {}
                        if (!existing.__ccBound) {
                            existing.__ccBound = true;
                            const closeBtn = document.getElementById('cc-overrides-save-banner-floating-close');
                            if (closeBtn) {
                                try { closeBtn.setAttribute('onclick', "try{window.ccDismissOverrideBanner&&window.ccDismissOverrideBanner();}catch(e){}"); } catch (e) {}
                                try { closeBtn.style.position = 'relative'; closeBtn.style.zIndex = '1000002'; closeBtn.style.pointerEvents = 'auto'; } catch (e) {}
                                closeBtn.addEventListener('click', (e) => {
                                    try { e.preventDefault(); } catch (err) {}
                                    try { window.ccDismissOverrideBanner && window.ccDismissOverrideBanner(); } catch (e2) { try { _clearOverridesSaveBanner(); } catch (e3) {} }
                                });
                            }
                            existing.addEventListener('click', (e) => {
                                const btn = e && e.target && e.target.closest ? e.target.closest('button[data-cc-selection]') : null;
                                if (!btn) return;
                                try { e.preventDefault(); } catch (err) {}
                                const sel = btn.getAttribute('data-cc-selection');
                                if (!sel) return;
                                try {
                                    if (typeof applySelection === 'function') applySelection(sel);
                                    _clearOverridesSaveBanner();
                                } catch (err) { console.warn('Failed to switch selection', err); }
                            }, true);
                        }
                    } catch (e) {}
                    return existing;
                }

                const el = document.createElement('div');
                el.id = 'cc-overrides-save-banner-floating';
                el.setAttribute('role', 'status');
                el.setAttribute('aria-live', 'polite');
                el.style.display = 'none';
                el.style.position = 'fixed';
                el.style.left = '50%';
                el.style.top = '14px';
                el.style.transform = 'translateX(-50%)';
                el.style.zIndex = '1000001';
                el.style.pointerEvents = 'auto';
                el.style.maxWidth = 'min(920px, calc(100vw - 24px))';
                el.style.width = 'min(920px, calc(100vw - 24px))';
                el.style.padding = '12px 12px';
                el.style.borderRadius = '12px';
                el.style.border = '1px solid #fecaca';
                el.style.background = '#fef2f2';
                el.style.color = '#7f1d1d';
                el.style.boxShadow = '0 10px 22px rgba(0,0,0,0.18)';
                el.style.fontSize = '14px';
                el.style.lineHeight = '1.35';

                el.innerHTML = `
                    <div style="display:flex; align-items:flex-start; justify-content:space-between; gap:12px;">
                        <div id="cc-overrides-save-banner-floating-body"></div>
                        <button type="button" id="cc-overrides-save-banner-floating-close" onclick="try{window.ccDismissOverrideBanner&&window.ccDismissOverrideBanner();}catch(e){}" style="border:0; background:transparent; color:#7f1d1d; font-weight:800; cursor:pointer; padding:2px 6px; border-radius:8px;">×</button>
                    </div>
                `;

                document.body.appendChild(el);

                // Close button
                try {
                    const closeBtn = document.getElementById('cc-overrides-save-banner-floating-close');
                    if (closeBtn) {
                        try { closeBtn.style.position = 'relative'; closeBtn.style.zIndex = '1000002'; closeBtn.style.pointerEvents = 'auto'; } catch (e) {}
                        closeBtn.addEventListener('click', (e) => {
                            try { e.preventDefault(); } catch (err) {}
                            try { window.ccDismissOverrideBanner && window.ccDismissOverrideBanner(); } catch (e2) { _clearOverridesSaveBanner(); }
                        });
                    }
                } catch (e) {}

                // Action buttons inside banner
                try {
                    el.addEventListener('click', (e) => {
                        const btn = e && e.target && e.target.closest ? e.target.closest('button[data-cc-selection]') : null;
                        if (!btn) return;
                        try { e.preventDefault(); } catch (err) {}
                        const sel = btn.getAttribute('data-cc-selection');
                        if (!sel) return;
                        try {
                            if (typeof applySelection === 'function') applySelection(sel);
                            _clearOverridesSaveBanner();
                        } catch (err) { console.warn('Failed to switch selection', err); }
                    }, true);
                } catch (e) {}

                try { el.__ccBound = true; } catch (e) {}

                return el;
            } catch (e) {
                return null;
            }
        }

        function _clearOverridesSaveBanner(){
            // Clear whichever banners exist; do not return early if one is missing.
            try {
                const el = document.getElementById('cc-overrides-save-banner');
                const body = document.getElementById('cc-overrides-save-banner-body');
                if (el) el.style.display = 'none';
                if (body) body.innerHTML = '';
            } catch (e) {}

            try {
                const fel = document.getElementById('cc-overrides-save-banner-floating');
                const fbody = document.getElementById('cc-overrides-save-banner-floating-body');
                if (fel) fel.style.display = 'none';
                if (fbody) fbody.innerHTML = '';
            } catch (e) {}

            try {
                const hel = document.getElementById('cc-overrides-save-banner-hard');
                const hbody = document.getElementById('cc-overrides-save-banner-hard-body');
                if (hel) hel.style.display = 'none';
                if (hbody) hbody.innerHTML = '';
            } catch (e) {}
        }

        // Expose a global dismiss helper so inline onclick fallbacks work.
        try {
            window.ccDismissOverrideBanner = function(){
                try { window.__ccOverrideBannerSuppressUntil = Date.now() + 5000; } catch (e) {}
                try { _clearOverridesSaveBanner(); } catch (e) {}
            };
        } catch (e) {}

        function _ccSelectedServiceObj(){
            try {
                if (!SELECTED_MEMBER || !String(SELECTED_MEMBER).startsWith('svc:')) return null;
                const svcId = String(SELECTED_MEMBER).slice(4);
                return (Array.isArray(SERVICES) ? SERVICES.find(s => String(s.id) === String(svcId)) : null) || null;
            } catch (e) {
                return null;
            }
        }

        function _ccMemberNameByMembershipId(mid){
            try {
                const m = (Array.isArray(MEMBERS) ? MEMBERS.find(mm => String(mm.id) === String(mid)) : null);
                if (!m) return 'Member';
                if (typeof memberDisplayName === 'function') return memberDisplayName(m);
                return String(m.user__first_name || m.user__email || 'Member');
            } catch (e) {
                return 'Member';
            }
        }

        function _ccOrdinalSuffix(n){
            const v = Number(n) || 0;
            const mod100 = v % 100;
            if (mod100 >= 11 && mod100 <= 13) return 'th';
            switch (v % 10) {
                case 1: return 'st';
                case 2: return 'nd';
                case 3: return 'rd';
                default: return 'th';
            }
        }

        function _ccPrettyDateFromYMD(ymd){
            try {
                const s = String(ymd || '').trim();
                const m = s.match(/^(\d{4})-(\d{2})-(\d{2})$/);
                if (!m) return s;
                const year = Number(m[1]);
                const month = Number(m[2]);
                const day = Number(m[3]);
                const monthNames = ['January','February','March','April','May','June','July','August','September','October','November','December'];
                const name = monthNames[month - 1] || null;
                if (!name || !day) return s;
                return `${name} ${day}${_ccOrdinalSuffix(day)}`;
            } catch (e) {
                return String(ymd || '');
            }
        }

        function _ccHumanizeOverrideMessage(message){
            try {
                const msg = String(message || '');
                // Replace ISO dates (YYYY-MM-DD) with friendly month/day format.
                return msg.replace(/\b(\d{4}-\d{2}-\d{2})\b/g, (full, ymd) => _ccPrettyDateFromYMD(ymd));
            } catch (e) {
                return String(message || '');
            }
        }

        // Export so global banner helpers (outside this closure) can use it.
        try { window.__ccHumanizeOverrideMessage = _ccHumanizeOverrideMessage; } catch (e) {}

        function _overrideSaveHints(message){
            const m = String(message || '').toLowerCase();
            const hints = [];
            if (m.includes('no overlapping availability') || m.includes('overlapping availability for this group service')) {
                hints.push('This is a group service: open per-date or weekly availability for the assigned members first (the times must overlap), then retry the service override.');
            }
            if (m.includes('member calendar override') || m.includes('member calendar first') || m.includes('unavailable by default for this member')) {
                hints.push("This is a solo-service constraint: create the per-date override in the member's calendar first, then switch back to the service and retry.");
            }
            if (m.includes('within the assigned member\'s weekly availability')) {
                hints.push("Expand the member's weekly availability (or shrink the override range), then retry.");
            }
            if (m.includes("within this service's weekly availability")) {
                hints.push('Expand the service weekly availability for that day (or choose a time inside it), then retry.');
            }
            if (m.includes('overlaps')) {
                hints.push('If you need this time for this service, override the other solo service to unavailable for that date (or adjust weekly partitions first).');
            }
            return hints;
        }

        // Export for any code paths that run outside this closure.
        try { window.__ccOverrideSaveHints = _overrideSaveHints; } catch (e) {}

        function _overrideSaveActions(serverData){
            const actions = [];
            try {
                // If server tells us which member must be edited first, offer a one-click switch.
                if (serverData && serverData.membership_id != null) {
                    const mid = String(serverData.membership_id);
                    actions.push({ selection: mid, label: `Open ${_ccMemberNameByMembershipId(mid)} calendar` });
                }

                // In service scope, also offer switches to assigned members (group services).
                let svcId = null;
                try {
                    if (SELECTED_MEMBER && String(SELECTED_MEMBER).startsWith('svc:')) svcId = String(SELECTED_MEMBER).slice(4);
                    else if (window.__ccLastOverrideTarget && String(window.__ccLastOverrideTarget).startsWith('svc:')) svcId = String(window.__ccLastOverrideTarget).slice(4);
                    else {
                        const selEl = document.getElementById('memberSelect');
                        const domVal = selEl && selEl.value ? String(selEl.value) : '';
                        if (domVal && domVal.startsWith('svc:')) svcId = domVal.slice(4);
                        else {
                            const stored = (function(){ try { return localStorage.getItem('cc_selected_member'); } catch (e) { return null; } })();
                            const s = stored ? String(stored) : '';
                            if (s && s.startsWith('svc:')) svcId = s.slice(4);
                        }
                    }
                } catch (e) {}

                if (svcId != null) {
                    const svc = (Array.isArray(SERVICES) ? SERVICES.find(s => String(s.id) === String(svcId)) : null) || null;
                    const assigned = (typeof getAssignedMembersForService === 'function') ? (getAssignedMembersForService(svc) || []) : (svc && svc.assigned_members ? svc.assigned_members.map(String) : []);
                    const unique = Array.from(new Set((assigned || []).map(String)));
                    if (unique.length >= 1) {
                        unique.forEach(mid => {
                            // Avoid duplicating the server-specified member action
                            if (serverData && String(serverData.membership_id) === String(mid)) return;
                            actions.push({ selection: String(mid), label: `Open ${_ccMemberNameByMembershipId(mid)} calendar` });
                        });
                    }
                }
            } catch (e) { /* ignore */ }
            return actions;
        }

        // Export for any code paths that run outside this closure.
        try { window.__ccOverrideSaveActions = _overrideSaveActions; } catch (e) {}

        function _showOverridesSaveBanner(message, opts){
            const el = _ensureOverridesSaveBanner();
            const body = document.getElementById('cc-overrides-save-banner-body');
            const fel = _ensureOverridesSaveBannerFloating();
            const fbody = document.getElementById('cc-overrides-save-banner-floating-body');

            const status = opts && opts.status ? Number(opts.status) : null;
            const data = opts && opts.data ? opts.data : null;

            const msg = String(message || '').trim();
            const humanMsg = _ccHumanizeOverrideMessage(msg);
            const hints = _overrideSaveHints(msg);
            const actions = _overrideSaveActions(data);

            const actionsHtml = actions.length
                ? `<div style="margin-top:10px; display:flex; flex-wrap:wrap; gap:8px;">
                        ${actions.map(a => {
                            const sel = _ccEscapeHtml(a.selection);
                            const lbl = _ccEscapeHtml(a.label);
                            return `<button type="button" data-cc-selection="${sel}" style="border:1px solid #fca5a5; background:#fff; color:#7f1d1d; padding:7px 10px; border-radius:10px; cursor:pointer; font-weight:600;">${lbl}</button>`;
                        }).join('')}
                    </div>`
                : '';

            const hintsHtml = hints.length
                ? `<div style="margin-top:10px; color:#991b1b;">
                        ${hints.slice(0, 3).map(h => `<div style="margin-top:6px;"><strong>•</strong> ${_ccEscapeHtml(h)}</div>`).join('')}
                    </div>`
                : '';

            const html = `
                <div style="font-weight:800;">Couldn't save override</div>
                <div style="margin-top:3px;">${_ccEscapeHtml(humanMsg || (status ? `Server returned ${status}` : 'The server rejected this override.'))}</div>
                ${hintsHtml}
                ${actionsHtml}
            `;

            // In-card banner (if present)
            try {
                if (el && body) {
                    body.innerHTML = html;
                    el.style.display = 'block';
                }
            } catch (e) {}

            // Floating banner fallback (always try to show)
            try {
                if (fel && fbody) {
                    fbody.innerHTML = html;
                    fel.style.display = 'block';
                }
            } catch (e) {}

            // Make it hard to miss: flash the overrides card briefly.
            try {
                const oc = document.getElementById('overridesContainer');
                if (oc) {
                    oc.classList.add('cc-overrides-flash');
                    setTimeout(() => { try { oc.classList.remove('cc-overrides-flash'); } catch (e) {} }, 1400);
                }
            } catch (e) {}

            // Scroll to banner (some modal flows lock scrolling; fallback to window.scrollTo).
            try {
                if (el) el.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            } catch (e) {
                try {
                    const r = (el && el.getBoundingClientRect) ? el.getBoundingClientRect() : null;
                    if (!r) return;
                    const top = (r.top || 0) + (window.pageYOffset || document.documentElement.scrollTop || 0);
                    window.scrollTo({ top: Math.max(0, top - 18), behavior: 'smooth' });
                } catch (e2) {}
            }
        }

        saveBtn.onclick = async function() {
            // Build payload from dynamic inputs
            const payload = [];
            for (let day = 0; day < 7; day++) {
                const containerEl = document.getElementById(`ranges-container-${day}`);
                const rows = containerEl ? Array.from(containerEl.querySelectorAll('.range-row')) : [];
                const ranges = [];
                try {
                    const verdict = _ccValidateRangeRowsNoOverlap(rows, '.range-start', '.range-end');
                    if (!verdict.ok) {
                        _ccToastRangeError(`Invalid range for ${days[day]}: ${verdict.message}`);
                        return;
                    }
                } catch (e) { /* ignore */ }
                for (const r of rows) {
                    const s = r.querySelector('.range-start').value;
                    const e = r.querySelector('.range-end').value;
                    if (!s || !e) continue;
                    if (s >= e) {
                        _ccToastRangeError(`Invalid range for ${days[day]}: start must be before end (${s} >= ${e})`);
                        return;
                    }
                    ranges.push(`${s}-${e}`);
                }
                const cb = document.querySelector(`.unavailable-checkbox[data-day='${day}']`);
                const unavailableChecked = !!(cb && cb.checked);
                // If no ranges remain, treat the day as unavailable even if the checkbox
                // wasn't toggled. This matches persisted semantics and avoids re-render
                // creating a default range row.
                const unavailable = unavailableChecked || ranges.length === 0;
                // Backend accepts day names or numeric; send full day name for clarity
                payload.push({ day: days[day], ranges: ranges, unavailable: unavailable });
            }

            // Debug: show payload about to be sent to server (days sent as names)
            console.log('Saving weekly availability payload (day names):', JSON.parse(JSON.stringify(payload)));

            try {
                // Save ONLY the current selection (member or service). Sending bulk maps here
                // causes stale data to overwrite the current edits.
                const target = (ccOverrideTarget() || null);
                let scopeLabel = '';
                try { if (typeof getSelectionLabel === 'function') scopeLabel = String(getSelectionLabel() || '').trim(); } catch (e) { scopeLabel = ''; }
                try { console.log('Saving weekly availability target:', target, 'label:', scopeLabel); } catch (e) {}

                const res = await fetch(`/bus/${orgSlug}/availability/save/`, {
                    method: 'POST',
                    credentials: 'same-origin',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrftoken
                    },
                    body: JSON.stringify({ availability: payload, target: target })
                });

                const data = await res.json().catch(() => null);
                if (res.ok && data && data.success) {
                    _showAvailabilitySaveBanner('success', 'Weekly availability saved.', { scopeLabel: scopeLabel });

                    // Update selection-specific caches so switching scopes doesn't revert until reload.
                    try {
                        if (target && !String(target).startsWith('svc:')) {
                            // membership id
                            memberDefaultAvailability[String(target)] = buildAvailabilityFromPayload(payload);
                            try { memberAvailMap[String(target)] = payload; } catch (e) {}
                        } else if (target && String(target).startsWith('svc:')) {
                            const svcId = String(target).slice(4);
                            const svc = (SERVICES||[]).find(s => String(s.id) === String(svcId));
                            if (svc) {
                                // Store as list-of-lists (UI expects this shape for unions).
                                const byDay = [[],[],[],[],[],[],[]];
                                for (let i=0;i<7;i++){
                                    const row = payload[i];
                                    if (row && !row.unavailable && Array.isArray(row.ranges)) byDay[i] = row.ranges.slice();
                                    else byDay[i] = [];
                                }
                                svc.weekly_map = byDay;
                                svc.has_service_weekly_windows = true;
                            }
                        }
                    } catch (e) { console.warn('Failed to update selection caches after save', e); }

                    // Update local defaultAvailability from payload so the UI reflects saved values immediately
                    try {
                        payload.forEach(item => {
                            let dayIdx = null;
                            if (typeof item.day === 'number') dayIdx = item.day;
                            else if (typeof item.day === 'string') {
                                const name = item.day.trim();
                                // try to match full weekday name first
                                const idx = weekdayNames.indexOf(name);
                                if (idx !== -1) dayIdx = idx;
                                else {
                                    // try numeric string
                                    const asNum = parseInt(name, 10);
                                    if (!isNaN(asNum)) dayIdx = ((asNum % 7) + 7) % 7;
                                }
                            }
                            if (dayIdx === null || typeof dayIdx !== 'number' || isNaN(dayIdx)) return;
                            // apply values
                            defaultAvailability[dayIdx].unavailable = !!item.unavailable;
                            defaultAvailability[dayIdx].ranges = Array.isArray(item.ranges) ? item.ranges.slice() : [];
                            if (defaultAvailability[dayIdx].ranges && defaultAvailability[dayIdx].ranges.length) {
                                const first = defaultAvailability[dayIdx].ranges[0];
                                if (first && first.includes('-')) {
                                    const [s,e] = first.split('-');
                                    defaultAvailability[dayIdx].start = s.trim();
                                    defaultAvailability[dayIdx].end = e.trim();
                                }
                            }
                        });
                    } catch (e) { console.warn('Failed to update local defaults after save', e); }

                    // If we're in service scope, month "day circles" are driven by a cached
                    // backend-computed parity map. Weekly default changes must invalidate that
                    // cache so the current month updates immediately without a hard refresh.
                    try { if (typeof _invalidateServiceScopeParityCache === 'function') _invalidateServiceScopeParityCache(); } catch (e) {}

                    // Re-render inputs and calendar backgrounds immediately
                    try { displayDefaultAvailability(); } catch (e) { console.warn('displayDefaultAvailability failed', e); }
                    // Prefer the immediate sync (non-debounced) on save so changes paint instantly.
                    try {
                        if (typeof syncAvailabilityToCalendarImmediate === 'function') syncAvailabilityToCalendarImmediate();
                        else syncAvailabilityToCalendar();
                    } catch (e) { console.warn('syncAvailabilityToCalendar failed', e); }
                    try { updateUnavailableDays(); } catch (e) { console.warn('updateUnavailableDays failed', e); }
                    // Also refetch server events to pick up any server-side overrides
                    try { calendar.refetchEvents(); } catch (e) { /* ignore */ }
                } else {
                    const msg = (data && (data.error || data.message)) || `Server returned ${res.status}`;
                    _showAvailabilitySaveBanner('error', msg, { scopeLabel: scopeLabel });
                }
            } catch (err) {
                console.error('Save failed', err);
                const msg = (err && err.message) ? err.message : String(err);
                let scopeLabel = '';
                try { if (typeof getSelectionLabel === 'function') scopeLabel = String(getSelectionLabel() || '').trim(); } catch (e) { scopeLabel = ''; }
                _showAvailabilitySaveBanner('error', msg, { scopeLabel: scopeLabel });
            }
        };
    }

    const calendarEl = document.getElementById('calendar');
    const clearBtn = document.getElementById('clearSelectionBtn');
    const selectBtn = document.getElementById('selectDaysBtn');
     const retryInitBtn = document.getElementById('retryInitCalendarBtn');
    if (retryInitBtn) retryInitBtn.addEventListener('click', () => { try { location.reload(); } catch(e){} });
    
    const orgSlug = "{{ organization.slug }}";
    const orgTimezone = "{{ org_timezone }}";  // e.g., 'America/Los_Angeles'
    const EDIT_SERVICE_URL_TEMPLATE = "{% url 'calendar_app:edit_service' organization.slug 0 %}";
        // Services metadata from server (includes per-service weekly_map)
        const SERVICES = {{ services_json|default:"[]"|safe }} || [];
        const MEMBERS = {{ members_list|default:'[]'|safe }} || [];
        const IS_TEAM = {{ is_team_plan|yesno:'true,false' }};
        const IS_PRO = {{ is_pro_plan|yesno:'true,false' }};
        const CAN_USE_OVERRIDES = {{ can_use_overrides|yesno:'true,false' }};
        const CC_APP_MODE = {{ cc_app_mode|yesno:'true,false' }};
        const PRICING_URL = "{% url 'calendar_app:pricing_page' organization.slug %}";
        const APP_PLANS_URL = "{% url 'calendar_app:app_plans_page' organization.slug %}?cc_app=1";
        // Selected member id (string). Defaults to saved selection or provided default_member_id or first member id.
        const DEFAULT_MEMBER = {{ default_member_id|default:'null' }};
        // Selection storage:
        // - Team: cc_selected_member (membership id or svc:<id>)
        // - Pro:  cc_selected_scope (svc:<id> or 'overall')
        let SELECTED_MEMBER = null;
        try {
            if (IS_TEAM) {
                const _stored_selected = localStorage.getItem('cc_selected_member');
                SELECTED_MEMBER = (_stored_selected && _stored_selected !== 'null') ? _stored_selected : (DEFAULT_MEMBER ? String(DEFAULT_MEMBER) : (MEMBERS.length? String(MEMBERS[0].id) : null));
            } else if (IS_PRO) {
                const stored = localStorage.getItem('cc_selected_scope');
                if (stored && String(stored).startsWith('svc:')) {
                    const svcId = String(stored).slice(4);
                    const exists = SERVICES.some(s => String(s.id) === String(svcId));
                    SELECTED_MEMBER = exists ? String(stored) : null;
                } else {
                    // Default to overall availability on Pro
                    SELECTED_MEMBER = null;
                }
            } else {
                // Non-Team/Non-Pro plans: always org scope.
                SELECTED_MEMBER = null;
            }
        } catch (e) {
            SELECTED_MEMBER = null;
        }
        // If not Team/Pro, disable selection and ensure stale team storage is cleared.
        if (!IS_TEAM && !IS_PRO) {
            SELECTED_MEMBER = null;
            try{ localStorage.removeItem('cc_selected_member'); }catch(e){}
            try{ localStorage.removeItem('cc_selected_scope'); }catch(e){}
        }

        // Deep-link: allow setting the selected team member from querystring.
        // Used by Service edit prompts when a member has no availability.
        try{
            const params = new URLSearchParams(window.location.search || '');
            const qSel = params.get('select_member');
            if (IS_TEAM && qSel) {
                const exists = MEMBERS.some(m => String(m.id) === String(qSel));
                if (exists) {
                    SELECTED_MEMBER = String(qSel);
                    try{ localStorage.setItem('cc_selected_member', SELECTED_MEMBER); }catch(e){}
                }
                try{
                    params.delete('select_member');
                    const qs = params.toString();
                    const nextUrl = window.location.pathname + (qs ? ('?' + qs) : '') + (window.location.hash || '');
                    window.history.replaceState({}, '', nextUrl);
                } catch(e) {}
            }
        }catch(e){ /* ignore */ }
        // Visible services after filtering by selected member
        let VISIBLE_SERVICES = [];

        function ccPromptOverridesUpgrade() {
            try {
                const modal = document.getElementById('ccOverridesUpgradeModal');
                const cancelBtn = document.getElementById('ccOverridesUpgradeCancelBtn');
                const goBtn = document.getElementById('ccOverridesUpgradeGoBtn');

                // Fallback if the modal HTML isn't present for some reason
                if (!modal || !cancelBtn || !goBtn) {
                    const msg = 'A higher subscription plan is required to override days.';
                    if (CC_APP_MODE) {
                        alert(msg + "\n\nThis feature isn’t available in the mobile app. You can view plan details in Plans or contact support.");
                    } else {
                        const go = confirm(msg + "\n\nPress OK to view pricing, or Cancel to stay on the calendar.");
                        if (go) {
                            try { window.location.href = PRICING_URL; } catch (e) {}
                        }
                    }
                    return false;
                }

                // Show
                modal.style.display = 'flex';

                let cleaned = false;
                function cleanup() {
                    if (cleaned) return;
                    cleaned = true;
                    try { cancelBtn.onclick = null; } catch (e) {}
                    try { goBtn.onclick = null; } catch (e) {}
                    try { modal.onclick = null; } catch (e) {}
                    try { document.removeEventListener('keydown', onKey); } catch (e) {}
                }
                function close() {
                    try { modal.style.display = 'none'; } catch (e) {}
                    cleanup();
                }
                function onKey(e) {
                    try {
                        if (e && e.key === 'Escape') close();
                    } catch (err) {}
                }

                cancelBtn.onclick = (e) => {
                    try { e.preventDefault(); } catch (err) {}
                    close();
                };
                goBtn.onclick = (e) => {
                    try { e.preventDefault(); } catch (err) {}
                    if (CC_APP_MODE) {
                        close();
                        try { window.location.href = APP_PLANS_URL; } catch (err) {}
                    } else {
                        try { window.location.href = PRICING_URL; } catch (err) {}
                    }
                };
                // Click outside the dialog -> cancel
                modal.onclick = (e) => {
                    try {
                        if (e && e.target === modal) close();
                    } catch (err) {}
                };
                try { document.addEventListener('keydown', onKey); } catch (e) {}
            } catch (e) {
                const msg = 'Upgrade to at least the Pro plan to override days (per-date availability).';
                if (CC_APP_MODE) {
                    try { alert(msg + "\n\nThis feature isn’t available in the mobile app. You can view plan details in Plans or contact support."); } catch (err) {}
                } else {
                    const go = confirm(msg + "\n\nPress OK to view pricing, or Cancel to stay on the calendar.");
                    if (go) {
                        try { window.location.href = PRICING_URL; } catch (err) {}
                    }
                }
            }
            return false;
        }

        // Hard-stop any background/legacy flows that try to hit the per-date override endpoints
        // when the plan doesn't allow it, and show the upgrade prompt instead.
        (function ccGuardOverrideEndpoints(){
            if (CAN_USE_OVERRIDES) return;
            try {
                const _fetch = window.fetch;
                if (typeof _fetch !== 'function') return;
                window.fetch = function(input, init){
                    try {
                        const url = (typeof input === 'string') ? input : (input && input.url ? input.url : '');
                        if (url && (url.includes(`/bus/${orgSlug}/bookings/batch_create/`) || url.includes(`/bus/${orgSlug}/bookings/batch_delete/`))) {
                            ccPromptOverridesUpgrade();
                            return Promise.reject(new Error('Per-date overrides are locked by plan'));
                        }
                    } catch (e) {}
                    return _fetch.apply(this, arguments);
                };
            } catch (e) {}
        })();

        function ccEnforceOverridesLock() {
            if (CAN_USE_OVERRIDES) return;
            // Keep the section visible but greyed out.
            const oc = document.getElementById('overridesContainer');
            if (oc) {
                try { oc.classList.add('cc-overrides-disabled'); } catch (e) {}
                // Intercept attempts from within the overrides section (any click).
                // The overlay + pointer-events CSS blocks interaction; this click handler provides the prompt.
                try {
                    oc.addEventListener('click', (evt) => {
                        evt.preventDefault();
                        evt.stopPropagation();
                        ccPromptOverridesUpgrade();
                    }, true);
                } catch (e) {}
            }
        }
        try { ccEnforceOverridesLock(); } catch(e) {}

        // Keep service-scope month visuals in sync immediately after per-date override changes.
        // This fixes cases where overrides apply server-side (public page correct) but the
        // internal calendar stays visually stale due to parity caching.
        (function ccHookOverrideMutations(){
            try {
                const _fetch = window.fetch;
                if (typeof _fetch !== 'function') return;
                // Avoid double-wrapping
                if (window.__ccOverrideMutationHookInstalled) return;
                window.__ccOverrideMutationHookInstalled = true;

                window.fetch = function(input, init){
                    let url = '';
                    try {
                        url = (typeof input === 'string') ? input : (input && input.url ? input.url : '');
                    } catch (e) { url = ''; }

                    const isOverrideMutation = !!(url && (url.includes(`/bus/${orgSlug}/bookings/batch_create/`) || url.includes(`/bus/${orgSlug}/bookings/batch_delete/`)));
                    const p = _fetch.apply(this, arguments);
                    if (!isOverrideMutation || !p || typeof p.then !== 'function') return p;

                    return p.then((res) => {
                        try {
                            if (res && res.ok) {
                                try { _clearOverridesSaveBanner(); } catch (e) {}
                                try { if (typeof _invalidateServiceScopeParityCache === 'function') _invalidateServiceScopeParityCache(); } catch (e) {}
                                // Refresh day styles + table on the next tick (after any refetchEvents).
                                try {
                                    setTimeout(() => {
                                        try { updateUnavailableDays(); } catch (e) {}
                                        try { renderOverridesTable(); } catch (e) {}
                                    }, 0);
                                } catch (e) {}
                            } else if (res && !res.ok) {
                                // Surface the denial reason in the UI banner (do not consume the original body).
                                try {
                                    const clone = (typeof res.clone === 'function') ? res.clone() : null;
                                    if (clone && typeof _ccReadJsonOrText === 'function') {
                                        _ccReadJsonOrText(clone).then(({ data, text }) => {
                                            try {
                                                const msg = (data && (data.error || data.message)) || (String(text || '').trim()) || `Server returned ${res.status}`;
                                                _showOverridesSaveBanner(msg, { status: res.status, data: data || null });
                                            } catch (e) {}
                                        }).catch(() => {
                                            try { _showOverridesSaveBanner(`Server returned ${res.status}`, { status: res.status }); } catch (e) {}
                                        });
                                    } else {
                                        try { _showOverridesSaveBanner(`Server returned ${res.status}`, { status: res.status }); } catch (e) {}
                                    }
                                } catch (e) { /* ignore */ }
                            }
                        } catch (e) {}
                        return res;
                    });
                };
            } catch (e) { /* ignore */ }
        })();

        // Ensure each service has a weekly_map array (server should provide this, but keep a defensive fallback).
        try{
            if (Array.isArray(SERVICES)){
                for (const s of SERVICES){
                    try{
                        if (!s.weekly_map || !Array.isArray(s.weekly_map) || s.weekly_map.length !== 7){
                            s.weekly_map = makeAllUnavailablePayload().map(row => row.ranges || []);
                        }
                    }catch(e){}
                }
            }
        }catch(e){}

        function getAssignedMembersForService(serviceObj) {
            try {
                const assigned = (serviceObj && Array.isArray(serviceObj.assigned_members)) ? serviceObj.assigned_members : [];
                return assigned.map(String);
            } catch (e) {
                return [];
            }
        }

        function isSingleAssigneeService(serviceObj) {
            try {
                return getAssignedMembersForService(serviceObj).length === 1;
            } catch (e) {
                return false;
            }
        }

        function _soloServicesForMember(membershipId) {
            try {
                const idStr = String(membershipId);
                if (!idStr) return [];
                if (!Array.isArray(SERVICES)) return [];
                return SERVICES.filter(s => {
                    try {
                        const assigned = getAssignedMembersForService(s);
                        return assigned.length === 1 && String(assigned[0]) === idStr;
                    } catch (e) {
                        return false;
                    }
                });
            } catch (e) {
                return [];
            }
        }

        function _mergedSoloServiceIdForMemberScope(membershipId) {
            try {
                if (!membershipId) return null;
                const solo = _soloServicesForMember(membershipId);
                if (solo.length !== 1) return null;
                const svc = solo[0];
                const id = (svc && (svc.id != null)) ? svc.id : null;
                return id != null ? String(id) : null;
            } catch (e) {
                return null;
            }
        }

        function getSelectedUserIdForMembership(membershipId) {
            try {
                const m = MEMBERS.find(mm => String(mm.id) === String(membershipId));
                if (!m) return null;
                const uid = (m.user__id || m.user_id || (m.user && (m.user.id || m.user.pk)) || null);
                return uid ? Number(uid) : null;
            } catch (e) {
                return null;
            }
        }

        function getScopePropsForSelection(selection) {
            try {
                if (!selection) return {};
                if (String(selection).startsWith('svc:')) {
                    return { assigned_scope_service_id: Number(String(selection).slice(4)) };
                }
                // membership selection: use assigned_user_id (user id) to match server event feed,
                // but keep membership id as well for debugging/traceability.
                const userId = getSelectedUserIdForMembership(selection);
                const props = { assigned_membership_id: Number(selection) };
                if (userId) props.assigned_user_id = Number(userId);
                return props;
            } catch (e) {
                return {};
            }
        }

        function ccSetBtnLoading(btn, isLoading, loadingLabel) {
            try {
                if (!btn) return;
                if (isLoading) {
                    if (!btn.dataset.ccOrigHtml) btn.dataset.ccOrigHtml = btn.innerHTML;
                    if (btn.dataset.ccOrigDisabled == null) btn.dataset.ccOrigDisabled = String(!!btn.disabled);
                    btn.classList.add('cc-btn-loading');
                    btn.disabled = true;
                    const label = (loadingLabel != null) ? String(loadingLabel) : 'Working…';
                    btn.innerHTML = `<span class="cc-btn-loading-content"><span class="cc-inline-spinner" aria-hidden="true"></span><span>${label}</span></span>`;
                } else {
                    btn.classList.remove('cc-btn-loading');
                    if (btn.dataset.ccOrigHtml) {
                        btn.innerHTML = btn.dataset.ccOrigHtml;
                        delete btn.dataset.ccOrigHtml;
                    }
                    if (btn.dataset.ccOrigDisabled != null) {
                        btn.disabled = (btn.dataset.ccOrigDisabled === 'true');
                        delete btn.dataset.ccOrigDisabled;
                    }
                }
            } catch (e) { /* ignore */ }
        }

        // Return the current override target (membership id or 'svc:<id>')
        function ccOverrideTarget() {
            try {
                // Prefer explicit SELECTED_MEMBER value used across the template
                if (typeof SELECTED_MEMBER !== 'undefined' && SELECTED_MEMBER) {
                    try { window.__ccLastOverrideTarget = SELECTED_MEMBER; } catch (e) {}
                    return SELECTED_MEMBER;
                }
                // Fallback to DOM member select if present
                const sel = document.getElementById('memberSelect');
                if (sel && sel.value) {
                    try { window.__ccLastOverrideTarget = sel.value; } catch (e) {}
                    return sel.value;
                }
            } catch (e) { /* ignore */ }
            return null;
        }

        function purgeOptimisticPerDateEvents() {
            try {
                if (!calendar || typeof calendar.getEvents !== 'function') return;
                calendar.getEvents().forEach(ev => {
                    try {
                        const xp = ev.extendedProps || {};
                        if (ev.display === 'background' && xp.is_per_date && xp.optimistic) {
                            ev.remove();
                        }
                    } catch (e) { /* ignore */ }
                });
            } catch (e) { /* ignore */ }
        }

        function _minutesFromTimeStr(t) {
            try {
                const s = String(t || '').trim();
                const parts = s.split(':');
                const hh = parseInt(parts[0] || '0', 10) || 0;
                const mm = parseInt(parts[1] || '0', 10) || 0;
                return (hh * 60) + mm;
            } catch (e) {
                return 0;
            }
        }

        // -----------------------------
        // Weekly + Modal range validation
        // -----------------------------
        function _ccHHMMFromMinutes(mins) {
            // HTML <input type="time"> uses 24h HH:MM. Clamp to 00:00..23:59.
            try {
                const m = Math.max(0, Math.min(23 * 60 + 59, Number(mins) || 0));
                const hh = Math.floor(m / 60);
                const mm = m % 60;
                return `${String(hh).padStart(2, '0')}:${String(mm).padStart(2, '0')}`;
            } catch (e) {
                return '00:00';
            }
        }

        function _ccToastRangeError(msg) {
            const text = String(msg || 'Time ranges cannot overlap or duplicate.');
            try {
                if (typeof showToast === 'function') return showToast('error', text);
            } catch (e) {}
            try { alert(text); } catch (e) {}
        }

        function _ccSetPrevValue(el) {
            try {
                if (!el) return;
                el.dataset.ccPrevValue = String(el.value || '');
            } catch (e) {}
        }

        function _ccRevertToPrevValue(el) {
            try {
                if (!el) return;
                const prev = (el.dataset && el.dataset.ccPrevValue != null) ? el.dataset.ccPrevValue : null;
                if (prev != null) el.value = prev;
            } catch (e) {}
        }

        function _ccCollectIntervalsFromRows(rows, startSelector, endSelector) {
            const intervals = [];
            for (const row of (rows || [])) {
                try {
                    const sEl = row.querySelector(startSelector);
                    const eEl = row.querySelector(endSelector);
                    const s = (sEl && sEl.value) ? String(sEl.value).trim() : '';
                    const e = (eEl && eEl.value) ? String(eEl.value).trim() : '';
                    if (!s || !e) continue;
                    const startMin = _minutesFromTimeStr(s);
                    const endMin = _minutesFromTimeStr(e);
                    intervals.push({ start: s, end: e, startMin, endMin });
                } catch (e) { /* ignore */ }
            }
            return intervals;
        }

        function _ccValidateIntervalsNoOverlap(intervals) {
            // intervals: [{start,end,startMin,endMin}, ...]
            try {
                const list = (intervals || []).slice();
                for (const it of list) {
                    if (!Number.isFinite(it.startMin) || !Number.isFinite(it.endMin)) {
                        return { ok: false, message: 'Invalid time range.' };
                    }
                    if (it.startMin >= it.endMin) {
                        return { ok: false, message: 'End time must be after start time.' };
                    }
                }
                list.sort((a, b) => (a.startMin === b.startMin ? a.endMin - b.endMin : a.startMin - b.startMin));
                let prev = null;
                for (const cur of list) {
                    if (prev) {
                        // duplicates also count as overlap
                        if (cur.startMin < prev.endMin) {
                            return { ok: false, message: `Time ranges cannot overlap or duplicate (${prev.start}-${prev.end} conflicts with ${cur.start}-${cur.end}).` };
                        }
                    }
                    prev = cur;
                }
                return { ok: true, message: '' };
            } catch (e) {
                return { ok: false, message: 'Invalid time ranges.' };
            }
        }

        function _ccValidateRangeRowsNoOverlap(rows, startSelector, endSelector) {
            const intervals = _ccCollectIntervalsFromRows(rows, startSelector, endSelector);
            return _ccValidateIntervalsNoOverlap(intervals);
        }

        function _ccSuggestNextNonOverlappingRange(existingIntervals, preferredDurationMinutes) {
            try {
                const dur = Math.max(5, Number(preferredDurationMinutes) || 60);
                const list = (existingIntervals || []).slice().filter(it => Number.isFinite(it.startMin) && Number.isFinite(it.endMin) && it.startMin < it.endMin);
                list.sort((a, b) => (a.startMin === b.startMin ? a.endMin - b.endMin : a.startMin - b.startMin));
                const lastEnd = list.length ? list[list.length - 1].endMin : (9 * 60);
                const startMin = Math.max(0, Math.min(23 * 60 + 59, lastEnd));
                const endMin = Math.min(23 * 60 + 59, startMin + dur);
                if (endMin <= startMin) return null;
                return { start: _ccHHMMFromMinutes(startMin), end: _ccHHMMFromMinutes(endMin) };
            } catch (e) {
                return { start: '09:00', end: '10:00' };
            }
        }

        function _timeStrFromMinutes(mins) {
            try {
                const m = Math.max(0, Math.min(24 * 60, Number(mins) || 0));
                const hh = Math.floor(m / 60);
                const mm = m % 60;
                const ampm = hh >= 12 ? 'PM' : 'AM';
                let h12 = hh % 12;
                if (h12 === 0) h12 = 12;
                return `${h12}:${String(mm).padStart(2, '0')} ${ampm}`;
            } catch (e) {
                return '';
            }
        }

        function _getDayBoundsLocal(dateStr) {
            const d = parseYMD(dateStr);
            const start = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0, 0, 0, 0);
            const end = new Date(d.getFullYear(), d.getMonth(), d.getDate() + 1, 0, 0, 0, 0);
            return [start, end];
        }

        function _isRealBookingEvent(ev) {
            try {
                const xp = ev.extendedProps || {};
                if (xp.is_blocking || xp.is_per_date || ev.display === 'background') return false;
                return true;
            } catch (e) {
                return false;
            }
        }

        function _isBookingInSelectedScope(ev) {
            try {
                if (!SELECTED_MEMBER) return true;
                const xp = ev.extendedProps || {};

                // Service-scoped selection: only consider bookings for that service
                if (String(SELECTED_MEMBER).startsWith('svc:')) {
                    const svcId = String(SELECTED_MEMBER).slice(4);
                    const bookingSvc = (xp.service_id || xp.service || ev.service_id || null);
                    if (!bookingSvc) return true; // conservative if id is missing
                    return String(bookingSvc) === String(svcId);
                }

                // Member-scoped selection:
                // Show bookings that belong to this member.
                // Primary signals are assigned_user_id / assigned_membership_id, but
                // if those are missing we fall back to the booking's service assignment.
                try {
                    const mUserId = getSelectedUserIdForMembership(SELECTED_MEMBER);
                    const assignedUserId = (xp.assigned_user_id || ev.assigned_user_id || null);
                    if (assignedUserId && mUserId && String(assignedUserId) === String(mUserId)) return true;
                    const assignedMembershipId = (xp.assigned_membership_id || ev.assigned_membership_id || null);
                    if (assignedMembershipId && String(assignedMembershipId) === String(SELECTED_MEMBER)) return true;

                    // Fallback: match by service assignment (covers older payloads)
                    const bookingSvc = (
                        xp.service_id || xp.assigned_scope_service_id || xp.assigned_scope_service ||
                        xp.assigned_service_id || xp.service || ev.service_id || null
                    );
                    if (bookingSvc != null) {
                        const svc = (typeof svcById === 'function') ? svcById(bookingSvc) : null;
                        if (svc) {
                            const assigned = (typeof getAssignedMembersForService === 'function') ? (getAssignedMembersForService(svc) || []) : [];
                            if (assigned.some(x => String(x) === String(SELECTED_MEMBER))) return true;
                        }
                    }

                    return false;
                } catch (e) {
                    return true;
                }
            } catch (e) {
                return true;
            }
        }

        function _getBookingsForDateInScope(dateStr) {
            const out = [];
            if (!calendar || typeof calendar.getEvents !== 'function') return out;
            const [dayStart, dayEnd] = _getDayBoundsLocal(dateStr);

            let events = [];
            try { events = calendar.getEvents() || []; } catch (e) { events = []; }

            for (const ev of events) {
                try {
                    if (!_isRealBookingEvent(ev)) continue;
                    if (!_isBookingInSelectedScope(ev)) continue;
                    const s = ev.start || null;
                    const e = ev.end || null;
                    if (!s) continue;
                    const end = e || s;
                    const overlaps = (s < dayEnd) && (end > dayStart);
                    if (!overlaps) continue;
                    out.push(ev);
                } catch (e) { /* ignore */ }
            }

            try { out.sort((a,b) => (a.start?.getTime()||0) - (b.start?.getTime()||0)); } catch (e) {}
            return out;
        }

        function _weeklyDefaultRangesForDate(dateStr) {
            try {
                const d = parseYMD(dateStr);
                const dow = d.getDay();
                const info = defaultAvailability[dow] || {};
                const ranges = info.ranges && info.ranges.length ? info.ranges : (info.start && info.end ? [`${info.start}-${info.end}`] : []);
                if (!ranges || !ranges.length) return [];
                return ranges.map(r => {
                    const parts = String(r || '').split('-');
                    return { start: (parts[0] || '00:00').trim(), end: (parts[1] || '00:00').trim() };
                }).filter(r => r.start && r.end && r.start < r.end);
            } catch (e) {
                return [];
            }
        }

        function _validateOverrideAgainstBookings(dateStr, rangesOrNull) {
            const bookings = _getBookingsForDateInScope(dateStr);
            if (!bookings.length) return { ok: true };

            // Full-day unavailable (blocking): any booking blocks this action
            if (!rangesOrNull || !Array.isArray(rangesOrNull) || rangesOrNull.length === 0) {
                const first = bookings[0];
                const s = first.start;
                const e = first.end || first.start;
                const msg = `Can’t block ${dateStr} because there’s already a booking (${s ? s.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}) : '—'}${e ? ' - ' + e.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}) : ''}).`;
                return { ok: false, message: msg };
            }

            const parsedRanges = [];
            for (const r of rangesOrNull) {
                try {
                    const start = _minutesFromTimeStr(r.start);
                    const end = _minutesFromTimeStr(r.end);
                    if (start < end) parsedRanges.push({ start, end });
                } catch (e) {}
            }
            if (!parsedRanges.length) {
                return _validateOverrideAgainstBookings(dateStr, null);
            }

            const [dayStart] = _getDayBoundsLocal(dateStr);
            for (const b of bookings) {
                try {
                    const bs = b.start;
                    const be = b.end || b.start;
                    if (!bs) continue;
                    const startMin = Math.max(0, Math.floor((bs.getTime() - dayStart.getTime()) / 60000));
                    const endMin = Math.min(24 * 60, Math.ceil((be.getTime() - dayStart.getTime()) / 60000));

                    const covered = parsedRanges.some(r => r.start <= startMin && endMin <= r.end);
                    if (!covered) {
                        const msg = `Can’t save availability for ${dateStr}. A booking (${_timeStrFromMinutes(startMin)} - ${_timeStrFromMinutes(endMin)}) would fall outside the new override ranges.`;
                        return { ok: false, message: msg };
                    }
                } catch (e) { /* ignore */ }
            }

            return { ok: true };
        }

        // Helper: return a human-friendly label for the current selection (member or service)
        function getSelectionLabel() {
            try {
                if (!SELECTED_MEMBER) return (IS_PRO && !IS_TEAM) ? 'Overall availability' : 'organization defaults';
                if (String(SELECTED_MEMBER).startsWith('svc:')) {
                    const svcId = String(SELECTED_MEMBER).slice(4);
                    const svc = SERVICES.find(s => String(s.id) === String(svcId));
                    const svcLabel = svc ? (svc.name || svc.title || `Service ${svcId}`) : `Service ${svcId}`;
                    try {
                        if (svc) {
                            const assigned = getAssignedMembersForService(svc) || [];
                            if (assigned.length === 1) {
                                const m = MEMBERS.find(mm => String(mm.id) === String(assigned[0]));
                                const mLabel = m ? memberDisplayName(m) : 'Member';
                                return `${mLabel} - ${svcLabel}`;
                            }
                        }
                    } catch (e) { /* ignore */ }
                    return svcLabel;
                }
                const m = MEMBERS.find(mm => String(mm.id) === String(SELECTED_MEMBER));
                if (!m) return 'selected member';
                const fname = (m.user__first_name || m.first_name || (m.user && (m.user.first_name || m.user.firstName)) || '');
                const lname = (m.user__last_name || m.last_name || (m.user && (m.user.last_name || m.user.lastName)) || '');
                const email = (m.user__email || m.email || (m.user && m.user.email) || '');
                const display = (m.display_name || m.profile_display_name || m.name || '').trim();
                const full = ((fname || lname) ? `${(fname||'').trim()} ${(lname||'').trim()}`.trim() : (email || display || 'member'));
                if (display && display.length && display.toLowerCase() !== full.toLowerCase()) return `${full} (${display})`;
                return full;
            } catch (e) { return 'selected member'; }
        }

        function updateVisibleServices(){
            if (!SELECTED_MEMBER){
                VISIBLE_SERVICES = SERVICES.slice();
                return;
            }
            // If a service option is selected (prefixed with 'svc:'), show only that service
            try{
                if (String(SELECTED_MEMBER).startsWith('svc:')){
                    const svcId = String(SELECTED_MEMBER).slice(4);
                    VISIBLE_SERVICES = SERVICES.filter(s => String(s.id) === svcId);
                    return;
                }
            }catch(e){ /* fall back to member filtering */ }

            VISIBLE_SERVICES = SERVICES.filter(s => {
                try{
                    const assigned = getAssignedMembersForService(s);
                    if (assigned.length === 0) return false; // hide unassigned services when a member is selected
                    return assigned.indexOf(String(SELECTED_MEMBER)) !== -1;
                }catch(e){ return false; }
            });
        }

        function svcById(svcId){
            const idStr = String(svcId);
            let found = VISIBLE_SERVICES.find(s => String(s.id) === idStr);
            if (!found) found = SERVICES.find(s => String(s.id) === idStr);
            return found || null;
        }

        // Initialize visible services
        updateVisibleServices();

        // Wire member selector when present
        try{
            const sel = document.getElementById('memberSelect');
            if (sel) {
                function selectDefaultAvailabilityFor(selection){
                    try{
                        if (selection && String(selection).startsWith('svc:')){
                            const svcId = String(selection).slice(4);
                            const svc = SERVICES.find(s=>String(s.id)===svcId) || null;
                            // IMPORTANT: If a service has no explicitly saved weekly availability,
                            // keep it unavailable until the user manually enables days/ranges and saves.
                            // Do NOT inherit overall/member availability here.
                            const hasExplicit = !!(svc && (svc.has_service_weekly_windows || false));
                            if (hasExplicit && svc && svc.weekly_map) {
                                const src = svc.weekly_map;
                                const built = buildAvailabilityFromPayload(src);
                                for (const k of Object.keys(built)) defaultAvailability[k] = built[k];
                                return;
                            }
                            if (svc) {
                                const emptyWeekly = makeAllUnavailablePayload().map(row => row.ranges || []);
                                const built = buildAvailabilityFromPayload(emptyWeekly);
                                for (const k of Object.keys(built)) defaultAvailability[k] = built[k];
                                return;
                            }
                        }
                        // Default membership-specific availability
                        if (selection && memberDefaultAvailability[String(selection)]){
                            const src = memberDefaultAvailability[String(selection)];
                            for (const k of Object.keys(src)) defaultAvailability[k] = JSON.parse(JSON.stringify(src[k]));
                        } else {
                            // fallback to org defaults
                            for (const k of Object.keys(orgDefaultAvailability)) defaultAvailability[k] = JSON.parse(JSON.stringify(orgDefaultAvailability[k]));
                        }
                    }catch(e){ console.warn('selectDefaultAvailabilityFor error', e); }
                }

                // Expose to other parts of the page so the weekly editor can
                // always re-sync correctly even when called from different flows.
                try { window.__ccSelectDefaultAvailabilityFor = selectDefaultAvailabilityFor; } catch (e) {}

                    function updateSelectionBadge(selection){
                        try{
                            const badge = document.getElementById('memberScopeBadge');
                            if (!badge) return;

                            // Pro overall scope
                            if ((IS_PRO && !IS_TEAM) && !selection) {
                                badge.textContent = 'Showing overall availability';
                                badge.style.borderColor = 'rgba(59,130,246,0.15)';
                                badge.style.background = 'rgba(59,130,246,0.06)';
                                badge.style.color = 'var(--primary-600)';
                                return;
                            }

                            if (selection && String(selection).startsWith('svc:')){
                                const svcId = String(selection).slice(4);
                                const svc = SERVICES.find(s=>String(s.id)===svcId) || null;
                                const hasAnyRanges = !!(svc && Array.isArray(svc.weekly_map) && svc.weekly_map.some(day => Array.isArray(day) && day.length > 0));
                                if (hasAnyRanges && svc && (svc.has_service_weekly_windows || false)){
                                    badge.textContent = 'Service-specific availability';
                                    badge.style.borderColor = 'rgba(16,185,129,0.15)';
                                    badge.style.background = 'rgba(16,185,129,0.06)';
                                    badge.style.color = 'var(--success-600)';
                                    return;
                                }
                                // Inheritance case: weekly_map has ranges but there are no explicit service-weekly rows.
                                // This commonly happens for single-assignee solo services.
                                if (hasAnyRanges && svc && !(svc.has_service_weekly_windows || false)){
                                    badge.textContent = (IS_PRO && !IS_TEAM) ? 'Inheriting overall availability' : 'Inheriting member availability';
                                    badge.style.borderColor = 'rgba(107,114,128,0.18)';
                                    badge.style.background = 'rgba(107,114,128,0.06)';
                                    badge.style.color = 'var(--gray-700)';
                                    return;
                                }
                            }
                            if (selection && memberAvailMap && memberAvailMap[String(selection)]){
                                badge.textContent = 'Member-specific availability';
                                badge.style.borderColor = 'rgba(59,130,246,0.15)';
                                badge.style.background = 'rgba(59,130,246,0.06)';
                                badge.style.color = 'var(--primary-600)';
                                return;
                            }
                            // default
                            badge.textContent = (IS_PRO && !IS_TEAM) ? 'Showing overall availability' : 'Showing org defaults';
                            badge.style.borderColor = 'var(--gray-200)';
                            badge.style.background = 'transparent';
                            badge.style.color = 'var(--gray-600)';
                        }catch(e){ /* ignore */ }
                    }

                    function updateInterchangeLink(selection){
                        try{
                            const btn = document.getElementById('cc-open-edit-service-from-calendar');
                            const note = document.getElementById('cc-weekly-interchange-note');
                            if (!btn || !note) return;

                            if (selection && String(selection).startsWith('svc:')){
                                const svcId = String(selection).slice(4);
                                const url = String(EDIT_SERVICE_URL_TEMPLATE).replace('/0/edit/', '/' + svcId + '/edit/');
                                btn.setAttribute('href', url);
                                btn.style.display = 'inline-flex';
                                note.style.display = 'block';
                                note.textContent = 'These weekly service availability settings are interchangeable with the Edit Service page. You can update them in either place.';
                                return;
                            }

                            // Member scope: no interchange tip (it reads like a service setting).
                            if (selection && !String(selection).startsWith('svc:')){
                                btn.style.display = 'none';
                                btn.setAttribute('href', '#');
                                note.style.display = 'none';
                                return;
                            }

                            btn.style.display = 'none';
                            btn.setAttribute('href', '#');
                            note.style.display = 'block';
                            note.textContent = 'Tip: When you select a service scope, this weekly schedule is interchangeable with that service’s availability on the Edit Service page.';
                        }catch(e){ /* ignore */ }
                    }

                // Explicit apply flow: changing the select only stages a pending selection.
                let pendingSelection = SELECTED_MEMBER;

                // Initialize the Calendar <-> Edit Service cross-link based on the current scope.
                try { updateInterchangeLink(SELECTED_MEMBER); } catch(e){}
                try { updateServiceScopeExplainer(); } catch(e){}
                try { if (typeof window.updateTeamOverlapGroupSummary === 'function') window.updateTeamOverlapGroupSummary(); } catch(e){}
                try { updateWeeklyAvailabilityTitleAndDesc(); } catch(e){}

                function applySelection(selection){
                    try{
                        SELECTED_MEMBER = selection || null;

                        // Always clear any prior "no remaining availability" overlay state immediately
                        // when switching scopes so it cannot stick from a previous service.
                        try {
                            const calEl = document.getElementById('calendar');
                            const controlsEl = document.getElementById('calendar-controls');
                            if (calEl) calEl.classList.remove('cc-svc-no-availability');
                            if (controlsEl) controlsEl.classList.remove('cc-disabled');
                            const overlay = document.getElementById('ccSvcNoAvailabilityOverlay');
                            if (overlay) overlay.style.display = 'none';
                            try { window.__ccServiceScopeNoAvailability = false; } catch (e) {}
                            try { if (typeof ccHideSvcNoAvailabilityClickModal === 'function') ccHideSvcNoAvailabilityClickModal(); } catch (e) {}
                        } catch (e) { /* ignore */ }

                        // Persist selection for Team vs Pro
                        try {
                            if (IS_TEAM) {
                                if (SELECTED_MEMBER) localStorage.setItem('cc_selected_member', SELECTED_MEMBER);
                                else localStorage.removeItem('cc_selected_member');
                            } else if (IS_PRO) {
                                if (SELECTED_MEMBER && String(SELECTED_MEMBER).startsWith('svc:')) localStorage.setItem('cc_selected_scope', String(SELECTED_MEMBER));
                                else localStorage.setItem('cc_selected_scope', 'overall');
                            }
                        } catch (e) { /* ignore */ }

                        // Remember the last scope selection so denial banners can offer relevant actions
                        // even if the UI state changes (modal close, refetch, etc.).
                        try { window.__ccLastOverrideTarget = SELECTED_MEMBER; } catch (e) {}

                        try { _clearOverridesSaveBanner(); } catch (e) {}

                        // Prevent optimistic per-date overrides from "carrying over" when switching
                        // member/service: clear any locally added background events.
                        try { purgeOptimisticPerDateEvents(); } catch (e) {}

                        updateVisibleServices();
                        try { selectDefaultAvailabilityFor(SELECTED_MEMBER); } catch(e){}
                        try { updateSelectionBadge(SELECTED_MEMBER); } catch(e){}
                        try { updateInterchangeLink(SELECTED_MEMBER); } catch(e){}
                        try { updateServiceScopeExplainer(); } catch(e){}
                        try { if (typeof window.updateTeamOverlapGroupSummary === 'function') window.updateTeamOverlapGroupSummary(); } catch(e){}
                        try { updateWeeklyAvailabilityTitleAndDesc(); } catch(e){}

                        // Keep scope dropdown label in sync *before* updating service-scope UI.
                        try {
                            const lbl = document.getElementById('ccScopeMenuButtonLabel');
                            if (lbl) lbl.textContent = getSelectionLabel();
                        } catch (e) {}

                        // Refresh service-scope constraints when switching scopes/services.
                        try { window.__ccWeeklyServiceConstraints = _ccGetWeeklyEditorConstraints() || null; } catch (e) {}
                        try { if (typeof ccUpdateServiceScopeDisabledUI === 'function') ccUpdateServiceScopeDisabledUI(); } catch (e) {}

                        try { calendar && calendar.refetchEvents(); } catch(e){}
                        try { displayDefaultAvailability(); } catch(e){}
                        try { syncAvailabilityToCalendar(); } catch(e){}
                        try { if (typeof updateBookingsViewAllLink === 'function') updateBookingsViewAllLink(); } catch(e){}
                        try { if (typeof filterInlineAuditBySelection === 'function') filterInlineAuditBySelection(); } catch(e){}

                        // Critical: refresh month day-circle classes for the *current* selection.
                        // Relying only on FullCalendar's async `eventsSet`/`datesSet` can leave the
                        // UI showing stale availability until a hard refresh.
                        try { if (typeof updateUnavailableDays === 'function') updateUnavailableDays(); } catch (e) {}
                        try { setTimeout(function(){ try { if (typeof updateUnavailableDays === 'function') updateUnavailableDays(); } catch (e) {} }, 0); } catch (e) {}

                        // Also refresh in case other parts updated label later.
                        try {
                            const lbl = document.getElementById('ccScopeMenuButtonLabel');
                            if (lbl) lbl.textContent = getSelectionLabel();
                        } catch (e) {}
                    }catch(e){ console.warn('applySelection failed', e); }
                }

                function _ccPossessiveName(displayName, lastName){
                    try {
                        const base = String(displayName || '').trim();
                        if (!base) return "Member's";
                        let token = String(lastName || '').trim();
                        if (!token) {
                            const parts = base.split(/\s+/).filter(Boolean);
                            token = (parts.length ? parts[parts.length - 1] : base);
                        }
                        const endsWithS = /s$/i.test(token);
                        return endsWithS ? `${base}'` : `${base}'s`;
                    } catch (e) {
                        return "Member's";
                    }
                }

                function updateWeeklyAvailabilityTitleAndDesc(){
                    const titleEl = document.getElementById('cc-weekly-availability-title');
                    const descEl = document.getElementById('cc-weekly-availability-desc');
                    if (!titleEl || !descEl) return;

                    const sel = SELECTED_MEMBER;

                    // Org defaults
                    if (!sel){
                        titleEl.textContent = (IS_PRO && !IS_TEAM) ? 'Overall Weekly Availability' : 'Default Weekly Availability';
                        descEl.style.display = 'none';
                        return;
                    }

                    // Service scope: show service weekly availability title (client-facing).
                    if (String(sel).startsWith('svc:')){
                        const svcId = String(sel).slice(4);
                        const svc = (Array.isArray(SERVICES) ? SERVICES.find(s => String(s.id) === String(svcId)) : null);
                        const svcName = (svc && svc.name) ? String(svc.name) : 'Service';
                        titleEl.textContent = `${svcName} Weekly Availability`;
                        descEl.style.display = 'none';
                        return;
                    }

                    // Member scope: show member-specific title + explanatory description.
                    const m = MEMBERS.find(mm => String(mm.id) === String(sel));
                    const display = m ? memberDisplayName(m) : 'Member';
                    const lname = m ? (m.user__last_name || '') : '';
                    const poss = _ccPossessiveName(display, lname);

                    titleEl.textContent = `${poss} Overall Weekly Availability`;
                    descEl.style.display = 'block';
                }

                function updateServiceScopeExplainer(){
                    const box = document.getElementById('ccServiceScopeExplainer');
                    const title = document.getElementById('ccServiceScopeExplainerTitle');
                    const body = document.getElementById('ccServiceScopeExplainerBody');
                    if (!box || !title || !body) return;

                    let legend = null;
                    try { legend = box.querySelector('.cc-scope-legend'); } catch (e) { legend = null; }

                    const sel = SELECTED_MEMBER;
                    const isSvcScope = !!(sel && String(sel).startsWith('svc:'));

                    // Pro overall view: always show a compatibility note so the user can
                    // find it easily. If there are no shared groups, say so explicitly.
                    if (!isSvcScope) {
                        try {
                            if (legend) legend.style.display = 'none';
                        } catch (e) {}

                        if (!(IS_PRO && !IS_TEAM)) {
                            box.style.display = 'none';
                            return;
                        }

                        // Build signature groups.
                        const all = Array.isArray(SERVICES) ? SERVICES.slice() : [];
                        const groups = new Map();
                        for (const s of all) {
                            try {
                                if (!s) continue;
                                const sig = _ccSigKey(s);
                                if (!sig) continue;
                                if (!groups.has(sig)) groups.set(sig, []);
                                groups.get(sig).push(s);
                            } catch (e) { /* ignore */ }
                        }
                        const multi = [];
                        for (const [sig, arr] of groups.entries()) {
                            try {
                                if (arr && arr.length >= 2) multi.push(arr);
                            } catch (e) {}
                        }
                        title.textContent = 'Shared duration/buffer groups';

                        body.textContent = '';
                        while (body.firstChild) body.removeChild(body.firstChild);

                        const line1 = document.createElement('div');
                        line1.textContent = 'Services with the same duration and buffer settings share the same availability group, so their schedules can overlap.';
                        body.appendChild(line1);

                        if (!multi.length) {
                            const none = document.createElement('div');
                            none.style.marginTop = '8px';
                            none.style.color = 'var(--gray-700)';
                            none.textContent = 'No services share the same duration/buffer settings right now.';
                            body.appendChild(none);
                            box.style.display = 'block';
                            return;
                        }

                        // Show up to 2 groups and keep names short.
                        const maxGroups = 2;
                        const maxNamesPerGroup = 4;
                        multi.sort((a,b) => b.length - a.length);
                        const shownGroups = multi.slice(0, maxGroups);

                        for (const arr of shownGroups) {
                            const names = (arr || []).map(s => {
                                const nm = (s && s.name) ? String(s.name) : 'Service';
                                const inactive = (s && Object.prototype.hasOwnProperty.call(s, 'is_active')) ? (!s.is_active) : false;
                                return inactive ? `${nm} (inactive)` : nm;
                            }).filter(Boolean);
                            const shown = names.slice(0, maxNamesPerGroup);
                            const extra = Math.max(0, names.length - shown.length);

                            const g = document.createElement('div');
                            g.style.marginTop = '8px';
                            g.style.fontSize = '13px';
                            g.style.color = 'var(--gray-700)';
                            g.textContent = `• ${shown.join(', ')}${extra ? ` + ${extra} more` : ''}`;
                            body.appendChild(g);
                        }

                        box.style.display = 'block';
                        return;
                    }

                    try { if (legend) legend.style.display = ''; } catch (e) {}

                    const svcId = String(sel).slice(4);
                    const svc = (Array.isArray(SERVICES) ? SERVICES.find(s => String(s.id) === String(svcId)) : null);
                    const svcName = (svc && svc.name) ? String(svc.name) : 'this service';
                    title.textContent = `Client-facing availability for: ${svcName}`;

                    // Build the body safely (no innerHTML) to avoid accidental injection.
                    body.textContent = '';
                    while (body.firstChild) body.removeChild(body.firstChild);

                    const line2 = document.createElement('div');
                    line2.style.marginTop = '0px';
                    line2.textContent = (IS_PRO && !IS_TEAM)
                        ? 'Clients can only book time within your overall availability, minus time reserved by your other services.'
                        : 'Select a service to preview what clients can actually book.';
                    body.appendChild(line2);

                    const line3 = document.createElement('div');
                    line3.style.marginTop = '6px';
                    line3.textContent = (IS_PRO && !IS_TEAM)
                        ? 'Per-date overrides can open/close time, but they still must stay within your overall availability.'
                        : 'Per-date overrides can open/close time, but they still must stay within member availability.';
                    body.appendChild(line3);

                    // Signature-sharing note: same duration/buffer settings => shared partitioning group.
                    try {
                        const mySig = svc ? _ccSigKey(svc) : '';
                        const peers = (mySig && Array.isArray(SERVICES))
                            ? SERVICES.filter(s => s && String(s.id) !== String(svcId) && _ccSigKey(s) === mySig)
                            : [];

                        const compat = document.createElement('div');
                        compat.className = 'cc-scope-compat';

                        const label = document.createElement('div');
                        label.className = 'label';
                        label.textContent = 'Shares duration/buffer settings:';
                        compat.appendChild(label);

                        const namesLine = document.createElement('div');
                        namesLine.className = 'names';

                        if (!peers || !peers.length) {
                            namesLine.textContent = 'No other services share the same duration/buffer settings.';
                        } else {
                            // Keep the list short and readable.
                            const names = (peers || [])
                                .map(p => {
                                    const nm = (p && p.name) ? String(p.name) : 'Service';
                                    const inactive = (p && Object.prototype.hasOwnProperty.call(p, 'is_active')) ? (!p.is_active) : false;
                                    return inactive ? `${nm} (inactive)` : nm;
                                })
                                .filter(Boolean);
                            const maxShow = 4;
                            const shown = names.slice(0, maxShow);
                            const extra = Math.max(0, names.length - shown.length);
                            const suffix = (extra > 0) ? ` + ${extra} more` : '';
                            namesLine.textContent = `${shown.join(', ')}${suffix}. These services share the same availability group and can overlap schedules.`;
                        }

                        compat.appendChild(namesLine);
                        body.appendChild(compat);
                    } catch (e) {}

                    box.style.display = 'block';
                }

                // Team-only: show overlap groups ONLY when appropriate, and show NOTHING otherwise.
                // Exposed on window to avoid any block-scope/hoisting surprises.
                window.updateTeamOverlapGroupSummary = function(){
                    try {
                        if (!IS_TEAM) return;

                        const box = document.getElementById('ccSharedSignatureSummary');
                        const title = document.getElementById('ccSharedSignatureTitle');
                        const desc = document.getElementById('ccSharedSignatureDesc');
                        const list = document.getElementById('ccSharedSignatureList');
                        if (!box || !title || !desc || !list) return;

                        // Default: hide (Team requirement: show nothing if no matches)
                        function hide(){
                            try { box.style.display = 'none'; } catch(e){}
                            try { list.textContent = ''; while (list.firstChild) list.removeChild(list.firstChild); } catch(e){}
                        }
                        function show(){
                            try { box.style.display = 'block'; } catch(e){}
                        }
                        function clearList(){
                            try { list.textContent = ''; while (list.firstChild) list.removeChild(list.firstChild); } catch(e){}
                        }
                        function addRow(text){
                            const row = document.createElement('div');
                            row.style.marginTop = '4px';
                            row.textContent = `• ${text}`;
                            list.appendChild(row);
                        }

                        // Only Team: never show on null selection (shouldn't happen), or non-member/non-service.
                        const sel = SELECTED_MEMBER;
                        if (!sel) return hide();

                        // Helper to get assigned members array.
                        function assignedMembers(svc){
                            try { return (svc && Array.isArray(svc.assigned_members)) ? svc.assigned_members.map(String) : []; }
                            catch(e){ return []; }
                        }

                        // Core signature for overlap grouping: duration + buffer_before + buffer_after ONLY.
                        // This intentionally ignores other scheduling flags/settings.
                        function coreSigKey(svc){
                            try {
                                const sig = (svc && Array.isArray(svc.schedule_signature)) ? svc.schedule_signature : null;
                                if (sig && sig.length >= 3) {
                                    return [sig[0], sig[1], sig[2]].map(x => String(x)).join('|');
                                }
                                return [
                                    String(svc?.duration ?? ''),
                                    String(svc?.buffer_before ?? ''),
                                    String(svc?.buffer_after ?? ''),
                                ].join('|');
                            } catch (e) {
                                return '';
                            }
                        }

                        title.textContent = 'Duration/buffer overlap groups';
                        desc.textContent = 'Services with the same duration and buffer settings share the same availability group, so their schedules can overlap.';

                        // Case 1: member-scope => show groups among services assigned to that member.
                        if (!String(sel).startsWith('svc:')){
                            const mid = String(sel);
                            const assigned = (Array.isArray(SERVICES) ? SERVICES : []).filter(s => {
                                try { return assignedMembers(s).includes(mid); } catch(e){ return false; }
                            });

                            const groups = new Map();
                            for (const s of assigned) {
                                try {
                                    if (!s) continue;
                                    const sig = coreSigKey(s);
                                    if (!sig) continue;
                                    if (!groups.has(sig)) groups.set(sig, []);
                                    groups.get(sig).push(s);
                                } catch(e){}
                            }

                            const multi = [];
                            for (const arr of groups.values()) {
                                try { if (arr && arr.length >= 2) multi.push(arr); } catch(e){}
                            }
                            if (!multi.length) return hide();

                            clearList();
                            multi.sort((a,b) => (b.length - a.length));
                            for (const arr of multi) {
                                const names = (arr || []).map(s => (s && s.name) ? String(s.name) : 'Service').filter(Boolean);
                                addRow(names.join(', '));
                            }
                            show();
                            return;
                        }

                        // Service scope cases
                        const svcId = String(sel).slice(4);
                        const svc = (Array.isArray(SERVICES) ? SERVICES.find(s => String(s.id) === String(svcId)) : null);
                        if (!svc) return hide();

                        const am = assignedMembers(svc);
                        const isGroupService = am.length >= 2;
                        const isUnassignedService = am.length === 0;
                        const isSoloAssignedService = am.length === 1;

                        // Case 3: group service => show nothing (explicit requirement)
                        if (isGroupService) return hide();

                        // Case 2: unassigned service => show global peers with same signature
                        if (isUnassignedService){
                            const sig = coreSigKey(svc);
                            if (!sig) return hide();
                            const peers = (Array.isArray(SERVICES) ? SERVICES : []).filter(s => {
                                try {
                                    if (!s) return false;
                                    if (String(s.id) === String(svcId)) return false;
                                    return coreSigKey(s) === sig;
                                } catch(e){ return false; }
                            });
                            if (!peers.length) return hide();

                            clearList();
                            const names = [svc, ...peers].map(s => (s && s.name) ? String(s.name) : 'Service').filter(Boolean);
                            addRow(names.join(', '));
                            show();
                            return;
                        }

                        // Solo assigned service in service-scope: do not show (keeps it member-unique)
                        if (isSoloAssignedService) return hide();

                        // Fallback
                        return hide();
                    } catch (e) {
                        // Fail closed (don't show anything)
                        try {
                            const box = document.getElementById('ccSharedSignatureSummary');
                            if (box) box.style.display = 'none';
                        } catch (err) {}
                    }
                };

                // ---- Scope menu wiring ----
                function memberDisplayName(m){
                    try {
                        const fname = (m.user__first_name || '').trim();
                        const lname = (m.user__last_name || '').trim();
                        const email = (m.user__email || '').trim();
                        const base = ((fname || lname) ? `${fname} ${lname}`.trim() : (email || 'Member'));
                        return base;
                    } catch (e) { return 'Member'; }
                }

                function personalServicesForMember(mid){
                    try {
                        const idStr = String(mid);
                        return SERVICES.filter(s => {
                            const assigned = getAssignedMembersForService(s);
                            return assigned.length === 1 && String(assigned[0]) === idStr;
                        });
                    } catch (e) { return []; }
                }

                function closeScopeMenus(){
                    try{ const m = document.getElementById('ccScopeMenu'); if (m) m.style.display = 'none'; }catch(e){}
                    try{ const sm = document.getElementById('ccScopeSubmenu'); if (sm) sm.style.display = 'none'; }catch(e){}
                }

                function openScopeMenu(){
                    try{ const m = document.getElementById('ccScopeMenu'); if (m) m.style.display = 'block'; }catch(e){}
                }

                function openSubmenuForMember(mid){
                    const sm = document.getElementById('ccScopeSubmenu');
                    const inner = document.getElementById('ccScopeSubmenuInner');
                    if (!sm || !inner) return;
                    inner.innerHTML = '';

                    const header = document.createElement('div');
                    header.style.padding = '10px 12px';
                    header.style.borderBottom = '1px solid var(--gray-100)';
                    header.style.fontWeight = '700';
                    header.style.fontSize = '12px';
                    header.style.color = 'var(--gray-700)';
                    header.style.textTransform = 'uppercase';
                    header.style.letterSpacing = '0.5px';
                    const m = MEMBERS.find(mm => String(mm.id) === String(mid));
                    header.textContent = m ? memberDisplayName(m) : 'Member';
                    inner.appendChild(header);

                    const memberItem = document.createElement('button');
                    memberItem.type = 'button';
                    memberItem.textContent = 'View member availability';
                    memberItem.style.display = 'block';
                    memberItem.style.width = '100%';
                    memberItem.style.textAlign = 'left';
                    memberItem.style.padding = '10px 12px';
                    memberItem.style.border = 'none';
                    memberItem.style.background = 'transparent';
                    memberItem.style.cursor = 'pointer';
                    memberItem.addEventListener('click', function(){
                        closeScopeMenus();
                        pendingSelection = String(mid);
                        applySelection(pendingSelection);
                    });
                    inner.appendChild(memberItem);

                    const divider = document.createElement('div');
                    divider.style.height = '1px';
                    divider.style.background = 'var(--gray-100)';
                    inner.appendChild(divider);

                    const svcHeader = document.createElement('div');
                    svcHeader.style.padding = '10px 12px 6px 12px';
                    svcHeader.style.fontWeight = '700';
                    svcHeader.style.fontSize = '12px';
                    svcHeader.style.color = 'var(--gray-700)';
                    svcHeader.style.textTransform = 'uppercase';
                    svcHeader.style.letterSpacing = '0.5px';
                    svcHeader.textContent = 'Personal services';
                    inner.appendChild(svcHeader);

                    const services = personalServicesForMember(mid);
                    if (!services.length){
                        const empty = document.createElement('div');
                        empty.style.padding = '8px 12px 12px 12px';
                        empty.style.color = 'var(--gray-600)';
                        empty.style.fontSize = '13px';
                        empty.textContent = 'No personal services.';
                        inner.appendChild(empty);
                    } else {
                        for (const s of services){
                            const btn = document.createElement('button');
                            btn.type = 'button';
                            btn.textContent = s.name || ('Service ' + String(s.id));
                            btn.style.display = 'block';
                            btn.style.width = '100%';
                            btn.style.textAlign = 'left';
                            btn.style.padding = '10px 12px';
                            btn.style.border = 'none';
                            btn.style.background = 'transparent';
                            btn.style.cursor = 'pointer';
                            btn.addEventListener('click', function(){
                                closeScopeMenus();
                                pendingSelection = 'svc:' + String(s.id);
                                applySelection(pendingSelection);
                            });
                            inner.appendChild(btn);
                        }
                    }

                    sm.style.display = 'block';
                }

                function buildScopeMenu(){
                    const root = document.getElementById('ccScopeMenuRoot');
                    const btn = document.getElementById('ccScopeMenuButton');
                    const menu = document.getElementById('ccScopeMenu');
                    const list = document.getElementById('ccScopeMenuMembers');
                    if (!root || !btn || !menu || !list) return;

                    // Pro plan (solo): Overall availability + all services (no members/group/unassigned).
                    if (IS_PRO && !IS_TEAM) {
                        list.innerHTML = '';

                        const overallRow = document.createElement('div');
                        overallRow.style.display = 'flex';
                        overallRow.style.alignItems = 'center';
                        overallRow.style.justifyContent = 'space-between';
                        overallRow.style.gap = '10px';
                        overallRow.style.padding = '10px 12px';
                        overallRow.style.cursor = 'pointer';

                        const overallLeft = document.createElement('div');
                        overallLeft.style.flex = '1 1 auto';
                        overallLeft.style.whiteSpace = 'nowrap';
                        overallLeft.style.overflow = 'hidden';
                        overallLeft.style.textOverflow = 'ellipsis';
                        overallLeft.textContent = 'Overall availability';

                        const overallRight = document.createElement('div');
                        overallRight.style.flex = '0 0 auto';
                        overallRight.style.color = 'var(--gray-600)';
                        overallRight.style.fontSize = '12px';
                        overallRight.textContent = '';

                        overallRow.appendChild(overallLeft);
                        overallRow.appendChild(overallRight);

                        overallRow.addEventListener('mouseenter', function(){
                            try { const sm = document.getElementById('ccScopeSubmenu'); if (sm) sm.style.display = 'none'; } catch (e) {}
                        });
                        overallRow.addEventListener('click', function(){
                            closeScopeMenus();
                            pendingSelection = null;
                            applySelection(null);
                        });

                        list.appendChild(overallRow);

                        const divider = document.createElement('div');
                        divider.style.height = '1px';
                        divider.style.background = 'var(--gray-100)';
                        list.appendChild(divider);

                        const header = document.createElement('div');
                        header.style.padding = '10px 12px 6px 12px';
                        header.style.fontWeight = '700';
                        header.style.fontSize = '12px';
                        header.style.color = 'var(--gray-700)';
                        header.style.textTransform = 'uppercase';
                        header.style.letterSpacing = '0.5px';
                        header.textContent = 'Services';
                        list.appendChild(header);

                        const svcs = (Array.isArray(SERVICES) ? SERVICES.slice() : []).sort((a,b)=>String(a.name||'').localeCompare(String(b.name||'')));
                        if (!svcs.length) {
                            const empty = document.createElement('div');
                            empty.style.padding = '8px 12px 12px 12px';
                            empty.style.color = 'var(--gray-600)';
                            empty.style.fontSize = '13px';
                            empty.textContent = 'No services.';
                            list.appendChild(empty);
                        } else {
                            for (const s of svcs) {
                                const row = document.createElement('div');
                                row.style.display = 'flex';
                                row.style.alignItems = 'center';
                                row.style.justifyContent = 'space-between';
                                row.style.gap = '10px';
                                row.style.padding = '10px 12px';
                                row.style.cursor = 'pointer';

                                const left = document.createElement('div');
                                left.style.flex = '1 1 auto';
                                left.style.whiteSpace = 'nowrap';
                                left.style.overflow = 'hidden';
                                left.style.textOverflow = 'ellipsis';
                                left.textContent = (s.name || ('Service ' + String(s.id))) + (s.is_active === false ? ' (inactive)' : '');

                                const right = document.createElement('div');
                                right.style.flex = '0 0 auto';
                                right.style.color = 'var(--gray-600)';
                                right.style.fontSize = '12px';
                                right.textContent = '';

                                row.appendChild(left);
                                row.appendChild(right);

                                row.addEventListener('mouseenter', function(){
                                    try { const sm = document.getElementById('ccScopeSubmenu'); if (sm) sm.style.display = 'none'; } catch (e) {}
                                });
                                row.addEventListener('click', function(){
                                    closeScopeMenus();
                                    pendingSelection = 'svc:' + String(s.id);
                                    applySelection(pendingSelection);
                                });

                                list.appendChild(row);
                            }
                        }

                        btn.addEventListener('click', function(e){
                            e.preventDefault();
                            e.stopPropagation();
                            const isOpen = menu.style.display === 'block';
                            if (isOpen){ closeScopeMenus(); }
                            else { openScopeMenu(); }
                        });

                        document.addEventListener('click', function(ev){
                            try{
                                if (!root.contains(ev.target)) closeScopeMenus();
                            }catch(e){}
                        });
                        return;
                    }

                    list.innerHTML = '';
                    for (const m of MEMBERS){
                        const row = document.createElement('div');
                        row.style.display = 'flex';
                        row.style.alignItems = 'center';
                        row.style.justifyContent = 'space-between';
                        row.style.gap = '10px';
                        row.style.padding = '10px 12px';
                        row.style.cursor = 'pointer';

                        const left = document.createElement('div');
                        left.style.flex = '1 1 auto';
                        left.style.whiteSpace = 'nowrap';
                        left.style.overflow = 'hidden';
                        left.style.textOverflow = 'ellipsis';
                        left.textContent = memberDisplayName(m);

                        const right = document.createElement('div');
                        right.style.flex = '0 0 auto';
                        right.style.color = 'var(--gray-600)';
                        right.style.fontSize = '16px';
                        right.textContent = '›';

                        row.appendChild(left);
                        row.appendChild(right);

                        row.addEventListener('mouseenter', function(){
                            try{ openSubmenuForMember(m.id); }catch(e){}
                        });
                        row.addEventListener('click', function(){
                            try{ openSubmenuForMember(m.id); }catch(e){}
                        });

                        list.appendChild(row);
                    }

                    // ---- Service scopes (below members) ----
                    function hideSubmenu(){
                        try{
                            const sm = document.getElementById('ccScopeSubmenu');
                            if (sm) sm.style.display = 'none';
                        }catch(e){}
                    }

                    function addDivider(){
                        const divider = document.createElement('div');
                        divider.style.height = '1px';
                        divider.style.background = 'var(--gray-100)';
                        list.appendChild(divider);
                    }

                    function addSectionHeader(text){
                        const h = document.createElement('div');
                        h.style.padding = '10px 12px 6px 12px';
                        h.style.fontWeight = '700';
                        h.style.fontSize = '12px';
                        h.style.color = 'var(--gray-700)';
                        h.style.textTransform = 'uppercase';
                        h.style.letterSpacing = '0.5px';
                        h.textContent = text;
                        list.appendChild(h);
                    }

                    function addEmptyRow(text){
                        const empty = document.createElement('div');
                        empty.style.padding = '8px 12px 12px 12px';
                        empty.style.color = 'var(--gray-600)';
                        empty.style.fontSize = '13px';
                        empty.textContent = text;
                        list.appendChild(empty);
                    }

                    function addServiceRow(service, badgeText){
                        const row = document.createElement('div');
                        row.style.display = 'flex';
                        row.style.alignItems = 'center';
                        row.style.justifyContent = 'space-between';
                        row.style.gap = '10px';
                        row.style.padding = '10px 12px';
                        row.style.cursor = 'pointer';

                        const left = document.createElement('div');
                        left.style.flex = '1 1 auto';
                        left.style.whiteSpace = 'nowrap';
                        left.style.overflow = 'hidden';
                        left.style.textOverflow = 'ellipsis';
                        left.textContent = service.name || ('Service ' + String(service.id));

                        const right = document.createElement('div');
                        right.style.flex = '0 0 auto';
                        right.style.color = 'var(--gray-600)';
                        right.style.fontSize = '12px';
                        right.textContent = badgeText || '';

                        row.appendChild(left);
                        row.appendChild(right);

                        row.addEventListener('mouseenter', function(){
                            hideSubmenu();
                        });
                        row.addEventListener('click', function(){
                            hideSubmenu();
                            closeScopeMenus();
                            pendingSelection = 'svc:' + String(service.id);
                            applySelection(pendingSelection);
                        });

                        list.appendChild(row);
                    }

                    // Below the members list, show ONLY:
                    // - Unassigned services (0 assignees)
                    // - Group services (2+ assignees)
                    // Solo (1-assignee) services stay in each member's submenu only.
                    let unassigned = [];
                    let shared = [];
                    try{
                        for (const s of SERVICES){
                            const assigned = getAssignedMembersForService(s) || [];
                            if (assigned.length === 0) unassigned.push(s);
                            else if (assigned.length >= 2) shared.push(s);
                        }
                    }catch(e){ unassigned = []; shared = []; }

                    addDivider();
                    addSectionHeader('Unassigned services');
                    if (!unassigned.length) addEmptyRow('No unassigned services.');
                    else {
                        unassigned.sort((a,b)=>String(a.name||'').localeCompare(String(b.name||'')));
                        for (const s of unassigned) addServiceRow(s, 'Unassigned');
                    }

                    addDivider();
                    addSectionHeader('Group services');
                    if (!shared.length) addEmptyRow('No group services.');
                    else {
                        shared.sort((a,b)=>String(a.name||'').localeCompare(String(b.name||'')));
                        for (const s of shared){
                            let badge = '';
                            try { badge = String((getAssignedMembersForService(s)||[]).length) + ' members'; } catch(e) { badge = 'Group'; }
                            addServiceRow(s, badge);
                        }
                    }

                    btn.addEventListener('click', function(e){
                        e.preventDefault();
                        e.stopPropagation();
                        const isOpen = menu.style.display === 'block';
                        if (isOpen){ closeScopeMenus(); }
                        else { openScopeMenu(); }
                    });

                    document.addEventListener('click', function(ev){
                        try{
                            if (!root.contains(ev.target)) closeScopeMenus();
                        }catch(e){}
                    });
                }

                // Initialize defaultAvailability for the current selection by applying it once
                try { applySelection(SELECTED_MEMBER); } catch(e){}
                try { buildScopeMenu(); } catch(e){}
                try {
                    const lbl = document.getElementById('ccScopeMenuButtonLabel');
                    if (lbl) lbl.textContent = getSelectionLabel();
                } catch (e) {}
            }
        }catch(e){ console.warn('member selector wiring failed', e); }
    const AUTO_OPEN_SERVICE = "{{ auto_open_service|default:'' }}";
    const AUTO_OPEN_DATE = "{{ auto_open_date|default:'' }}";
     
                if (!calendarEl) return;

    let selectedDates = new Set();
    let isDragging = false;
    let dragStartDate = null;
    let dragMode = null;
    let dragStartIsUnavailable = false;

    let calendar = null;
        try {
        calendar = new FullCalendar.Calendar(calendarEl, {
        initialView: 'dayGridMonth',
        height: 'auto',
        selectable: false, // disable default selection highlight
        editable: false,
        events: function(fetchInfo, successCallback, failureCallback) {
            // Fetch events from server then filter by VISIBLE_SERVICES
            const params = new URLSearchParams();
            if (fetchInfo && fetchInfo.startStr) params.set('start', fetchInfo.startStr);
            if (fetchInfo && fetchInfo.endStr) params.set('end', fetchInfo.endStr);
            // Avoid stale overrides/bookings from browser/proxy caching.
            try { params.set('_t', String(Date.now())); } catch (e) {}
            const url = `/bus/${orgSlug}/events/?` + params.toString();
            fetch(url, { credentials: 'same-origin', cache: 'no-store' }).then(r => r.json()).then(data => {
                try{
                    const items = Array.isArray(data) ? data : (data.events || []);
                    // build allowed service id set from VISIBLE_SERVICES
                    const allowed = new Set((VISIBLE_SERVICES||[]).map(s=>String(s.id)));
                    // Map membership id -> user id (if provided in MEMBERS payload)
                    const MEMBER_TO_USER = {};
                    try{ MEMBERS.forEach(m => { MEMBER_TO_USER[String(m.id)] = (m.user__id || m.user_id || (m.user && (m.user.id || m.user.pk)) || null); }); }catch(e){}

                    const filtered = items.filter(ev => {
                        try{
                            const ext = (ev.extendedProps || {});
                            // If this is a per-date override, allow it when it matches the selected scope
                            if (ext.is_per_date) {
                                // No selection -> show all per-date overrides
                                if (!SELECTED_MEMBER) return true;
                                // Service-scoped selection (values like 'svc:123') -> match assigned_scope_service_id
                                if (String(SELECTED_MEMBER).startsWith('svc:')){
                                    const svcId = String(SELECTED_MEMBER).slice(4);
                                    const assignedSvc = (ext.assigned_scope_service_id || ext.assigned_scope_service || (ev.client_name && ev.client_name.replace && ev.client_name.replace('scope:svc:','')) || null);
                                    if (assignedSvc && String(assignedSvc) === svcId) return true;
                                    // Also allow member-scoped per-date overrides when the assigned_user_id
                                    // belongs to any member assigned to this service. This makes member
                                    // overrides affect services the member participates in.
                                    try {
                                        const svcObj = (Array.isArray(SERVICES) ? SERVICES.find(s => String(s.id) === String(svcId)) : null) || null;
                                        const assigned = getAssignedMembersForService(svcObj) || [];
                                        const assignedUserId = ext.assigned_user_id || ev.assigned_user_id || null;
                                        if (assignedUserId && assigned.length) {
                                            for (const mid of assigned) {
                                                const mUser = MEMBER_TO_USER[String(mid)] || null;
                                                if (mUser && String(mUser) === String(assignedUserId)) return true;
                                                if (String(mid) === String(ext.assigned_membership_id || ev.assigned_membership_id || '')) return true;
                                            }
                                        }
                                    } catch (e) { /* ignore */ }
                                    return false;
                                }
                                // Membership selection -> compare assigned_user_id (map membership->user id when needed)
                                const mUser = MEMBER_TO_USER[String(SELECTED_MEMBER)] || null;
                                const assignedUserId = ext.assigned_user_id || ev.assigned_user_id || null;
                                const assignedMembershipId = ext.assigned_membership_id || ev.assigned_membership_id || null;
                                if (assignedMembershipId && String(assignedMembershipId) === String(SELECTED_MEMBER)) return true;
                                if (assignedUserId && String(assignedUserId) === String(mUser)) return true;
                                return false;
                            }

                            // Non per-date events: match by visible service ids or slug/name fallback
                            const svcId = (ev.service_id || ext.service_id || ext.service || null);
                            if (svcId && allowed.has(String(svcId))) return true;
                            const slug = (ev.service_slug || ext.service_slug || ev.title || ev.service || null);
                            if (slug) {
                                for (const s of VISIBLE_SERVICES) {
                                    if (String(s.slug) === String(slug) || String(s.name) === String(slug)) return true;
                                }
                            }
                        }catch(e){/* ignore */}
                        return false;
                    });
                    successCallback(filtered);
                }catch(e){ successCallback([]); }
            }).catch(err => { failureCallback(err); });
        },
        headerToolbar: { left: 'prev', center: 'title', right: 'next' },
        showNonCurrentDates: false,
        dayMaxEvents: true,
        eventsSet: function(events) {
            // After events load/refetch, recompute override/past/unavailable visuals & table
            try { updateUnavailableDays(); } catch(e) { console.warn('eventsSet updateUnavailableDays failed', e); }
            try { if (typeof _recomputeFullyBookedOutDates === 'function') _recomputeFullyBookedOutDates(); } catch(e) { /* ignore */ }
            try { if (typeof renderOverridesTable === 'function') renderOverridesTable(); } catch(e) { console.warn('eventsSet renderOverridesTable failed', e); }
            try { styleOverridesTable(); } catch(e) { /* ignore */ }
            try { if (typeof renderInlineBookings === 'function') renderInlineBookings(); } catch(e) { console.warn('eventsSet renderInlineBookings failed', e); }
            try {
                const selSpan = document.getElementById('overridesHeaderSelection');
                const monthSpan = document.getElementById('overridesHeaderMonth');
                if (monthSpan && calendar) {
                    const currentDate = calendar.getDate ? calendar.getDate() : new Date();
                    const monthName = currentDate.toLocaleString('default', { month: 'long' });
                    monthSpan.textContent = monthName;
                    if (selSpan) selSpan.textContent = getSelectionLabel();
                }
            } catch (e) { /* ignore */ }
        },

         // Handle selection in timeGridDay view
        select: function(info) {
            if (calendar.view.type === 'timeGridDay') {
                handleTimeSlotSelection(info);
            }
        },

        // View changed (month navigated). Recompute day visuals and trim trailing weeks.
        datesSet: function() {
            try { updateUnavailableDays(); } catch(e) { console.warn('datesSet updateUnavailableDays failed', e); }
            try { hideTrailingOtherRows(); } catch (e) { /* ignore */ }
        }
        });
    } catch (err) {
        console.error('FullCalendar initialization failed', err);
        calendarEl.innerHTML = '<div style="color:#721c24;background:#f8d7da;border:1px solid #f5c6cb;padding:12px;border-radius:6px;">Calendar failed to initialize. Check browser console for errors (see server console too).</div>';
        return; // abort further calendar-related setup to avoid runtime errors
    }

    // Render the calendar so DOM/date cells exist for later manipulation
    try { calendar.render(); } catch (e) { console.warn('calendar.render failed', e); }

    // -----------------------------
    // Initial-load scope sync (no hard refresh)
    // -----------------------------
    function _ccSelectionFromStorage() {
        try {
            if (IS_TEAM) {
                const s = localStorage.getItem('cc_selected_member');
                return (s && s !== 'null') ? String(s) : null;
            }
            if (IS_PRO) {
                const s = localStorage.getItem('cc_selected_scope');
                if (s && String(s).startsWith('svc:')) {
                    const svcId = String(s).slice(4);
                    const exists = (Array.isArray(SERVICES) ? SERVICES.some(x => String(x.id) === String(svcId)) : false);
                    return exists ? String(s) : null;
                }
                return null; // 'overall' or missing
            }
        } catch (e) {}
        return null;
    }

    function _ccRefreshMonthAvailabilityForSelection() {
        try {
            // Ensure month circles/overrides table match the current selection.
            // updateUnavailableDays() will automatically switch to service-scope parity
            // when a service scope is active.
            if (typeof updateUnavailableDays === 'function') updateUnavailableDays();
        } catch (e) {}
        // One more delayed refresh to catch cases where FullCalendar is still painting
        // its day cells on first load / after a refetch.
        try { setTimeout(function(){ try { if (typeof updateUnavailableDays === 'function') updateUnavailableDays(); } catch (e) {} }, 120); } catch (e) {}
        try { if (typeof ccUpdateServiceScopeDisabledUI === 'function') ccUpdateServiceScopeDisabledUI(); } catch (e) {}
    }

    function _ccSyncSelectionFromStorageAndRefresh(reason) {
        try {
            const storedSel = _ccSelectionFromStorage();
            // If the page was restored from BFCache (or similar), SELECTED_MEMBER may be stale.
            if (storedSel !== (SELECTED_MEMBER || null)) {
                try { if (typeof applySelection === 'function') applySelection(storedSel); else SELECTED_MEMBER = storedSel; } catch (e) { try { SELECTED_MEMBER = storedSel; } catch (e2) {} }
            } else {
                // Ensure we still refetch/repaint after initial render.
                try { if (typeof applySelection === 'function') applySelection(SELECTED_MEMBER); } catch (e) {}
            }

            // Force a repaint of month day circles now that the calendar DOM exists.
            _ccRefreshMonthAvailabilityForSelection();
        } catch (e) { /* ignore */ }
    }

    // After render, re-apply selection and refresh month visuals.
    try { setTimeout(function(){ _ccSyncSelectionFromStorageAndRefresh('after_render'); }, 0); } catch (e) {}

    // When coming back via browser back/forward cache, re-sync selection + month visuals.
    try {
        window.addEventListener('pageshow', function(ev){
            try { setTimeout(function(){ _ccSyncSelectionFromStorageAndRefresh('pageshow'); }, 0); } catch (e) {}
        });
    } catch (e) {}

    // Apply service-scope disabled state after the calendar exists.
    try {
        // Recompute constraints now that the calendar DOM exists, then refresh overlay content.
        if (typeof _ccRefreshConstraints === 'function') _ccRefreshConstraints();
        else if (typeof _ccGetWeeklyEditorConstraints === 'function') window.__ccWeeklyServiceConstraints = _ccGetWeeklyEditorConstraints() || null;
    } catch (e) {}
    try { if (typeof ccUpdateServiceScopeDisabledUI === 'function') ccUpdateServiceScopeDisabledUI(); } catch (e) {}

    // Pro service scope with no availability: clicking anywhere in the calendar should
    // show a full-screen modal (dismissed via X only) instead of letting interactions proceed.
    try {
        if (calendarEl && typeof calendarEl.addEventListener === 'function') {
            calendarEl.addEventListener('click', function(ev){
                try {
                    if (typeof _ccShouldShowNoAvailModalForSelection === 'function' && _ccShouldShowNoAvailModalForSelection()) {
                        try { ev.preventDefault(); } catch (e) {}
                        try { ev.stopPropagation(); } catch (e) {}
                        try { if (ev.stopImmediatePropagation) ev.stopImmediatePropagation(); } catch (e) {}
                        try { if (typeof ccShowSvcNoAvailabilityClickModal === 'function') ccShowSvcNoAvailabilityClickModal(); } catch (e) {}
                        return false;
                    }
                } catch (e) {}
            }, true);
        }
    } catch (e) {}

        // If the admin requested opening the Day Schedule for a service, compute the
        // soonest date with default weekly availability for that service and open the modal.
        (function(){
            try {
                if (!AUTO_OPEN_SERVICE) return;
                // AUTO_OPEN_SERVICE may be an id (numeric). Find service by id.
                const svcId = Number(AUTO_OPEN_SERVICE) || null;
                const svc = svcById(svcId);
                if (!svc) return;

                // Starting date: prefer AUTO_OPEN_DATE, fall back to today
                let start = null;
                if (AUTO_OPEN_DATE && AUTO_OPEN_DATE.match(/^\d{4}-\d{2}-\d{2}$/)) {
                    start = new Date(AUTO_OPEN_DATE + 'T00:00:00');
                } else {
                    const t = new Date();
                    start = new Date(t.getFullYear(), t.getMonth(), t.getDate());
                }

                // Search forward up to 365 days for the first weekday that has any default ranges
                let foundDate = null;
                for (let i = 0; i < 365; i++) {
                    const candidate = new Date(start);
                    candidate.setDate(start.getDate() + i);
                    const dow = candidate.getDay(); // 0=Sunday..6=Saturday
                    const weekly = (svc.weekly_map && Array.isArray(svc.weekly_map)) ? svc.weekly_map : [];
                    const ranges = weekly[dow] || [];
                    if (ranges && ranges.length > 0) {
                        // Ensure not a past date
                        const iso = candidate.toISOString().slice(0,10);
                        if (!isPastDate(iso)) {
                            foundDate = iso;
                            // Convert ranges like '09:00-12:00' to objects expected by modal
                            const rangesObjs = ranges.map(r => {
                                const parts = (r||'').split('-');
                                return { start: (parts[0]||'09:00').trim(), end: (parts[1]||'17:00').trim() };
                            });
                            // Use service-level increment; if fixed increments are enabled, use duration+buffer_after
                            let inc = Number(svc.time_increment_minutes || 30);
                            try {
                                if (svc.use_fixed_increment) {
                                    const dur = Number(svc.duration || 0);
                                    const buf = Number(svc.buffer_after || 0);
                                    if (!isNaN(dur) && !isNaN(buf) && (dur + buf) > 0) {
                                        inc = dur + buf;
                                    }
                                }
                            } catch (e) { /* ignore */ }
                            // Open the Day Schedule modal for this date
                            try { openTimeCirclesModal(foundDate, inc, 1, rangesObjs); } catch (e) { console.warn('auto-open modal failed', e); }
                            break;
                        }
                    }
                }
            } catch (e) { console.warn('auto-open Day Schedule failed', e); }
        })();

    // Relocate calendar controls below the month title on mobile, revert on desktop
    function relocateCalendarControls() {
        const controls = document.getElementById('calendar-controls');
        const cal = document.getElementById('calendar');
        if (!controls || !cal) return;
        const isMobile = window.matchMedia('(max-width: 768px)').matches;
        const toolbar = cal.querySelector('.fc-header-toolbar');
        if (isMobile && toolbar) {
            if (controls.dataset.inHeader !== '1') {
                controls.dataset.inHeader = '1';
                // Ensure inline layout
                controls.style.position = 'static';
                controls.style.left = '';
                controls.style.top = '';
                controls.style.transform = 'none';
                toolbar.insertAdjacentElement('afterend', controls);
            }
        } else {
            if (controls.dataset.inHeader === '1') {
                controls.dataset.inHeader = '';
                const parent = cal.parentElement; // calendar column container
                if (parent) parent.appendChild(controls);
                // Restore desktop overlay positioning
                controls.style.position = 'absolute';
                controls.style.left = '50%';
                controls.style.top = '80px';
                controls.style.transform = 'translateX(-50%)';
            }
        }
    }
    try { relocateCalendarControls(); } catch (e) {}
    try { window.addEventListener('resize', relocateCalendarControls); } catch (e) {}

    // Remove trailing extra rows made of only other-month days
    try { hideTrailingOtherRows(); } catch (e) { /* ignore */ }

    // Initial styling for overrides table (badges + animated buttons)
    try { styleOverridesTable(); } catch (e) { /* ignore */ }

    // Inline bookings: render bookings for the current visible calendar range
    function renderInlineBookings() {
        const tbody = document.getElementById('bookingsInlineTBody');
        if (!tbody || !calendar) return;

        const view = calendar.view;
        const rangeStart = view && view.activeStart ? view.activeStart : null;
        const rangeEnd = view && view.activeEnd ? view.activeEnd : null;

        // Gather events already loaded in calendar and filter to real bookings only
        let events = [];
        try { events = calendar.getEvents() || []; } catch (e) { events = []; }
        const bookings = events.filter(ev => {
            try {
                const xp = ev.extendedProps || {};
                if (xp.is_blocking || xp.is_per_date || ev.display === 'background') return false;
                // Keep this in sync with Day Schedule booking scope behavior
                try {
                    if (typeof _isBookingInSelectedScope === 'function' && !_isBookingInSelectedScope(ev)) return false;
                } catch (e) { /* ignore */ }
                if (rangeStart && ev.start < rangeStart) return false;
                if (rangeEnd && ev.start >= rangeEnd) return false;
                return true;
            } catch (_) { return false; }
        }).sort((a,b) => (a.start?.getTime()||0) - (b.start?.getTime()||0));

        const search = (document.getElementById('bookingsSearchInline')?.value || '').toLowerCase();
        const filtered = bookings.filter(ev => {
            const xp = ev.extendedProps || {};
            const name = (xp.client_name || xp.customer_name || '').toLowerCase();
            const email = (xp.client_email || xp.customer_email || '').toLowerCase();
            return !search || name.includes(search) || email.includes(search);
        });

        tbody.innerHTML = '';
        if (filtered.length === 0) {
            const msg = (typeof IS_TEAM !== 'undefined' && IS_TEAM) ? 'No bookings from this member/service' : 'No bookings for this period';
            tbody.innerHTML = `<tr><td colspan="5" style="text-align:center; color:var(--gray-600); padding:16px;">${msg}</td></tr>`;
            return;
        }

        const todayStr = new Date().toDateString();
        filtered.forEach(ev => {
            const tr = document.createElement('tr');
            tr.style.borderBottom = '1px solid var(--gray-200)';

            const xp = ev.extendedProps || {};
            const client = xp.client_name || xp.customer_name || '—';
            const email = xp.client_email || xp.customer_email || '';
            let service = xp.service_name || xp.service_slug || '';
            if (!service) {
                try {
                    const svcId = (xp.service_id || ev.service_id || null);
                    const svc = svcId ? svcById(svcId) : null;
                    service = (svc && svc.name) ? svc.name : '';
                } catch (e) { /* ignore */ }
            }
            if (!service) service = ev.title || '—';
            const start = ev.start;
            const end = ev.end || null;

            let status = 'Upcoming';
            if (start) {
                const startDay = start.toDateString();
                if (startDay === todayStr) status = 'Today';
                else if (start < new Date()) status = 'Past';
            }

            const tdDT = document.createElement('td');
            tdDT.style.padding = '10px';
            tdDT.innerHTML = start ? `<div style="font-weight:600;">${start.toLocaleDateString()}</div><div style="font-size:13px; color:var(--gray-600);">${start.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}${end ? ' - ' + end.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}) : ''}</div>` : '—';

            const tdClient = document.createElement('td');
            tdClient.style.padding = '10px';
            tdClient.innerHTML = `<div style="font-weight:600;">${client}</div><div style="font-size:13px; color:var(--gray-600);">${email}</div>`;

            const tdService = document.createElement('td');
            tdService.style.padding = '10px';
            tdService.textContent = service;

            const tdStatus = document.createElement('td');
            tdStatus.style.padding = '10px';
            const badgeMap = { Today: ['#d4edda','#155724'], Past:['#d6d8db','#383d41'], Upcoming:['#d1ecf1','#0c5460'] };
            const [bg, fg] = badgeMap[status] || ['#eee','#444'];
            tdStatus.innerHTML = `<span style="padding:4px 8px; border-radius:4px; font-size:12px; font-weight:600; background:${bg}; color:${fg};">${status}</span>`;

            const tdActions = document.createElement('td');
            tdActions.style.padding = '10px';
            const viewBtn = document.createElement('button');
            viewBtn.type = 'button';
            viewBtn.textContent = 'View';
            viewBtn.style.cssText = 'padding:6px 10px; background:var(--primary-500); color:white; border:none; border-radius:6px; cursor:pointer;';
            viewBtn.onclick = () => {
                try { openBookingModal(ev); } catch (e) { console.error('openBookingModal failed', e); }
            };
            tdActions.appendChild(viewBtn);

            tr.appendChild(tdDT);
            tr.appendChild(tdClient);
            tr.appendChild(tdService);
            tr.appendChild(tdStatus);
            tr.appendChild(tdActions);
            tbody.appendChild(tr);
        });
    }

    function updateBookingsViewAllLink(){
        try{
            const a = document.getElementById('bookingsViewAllBtn');
            if (!a) return;
            const base = `/bus/${orgSlug}/bookings/`;
            if (SELECTED_MEMBER) a.setAttribute('href', `${base}?scope=${encodeURIComponent(String(SELECTED_MEMBER))}`);
            else a.setAttribute('href', base);
        }catch(e){ /* ignore */ }
    }

    function filterInlineAuditBySelection(){
        try{
            const rows = Array.from(document.querySelectorAll('.cc-inline-audit-row'));
            const empty = document.getElementById('inlineAuditEmptyScoped');
            if (!rows.length) {
                if (empty) empty.style.display = 'none';
                return;
            }

            // allowed service ids for current scope
            let allowed = null;
            if (SELECTED_MEMBER) {
                if (String(SELECTED_MEMBER).startsWith('svc:')) {
                    allowed = new Set([String(SELECTED_MEMBER).slice(4)]);
                } else {
                    // Member selection -> show audit entries for visible services
                    try { allowed = new Set((VISIBLE_SERVICES || []).map(s => String(s.id))); }
                    catch (e) { allowed = new Set(); }
                }
            }

            let shown = 0;
            rows.forEach(li => {
                try{
                    const sid = String(li.getAttribute('data-service-id') || '');
                    const show = (!allowed) ? true : (sid && allowed.has(sid));
                    li.style.display = show ? 'flex' : 'none';
                    if (!show) {
                        const cb = li.querySelector('input.auditRowCbInline');
                        if (cb) cb.checked = false;
                    } else {
                        shown += 1;
                    }
                }catch(e){ /* ignore */ }
            });

            if (empty) empty.style.display = (allowed && shown === 0) ? 'block' : 'none';
            try { const selAll = document.getElementById('auditInlineSelectAll'); if (selAll) selAll.checked = false; } catch(e) {}
        }catch(e){ /* ignore */ }
    }

    // Search and manual refresh handlers
    try {
        document.getElementById('bookingsSearchInline')?.addEventListener('input', () => renderInlineBookings());
        document.getElementById('bookingsRefreshBtn')?.addEventListener('click', () => renderInlineBookings());
    } catch (_) {}

    // Initial render
    try { renderInlineBookings(); } catch (_) {}
    try { updateBookingsViewAllLink(); } catch (_) {}
    try { filterInlineAuditBySelection(); } catch (_) {}

    // Render the default availability UI and sync backgrounds to the calendar
    try { displayDefaultAvailability(); } catch (e) { console.warn('displayDefaultAvailability failed', e); }
    try { syncAvailabilityToCalendar(); } catch (e) { console.warn('syncAvailabilityToCalendar failed', e); }
    try { updateUnavailableDays(); } catch (e) { console.warn('updateUnavailableDays failed', e); }
    try { reapplySelections(); } catch (e) { /* optional */ }
    try { updateClearButton(); } catch (e) { /* optional */ }

    // Mobile safety: don't pin a fixed/min height on the weekly availability card.
    // The card should grow naturally as ranges are added and the Save button appears.
    (function ensureAvailabilityContainerFlexible() {
        function apply() {
            try {
                if (window.innerWidth > 768) return;
                const el = document.getElementById('defaultAvailabilityContainer');
                if (!el) return;
                // Ensure no code path leaves a fixed height/max-height that would clip content.
                el.style.height = 'auto';
                el.style.maxHeight = 'none';
                // Keep overflow hidden so the top-gradient (::before) stays clipped to border-radius.
                el.style.overflow = 'hidden';
            } catch (err) { /* ignore */ }
        }

        // Run after next paint to allow layout to settle
        requestAnimationFrame(() => setTimeout(apply, 0));

        // Also adjust on viewport resizes (debounced)
        let t = null;
        window.addEventListener('resize', () => {
            clearTimeout(t);
            t = setTimeout(apply, 120);
        });

        // If the card's content changes (adding ranges, Save button becomes visible), re-apply.
        try {
            const el = document.getElementById('defaultAvailabilityContainer');
            if (el && typeof MutationObserver !== 'undefined') {
                const obs = new MutationObserver(() => apply());
                obs.observe(el, { childList: true, subtree: true, attributes: true });
            }
        } catch (e) { /* ignore */ }
    })();

    // Audit modal for inline feed
    function tryParseSnapshot(raw){
        if(!raw) return null;
        try{
            // unescape unicode sequences like \u0027 -> '
            raw = String(raw).replace(/\\u([0-9a-fA-F]{4})/g, function(_, g){ return String.fromCharCode(parseInt(g,16)); });
        }catch(e){}
        try { return JSON.parse(raw); } catch(e){}
        try {
            let alt = String(raw).replace(/\\'/g, "'");
            alt = alt.replace(/'/g, '"');
            alt = alt.replace(/\bNone\b/g, 'null').replace(/\bTrue\b/g,'true').replace(/\bFalse\b/g,'false');
            return JSON.parse(alt);
        } catch(e){}
        try { return (new Function('return ' + raw))(); } catch(e){}
        return null;
    }
    window.openAuditInline = function(btn) {
        try {
            const raw = btn.getAttribute('data-snapshot');
            let parsed = tryParseSnapshot(raw);
            const out = document.getElementById('inlineAuditContent');
            if (parsed && typeof parsed === 'object'){
                // Build friendly HTML
                const parts = [];
                if (parsed.title) parts.push(`<div><strong>Title:</strong> ${parsed.title}</div>`);
                if (parsed.start) parts.push(`<div><strong>Start:</strong> ${new Date(parsed.start).toLocaleString()}</div>`);
                if (parsed.end) parts.push(`<div><strong>End:</strong> ${new Date(parsed.end).toLocaleString()}</div>`);
                if (parsed.client_name) parts.push(`<div><strong>Client:</strong> ${parsed.client_name} <span style="color:#666">&lt;${parsed.client_email || parsed.clientEmail || '-'}&gt;</span></div>`);
                const svc = parsed.service_slug || parsed.service || parsed.service_name || (parsed.snapshot && parsed.snapshot.service_slug);
                if (svc) parts.push(`<div><strong>Service:</strong> ${svc}</div>`);
                if (parsed.created_at) parts.push(`<div><strong>Booked At:</strong> ${new Date(parsed.created_at).toLocaleString()}</div>`);
                out.innerHTML = parts.join('\n') || (raw || 'No detail');
            } else {
                out.textContent = raw || 'No detail';
            }
            document.getElementById('inlineAuditModal').style.display = 'flex';
        } catch (e) { console.error(e); }
    }
    window.closeInlineAudit = function() { document.getElementById('inlineAuditModal').style.display = 'none'; }

    // Inline audit select-all + export
    const auditInlineSelectAll = document.getElementById('auditInlineSelectAll');
    if (auditInlineSelectAll) {
        auditInlineSelectAll.addEventListener('change', (e) => {
            document.querySelectorAll('.auditRowCbInline').forEach(cb => cb.checked = e.target.checked);
        });
    }

    const exportAuditInlineBtn = document.getElementById('exportAuditInlineBtn');
    if (exportAuditInlineBtn) {
        exportAuditInlineBtn.addEventListener('click', async () => {
            const ids = Array.from(document.querySelectorAll('.auditRowCbInline:checked')).map(cb => Number(cb.value));
            if (!ids.length) { alert('No audit rows selected'); return; }
            try {
                const resp = await fetch(`/bus/{{ organization.slug }}/bookings/audit/export/`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'X-CSRFToken': getCookie('csrftoken') || '' },
                    body: JSON.stringify({ ids })
                });
                if (!resp.ok) { alert('Export failed'); return; }
                const blob = await resp.blob();
                const contentType = resp.headers.get('Content-Type') || '';
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url;
                if (contentType === 'application/pdf') a.download = 'audit_export.pdf'; else a.download = 'audit_export.json';
                document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
            } catch (e) { console.error(e); alert('Export error'); }
        });
        const deleteAuditInlineBtn = document.getElementById('deleteAuditInlineBtn');
        if (deleteAuditInlineBtn){
            deleteAuditInlineBtn.addEventListener('click', async () => {
                const ids = Array.from(document.querySelectorAll('.auditRowCbInline:checked')).map(cb => Number(cb.value));
                if (!ids.length) { alert('No audit rows selected'); return; }
                if (!confirm('Permanently delete selected audit records? This cannot be undone.')) return;
                try {
                    const resp = await fetch(`/bus/{{ organization.slug }}/bookings/audit/delete/`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': getCookie('csrftoken') || '' },
                        body: JSON.stringify({ ids })
                    });
                    if (!resp.ok) { alert('Delete failed'); return; }
                    const data = await resp.json();
                    showToast('success', `Deleted ${data.deleted || 0} audit rows.`);
                    document.querySelectorAll('.auditRowCbInline:checked').forEach(cb => { const li = cb.closest('li'); if (li) li.remove(); });
                } catch (e) { console.error(e); alert('Delete error'); }
            });
        }
    }

    // Day Schedule is read-only; change client slot settings in Edit Service.

    // Ensure every day-number has a click handler that opens the proper modal
    function attachDayNumberClickHandlers() {
        document.querySelectorAll('.fc-daygrid-day').forEach(dayCell => {
            const dateStr = dayCell.dataset.date;
            if (!dateStr) return;
            const numberEl = dayCell.querySelector('.fc-daygrid-day-number');
            if (!numberEl) return;

            // Keep cursor interactive; actual click handling is done by delegated pointerup
            numberEl.style.cursor = 'pointer';
        });
    }

    try { attachDayNumberClickHandlers(); } catch (e) { console.warn('attachDayNumberClickHandlers failed', e); }

    // Mobile drag-selection (touch): mirror the existing desktop mousedown/mousemove/mouseup logic.
    // We start the selection on pointerdown and extend it on pointermove across day cells.
    let _ccTouchDragPointerId = null;
    let _ccSuppressMouseDownUntil = 0;

    function _ccCellFromPointer(ev) {
        try {
            const el = document.elementFromPoint(ev.clientX, ev.clientY);
            return el ? el.closest('.fc-daygrid-day') : null;
        } catch (e) {
            return null;
        }
    }

    calendarEl.addEventListener('pointerdown', function(ev) {
        try {
            const isTouch = (ev && ev.pointerType === 'touch') || ('ontouchstart' in window) || (navigator && navigator.maxTouchPoints > 0);
            if (!isTouch) return;
            if (isDragging) return;

            const target = (ev && ev.target && ev.target.nodeType === 3) ? ev.target.parentElement : ev.target;
            if (!target || typeof target.closest !== 'function') return;
            const num = target.closest('.fc-daygrid-day-number');
            if (!num) return;
            const cell = num.closest('.fc-daygrid-day');
            if (!cell) return;

            const date = cell.dataset.date;
            if (!date) return;

            // Stop scroll while dragging/selecting.
            try { ev.preventDefault(); } catch (_) {}
            try { ev.stopPropagation(); } catch (_) {}

            _ccSuppressMouseDownUntil = Date.now() + 700;
            _ccTouchDragPointerId = ev.pointerId;
            try { calendarEl.setPointerCapture(ev.pointerId); } catch (_) {}

            const isPast = isPastDate(date);

            // Fully-booked days cannot be overridden.
            try {
                if (!isPast && (typeof _ccFullyBookedProtectionEnabled === 'function' && _ccFullyBookedProtectionEnabled()) && window.__ccFullyBookedOutDates && window.__ccFullyBookedOutDates.has(String(date))) {
                    ccToastFullyBooked([String(date)]);
                    return;
                }
            } catch (e) { /* ignore */ }

            // Mixed selection guard.
            if (isPast && [...selectedDates].some(d => !isPastDate(d)) ||
                !isPast && [...selectedDates].some(d => isPastDate(d)))
            {
                alert('You can only select past days or available days — not both at the same time.');
                isDragging = false;
                dragStartDate = null;
                dragMode = null;
                dragStartIsUnavailable = false;
                document.querySelectorAll('.fc-daygrid-day-number.temp-highlight').forEach(el => el.classList.remove('temp-highlight'));
                return;
            }

            if (isPast) {
                openPastDayModal(date);
                return;
            }

            // Start drag selection.
            isDragging = true;
            dragStartDate = date;
            dragMode = selectedDates.has(date) ? 'deselect' : 'select';
            try {
                const numEl = cell.querySelector('.fc-daygrid-day-number');
                dragStartIsUnavailable = cell.classList.contains('fc-day-unavailable') || (numEl && numEl.classList.contains('unavailable-number'));
            } catch (e) { dragStartIsUnavailable = false; }

            toggleDateSelection(date, dragMode === 'select');
        } catch (err) { console.error('delegated pointerdown handler failed', err); }
    }, { passive: false });

    calendarEl.addEventListener('pointermove', function(ev) {
        try {
            if (!isDragging || !dragStartDate) return;
            if (!ev || ev.pointerType !== 'touch') return;
            if (_ccTouchDragPointerId != null && ev.pointerId !== _ccTouchDragPointerId) return;

            try { ev.preventDefault(); } catch (_) {}

            const cell = _ccCellFromPointer(ev);
            if (!cell) return;
            const currentDate = cell.dataset.date;
            if (!currentDate) return;

            // Skip if mixed past/future detected
            const isPast = isPastDate(currentDate);
            if (isPast && [...selectedDates].some(d => !isPastDate(d)) ||
                !isPast && [...selectedDates].some(d => isPastDate(d)))
            {
                isDragging = false;
                dragStartDate = null;
                dragMode = null;
                dragStartIsUnavailable = false;
                document.querySelectorAll('.fc-daygrid-day-number.temp-highlight').forEach(el => el.classList.remove('temp-highlight'));
                return;
            }

            const start = parseYMD(dragStartDate);
            const end = parseYMD(currentDate);
            const minDate = start < end ? start : end;
            const maxDate = start > end ? start : end;

            const selector = dragStartIsUnavailable ? '.fc-daygrid-day.fc-day-unavailable' : '.fc-daygrid-day.fc-day-available';
            const blockedDuringDrag = [];
            document.querySelectorAll(selector).forEach(c => {
                const dateStr = c.dataset.date;
                const numberEl = c.querySelector('.fc-daygrid-day-number');
                if (!numberEl || !dateStr) return;

                // Skip fully-booked days during drag selection.
                try {
                    if ((typeof _ccFullyBookedProtectionEnabled === 'function' && _ccFullyBookedProtectionEnabled()) && window.__ccFullyBookedOutDates && window.__ccFullyBookedOutDates.has(String(dateStr))) {
                        numberEl.classList.remove('temp-highlight');
                        numberEl.classList.remove('selected');
                        blockedDuringDrag.push(String(dateStr));
                        return;
                    }
                } catch (e) { /* ignore */ }

                const d = parseYMD(dateStr);
                if (d >= minDate && d <= maxDate) {
                    numberEl.classList.add('temp-highlight');
                    if (dragMode === 'select') numberEl.classList.add('selected');
                    else numberEl.classList.remove('selected');
                } else {
                    numberEl.classList.remove('temp-highlight');
                    if (dragMode === 'select' && !selectedDates.has(dateStr)) numberEl.classList.remove('selected');
                    if (dragMode === 'deselect' && selectedDates.has(dateStr)) numberEl.classList.add('selected');
                }
            });

            try {
                if (!window.__ccDragBlockedFullyBooked) window.__ccDragBlockedFullyBooked = new Set();
                for (const d of blockedDuringDrag) window.__ccDragBlockedFullyBooked.add(d);
            } catch (e) { /* ignore */ }
        } catch (err) { console.error('delegated pointermove handler failed', err); }
    }, { passive: false });

    function _ccEndTouchDragSelection(ev) {
        try {
            if (!isDragging) return;
            if (!ev || ev.pointerType !== 'touch') return;
            if (_ccTouchDragPointerId != null && ev.pointerId !== _ccTouchDragPointerId) return;

            // Commit ranged temp highlights.
            document.querySelectorAll('.fc-daygrid-day-number.temp-highlight').forEach(el => {
                el.classList.remove('temp-highlight');
                const date = el.closest('.fc-daygrid-day').dataset.date;
                if (dragMode === 'select') selectedDates.add(date);
                else if (dragMode === 'deselect') selectedDates.delete(date);
            });

            isDragging = false;
            dragStartDate = null;
            dragMode = null;
            dragStartIsUnavailable = false;
            _ccTouchDragPointerId = null;

            updateClearButton();
            updateSelectButtonText();

            try {
                if (window.__ccDragBlockedFullyBooked) window.__ccDragBlockedFullyBooked.clear();
            } catch (e) { /* ignore */ }

            try { calendarEl.releasePointerCapture(ev.pointerId); } catch (_) {}
        } catch (err) { console.error('touch drag end failed', err); }
    }

    calendarEl.addEventListener('pointerup', _ccEndTouchDragSelection, { passive: false });
    calendarEl.addEventListener('pointercancel', _ccEndTouchDragSelection, { passive: false });

    // Use a single delegated pointerup handler to toggle selection or open past-day modal.
    calendarEl.addEventListener('pointerup', function(ev) {
        try {
            // If a drag is in progress, skip (drag logic will handle selection on mouseup)
            if (isDragging) return;

            // Touch is handled on pointerdown for reliability.
            if (ev && ev.pointerType === 'touch') return;

            // iOS Safari can report a Text node as the event target.
            const target = (ev && ev.target && ev.target.nodeType === 3) ? ev.target.parentElement : ev.target;
            if (!target || typeof target.closest !== 'function') return;

            const num = target.closest('.fc-daygrid-day-number');
            if (!num) return;
            const dayCell = num.closest('.fc-daygrid-day');
            if (!dayCell) return;
            const dateStr = dayCell.dataset.date;
            if (!dateStr) return;

            // Past-day click -> open past-day modal
            if (isPastDate(dateStr)) {
                return openPastDayModal(dateStr);
            }

            // Toggle selection for any non-past day (available or unavailable)
            toggleDateSelection(dateStr);
        } catch (err) { console.error('delegated pointerup handler failed', err); }
    });

    // Parse a YYYY-MM-DD string into a local Date at midnight (avoids Date("YYYY-MM-DD") UTC parsing)
    function parseYMD(dateStr) {
            const parts = String(dateStr).split('-');
            if (parts.length !== 3) return new Date(dateStr);
            const y = parseInt(parts[0], 10);
            const m = parseInt(parts[1], 10) - 1;
            const d = parseInt(parts[2], 10);
            return new Date(y, m, d);
        }

        // Apply visual badges for type column and animated styles for action buttons
        function styleOverridesTable() {
            const tbody = document.getElementById('overridesTableBody');
            if (!tbody) return;
            // Wrap type text in badges
            Array.from(tbody.querySelectorAll('tr')).forEach(row => {
                const cells = row.children;
                if (!cells || cells.length < 2) return;
                const typeCell = cells[1]; // Date(0), Type(1), Time Ranges(2)...
                if (!typeCell) return;
                const raw = (typeCell.textContent || '').trim();
                if (!raw) return;
                const lower = raw.toLowerCase();
                let cls = 'type-badge';
                if (lower.includes('blocked') || lower.includes('unavailable')) cls += ' blocked';
                else if (lower.includes('available')) cls += ' available';
                // Avoid double-wrapping
                if (!typeCell.querySelector('.type-badge')) {
                    typeCell.innerHTML = `<span class="${cls}">${raw}</span>`;
                }
            });
            // Upgrade buttons with animation styles
            Array.from(tbody.querySelectorAll('button')).forEach(btn => {
                if (!btn.classList.contains('overrides-btn')) {
                    btn.classList.add('overrides-btn');
                }
            });
        }

        // Re-style badges/buttons whenever overrides table changes
        try {
            const overridesBody = document.getElementById('overridesTableBody');
            if (overridesBody) {
                const obs = new MutationObserver(() => { try { styleOverridesTable(); } catch(e){} });
                obs.observe(overridesBody, { childList: true, subtree: true });
            }
        } catch (e) { /* ignore */ }

        // Hide any week rows that contain only out-of-month cells (prevents grey frames below last week)
        function hideTrailingOtherRows() {
            try {
                document.querySelectorAll('.fc-daygrid-week').forEach(week => {
                    const cells = week.querySelectorAll('.fc-daygrid-day');
                    if (!cells.length) return;
                    const allOther = Array.from(cells).every(c => c.classList.contains('fc-day-other'));
                    week.style.display = allOther ? 'none' : '';
                });
            } catch (e) { /* ignore */ }
        }

        // Format a Date object into YYYY-MM-DD using local date components
        function formatYMD(d) {
            if (!(d instanceof Date)) d = new Date(d);
            const y = d.getFullYear();
            const m = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${y}-${m}-${day}`;
        }

        // Toggle the modal ranges container visibility based on whether the given date
        // is fully unavailable (weekly default or per-date full-day block).
        function setModalTimeRowVisibility(dateStr) {
            try {
                const rangesContainer = document.getElementById('modalRangesContainer');
                const noticeId = 'makeAvailableNotice';
                const prev = document.getElementById(noticeId);
                if (prev) prev.remove();

                if (!rangesContainer) return;

                const d = parseYMD(dateStr);
                const dow = d.getDay();
                const info = defaultAvailability[dow] || {};
                const firstRange = (info.ranges && info.ranges.length) ? info.ranges[0] : (info.start && info.end ? `${info.start}-${info.end}` : null);

                let hasPerDateBlocked = false;
                let hasPerDateAvailable = false;
                try {
                    const events = (typeof calendar.getEvents === 'function') ? calendar.getEvents() : [];
                    for (const ev of events) {
                        if (!ev || ev.display !== 'background') continue;
                        const props = ev.extendedProps || {};
                        if (!props.is_per_date) continue;
                        if (!ev.start) continue;
                        const evDate = formatYMD(ev.start);
                        if (evDate !== dateStr) continue;
                        const isFullDay = ev.startStr && ev.endStr && ev.startStr.endsWith('T00:00') && ev.endStr.endsWith('T23:59');
                        if (props.override_type === 'blocked' && isFullDay) {
                            hasPerDateBlocked = true;
                        } else if (props.override_type === 'available') {
                            hasPerDateAvailable = true;
                        }
                    }
                } catch (e) { /* ignore */ }

                // Precedence: per-date blocked > per-date available > weekly defaults
                let fullyUnavailable = hasPerDateBlocked || ((!!info.unavailable || (!firstRange && (!info.ranges || info.ranges.length === 0))) && !hasPerDateAvailable);
                try {
                    const cell = document.querySelector(`.fc-daygrid-day[data-date="${dateStr}"]`);
                    const num = cell ? cell.querySelector('.fc-daygrid-day-number') : null;
                    const cellUnavailable = cell && (cell.classList.contains('fc-day-unavailable') || (num && num.classList.contains('unavailable-number')));
                    if (cellUnavailable) fullyUnavailable = true;
                } catch (e) { /* ignore */ }

                if (fullyUnavailable) {
                    rangesContainer.style.display = 'none';
                    // Hide the Add Range button when the date is fully unavailable
                    try {
                        const addBtnEl = document.getElementById('addModalRangeBtn');
                        if (addBtnEl) addBtnEl.style.display = 'none';
                    } catch (e) { /* ignore */ }
                    const msg = document.createElement('div');
                    msg.id = noticeId;
                    msg.style.padding = '12px 0';
                    msg.style.fontWeight = '600';
                    msg.textContent = 'This date is currently fully unavailable; make it available to set times.';
                    const modalContent = document.getElementById('timeModal')?.querySelector('div[style*="padding"]') || document.getElementById('timeModal')?.firstElementChild;
                    if (modalContent) modalContent.insertBefore(msg, modalContent.querySelector('div') || modalContent.firstChild);
                } else {
                    rangesContainer.style.display = '';
                    // Ensure Add Range button is visible when date is available
                    try {
                        const addBtnEl = document.getElementById('addModalRangeBtn');
                        if (addBtnEl) addBtnEl.style.display = 'inline-block';
                    } catch (e) { /* ignore */ }
                }
            } catch (e) { console.warn('setModalTimeRowVisibility failed', e); }
        }

        function getCoachOccupiedDates() {
            const occupied = new Set();
            calendar.getEvents().forEach(event => {
                const start = event.startStr.split('T')[0];
                const end = event.endStr ? event.endStr.split('T')[0] : start;
                let curr = parseYMD(start);
                const last = parseYMD(end);
                while (curr <= last) {
                    occupied.add(formatYMD(curr));
                    curr.setDate(curr.getDate() + 1);
                }
            });
            return occupied;
        }

        // Apply a per-date unavailable UI immediately (client-side) by adding
        // a full-day background event and switching classes on the calendar cell.
        function applyPerDateUnavailable(dateStr) {
            try {
                // Add a background block for immediate visual feedback
                const overrideTarget = (ccOverrideTarget() || null);
                calendar.addEvent({
                    start: dateStr + 'T00:00',
                    end: dateStr + 'T23:59',
                    display: 'background',
                    color: '#e0e0e0',
                    extendedProps: Object.assign({ is_per_date: true, override_type: 'blocked', optimistic: true }, getScopePropsForSelection(overrideTarget))
                });
            } catch (e) { console.warn('applyPerDateUnavailable addEvent failed', e); }

            const cell = document.querySelector(`.fc-daygrid-day[data-date="${dateStr}"]`);
            if (!cell) return;
            cell.classList.add('fc-day-unavailable');
            cell.classList.remove('fc-day-available');
            const num = cell.querySelector('.fc-daygrid-day-number');
            if (num) {
                num.classList.add('unavailable-number');
                num.classList.remove('past-day');
                num.style.cursor = 'pointer';
            }
        }

        

        // -----------------------------
        // 6️⃣ Sync default weekly availability to calendar
        // -----------------------------
        function syncAvailabilityToCalendar() {
            // 1️⃣ Clear existing background events that we previously added as defaults
            calendar.getEvents().forEach(e => {
                try {
                    if (e.display === 'background' && e.extendedProps && e.extendedProps.is_default) e.remove();
                } catch (e) { /* ignore */ }
            });

            const occupied = getCoachOccupiedDates();

            // Prefer to sync over the currently visible calendar range so
            // the visuals always match what the user sees (important when
            // the month view spans different weeks).
            const viewStart = (calendar.view && calendar.view.activeStart) ? new Date(calendar.view.activeStart) : new Date();
            const viewEnd = (calendar.view && calendar.view.activeEnd) ? new Date(calendar.view.activeEnd) : (() => { const d=new Date(); d.setMonth(d.getMonth()+1); return d; })();

            // Iterate each day in the visible range
            for (let d = new Date(viewStart); d < viewEnd; d.setDate(d.getDate() + 1)) {
                const dateStr = formatYMD(d);
                if (isPastDate(dateStr)) continue;
                if (occupied.has(dateStr)) continue; // keep booked days alone

                const dow = d.getDay(); // 0=Sunday
                const info = defaultAvailability[dow] || {};

                // If day is unavailable, block whole day (mark as default)
                if (info.unavailable) {
                    calendar.addEvent({ start: dateStr + 'T00:00', end: dateStr + 'T23:59', display: 'background', color: '#e0e0e0', extendedProps: { is_default: true } });
                } else {
                    const ranges = info.ranges || (info.start && info.end ? [`${info.start}-${info.end}`] : []);
                    ranges.forEach(range => {
                        const [s, e] = range.split('-');
                        if (!s || !e) return;
                        calendar.addEvent({ start: dateStr + 'T' + s.trim(), end: dateStr + 'T' + e.trim(), display: 'background', color: '#d0f0d0', extendedProps: { is_default: true } });
                    });
                }
            }
        }

        // Keep a non-debounced version available for save-success flows.
        // (The debounced version is great for typing/rapid interactions, but
        // can make a successful save feel like it "didn't apply" immediately.)
        const syncAvailabilityToCalendarImmediate = syncAvailabilityToCalendar;

        // Debounce sync to avoid expensive repeated recalculations on rapid events
        function debounce(fn, wait) {
            let t = null;
            return function(...args) {
                if (t) clearTimeout(t);
                t = setTimeout(() => { try { fn.apply(this, args); } catch(e){}; t = null; }, wait);
            };
        }
        // Replace syncAvailabilityToCalendar with a debounced version to reduce CPU spikes
        syncAvailabilityToCalendar = debounce(syncAvailabilityToCalendar, 150);


    // 1️⃣ Function to mark past days grey
    function markPastDaysImmediately() {
        const calendarContainer = document.getElementById('calendar');
        if (!calendarContainer) return;

        // Avoid observing full calendar DOM changes (expensive).
        // Instead perform a single initial pass and rely on FullCalendar lifecycle
        // hooks (`eventsSet`, `datesSet`) which already call `updateUnavailableDays()`
        // when the calendar changes. Observing the entire subtree caused repeated
        // full DOM traversals and frequent calls to `updateUnavailableDays`, which
        // can be very CPU intensive when FullCalendar updates the view.
        (function applyPastClassesOnce() {
            document.querySelectorAll('.fc-daygrid-day').forEach(cell => {
                const dateStr = cell.dataset.date;
                const numberEl = cell.querySelector('.fc-daygrid-day-number');
                if (!numberEl) return;
                numberEl.classList.remove('past-day');
                if (isPastDate(dateStr)) numberEl.classList.add('past-day');
            });
            try { updateUnavailableDays(); } catch (e) { /* ignore errors during reapply */ }
        })();
    }

    // Return the first per-date timed override for a given date, or null.
    function findPerDateTimedOverride(dateStr) {
        try {
            const events = (typeof calendar.getEvents === 'function') ? calendar.getEvents() : [];
            for (const ev of events) {
                try {
                    if (!ev || ev.display !== 'background') continue;
                    if (!ev.extendedProps || !ev.extendedProps.is_per_date) continue;
                    // Only consider per-date overrides in the currently selected scope
                    try {
                        if (SELECTED_MEMBER) {
                            const xp = ev.extendedProps || {};
                            if (String(SELECTED_MEMBER).startsWith('svc:')) {
                                const svcId = String(SELECTED_MEMBER).slice(4);
                                const assignedSvc = (xp.assigned_scope_service_id || xp.assigned_scope_service || null);
                                if (!assignedSvc || String(assignedSvc) !== String(svcId)) continue;
                            } else {
                                const userId = getSelectedUserIdForMembership(SELECTED_MEMBER);
                                const assignedUserId = xp.assigned_user_id || null;
                                const assignedMembershipId = xp.assigned_membership_id || null;
                                if (userId && assignedUserId && String(assignedUserId) !== String(userId)) continue;
                                if (!userId && assignedMembershipId && String(assignedMembershipId) !== String(SELECTED_MEMBER)) continue;
                            }
                        }
                    } catch (e) { /* ignore scope check errors */ }
                    if (!ev.start || !ev.end) continue;
                    const evDate = formatYMD(ev.start);
                    if (evDate !== dateStr) continue;
                    // Skip full-day blocks
                    const isFullDay = ev.startStr && ev.endStr && ev.startStr.endsWith('T00:00') && ev.endStr.endsWith('T23:59');
                    if (isFullDay) continue;
                    const sH = String(ev.start.getHours()).padStart(2, '0');
                    const sM = String(ev.start.getMinutes()).padStart(2, '0');
                    const eH = String(ev.end.getHours()).padStart(2, '0');
                    const eM = String(ev.end.getMinutes()).padStart(2, '0');
                    return { start: `${sH}:${sM}`, end: `${eH}:${eM}` };
                } catch (ie) { /* ignore */ }
            }
        } catch (e) { /* ignore */ }
        return null;
    }

    // Return all per-date timed overrides for a given date (array)
    function findPerDateTimedOverrides(dateStr) {
        const out = [];
        try {
            const events = (typeof calendar.getEvents === 'function') ? calendar.getEvents() : [];
            for (const ev of events) {
                try {
                    if (!ev || ev.display !== 'background') continue;
                    if (!ev.extendedProps || !ev.extendedProps.is_per_date) continue;
                    // Only include per-date overrides in the currently selected scope
                    try {
                        if (SELECTED_MEMBER) {
                            const xp = ev.extendedProps || {};
                            if (String(SELECTED_MEMBER).startsWith('svc:')) {
                                const svcId = String(SELECTED_MEMBER).slice(4);
                                const assignedSvc = (xp.assigned_scope_service_id || xp.assigned_scope_service || null);
                                if (!assignedSvc || String(assignedSvc) !== String(svcId)) continue;
                            } else {
                                const userId = getSelectedUserIdForMembership(SELECTED_MEMBER);
                                const assignedUserId = xp.assigned_user_id || null;
                                const assignedMembershipId = xp.assigned_membership_id || null;
                                if (userId && assignedUserId && String(assignedUserId) !== String(userId)) continue;
                                if (!userId && assignedMembershipId && String(assignedMembershipId) !== String(SELECTED_MEMBER)) continue;
                            }
                        }
                    } catch (e) { /* ignore scope check errors */ }
                    if (!ev.start || !ev.end) continue;
                    const evDate = formatYMD(ev.start);
                    if (evDate !== dateStr) continue;
                    const isFullDay = ev.startStr && ev.endStr && ev.startStr.endsWith('T00:00') && ev.endStr.endsWith('T23:59');
                    if (isFullDay) continue;
                    const sH = String(ev.start.getHours()).padStart(2, '0');
                    const sM = String(ev.start.getMinutes()).padStart(2, '0');
                    const eH = String(ev.end.getHours()).padStart(2, '0');
                    const eM = String(ev.end.getMinutes()).padStart(2, '0');
                    out.push({ start: `${sH}:${sM}`, end: `${eH}:${eM}` });
                } catch (ie) { /* ignore */ }
            }
        } catch (e) { /* ignore */ }
        return out;
    }

    // Create a UI row for a modal range (start/end + remove)
    function createModalRangeRow(startVal = '09:00', endVal = '17:00') {
        const row = document.createElement('div');
        row.className = 'modal-range-row';
        row.style.display = 'flex';
        row.style.alignItems = 'center';
        row.style.justifyContent = 'center';
        row.style.gap = '8px';

        function _ccValidateModalRangesAndMaybeRevert(changedInputEl) {
            try {
                const container = document.getElementById('modalRangesContainer');
                if (!container) return;
                const rows = Array.from(container.querySelectorAll('.modal-range-row'));
                const verdict = _ccValidateRangeRowsNoOverlap(rows, '.modal-range-start', '.modal-range-end');
                if (!verdict.ok) {
                    _ccToastRangeError(verdict.message);
                    _ccRevertToPrevValue(changedInputEl);
                    return;
                }
                _ccSetPrevValue(changedInputEl);
            } catch (e) { /* ignore */ }
        }

        const startLabel = document.createElement('label');
        startLabel.className = 'range-label';
        startLabel.textContent = 'Start:';
        startLabel.style.minWidth = '45px';
        startLabel.style.textAlign = 'right';

        // Wrap the start input to position the custom picker relative to it
        const startContainer = document.createElement('div');
        startContainer.className = 'time-input-container';
        const start = document.createElement('input');
        start.type = 'time';
        start.className = 'modal-range-start';
        start.value = startVal;
        start.readOnly = true; // use custom time picker for consistency
        try { _ccSetPrevValue(start); } catch (e) {}
        startContainer.appendChild(start);
        function _ccOpenModalRangePicker(inputEl, containerEl) {
            try {
                document.querySelectorAll('.custom-time-picker').forEach(p => p.remove());
                const picker = (typeof createCustomTimePickerGlobal === 'function' ? createCustomTimePickerGlobal : createCustomTimePicker)(inputEl);
                picker.classList.add('active');
                containerEl.appendChild(picker);
            } catch (err) { /* ignore */ }
        }

        // Open custom picker (and block native mobile time picker)
        start.style.cursor = 'pointer';
        start.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            _ccOpenModalRangePicker(start, startContainer);
        });
        start.addEventListener('touchstart', (e) => {
            try { e.preventDefault(); } catch (_) {}
            e.stopPropagation();
            _ccOpenModalRangePicker(start, startContainer);
        }, { passive: false });
        start.addEventListener('focus', () => {
            try {
                const isTouch = ('ontouchstart' in window) || (navigator && navigator.maxTouchPoints > 0);
                if (isTouch) start.blur();
            } catch (_) {}
        });

        start.addEventListener('change', () => _ccValidateModalRangesAndMaybeRevert(start));

        const endLabel = document.createElement('label');
        endLabel.className = 'range-label';
        endLabel.textContent = 'End:';
        endLabel.style.minWidth = '40px';
        endLabel.style.textAlign = 'right';

        // Wrap the end input to position the custom picker relative to it
        const endContainer = document.createElement('div');
        endContainer.className = 'time-input-container';
        const end = document.createElement('input');
        end.type = 'time';
        end.className = 'modal-range-end';
        end.value = endVal;
        end.readOnly = true; // use custom time picker for consistency
        try { _ccSetPrevValue(end); } catch (e) {}
        endContainer.appendChild(end);
        // Open custom picker (and block native mobile time picker)
        end.style.cursor = 'pointer';
        end.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            _ccOpenModalRangePicker(end, endContainer);
        });
        end.addEventListener('touchstart', (e) => {
            try { e.preventDefault(); } catch (_) {}
            e.stopPropagation();
            _ccOpenModalRangePicker(end, endContainer);
        }, { passive: false });
        end.addEventListener('focus', () => {
            try {
                const isTouch = ('ontouchstart' in window) || (navigator && navigator.maxTouchPoints > 0);
                if (isTouch) end.blur();
            } catch (_) {}
        });

        end.addEventListener('change', () => _ccValidateModalRangesAndMaybeRevert(end));

        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'remove-range-btn cc-modal-remove-range-btn';
        removeBtn.setAttribute('aria-label', 'Remove time range');
        removeBtn.innerHTML = '<span class="remove-icon" aria-hidden="true">✖</span><span class="remove-text">Remove</span>';
        removeBtn.style.display = 'inline-flex';
        removeBtn.style.alignItems = 'center';
        removeBtn.style.justifyContent = 'center';
        removeBtn.style.gap = '6px';
        removeBtn.style.padding = '6px 10px';
        removeBtn.style.border = 'none';
        removeBtn.style.background = '#dc3545';
        removeBtn.style.color = 'white';
        removeBtn.style.borderRadius = '6px';
        removeBtn.style.cursor = 'pointer';
        removeBtn.onclick = () => row.remove();

        row.appendChild(startLabel);
        row.appendChild(startContainer);
        row.appendChild(endLabel);
        row.appendChild(endContainer);
        row.appendChild(removeBtn);
        return row;
    }

    function _ccAddModalRangeNoOverlap(rangesContainer, preferredDurationMinutes) {
        try {
            const container = rangesContainer || document.getElementById('modalRangesContainer');
            if (!container) return;
            const rows = Array.from(container.querySelectorAll('.modal-range-row'));
            const existing = _ccCollectIntervalsFromRows(rows, '.modal-range-start', '.modal-range-end');
            const candidate = _ccSuggestNextNonOverlappingRange(existing, (preferredDurationMinutes == null ? 60 : preferredDurationMinutes));
            if (!candidate || !candidate.start || !candidate.end || candidate.start === candidate.end) {
                _ccToastRangeError('No more non-overlapping time is available in the day.');
                return;
            }
            container.appendChild(createModalRangeRow(candidate.start, candidate.end));
        } catch (e) {
            try { _ccToastRangeError('Could not add a non-overlapping range.'); } catch (e2) {}
        }
    }

    // Call after calendar.render()
    // If the edit_service page requested opening the Day Schedule modal for a service,
    // compute the next available date (based on the service's weekly_map) and open it.
    (function autoOpenDaySchedule(){
        try{
            // Prefer localStorage keys for a clean redirect; fall back to query params
            let autoService = null, autoDate = null;
            try {
                const lsSvc = localStorage.getItem('cc_auto_open_service');
                const lsDate = localStorage.getItem('cc_auto_open_date');
                if (lsSvc) {
                    autoService = lsSvc;
                    autoDate = lsDate || "";
                    try { window.__ccDayScheduleServiceId = String(lsSvc); } catch (e) {}
                    // clear keys so this only runs once
                    try { localStorage.removeItem('cc_auto_open_service'); } catch(e){}
                    try { localStorage.removeItem('cc_auto_open_date'); } catch(e){}
                }
            } catch (e) {
                // localStorage may be unavailable; ignore
            }
            if (!autoService) {
                if (AUTO_OPEN_SERVICE && AUTO_OPEN_DATE) {
                    autoService = AUTO_OPEN_SERVICE;
                    autoDate = AUTO_OPEN_DATE;
                    try { window.__ccDayScheduleServiceId = String(AUTO_OPEN_SERVICE); } catch (e) {}
                }
            }
            if (!autoService || !autoDate) return;

            // Find the service by id (autoService may be string)
            const svcId = String(autoService);
            const svc = svcById(svcId);
            if (!svc) return;

            // helper: format Date to YYYY-MM-DD
            function formatYMD(d){
                const y = d.getFullYear();
                const m = String(d.getMonth()+1).padStart(2,'0');
                const dd = String(d.getDate()).padStart(2,'0');
                return `${y}-${m}-${dd}`;
            }

            // parse autoDate as local date
            const parts = (autoDate || '').split('-');
            let startDate = null;
            if (parts.length === 3){
                startDate = new Date(Number(parts[0]), Number(parts[1]) - 1, Number(parts[2]));
            } else {
                startDate = new Date();
            }

            // weekly_map expected: array length 7, each item is array of ranges like ['09:00-12:00']
            const weekly = Array.isArray(svc.weekly_map) ? svc.weekly_map : [[],[],[],[],[],[],[]];

            // scan up to 365 days forward for a weekday that has availability
            let foundDate = null;
            for (let i=0;i<365;i++){
                const d = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate() + i);
                const dow = d.getDay(); // 0=Sunday..6=Saturday
                const ranges = weekly[dow] || [];
                if (Array.isArray(ranges) && ranges.length > 0){
                    foundDate = d;
                    break;
                }
            }

            if (!foundDate) {
                // no weekly availability; fallback to the provided date
                try { foundDate = new Date(startDate); } catch(e){ foundDate = new Date(); }
            }

            // Build ranges object for the modal: convert 'HH:MM-HH:MM' -> {start, end}
            const dow = foundDate.getDay();
            const rawRanges = (weekly[dow] && Array.isArray(weekly[dow])) ? weekly[dow] : [];
            const modalRanges = rawRanges.map(r => {
                const p = (r || '').split('-');
                return { start: (p[0]||'09:00').trim(), end: (p[1]||'17:00').trim() };
            });

            // Determine client increment (fixed increments use duration+buffer_after)
            let increment = Number(svc.time_increment_minutes || 30);
            try {
                if (svc.use_fixed_increment) {
                    const dur = Number(svc.duration || 0);
                    const buf = Number(svc.buffer_after || 0);
                    if (!isNaN(dur) && !isNaN(buf) && (dur + buf) > 0) {
                        increment = dur + buf;
                    }
                }
            } catch (e) { /* ignore */ }

            // Delay opening slightly to ensure calendar cells & modal DOM exist
            setTimeout(() => {
                try{
                    const dateStr = formatYMD(foundDate);
                    // openTimeCirclesModal used for Day Schedule
                    if (typeof openTimeCirclesModal === 'function'){
                        openTimeCirclesModal(dateStr, increment, 1, modalRanges);
                    } else {
                        // fallback: highlight the day cell
                        const cell = document.querySelector(`.fc-daygrid-day[data-date="${dateStr}"] .fc-daygrid-day-number`);
                        if (cell) cell.classList.add('selected');
                    }
                } catch (e){ console.warn('autoOpenDaySchedule failed', e); }
            }, 300);

        } catch (e) { /* ignore */ }
    })();
    markPastDaysImmediately();

    // Render a table of per-date overrides (available/unavailable) based on calendar background events
    function renderOverridesTable() {
        const tbody = document.getElementById('overridesTableBody');
        if (!tbody) return;
        tbody.innerHTML = '';

        // Update month label in header
        try {
            const selSpan = document.getElementById('overridesHeaderSelection');
            const monthSpan = document.getElementById('overridesHeaderMonth');
            if (monthSpan && calendar) {
                const currentDate = calendar.getDate ? calendar.getDate() : new Date();
                const monthName = currentDate.toLocaleString('default', { month: 'long' });
                monthSpan.textContent = monthName;
                if (selSpan) selSpan.textContent = getSelectionLabel();
            }
        } catch (e) { /* ignore month label errors */ }

        // Header controls: normalize to 4 columns (Date, Type, Time Ranges, Actions); re-add Reset All button; no group actions
        try {
            const table = document.getElementById('overridesTable');
            const thead = table ? table.querySelector('thead') : null;
            const headerRow = thead ? thead.querySelector('tr') : null;
            if (headerRow) {
                // Trim extra columns if any
                while (headerRow.children.length > 4) {
                    headerRow.removeChild(headerRow.lastElementChild);
                }
                // Ensure headings
                if (headerRow.children[0]) headerRow.children[0].textContent = 'Date';
                if (headerRow.children[1]) headerRow.children[1].textContent = 'Type';
                if (headerRow.children[2]) headerRow.children[2].textContent = 'Time Ranges';
                // Intentionally omit label text for 4th column (Actions) per request
                if (headerRow.children[3]) headerRow.children[3].textContent = '';

                // Ensure Reset All Overrides button exists in 4th header cell
                const resetTh = headerRow.children[3];
                if (resetTh) {
                    // Center the button in the header cell
                    resetTh.style.textAlign = 'center';
                    // Avoid duplicates
                    const existing = resetTh.querySelector('#resetAllOverridesBtn');
                    if (!existing) {
                        const resetBtn = document.createElement('button');
                        resetBtn.id = 'resetAllOverridesBtn';
                        resetBtn.type = 'button';
                        resetBtn.textContent = 'Reset All Overrides';
                        resetBtn.style.padding = '6px 10px';
                        resetBtn.style.border = '1px solid #ccc';
                        resetBtn.style.borderRadius = '4px';
                        resetBtn.style.background = '#fff';
                        resetBtn.style.cursor = 'pointer';
                        resetTh.appendChild(resetBtn);

                        resetBtn.onclick = async () => {
                            if (!confirm('Reset ALL per-date overrides to weekly defaults?')) return;

                            ccSetBtnLoading(resetBtn, true, 'Resetting…');

                            // Reset exactly what is currently rendered in the overrides table.
                            const cache = (window._perDateOverridesCache && typeof window._perDateOverridesCache === 'object') ? window._perDateOverridesCache : {};
                            const byTarget = {}; // target -> dates[]

                            Object.keys(cache || {}).forEach(dateStr => {
                                try {
                                    const entry = cache[dateStr] || {};
                                    const t = (entry && entry.target != null) ? String(entry.target) : '';
                                    if (!t) return;
                                    if (!byTarget[t]) byTarget[t] = [];
                                    byTarget[t].push(String(dateStr));
                                } catch (e) { /* ignore */ }
                            });

                            const targets = Object.keys(byTarget);
                            if (!targets.length) {
                                alert('No per-date overrides to reset for this view.');
                                ccSetBtnLoading(resetBtn, false);
                                return;
                            }

                            // Dedupe dates across targets for guardrail checks
                            const dates = Array.from(new Set(targets.flatMap(t => byTarget[t] || [])));

                            // Prevent reset-all if weekly defaults would exclude existing bookings.
                            try {
                                const bad = [];
                                for (const d of dates) {
                                    const weekly = _weeklyDefaultRangesForDate(d);
                                    const verdict = _validateOverrideAgainstBookings(d, weekly);
                                    if (!verdict.ok) {
                                        bad.push(verdict.message || (`Reset blocked for ${d} due to existing booking(s).`));
                                        if (bad.length >= 5) break;
                                    }
                                }
                                if (bad.length) {
                                    alert(bad.join('\n\n'));
                                    ccSetBtnLoading(resetBtn, false);
                                    return;
                                }
                            } catch (e) { /* ignore */ }

                            function _ccLocalRemovePerDateEventsForTarget(dateList, target) {
                                try {
                                    if (!calendar || typeof calendar.getEvents !== 'function') return;
                                    const dateSet = new Set((dateList || []).map(String));
                                    const t = String(target || '');
                                    if (!t || !dateSet.size) return;
                                    const isSvc = t.startsWith('svc:');
                                    const svcId = isSvc ? t.slice(4) : null;
                                    const memId = !isSvc ? t : null;

                                    (calendar.getEvents() || []).forEach(ev => {
                                        try {
                                            if (!ev || ev.display !== 'background') return;
                                            const xp = ev.extendedProps || {};
                                            if (!xp.is_per_date) return;
                                            const startStr = ev.startStr || (ev.start ? ev.start.toISOString() : null);
                                            if (!startStr) return;
                                            const dateStr = String(startStr).split('T')[0];
                                            if (!dateSet.has(dateStr)) return;

                                            let matches = false;
                                            if (isSvc) {
                                                const assignedSvc = xp.assigned_scope_service_id || xp.assigned_scope_service || xp.assigned_service_id || xp.service_id || null;
                                                if (assignedSvc != null && String(assignedSvc) === String(svcId)) matches = true;
                                            } else {
                                                const assignedMembership = (xp.assigned_membership_id != null) ? String(xp.assigned_membership_id) : (xp.assigned_membership != null ? String(xp.assigned_membership) : null);
                                                if (assignedMembership && assignedMembership === String(memId)) {
                                                    matches = true;
                                                } else if (xp.assigned_user_id != null && Array.isArray(MEMBERS)) {
                                                    const uId = String(xp.assigned_user_id);
                                                    const m = MEMBERS.find(mm => {
                                                        try {
                                                            const uid = (mm.user__id || mm.user_id || (mm.user && (mm.user.id || mm.user.pk)) || null);
                                                            return uid != null && String(uid) === uId;
                                                        } catch (e) { return false; }
                                                    });
                                                    if (m && m.id != null && String(m.id) === String(memId)) matches = true;
                                                }
                                            }

                                            if (matches) ev.remove();
                                        } catch (e) { /* ignore */ }
                                    });
                                } catch (e) { /* ignore */ }
                            }

                            try {
                                let totalDeleted = 0;
                                for (const t of targets) {
                                    const chunk = Array.from(new Set(byTarget[t] || []));
                                    const res = await fetch(`/bus/${orgSlug}/bookings/batch_delete/`, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                                        body: JSON.stringify({ dates: chunk, target: t, mode: 'reset' })
                                    });
                                    const data = await res.json().catch(() => null);
                                    if (!res.ok) {
                                        const msg = (data && (data.error || data.message)) || `Server returned ${res.status}`;
                                        alert('Error resetting: ' + msg);
                                        return;
                                    }
                                    try { totalDeleted += Number((data && data.deleted) || 0) || 0; } catch (e) {}
                                }

                                // Make the overrides table update immediately (no refresh needed)
                                try {
                                    for (const t of targets) {
                                        _ccLocalRemovePerDateEventsForTarget(byTarget[t] || [], t);
                                    }
                                } catch (e) { /* ignore */ }
                                try {
                                    const cacheObj = (window._perDateOverridesCache && typeof window._perDateOverridesCache === 'object') ? window._perDateOverridesCache : null;
                                    if (cacheObj) {
                                        for (const t of targets) {
                                            for (const d of (byTarget[t] || [])) {
                                                try { delete cacheObj[String(d)]; } catch (e) {}
                                            }
                                        }
                                    }
                                } catch (e) { /* ignore */ }
                                try { renderOverridesTable(); } catch (e) {}

                                if (totalDeleted <= 0) {
                                    alert('No overrides were deleted. This usually means the visible overrides belong to a different scope (member vs service).');
                                }

                                try { if (typeof _invalidateServiceScopeParityCache === 'function') _invalidateServiceScopeParityCache(); } catch (e) {}
                                try { await calendar.refetchEvents(); } catch (e) {}
                                try { updateUnavailableDays(); } catch (e) {}
                                try { renderOverridesTable(); } catch (e) {}
                                alert('All per-date overrides reset.');
                            } catch (err) {
                                console.error('Reset all failed', err);
                                alert('Error resetting: ' + (err && err.message ? err.message : String(err)));
                            } finally {
                                ccSetBtnLoading(resetBtn, false);
                            }
                        };
                    }
                }
            }
        } catch (e) { /* ignore header setup errors */ }

        const events = (typeof calendar.getEvents === 'function') ? calendar.getEvents() : [];
        const perDate = {}; // date -> { rangesSet: Set, items: [], blocked: false, source?: 'service'|'members', target?: string|null }

        function fmtTime(h, m) {
            const hh = parseInt(h,10);
            const mm = parseInt(m,10);
            const ampm = hh >= 12 ? 'PM' : 'AM';
            let hour = hh % 12;
            if (hour === 0) hour = 12;
            return `${hour}:${String(mm).padStart(2,'0')} ${ampm}`;
        }

        // determine the current scope
        const isServiceScope = !!(SELECTED_MEMBER && String(SELECTED_MEMBER).startsWith('svc:'));
        const currentServiceId = isServiceScope ? String(SELECTED_MEMBER).slice(4) : null;
        const currentMemberId = (!isServiceScope && SELECTED_MEMBER) ? String(SELECTED_MEMBER) : null;

        // Team plan: group service overrides table should not show member overrides unless
        // they are identical across all assigned members.
        const _currentSvcObj = (isServiceScope && currentServiceId) ? (svcById(currentServiceId) || null) : null;
        const _assignedForCurrentSvc = _currentSvcObj ? (getAssignedMembersForService(_currentSvcObj) || []) : [];
        const _isTeamGroupServiceScope = !!(IS_TEAM && isServiceScope && _assignedForCurrentSvc.length >= 2);

        // Helper: decide if a per-date event should be visible in the current scope
        // (used for non-group contexts).
        function eventInCurrentScope(ev) {
            try {
                const xp = ev.extendedProps || {};
                // Always include org-level view (no SELECTED_MEMBER)
                if (!SELECTED_MEMBER) return true;

                // Service scope: include events explicitly assigned to this service
                // or member-level events for members assigned to this service.
                if (isServiceScope) {
                    const assignedSvc = xp.assigned_scope_service_id || xp.assigned_scope_service || xp.assigned_service_id || xp.service_id || null;
                    if (assignedSvc && String(assignedSvc) === String(currentServiceId)) return true;

                    const assignedMembership = xp.assigned_membership_id ? String(xp.assigned_membership_id) : (xp.assigned_membership ? String(xp.assigned_membership) : null);
                    const assignedUser = xp.assigned_user_id ? String(xp.assigned_user_id) : null;
                    if (assignedMembership) {
                        const svc = svcById(currentServiceId);
                        if (svc) {
                            const assigned = getAssignedMembersForService(svc) || [];
                            if (assigned.indexOf(String(assignedMembership)) !== -1) return true;
                        }
                    }
                    if (assignedUser) {
                        const svc = svcById(currentServiceId);
                        if (svc) {
                            const assigned = getAssignedMembersForService(svc) || [];
                            for (const mem of assigned) {
                                try { if (getSelectedUserIdForMembership(mem) && String(getSelectedUserIdForMembership(mem)) === String(assignedUser)) return true; } catch(e){}
                            }
                        }
                    }
                    return false;
                }

                // Member scope: include events assigned to this membership/user
                if (currentMemberId) {
                    const assignedMembership = xp.assigned_membership_id ? String(xp.assigned_membership_id) : (xp.assigned_membership ? String(xp.assigned_membership) : null);
                    const assignedUser = xp.assigned_user_id ? String(xp.assigned_user_id) : null;
                    if (assignedMembership && assignedMembership === currentMemberId) return true;
                    if (assignedUser && String(getSelectedUserIdForMembership(currentMemberId)) === String(assignedUser)) return true;
                    // Also include service-level overrides for any solo services owned by this member
                    const svcAssigned = xp.assigned_scope_service_id || xp.assigned_scope_service || xp.assigned_service_id || xp.service_id || null;
                    if (svcAssigned) {
                        const svc = svcById(svcAssigned);
                        if (svc) {
                            const assigned = getAssignedMembersForService(svc) || [];
                            if (assigned.length === 1 && assigned[0] === currentMemberId) return true;
                        }
                    }
                    return false;
                }

                return false;
            } catch (e) { return false; }
        }

        // Group service scope (Team plan): show service-scoped per-date overrides, and only
        // show member-scoped overrides when they are identical for ALL assigned members.
        if (_isTeamGroupServiceScope) {
            const memberDay = {}; // date -> memberId -> { blocked: bool, ranges: [[sH,sM,eH,eM],...] }

            const _ensureMemberEntry = (dateStr, memberId) => {
                if (!memberDay[dateStr]) memberDay[dateStr] = {};
                if (!memberDay[dateStr][memberId]) memberDay[dateStr][memberId] = { blocked: false, ranges: [] };
                return memberDay[dateStr][memberId];
            };

            const _normSig = (entry) => {
                if (!entry) return '';
                if (entry.blocked) return 'blocked:fullday';
                const r = (entry.ranges || []).slice().map(x => `${x[0]}:${x[1]}-${x[2]}:${x[3]}`);
                r.sort();
                return r.length ? `available:${r.join('|')}` : '';
            };

            // First pass: collect service-level overrides and aggregate member-level overrides.
            events.forEach(ev => {
                try {
                    if (ev.display !== 'background') return;
                    const props = ev.extendedProps || {};
                    if (!props.is_per_date) return;
                    const startStr = ev.startStr || (ev.start ? ev.start.toISOString() : null);
                    if (!startStr) return;
                    const date = startStr.split('T')[0];

                    const assignedSvc = props.assigned_scope_service_id || props.assigned_scope_service || props.assigned_service_id || props.service_id || null;
                    const assignedMembership = props.assigned_membership_id ? String(props.assigned_membership_id) : (props.assigned_membership ? String(props.assigned_membership) : null);

                    let sH = 0, sM = 0, eH = 23, eM = 59;
                    if (ev.start && ev.start.getHours) { sH = ev.start.getHours(); sM = ev.start.getMinutes(); }
                    else if (startStr.split('T')[1]) { const parts = startStr.split('T')[1].split(':'); sH = parseInt(parts[0]||'0',10); sM = parseInt(parts[1]||'0',10); }
                    if (ev.end && ev.end.getHours) { eH = ev.end.getHours(); eM = ev.end.getMinutes(); }
                    else if (ev.endStr && ev.endStr.split('T')[1]) { const parts = ev.endStr.split('T')[1].split(':'); eH = parseInt(parts[0]||'23',10); eM = parseInt(parts[1]||'59',10); }
                    const fullDay = (sH === 0 && sM === 0 && eH === 23 && eM === 59);

                    // Service-scoped per-date override
                    if (assignedSvc && String(assignedSvc) === String(currentServiceId)) {
                        if (!perDate[date]) perDate[date] = { rangesSet: new Set(), items: [], blocked: false, source: 'service', target: `svc:${currentServiceId}` };
                        if (props.override_type === 'blocked' && fullDay) {
                            perDate[date].blocked = true;
                        } else {
                            const key = `${sH}:${sM}-${eH}:${eM}`;
                            if (!perDate[date].rangesSet.has(key)) {
                                perDate[date].rangesSet.add(key);
                                perDate[date].items.push({ startH: sH, startM: sM, endH: eH, endM: eM });
                            }
                        }
                        return;
                    }

                    // Member-scoped override: aggregate (but do not show unless unanimous)
                    if (assignedMembership && _assignedForCurrentSvc.indexOf(String(assignedMembership)) !== -1) {
                        const entry = _ensureMemberEntry(date, String(assignedMembership));
                        if (props.override_type === 'blocked' && fullDay) {
                            entry.blocked = true;
                            entry.ranges = [];
                        } else if (!entry.blocked) {
                            entry.ranges.push([sH, sM, eH, eM]);
                        }
                    }
                } catch (e) { /* ignore */ }
            });

            // Second pass: only include member-scoped overrides when all assigned members match.
            Object.keys(memberDay).forEach(dateStr => {
                try {
                    // If there is already a service-level override for the day, prefer it.
                    if (perDate[dateStr]) return;

                    let sig = null;
                    for (const memId of _assignedForCurrentSvc) {
                        const e = (memberDay[dateStr] || {})[String(memId)] || null;
                        const s = _normSig(e);
                        if (!s) { sig = null; break; }
                        if (sig === null) sig = s;
                        else if (sig !== s) { sig = null; break; }
                    }

                    if (!sig) return;

                    // Shared across all members => show it in the group service overrides table
                    if (!perDate[dateStr]) perDate[dateStr] = { rangesSet: new Set(), items: [], blocked: false, source: 'members', target: null };
                    if (sig === 'blocked:fullday') {
                        perDate[dateStr].blocked = true;
                        return;
                    }
                    const entry0 = (memberDay[dateStr] || {})[String(_assignedForCurrentSvc[0])] || null;
                    const ranges = (entry0 && entry0.ranges) ? entry0.ranges.slice() : [];
                    ranges.sort((a,b) => (a[0]*60+a[1]) - (b[0]*60+b[1]));
                    for (const r of ranges) {
                        const key = `${r[0]}:${r[1]}-${r[2]}:${r[3]}`;
                        if (!perDate[dateStr].rangesSet.has(key)) {
                            perDate[dateStr].rangesSet.add(key);
                            perDate[dateStr].items.push({ startH: r[0], startM: r[1], endH: r[2], endM: r[3] });
                        }
                    }
                } catch (e) { /* ignore */ }
            });
        } else {
            // Default behavior (member scopes, solo services, non-team plans)
            events.forEach(ev => {
                try {
                    if (ev.display !== 'background') return;
                    const props = ev.extendedProps || {};
                    if (!props.is_per_date) return;
                    if (!eventInCurrentScope(ev)) return;
                    const startStr = ev.startStr || (ev.start ? ev.start.toISOString() : null);
                    if (!startStr) return;
                    const date = startStr.split('T')[0];

                    // Determine owning scope for this override (membership id or svc:<id>) so Reset deletes the correct record.
                    let owningTarget = null;
                    try {
                        if (!SELECTED_MEMBER) {
                            owningTarget = null;
                        } else if (isServiceScope) {
                            const assignedSvc = props.assigned_scope_service_id || props.assigned_scope_service || null;
                            if (assignedSvc && String(assignedSvc) === String(currentServiceId)) {
                                owningTarget = `svc:${currentServiceId}`;
                            } else if (props.assigned_membership_id != null) {
                                owningTarget = String(props.assigned_membership_id);
                            } else if (props.assigned_user_id != null && Array.isArray(MEMBERS)) {
                                const uId = String(props.assigned_user_id);
                                const m = MEMBERS.find(mm => {
                                    try {
                                        const uid = (mm.user__id || mm.user_id || (mm.user && (mm.user.id || mm.user.pk)) || null);
                                        return uid != null && String(uid) === uId;
                                    } catch (e) { return false; }
                                });
                                if (m && m.id != null) owningTarget = String(m.id);
                            }
                        } else {
                            // Member scope: most overrides are member-scoped, but we may also be showing
                            // service-scoped overrides for solo services owned by this member.
                            const svcAssigned = props.assigned_scope_service_id || props.assigned_scope_service || null;
                            if (svcAssigned != null) owningTarget = `svc:${String(svcAssigned)}`;
                            else owningTarget = currentMemberId;
                        }
                    } catch (e) { owningTarget = null; }

                    let sH = 0, sM = 0, eH = 23, eM = 59;
                    if (ev.start && ev.start.getHours) { sH = ev.start.getHours(); sM = ev.start.getMinutes(); }
                    else if (startStr.split('T')[1]) { const parts = startStr.split('T')[1].split(':'); sH = parseInt(parts[0]||'0',10); sM = parseInt(parts[1]||'0',10); }
                    if (ev.end && ev.end.getHours) { eH = ev.end.getHours(); eM = ev.end.getMinutes(); }
                    else if (ev.endStr && ev.endStr.split('T')[1]) { const parts = ev.endStr.split('T')[1].split(':'); eH = parseInt(parts[0]||'23',10); eM = parseInt(parts[1]||'59',10); }
                    if (!perDate[date]) {
                        perDate[date] = { rangesSet: new Set(), items: [], blocked: false, target: owningTarget };
                    } else {
                        const existingTarget = (perDate[date].target != null) ? String(perDate[date].target) : null;
                        const newTarget = (owningTarget != null) ? String(owningTarget) : null;
                        if (existingTarget && newTarget && existingTarget !== newTarget) {
                            perDate[date].target = null;
                        } else if (!existingTarget && newTarget) {
                            perDate[date].target = newTarget;
                        }
                    }
                    const fullDay = (sH === 0 && sM === 0 && eH === 23 && eM === 59);
                    if (props.override_type === 'blocked' && fullDay) {
                        perDate[date].blocked = true;
                    } else {
                        const key = `${sH}:${sM}-${eH}:${eM}`;
                        if (!perDate[date].rangesSet.has(key)) {
                            perDate[date].rangesSet.add(key);
                            perDate[date].items.push({ startH: sH, startM: sM, endH: eH, endM: eM });
                        }
                    }
                } catch (e) { /* ignore */ }
            });
        }

        // Ensure earlier ranges render to the left: sort by ascending start time
        Object.keys(perDate).forEach(d => {
            const entry = perDate[d];
            if (entry && Array.isArray(entry.items)) {
                entry.items.sort((a,b) => (a.startH*60 + a.startM) - (b.startH*60 + b.startM));
            }
        });

        // cache for group ops
        window._perDateOverridesCache = perDate;

        const dates = Object.keys(perDate).sort();
        if (dates.length === 0) {
            const r = document.createElement('tr');
            r.innerHTML = '<td colspan="4" style="text-align:center; color:#666; padding:12px;">No per-date overrides</td>';
            tbody.appendChild(r);
            return;
        }

        dates.forEach(d => {
            const entry = perDate[d];
            const items = entry.items;
            const type = entry.blocked ? 'Blocked' : 'Available';
            const isTeamGroupDerived = !!(_isTeamGroupServiceScope && entry && entry.source === 'members');
            let times = '';
            if (entry.blocked) {
                times = 'Blocked (Full Day)';
            } else if (items.length === 0) {
                times = 'No ranges';
            } else {
                const rngs = items.map(it => fmtTime(it.startH, it.startM) + ' - ' + fmtTime(it.endH, it.endM));
                times = rngs.join('; ');
            }

            const row = document.createElement('tr');
            row.style.borderBottom = '1px solid #eee';
            row.setAttribute('data-date', d);

            const tdDate = document.createElement('td');
            tdDate.style.padding = '8px';
            // Format YYYY-MM-DD as Mon D, YYYY (e.g., Nov 9, 2025)
            try {
                const parts = d.split('-');
                if (parts.length === 3) {
                    const y = parseInt(parts[0],10), m = parseInt(parts[1],10)-1, day = parseInt(parts[2],10);
                    const dt = new Date(y, m, day);
                    const monthShort = dt.toLocaleString('default', { month: 'short' });
                    tdDate.textContent = `${monthShort} ${day}, ${y}`;
                } else {
                    tdDate.textContent = d;
                }
            } catch (e) { tdDate.textContent = d; }
            const tdType = document.createElement('td');
            tdType.style.padding = '8px';
            tdType.textContent = isTeamGroupDerived ? `${type} (All members)` : type;
            const tdTimes = document.createElement('td'); tdTimes.style.padding = '8px'; tdTimes.textContent = times;
            const tdAction = document.createElement('td'); tdAction.style.padding = '8px';
            const tdSelect = document.createElement('td'); tdSelect.style.padding = '8px';

            if (isTeamGroupDerived) {
                tdAction.textContent = '—';
                const note = document.createElement('span');
                note.textContent = 'Edit/Reset in a member view';
                note.style.color = '#666';
                note.style.fontSize = '12px';
                tdSelect.appendChild(note);
            } else {
                const resetBtn = document.createElement('button');
                resetBtn.type = 'button';
                resetBtn.textContent = 'Reset';
                resetBtn.setAttribute('data-label', 'Reset');
                resetBtn.classList.add('overrides-btn');
                // Use class-based styling; avoid inline white background which can hide white text
                resetBtn.style.padding = '';
                resetBtn.style.border = '';
                resetBtn.style.borderRadius = '';
                resetBtn.style.background = '';
                resetBtn.style.cursor = '';
                try { if (isPastDate(d)) { resetBtn.disabled = true; resetBtn.title = 'Cannot reset past dates'; resetBtn.style.opacity = '0.6'; resetBtn.style.cursor = 'not-allowed'; } } catch(e) {}

                const rowTarget = (entry && entry.target != null) ? String(entry.target) : null;
                if (!rowTarget) {
                    resetBtn.disabled = true;
                    resetBtn.title = 'This override day contains multiple sources; reset from a specific member/service view.';
                    resetBtn.style.opacity = '0.6';
                    resetBtn.style.cursor = 'not-allowed';
                }

                resetBtn.onclick = async () => {
                    if (!rowTarget) return;
                    if (!confirm(`Reset ${d} to weekly defaults? This will remove per-date overrides for this date.`)) return;

                    // Prevent reset if weekly defaults would exclude existing bookings.
                    try {
                        const weekly = _weeklyDefaultRangesForDate(d);
                        const verdict = _validateOverrideAgainstBookings(d, weekly);
                        if (!verdict.ok) { alert(verdict.message || 'This day already has a booking.'); return; }
                    } catch (e) { /* ignore */ }
                    ccSetBtnLoading(resetBtn, true, 'Resetting…');
                    try {
                        const overrideTarget = rowTarget;
                        const res = await fetch(`/bus/${orgSlug}/bookings/batch_delete/`, {
                            method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken }, body: JSON.stringify({ dates: [d], target: overrideTarget, mode: 'reset' })
                        });
                        const data = await res.json().catch(() => null);
                        if (res.ok) {
                            try {
                                const deleted = Number((data && data.deleted) || 0) || 0;
                                if (deleted <= 0) {
                                    alert('No overrides were deleted. This override may belong to a different scope (member vs service).');
                                    try { await calendar.refetchEvents(); } catch(e){}
                                    try { updateUnavailableDays(); } catch(e){}
                                    try { renderOverridesTable(); } catch(e){}
                                    return;
                                }
                            } catch (e) { /* ignore */ }
                            // Remove per-date background events for this DATE in the current SCOPE.
                            try {
                                const isSvcTarget = !!(overrideTarget && String(overrideTarget).startsWith('svc:'));
                                const svcId = isSvcTarget ? String(overrideTarget).slice(4) : null;
                                const membershipId = (!isSvcTarget && overrideTarget) ? String(overrideTarget) : null;
                                const userId = membershipId ? getSelectedUserIdForMembership(membershipId) : null;
                                (calendar.getEvents() || []).forEach(ev => {
                                    try {
                                        if (!ev || ev.display !== 'background') return;
                                        if (!(ev.extendedProps && ev.extendedProps.is_per_date)) return;
                                        const s = ev.startStr || (ev.start ? ev.start.toISOString() : null);
                                        if (!s || !String(s).startsWith(d)) return;

                                        const xp = ev.extendedProps || {};
                                        if (isSvcTarget) {
                                            const assignedSvc = (xp.assigned_scope_service_id || xp.assigned_scope_service || (xp.client_name && String(xp.client_name).replace('scope:svc:','')) || null);
                                            if (!assignedSvc || String(assignedSvc) !== String(svcId)) return;
                                        } else {
                                            const assignedUserId = xp.assigned_user_id || null;
                                            const assignedMembershipId = xp.assigned_membership_id || null;
                                            if (assignedMembershipId && String(assignedMembershipId) === String(membershipId)) {
                                                // ok
                                            } else if (userId && assignedUserId && String(assignedUserId) === String(userId)) {
                                                // ok
                                            } else {
                                                return;
                                            }
                                        }
                                        ev.remove();
                                    } catch (e) {}
                                });
                            } catch(e){}
                            try { await calendar.refetchEvents(); } catch(e){}
                            try { updateUnavailableDays(); } catch(e){}
                            try { renderOverridesTable(); } catch(e){}
                            alert('Reset to weekly defaults completed.');
                        } else {
                            const msg = (data && (data.error || data.message)) || `Server returned ${res.status}`;
                            alert('Error resetting: ' + msg);
                            try { await calendar.refetchEvents(); } catch(e){}
                            try { updateUnavailableDays(); } catch(e){}
                        }
                    } catch (err) {
                        console.error('Reset request failed', err);
                        alert('Error: ' + (err && err.message ? err.message : String(err)));
                        try { await calendar.refetchEvents(); } catch(e){}
                        try { updateUnavailableDays(); } catch(e){}
                    } finally {
                        ccSetBtnLoading(resetBtn, false);
                        try {
                            // Restore disabled state based on rules
                            if (!rowTarget) {
                                resetBtn.disabled = true;
                            } else {
                                resetBtn.disabled = isPastDate(d);
                            }
                        } catch(e) { resetBtn.disabled = false; }
                    }
                };

                const selectBtn = document.createElement('button');
                selectBtn.type = 'button';
                selectBtn.className = 'override-select-btn';
                selectBtn.textContent = 'Select';
                selectBtn.setAttribute('data-label', 'Select');
                selectBtn.classList.add('overrides-btn');
                // Use class-based styling; avoid inline white background which can hide white text
                selectBtn.style.padding = '';
                selectBtn.style.border = '';
                selectBtn.style.borderRadius = '';
                selectBtn.style.background = '';
                selectBtn.style.cursor = '';
                selectBtn.onclick = () => {
                    try { openMakeAvailableModal(d); } catch (e) { console.error('Failed to open edit modal for', d, e); }
                };

                tdSelect.appendChild(selectBtn);
                tdAction.appendChild(resetBtn);
            }
            row.appendChild(tdDate); row.appendChild(tdType); row.appendChild(tdTimes); row.appendChild(tdAction); row.appendChild(tdSelect);
            tbody.appendChild(row);
        });
    }

    // Bulk edit modal using the existing timeModal
    async function openBulkEditModal(dates, initRanges) {
        if (!CAN_USE_OVERRIDES) {
            ccPromptOverridesUpgrade();
            return;
        }

        // Fully-booked days cannot be overridden.
        try {
            if (typeof _ccFullyBookedProtectionEnabled === 'function' && _ccFullyBookedProtectionEnabled()) {
                const blocked = (dates || []).map(String).filter(d => window.__ccFullyBookedOutDates && window.__ccFullyBookedOutDates.has(String(d)));
                if (blocked && blocked.length) {
                    ccToastFullyBooked(blocked);
                    return;
                }
            }
        } catch (e) { /* ignore */ }

        const modal = document.getElementById('timeModal');
        const rangesContainer = document.getElementById('modalRangesContainer');
        const addBtn = document.getElementById('addModalRangeBtn');
        const saveBtnEl = document.getElementById('saveTimeBtn');
        const closeBtnEl = document.getElementById('closeTimeBtn');
        const makeUnavailableBtn = document.getElementById('makeUnavailableBtn');

        try { rangesContainer.innerHTML = ''; } catch(e) {}
        if (Array.isArray(initRanges) && initRanges.length) {
            const seen = new Set();
            initRanges.forEach(r => {
                try {
                    const [s,e] = r.split('-');
                    const key = `${s}-${e}`;
                    if (!seen.has(key)) { seen.add(key); rangesContainer.appendChild(createModalRangeRow(s,e)); }
                } catch (er) {}
            });
        } else {
            rangesContainer.appendChild(createModalRangeRow('09:00','17:00'));
        }
        if (addBtn) addBtn.onclick = () => _ccAddModalRangeNoOverlap(rangesContainer, 60);

        // Adjust visibility for bulk: always show ranges; hide makeUnavailable (use Delete Selected instead)
        try { rangesContainer.style.display = ''; } catch(e){}
        try { if (makeUnavailableBtn) makeUnavailableBtn.style.display = 'none'; } catch(e){}

        modal.style.display = 'flex';

        // Temporarily override handlers
        const prevSave = saveBtnEl.onclick;
        const prevClose = closeBtnEl.onclick;
        let restored = false;
        function restoreHandlers() { if (restored) return; restored = true; saveBtnEl.onclick = prevSave; closeBtnEl.onclick = prevClose; }

        saveBtnEl.onclick = async () => {
            ccSetBtnLoading(saveBtnEl, true, 'Saving…');
            const overrideTarget = (ccOverrideTarget() || null);
            // Gather ranges
            const rows = Array.from(rangesContainer.querySelectorAll('.modal-range-row'));
            const ranges = [];
            for (const r of rows) {
                try {
                    const s = r.querySelector('.modal-range-start').value;
                    const e = r.querySelector('.modal-range-end').value;
                    if (s && e && s < e) ranges.push({ start: s, end: e });
                } catch (ie) {}
            }
            // Deduplicate
            const unique = [];
            const seen = new Set();
            for (const rr of ranges) { const k = `${rr.start}-${rr.end}`; if (!seen.has(k)) { seen.add(k); unique.push(rr); } }

            // Hard-stop if ranges overlap/duplicate (even if UI validation was bypassed)
            try {
                const intervals = unique.map(rr => ({
                    start: rr.start,
                    end: rr.end,
                    startMin: _minutesFromTimeStr(rr.start),
                    endMin: _minutesFromTimeStr(rr.end)
                }));
                const verdict = _ccValidateIntervalsNoOverlap(intervals);
                if (!verdict.ok) {
                    _ccToastRangeError(verdict.message);
                    return;
                }
            } catch (e) { /* ignore */ }

            // Prevent overrides that would conflict with existing bookings.
            try {
                const bad = [];
                for (const d of (dates || [])) {
                    const rangesToCheck = unique.length ? unique : _weeklyDefaultRangesForDate(d);
                    const verdict = _validateOverrideAgainstBookings(d, rangesToCheck);
                    if (!verdict.ok) {
                        bad.push(verdict.message || (`Override blocked for ${d} due to existing booking(s).`));
                        if (bad.length >= 5) break;
                    }
                }
                if (bad.length) {
                    alert(bad.join('\n\n'));
                    return;
                }
            } catch (e) { /* ignore */ }

            try {
                // Remove existing overrides for these dates (capture target at start)
                {
                    const resDel = await fetch(`/bus/${orgSlug}/bookings/batch_delete/`, { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken }, body: JSON.stringify({ dates, target: overrideTarget }) });
                    if (!resDel.ok) {
                        const { data, text } = await _ccReadJsonOrText(resDel);
                        const msg = (data && (data.error || data.message)) || (text || '').trim() || `Server returned ${resDel.status}`;
                        try { _showOverridesSaveBanner(msg, { status: resDel.status, data: data || null }); } catch (e) {}
                        alert('Error applying bulk update: ' + msg);
                        return;
                    }
                }

                if (unique.length === 0) {
                    // No ranges -> simply deleted (reverts to weekly defaults)
                } else {
                    // Create new ranges; batch by each distinct range across all selected dates
                    for (const rr of unique) {
                        const resCreate = await fetch(`/bus/${orgSlug}/bookings/batch_create/`, {
                            method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                            body: JSON.stringify({ dates, start_time: rr.start, end_time: rr.end, target: overrideTarget })
                        });
                        if (!resCreate.ok) {
                            const { data, text } = await _ccReadJsonOrText(resCreate);
                            const msg = (data && (data.error || data.message)) || (text || '').trim() || `Server returned ${resCreate.status}`;
                            try { _showOverridesSaveBanner(msg, { status: resCreate.status, data: data || null }); } catch (e) {}
                            alert('Error applying bulk update: ' + msg);
                            return;
                        }
                    }
                }
                try { await calendar.refetchEvents(); } catch(e){}
                try { updateUnavailableDays(); } catch(e){}
                try { renderOverridesTable(); } catch(e){}
                alert('Bulk update applied.');
            } catch (err) {
                console.error('Bulk update failed', err);
                alert('Error applying bulk update.');
            } finally {
                ccSetBtnLoading(saveBtnEl, false);
            }

            modal.style.display = 'none';
            restoreHandlers();
        };
        closeBtnEl.onclick = () => { modal.style.display = 'none'; restoreHandlers(); };
    }

    function updateClearButton() {
        clearBtn.style.display = selectedDates.size > 0 ? 'inline-block' : 'none';
        // Reset select button text if no dates selected
        if (selectedDates.size === 0) {
            selectBtn.textContent = "Select Day";
        }
    }

    // Open a small modal to make a single (previously-unavailable) date available
    function openMakeAvailableModal(dateStr) {
        if (!CAN_USE_OVERRIDES) {
            ccPromptOverridesUpgrade();
            return;
        }
        const modal = document.getElementById('timeModal');
        const rangesContainer = document.getElementById('modalRangesContainer');
        const addBtn = document.getElementById('addModalRangeBtn');
        const saveBtnEl = document.getElementById('saveTimeBtn');
        const closeBtnEl = document.getElementById('closeTimeBtn');

        // Clear existing rows
        try { rangesContainer.innerHTML = ''; } catch (e) { /* ignore */ }

        // Populate ranges: prefer per-date overrides, otherwise weekly defaults, otherwise sensible fallback
            try {
                const overrides = findPerDateTimedOverrides(dateStr);
                if (overrides && overrides.length) {
                    // dedupe overrides by start-end
                    const seen = new Set();
                    // sort by ascending start time
                    const sorted = overrides.slice().sort((a,b) => {
                        const [ah, am] = (a.start||'00:00').split(':').map(x=>parseInt(x,10)||0);
                        const [bh, bm] = (b.start||'00:00').split(':').map(x=>parseInt(x,10)||0);
                        return (ah*60+am) - (bh*60+bm);
                    });
                    sorted.forEach(o => {
                        try {
                            const k = `${o.start}-${o.end}`;
                            if (!seen.has(k)) { seen.add(k); rangesContainer.appendChild(createModalRangeRow(o.start, o.end)); }
                        } catch (er) { /* ignore */ }
                    });
                } else {
                const d = parseYMD(dateStr);
                const dow = d.getDay();
                const info = defaultAvailability[dow] || {};
                const ranges = info.ranges && info.ranges.length ? info.ranges : (info.start && info.end ? [`${info.start}-${info.end}`] : []);
                if (ranges && ranges.length) {
                    // sort by ascending start time
                    const sortedRanges = ranges.slice().sort((ra, rb) => {
                        try {
                            const [sa] = ra.split('-'); const [sb] = rb.split('-');
                            const [ah, am] = (sa||'00:00').split(':').map(x=>parseInt(x,10)||0);
                            const [bh, bm] = (sb||'00:00').split(':').map(x=>parseInt(x,10)||0);
                            return (ah*60+am) - (bh*60+bm);
                        } catch (er) { return 0; }
                    });
                    sortedRanges.forEach(r => {
                        try {
                            const parts = r.split('-');
                            const s = (parts[0]||'09:00').trim();
                            const e = (parts[1]||'17:00').trim();
                            rangesContainer.appendChild(createModalRangeRow(s, e));
                        } catch (er) { /* ignore row parse errors */ }
                    });
                } else {
                    rangesContainer.appendChild(createModalRangeRow('09:00','17:00'));
                }
            }
        } catch (e) { rangesContainer.appendChild(createModalRangeRow('09:00','17:00')); }

        // Wire Add Range
        if (addBtn) addBtn.onclick = () => _ccAddModalRangeNoOverlap(rangesContainer, 60);

        // Decide visibility based on fully-unavailable status
        try { setModalTimeRowVisibility(dateStr); } catch (e) { /* ignore */ }

        // Ensure Save/Add buttons reflect current ranges visibility (important after optimistic updates)
        try {
            const rangesVisible = (document.getElementById('modalRangesContainer')?.style.display !== 'none');
            const saveBtn = document.getElementById('saveTimeBtn');
            const addBtnEl = document.getElementById('addModalRangeBtn');
            if (saveBtn) saveBtn.style.display = rangesVisible ? 'inline-block' : 'none';
            if (addBtnEl) addBtnEl.style.display = rangesVisible ? 'inline-block' : 'none';
        } catch (e) { /* ignore */ }

        modal.style.display = 'flex';

        // Temporarily override handlers
        const prevSave = saveBtnEl.onclick;
        const prevClose = closeBtnEl.onclick;
        let restored = false;
        function restoreHandlers() {
            if (restored) return; restored = true;
            saveBtnEl.onclick = prevSave;
            closeBtnEl.onclick = prevClose;
        }

        // Show Make Unavailable button for single-date modal
        const makeUnavailableBtn = document.getElementById('makeUnavailableBtn');
        if (makeUnavailableBtn) {
            makeUnavailableBtn.style.display = 'inline-block';
            const prevMakeUnavailable = makeUnavailableBtn.onclick;
            let restoredMake = false;
            function restoreMake() { if (restoredMake) return; restoredMake = true; makeUnavailableBtn.onclick = prevMakeUnavailable; }

            makeUnavailableBtn.onclick = async () => {
                if (!CAN_USE_OVERRIDES) {
                    ccPromptOverridesUpgrade();
                    try { modal.style.display = 'none'; } catch (e) {}
                    restoreHandlers();
                    restoreMake();
                    return;
                }

                // Prevent blocking a day that already has bookings in this scope.
                try {
                    const verdict = _validateOverrideAgainstBookings(dateStr, null);
                    if (!verdict.ok) { alert(verdict.message || 'This day already has a booking.'); return; }
                } catch (e) { /* ignore */ }
                if (!confirm(`Mark ${dateStr} as unavailable? This will block the whole day.`)) return;
                ccSetBtnLoading(makeUnavailableBtn, true, 'Saving…');
                try {
                    const overrideTarget = (ccOverrideTarget() || null);
                    const res = await fetch(`/bus/${orgSlug}/bookings/batch_create/`, { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken }, body: JSON.stringify({ dates: [dateStr], start_time: '00:00', end_time: '23:59', is_blocking: true, target: overrideTarget }) });
                    const { data, text } = await _ccReadJsonOrText(res);
                    if (res.ok) {
                        applyPerDateUnavailable(dateStr);
                        try { calendar.refetchEvents(); } catch(e){}
                        try { updateUnavailableDays(); } catch(e){}
                        try { if (typeof _invalidateServiceScopeParityCache === 'function') _invalidateServiceScopeParityCache(); } catch (e) {}
                        try { if (typeof refreshServiceScopeMonthParity === 'function' && SELECTED_MEMBER && String(SELECTED_MEMBER).startsWith('svc:')) await refreshServiceScopeMonthParity(); } catch (e) {}
                        alert('Date marked unavailable.');
                    } else {
                        const msg = (data && (data.error || data.message)) || (text || '').trim() || `Server returned ${res.status}`;
                        try { _showOverridesSaveBanner(msg, { status: res.status, data: data || null }); } catch (e) {}
                        alert('Error marking unavailable: ' + msg);
                    }
                } catch (err) {
                    console.error('Make unavailable failed', err);
                    alert('Error: ' + (err && err.message ? err.message : String(err)));
                } finally {
                    ccSetBtnLoading(makeUnavailableBtn, false);
                }
                modal.style.display = 'none';
                restoreHandlers();
                restoreMake();
            };
        }

        // Save: collect ranges and create per-date overrides for this single date
        saveBtnEl.onclick = async () => {
            if (!CAN_USE_OVERRIDES) {
                ccPromptOverridesUpgrade();
                try { modal.style.display = 'none'; } catch (e) {}
                restoreHandlers();
                return;
            }
            ccSetBtnLoading(saveBtnEl, true, 'Saving…');
            const rows = Array.from(rangesContainer.querySelectorAll('.modal-range-row'));
            const ranges = [];
            for (const r of rows) {
                try {
                    const s = r.querySelector('.modal-range-start').value;
                    const e = r.querySelector('.modal-range-end').value;
                    if (s && e && s < e) ranges.push({ start: s, end: e });
                } catch (ie) { /* ignore */ }
            }

            // If coach removed all ranges for this single date, treat it as "make unavailable"
            if (ranges.length === 0) {
                // Prevent blocking a day that already has bookings in this scope.
                try {
                    const verdict = _validateOverrideAgainstBookings(dateStr, null);
                    if (!verdict.ok) { alert(verdict.message || 'This day already has a booking.'); return; }
                } catch (e) { /* ignore */ }
                if (!confirm(`No time ranges provided. Mark ${dateStr} as unavailable for the whole day?`)) return;
                try {
                    const overrideTarget = (ccOverrideTarget() || null);
                    const res = await fetch(`/bus/${orgSlug}/bookings/batch_create/`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                        body: JSON.stringify({ dates: [dateStr], start_time: '00:00', end_time: '23:59', is_blocking: true, target: overrideTarget })
                    });
                    const { data, text } = await _ccReadJsonOrText(res);
                    if (res.ok) {
                        // Apply UI changes immediately
                        applyPerDateUnavailable(dateStr);
                        try { await calendar.refetchEvents(); } catch (e) {}
                        try { updateUnavailableDays(); } catch (e) {}
                        alert('Date marked unavailable.');
                    } else {
                        const msg = (data && (data.error || data.message)) || (text || '').trim() || `Server returned ${res.status}`;
                        try { _showOverridesSaveBanner(msg, { status: res.status, data: data || null }); } catch (e) {}
                        alert('Error marking unavailable: ' + msg);
                    }
                } catch (err) {
                    console.error('Make unavailable failed', err);
                    alert('Error: ' + (err && err.message ? err.message : String(err)));
                } finally {
                    ccSetBtnLoading(saveBtnEl, false);
                }

                modal.style.display = 'none';
                restoreHandlers();
                return;
            }

            // Deduplicate ranges by start-end to avoid creating duplicate per-date events
            const uniqueRanges = [];
            const seen = new Set();
            for (const rr of ranges) {
                try {
                    const k = `${rr.start}-${rr.end}`;
                    if (!seen.has(k)) { seen.add(k); uniqueRanges.push(rr); }
                } catch (e) { /* ignore malformed */ }
            }
            // replace ranges with unique set
            const rangesToCreate = uniqueRanges;

            // Hard-stop if ranges overlap/duplicate (even if UI validation was bypassed)
            try {
                const intervals = rangesToCreate.map(rr => ({
                    start: rr.start,
                    end: rr.end,
                    startMin: _minutesFromTimeStr(rr.start),
                    endMin: _minutesFromTimeStr(rr.end)
                }));
                const verdict = _ccValidateIntervalsNoOverlap(intervals);
                if (!verdict.ok) {
                    _ccToastRangeError(verdict.message);
                    return;
                }
            } catch (e) { /* ignore */ }

            // Prevent saving ranges that would exclude existing bookings.
            try {
                const verdict = _validateOverrideAgainstBookings(dateStr, rangesToCreate);
                if (!verdict.ok) { alert(verdict.message || 'This day already has a booking.'); return; }
            } catch (e) { /* ignore */ }

            try {
                // remove existing per-date overrides for the date
                try { const overrideTarget = (ccOverrideTarget() || null); await fetch(`/bus/${orgSlug}/bookings/batch_delete/`, { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken }, body: JSON.stringify({ dates: [dateStr], target: overrideTarget }) }); } catch(e){}

                // Remove existing optimistic background events for this date before adding new ones
                try {
                    calendar.getEvents().forEach(ev => {
                        if (ev.display === 'background' && ev.startStr.startsWith(dateStr + 'T')) {
                            const props = ev.extendedProps || {};
                            if (props.override_type === 'available' || props.is_per_date) {
                                ev.remove();
                            }
                        }
                    });
                } catch (e) { /* ignore removal errors */ }

                let anyFailed = false;
                for (const r of rangesToCreate) {
                    try {
                        // optimistic UI
                        const overrideTarget = (ccOverrideTarget() || null);
                        const res = await fetch(`/bus/${orgSlug}/bookings/batch_create/`, { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken }, body: JSON.stringify({ dates: [dateStr], start_time: r.start, end_time: r.end, target: overrideTarget }) });
                        const { data, text } = await _ccReadJsonOrText(res);
                        if (!res.ok) {
                            anyFailed = true;
                            const msg = (data && (data.error || data.message)) || (text || '').trim() || `Server returned ${res.status}`;
                            try { _showOverridesSaveBanner(msg, { status: res.status, data: data || null }); } catch (e) {}
                            console.warn('Error creating per-date range', r, data || text);
                        } else {
                            // On success add event (avoid transient duplicate before server cleanup)
                            try { calendar.addEvent({ start: dateStr + 'T' + r.start, end: dateStr + 'T' + r.end, display: 'background', color: '#d0f0d0', extendedProps: Object.assign({ is_per_date: true, override_type: 'available', optimistic: true }, getScopePropsForSelection(overrideTarget)) }); } catch(e){}
                        }
                    } catch (err) { console.error('range create failed', err); }
                }

                try { await calendar.refetchEvents(); } catch(e){}
                try { updateUnavailableDays(); } catch(e){}
                if (!anyFailed) alert('Per-date availability saved.');
            } catch (err) {
                console.error('Save per-date failed', err);
                alert('Error saving: ' + (err && err.message ? err.message : String(err)));
            } finally {
                ccSetBtnLoading(saveBtnEl, false);
            }

            modal.style.display = 'none';
            restoreHandlers();
        };

        closeBtnEl.onclick = () => { modal.style.display = 'none'; restoreHandlers(); try { window._highlightAll = false; } catch(e) {} };
    }

    function toggleDateSelection(dateStr) {
        const numberEl = document.querySelector(`.fc-daygrid-day[data-date="${dateStr}"] .fc-daygrid-day-number`);
        if (!numberEl) return;

        // If the selected service has zero remaining availability across the week, treat the
        // calendar as no-interaction for that scope (show a modal on click).
        try {
            const isSvcScope = !!(SELECTED_MEMBER && String(SELECTED_MEMBER).startsWith('svc:'));
            if (isSvcScope && window.__ccServiceScopeNoAvailability) {
                try { if (typeof ccShowSvcNoAvailabilityClickModal === 'function') ccShowSvcNoAvailabilityClickModal(); } catch (e) {}
                return;
            }
        } catch (e) { /* ignore */ }

        // Block selecting fully-booked days (no remaining availability) so users can't override them.
        try {
            const isSvcScope = !!(SELECTED_MEMBER && String(SELECTED_MEMBER).startsWith('svc:'));
            if (isSvcScope && window.__ccFullyBookedOutDates && window.__ccFullyBookedOutDates.has(String(dateStr))) {
                try { ccToastFullyBooked([String(dateStr)]); } catch(e) {}
                return;
            }
        } catch (e) { /* ignore */ }

        const isPast = isPastDate(dateStr);

        // --- Handle past-day logic ---
        if (isPast) {
            // If coach is already selecting future/present days, block it
            if ([...selectedDates].some(d => !isPastDate(d))) {
                alert("You can only select past days or available days — not both at the same time.");
                return;
            }

            // Instead of selecting, open details
            openPastDayModal(dateStr); // your custom function
            return;
        }

        // --- Handle available/future days ---
        // If currently has any past days selected, block this
        if ([...selectedDates].some(d => isPastDate(d))) {
            alert("You can only select past days or available days — not both at the same time.");
            return;
        }

        // Toggle highlight
        if (selectedDates.has(dateStr)) {
            selectedDates.delete(dateStr);
            numberEl.classList.remove('selected');
        } else {
            selectedDates.add(dateStr);
            numberEl.classList.add('selected');
        }

        updateClearButton();
        updateSelectButtonText();
    }

    async function _ccReadJsonOrText(res) {
        try {
            const text = await res.text();
            if (!text) return { data: null, text: '' };
            try {
                return { data: JSON.parse(text), text };
            } catch (e) {
                return { data: null, text };
            }
        } catch (e) {
            return { data: null, text: '' };
        }
    }

    // -----------------------------
    // Fully-booked day protection
    // -----------------------------
    // A "fully booked" day is one that:
    // - is marked unavailable in the month view (no remaining bookable slots)
    // - has at least one booking in the current scope
    // - is NOT unavailable solely because of a full-day per-date override (those should remain editable)
    try { if (!window.__ccFullyBookedOutDates) window.__ccFullyBookedOutDates = new Set(); } catch(e) {}

    function _ccFullyBookedProtectionEnabled() {
        try { return !!(SELECTED_MEMBER && String(SELECTED_MEMBER).startsWith('svc:')); } catch (e) { return false; }
    }

    function ccShowToastSafe(type, message) {
        // For override-denial cases, show ONLY the banner (no toast).
        try {
            const t = String(type || '').toLowerCase();
            const msg = String(message || '').trim();
            if (t === 'error' && _ccLooksLikeOverrideDenialMessage(msg)) {
                ccMaybeShowOverrideBannerFromToast(type, msg);
                return;
            }
        } catch (e) {}

        try {
            if (typeof showToast === 'function') return showToast(type, message);
        } catch (e) { /* ignore */ }

        try { alert(String(message || '')); } catch (e) {}
    }

    function _ccLooksLikeOverrideDenialMessage(msg){
        try {
            const lower = String(msg || '').toLowerCase();
            return (
                lower.includes('not authorized') ||
                lower.includes('no overlapping availability') ||
                lower.includes('group service') ||
                lower.includes('member calendar override') ||
                lower.includes('member calendar first') ||
                lower.includes('overlaps another solo service') ||
                lower.includes('error making available')
            );
        } catch (e) {
            return false;
        }
    }

    function _ccEnsureOverrideBannerHardFallback(){
        try {
            const existing = document.getElementById('cc-overrides-save-banner-hard');
            if (existing) {
                try {
                    try { existing.style.zIndex = '1000001'; } catch (e) {}
                    try { existing.style.pointerEvents = 'auto'; } catch (e) {}
                    if (!existing.__ccBound) {
                        existing.__ccBound = true;
                        const btn = document.getElementById('cc-overrides-save-banner-hard-close');
                        if (btn) {
                            try { btn.setAttribute('onclick', "try{window.ccDismissOverrideBanner&&window.ccDismissOverrideBanner();}catch(e){}"); } catch (e) {}
                            try { btn.style.position = 'relative'; btn.style.zIndex = '1000002'; btn.style.pointerEvents = 'auto'; } catch (e) {}
                            btn.addEventListener('click', (e) => {
                                try { e.preventDefault(); } catch (err) {}
                                try { window.ccDismissOverrideBanner && window.ccDismissOverrideBanner(); } catch (e2) { try { _clearOverridesSaveBanner(); } catch (e3) {} }
                            });
                        }
                        existing.addEventListener('click', (e) => {
                            const b = e && e.target && e.target.closest ? e.target.closest('button[data-cc-selection]') : null;
                            if (!b) return;
                            try { e.preventDefault(); } catch (err) {}
                            const sel = b.getAttribute('data-cc-selection');
                            if (!sel) return;
                            try {
                                if (typeof applySelection === 'function') applySelection(sel);
                                _clearOverridesSaveBanner();
                            } catch (err) { console.warn('Failed to switch selection', err); }
                        }, true);
                    }
                } catch (e) {}
                return existing;
            }
            const el = document.createElement('div');
            el.id = 'cc-overrides-save-banner-hard';
            el.setAttribute('role', 'status');
            el.setAttribute('aria-live', 'polite');
            el.style.display = 'none';
            el.style.position = 'fixed';
            el.style.left = '50%';
            el.style.top = '14px';
            el.style.transform = 'translateX(-50%)';
            el.style.zIndex = '1000001';
            el.style.pointerEvents = 'auto';
            el.style.maxWidth = 'min(920px, calc(100vw - 24px))';
            el.style.width = 'min(920px, calc(100vw - 24px))';
            el.style.padding = '12px 12px';
            el.style.borderRadius = '12px';
            el.style.border = '1px solid #fecaca';
            el.style.background = '#fef2f2';
            el.style.color = '#7f1d1d';
            el.style.boxShadow = '0 10px 22px rgba(0,0,0,0.18)';
            el.style.fontSize = '14px';
            el.style.lineHeight = '1.35';
            el.innerHTML = `
                <div style="display:flex; align-items:flex-start; justify-content:space-between; gap:12px;">
                    <div id="cc-overrides-save-banner-hard-body"></div>
                    <button type="button" id="cc-overrides-save-banner-hard-close" onclick="try{window.ccDismissOverrideBanner&&window.ccDismissOverrideBanner();}catch(e){}" style="border:0; background:transparent; color:#7f1d1d; font-weight:800; cursor:pointer; padding:2px 6px; border-radius:8px;">×</button>
                </div>
            `;
            document.body.appendChild(el);
            try {
                const btn = document.getElementById('cc-overrides-save-banner-hard-close');
                if (btn) {
                    try { btn.style.position = 'relative'; btn.style.zIndex = '1000002'; btn.style.pointerEvents = 'auto'; } catch (e) {}
                    btn.addEventListener('click', (e) => {
                        try { e.preventDefault(); } catch (err) {}
                        try { window.ccDismissOverrideBanner && window.ccDismissOverrideBanner(); } catch (e2) { try { _clearOverridesSaveBanner(); } catch (e3) {} }
                    });
                }
            } catch (e) {}

            // Action buttons inside banner (member switch)
            try {
                el.addEventListener('click', (e) => {
                    const btn = e && e.target && e.target.closest ? e.target.closest('button[data-cc-selection]') : null;
                    if (!btn) return;
                    try { e.preventDefault(); } catch (err) {}
                    const sel = btn.getAttribute('data-cc-selection');
                    if (!sel) return;
                    try {
                        if (typeof applySelection === 'function') applySelection(sel);
                        _clearOverridesSaveBanner();
                    } catch (err) { console.warn('Failed to switch selection', err); }
                }, true);
            } catch (e) {}
            try { el.__ccBound = true; } catch (e) {}
            return el;
        } catch (e) {
            return null;
        }
    }

    function ccShowOverrideBannerGuaranteed(message, opts){
        const msg = String(message || '').trim();

        // If the user just dismissed the banner, don't immediately re-open it.
        try {
            const until = Number(window.__ccOverrideBannerSuppressUntil || 0) || 0;
            if (until && Date.now() < until) return false;
        } catch (e) {}

        // Try the full banner first.
        try {
            if (typeof _showOverridesSaveBanner === 'function') {
                _showOverridesSaveBanner(msg, opts || {});
            }
        } catch (e) {
            try { console.error('_showOverridesSaveBanner failed', e); } catch (e2) {}
        }

        // Always populate the top banner (hard fallback) with instructional HTML.
        try {
            const el = _ccEnsureOverrideBannerHardFallback();
            const body = document.getElementById('cc-overrides-save-banner-hard-body');
            if (el && body) {
                try {
                    const esc = (typeof _ccEscapeHtml === 'function') ? _ccEscapeHtml : (s => String(s || ''));
                    const humanizeFn = (typeof _ccHumanizeOverrideMessage === 'function')
                        ? _ccHumanizeOverrideMessage
                        : ((window && typeof window.__ccHumanizeOverrideMessage === 'function') ? window.__ccHumanizeOverrideMessage : null);
                    const humanMsg = humanizeFn ? humanizeFn(msg) : msg;
                    const hintsFn = (typeof _overrideSaveHints === 'function')
                        ? _overrideSaveHints
                        : ((window && typeof window.__ccOverrideSaveHints === 'function') ? window.__ccOverrideSaveHints : null);
                    const actionsFn = (typeof _overrideSaveActions === 'function')
                        ? _overrideSaveActions
                        : ((window && typeof window.__ccOverrideSaveActions === 'function') ? window.__ccOverrideSaveActions : null);
                    const hints = hintsFn ? (hintsFn(msg) || []) : [];
                    const actions = actionsFn ? (actionsFn((opts && opts.data) ? opts.data : null) || []) : [];
                    const actionsHtml = actions.length
                        ? `<div style="margin-top:10px; display:flex; flex-wrap:wrap; gap:8px;">
                                ${actions.map(a => {
                                    const sel = esc(a.selection);
                                    const lbl = esc(a.label);
                                    return `<button type="button" data-cc-selection="${sel}" style="border:1px solid #fca5a5; background:#fff; color:#7f1d1d; padding:7px 10px; border-radius:10px; cursor:pointer; font-weight:600;">${lbl}</button>`;
                                }).join('')}
                           </div>`
                        : '';
                    const hintsHtml = hints.length
                        ? `<div style="margin-top:10px; color:#991b1b;">
                                ${hints.slice(0, 3).map(h => `<div style="margin-top:6px;"><strong>•</strong> ${esc(h)}</div>`).join('')}
                           </div>`
                        : '';
                    body.innerHTML = `
                        <div style="font-weight:800;">Couldn't save override</div>
                        <div style="margin-top:3px;">${esc(humanMsg || 'The server rejected this override.')}</div>
                        ${hintsHtml}
                        ${actionsHtml}
                    `;
                } catch (e) {
                    body.textContent = msg || 'The server rejected this override.';
                }
                el.style.display = 'block';
                return true;
            }
        } catch (e) {
            try { console.error('hard fallback banner failed', e); } catch (e2) {}
        }
        return false;
    }

    function ccMaybeShowOverrideBannerFromToast(type, message){
        try {
            const t = String(type || '').toLowerCase();
            const msg = String(message || '').trim();
            if (t !== 'error') return;
            if (!_ccLooksLikeOverrideDenialMessage(msg)) return;
            const clean = msg.replace(/^error making available:\s*/i, '').trim();
            // Defer slightly so the toast renders first and any modal-close completes.
            setTimeout(() => {
                ccShowOverrideBannerGuaranteed(clean || msg, { status: 403, data: null });
            }, 0);
        } catch (e) {
            try { console.error('ccMaybeShowOverrideBannerFromToast failed', e); } catch (e2) {}
        }
    }

    // If the UI is already showing a toast for an override denial, always mirror it
    // into the instructional banner so staff see the “what to do next” guidance.
    (function ccHookShowToastForOverrideBanner(){
        try {
            if (window.__ccShowToastOverrideBannerHookInstalled) return;
            window.__ccShowToastOverrideBannerHookInstalled = true;
            if (typeof window.showToast !== 'function') return;

            const _orig = window.showToast;
            window.showToast = function(type, message) {
                try {
                    const t = String(type || '').toLowerCase();
                    const msg = String(message || '').trim();
                    if (t !== 'error') return _orig.apply(this, arguments);

                    // Only mirror override-related errors.
                    const lower = msg.toLowerCase();
                    const looksLikeOverrideDenial =
                        lower.includes('not authorized') ||
                        lower.includes('no overlapping availability') ||
                        lower.includes('group service') ||
                        lower.includes('member calendar override') ||
                        lower.includes('member calendar first') ||
                        lower.includes('overlaps another solo service') ||
                        lower.includes('error making available');
                    if (!looksLikeOverrideDenial) return _orig.apply(this, arguments);

                    // Normalize common prefixes so the banner headline reads cleanly.
                    const clean = msg.replace(/^error making available:\s*/i, '').trim();
                    // For override denials, show ONLY the banner (skip toast).
                    ccShowOverrideBannerGuaranteed(clean || msg, { status: 403, data: null });
                    return;
                } catch (e) {}

                // Non-override errors: keep original toast behavior.
                try { return _orig.apply(this, arguments); } catch (e) {}
            };
        } catch (e) { /* ignore */ }
    })();

    function ccToastFullyBooked(dates) {
        try {
            const uniq = Array.from(new Set((dates || []).map(String))).filter(Boolean).sort();
            if (!uniq.length) return;

            // De-dupe: multiple handlers can detect the same blocked dates (click, drag, select button).
            // Only show one toast for the same set within a short window.
            try {
                const key = uniq.join('|');
                const now = Date.now();
                const last = window.__ccLastFullyBookedToast || null;
                if (last && last.key === key && (now - (last.ts || 0)) < 1500) {
                    return;
                }
                window.__ccLastFullyBookedToast = { key, ts: now };
            } catch (e) { /* ignore */ }

            const count = uniq.length;
            const formatted = uniq.map(d => {
                try { return formatDateLong(d); } catch(e) { return d; }
            });
            const msg = count === 1
                ? `That day is fully booked and can’t be overridden: ${formatted[0]}`
                : `${count} fully booked day(s) can’t be overridden: ${formatted.join(', ')}`;
            ccShowToastSafe('error', msg);
        } catch (e) {
            ccShowToastSafe('error', 'One or more selected days are fully booked and cannot be overridden.');
        }
    }

    function _isFullDayBlockingPerDateOverrideInCurrentScope(dateStr) {
        try {
            if (!calendar || typeof calendar.getEvents !== 'function') return false;
            const isSvc = !!(SELECTED_MEMBER && String(SELECTED_MEMBER).startsWith('svc:'));
            const svcId = isSvc ? String(SELECTED_MEMBER).slice(4) : null;
            const memberId = (!isSvc && SELECTED_MEMBER) ? String(SELECTED_MEMBER) : null;
            const memberUserId = memberId ? getSelectedUserIdForMembership(memberId) : null;

            const evs = calendar.getEvents() || [];
            for (const ev of evs) {
                try {
                    if (!ev || ev.display !== 'background') continue;
                    const xp = ev.extendedProps || {};
                    if (!xp.is_per_date) continue;
                    if (xp.override_type !== 'blocked') continue;
                    if (!ev.start || !ev.end) continue;
                    const evDate = formatYMD(ev.start);
                    if (String(evDate) !== String(dateStr)) continue;
                    const isFullDay = (ev.startStr && ev.endStr && ev.startStr.endsWith('T00:00') && ev.endStr.endsWith('T23:59'))
                        || (ev.start.getHours() === 0 && ev.start.getMinutes() === 0 && ev.end.getHours() === 23 && ev.end.getMinutes() === 59);
                    if (!isFullDay) continue;

                    // Scope match (same rules as the event feed / table filters)
                    if (!SELECTED_MEMBER) return true;
                    if (isSvc) {
                        const assignedSvc = (xp.assigned_scope_service_id || xp.assigned_scope_service || xp.assigned_service_id || xp.service_id || null);
                        if (assignedSvc && String(assignedSvc) === String(svcId)) return true;
                        continue;
                    }
                    if (memberId) {
                        const assignedMem = (xp.assigned_membership_id || xp.assigned_membership || null);
                        if (assignedMem && String(assignedMem) === String(memberId)) return true;
                        const assignedUser = (xp.assigned_user_id || null);
                        if (assignedUser && memberUserId && String(assignedUser) === String(memberUserId)) return true;
                    }
                } catch (e) { /* ignore */ }
            }
        } catch (e) { /* ignore */ }
        return false;
    }

    function _isDayMarkedUnavailable(dateStr) {
        try {
            const cell = document.querySelector(`.fc-daygrid-day[data-date="${dateStr}"]`);
            if (!cell) return false;
            const num = cell.querySelector('.fc-daygrid-day-number');
            return cell.classList.contains('fc-day-unavailable') || (num && num.classList.contains('unavailable-number'));
        } catch (e) {
            return false;
        }
    }

    function _isClosedByWeeklyDefaults(dateStr) {
        try {
            // Use the current UI's weekly defaults (org/member) to tell whether a day is
            // "closed" rather than "booked out". Closed days should remain overrideable.
            const dow = parseYMD(dateStr).getDay();
            return !!(defaultAvailability && defaultAvailability[dow] && defaultAvailability[dow].unavailable);
        } catch (e) {
            return false;
        }
    }

    function _getBookingsForDateInSelectedService(dateStr) {
        const out = [];
        try {
            if (!calendar || typeof calendar.getEvents !== 'function') return out;
            if (!SELECTED_MEMBER || !String(SELECTED_MEMBER).startsWith('svc:')) return out;
            const svcId = String(SELECTED_MEMBER).slice(4);
            const [dayStart, dayEnd] = _getDayBoundsLocal(dateStr);
            const events = calendar.getEvents() || [];

            for (const ev of events) {
                try {
                    if (!_isRealBookingEvent(ev)) continue;
                    const xp = ev.extendedProps || {};
                    const bookingSvc = (xp.service_id || xp.service || ev.service_id || null);
                    if (!bookingSvc) continue;
                    if (String(bookingSvc) !== String(svcId)) continue;
                    const s = ev.start || null;
                    const e = ev.end || null;
                    if (!s) continue;
                    const end = e || s;
                    const overlaps = (s < dayEnd) && (end > dayStart);
                    if (!overlaps) continue;
                    out.push(ev);
                } catch (e) { /* ignore */ }
            }
        } catch (e) { /* ignore */ }
        return out;
    }

    function _recomputeFullyBookedOutDates() {
        try {
            if (!window.__ccFullyBookedOutDates) window.__ccFullyBookedOutDates = new Set();
            window.__ccFullyBookedOutDates.clear();
            if (!calendar || typeof calendar.getEvents !== 'function') return;

            // Fully-booked gating is only meaningful for service scope (matches public service page).
            // In member/org scope, "unavailable" can mean weekly defaults or overrides, not "fully booked".
            if (!_ccFullyBookedProtectionEnabled()) return;

            const dates = (typeof _visibleDayDates === 'function') ? _visibleDayDates() : [];
            for (const d of (dates || [])) {
                try {
                    if (!d || isPastDate(d)) continue;
                    if (!_isDayMarkedUnavailable(d)) continue;
                    // If the day is closed by weekly defaults, it is not "fully booked".
                    if (_isClosedByWeeklyDefaults(d)) continue;
                    if (_isFullDayBlockingPerDateOverrideInCurrentScope(d)) continue;
                    const bookings = _getBookingsForDateInSelectedService(d) || [];
                    if (bookings.length > 0) {
                        window.__ccFullyBookedOutDates.add(String(d));
                    }
                } catch (e) { /* ignore */ }
            }
        } catch (e) { /* ignore */ }
    }

    // --- Add this function here ---
    function updateSelectButtonText() {
        const count = selectedDates.size;

        if (count === 0) {
            selectBtn.textContent = "Select Day";
        } else if (count === 1) {
            selectBtn.textContent = "Select Day";
        } else {
            selectBtn.textContent = `Select ${count} Days`;
        }
    }

    // Format YYYY-MM-DD -> "January 14th, 2026"
    function formatDateLong(ymd) {
        try {
            const d = parseYMD(ymd);
            const month = d.toLocaleString(undefined, { month: 'long' });
            const day = d.getDate();
            const year = d.getFullYear();
            // ordinal suffix with 11/12/13 special-case
            const v = day % 100;
            let suf = 'th';
            if (v < 11 || v > 13) {
                switch (day % 10) {
                    case 1: suf = 'st'; break;
                    case 2: suf = 'nd'; break;
                    case 3: suf = 'rd'; break;
                }
            }
            return `${month} ${day}${suf}, ${year}`;
        } catch (e) { return String(ymd); }
    }

        function resetClientViewStyles() {
            const clientSettings = document.getElementById("clientTimeSettings");
            clientSettings.style.display = "flex"; // show for present/future days
            clientSettings.style.flexDirection = "column"; // stack vertically
            clientSettings.style.gap = "10px";
            clientSettings.style.alignItems = "flex-start";
        }

        function openPastDayModal(dateStr) {
            try {
                if (typeof openTimeCirclesModal === 'function') {
                    openTimeCirclesModal(dateStr, 30, 1, null);
                }
            } catch (e) { console.warn('openPastDayModal failed', e); }
        }


    function reapplySelections() {
        // Reapply selection highlights for any non-past day that is in selectedDates.
        // This includes both available and unavailable future days so selections
        // persist across FullCalendar re-renders.
        document.querySelectorAll('.fc-daygrid-day').forEach(cell => {
            const dateStr = cell.dataset.date;
            if (!dateStr) return;
            if (isPastDate(dateStr)) return; // skip past days
            if (selectedDates.has(dateStr)) {
                const numberEl = cell.querySelector('.fc-daygrid-day-number');
                if (numberEl) numberEl.classList.add('selected');
            } else {
                const numberEl = cell.querySelector('.fc-daygrid-day-number');
                if (numberEl) numberEl.classList.remove('selected');
            }
        });
    }

    function handleTimeSlotSelection(info) {
        const start = info.startStr;
        const end = info.endStr;

        // Example modal: ask whether to mark as available or block off
        const choice = confirm(`Mark time ${start} - ${end} as available? Click Cancel to block off.`);

        const color = choice ? '#4CAF50' : '#E74C3C'; // green for available, red for blocked

        calendar.addEvent({
            start: start,
            end: end,
            display: 'background',
            backgroundColor: color
        });

        // You can also send this to the backend via AJAX later
    }

        function _ccIsElementShown(el) {
            try {
                if (!el) return false;
                if (el.style && el.style.display === 'none') return false;
                return window.getComputedStyle(el).display !== 'none';
            } catch (e) {
                return false;
            }
        }

        function _ccRaiseBookingModalAboveDaySchedule(bookingModal) {
            try {
                if (!bookingModal) return;
                const dayScheduleModal = document.getElementById('timeCirclesModal');
                if (!_ccIsElementShown(dayScheduleModal)) return;

                const zDay = parseInt((window.getComputedStyle(dayScheduleModal).zIndex || '0'), 10) || 0;
                if (!bookingModal.dataset.ccPrevZIndex) {
                    bookingModal.dataset.ccPrevZIndex = bookingModal.style.zIndex || '';
                }

                // Ensure booking details sits above the Day Schedule modal.
                bookingModal.style.zIndex = String(Math.max(zDay + 1, 250000));
                bookingModal.dataset.ccRaisedAboveDaySchedule = '1';
            } catch (e) {
                // Don't block opening the modal if z-index math fails.
            }
        }

        function _ccRestoreBookingModalZIndex(bookingModal) {
            try {
                if (!bookingModal) return;
                if (bookingModal.dataset.ccRaisedAboveDaySchedule !== '1') return;
                bookingModal.style.zIndex = bookingModal.dataset.ccPrevZIndex || '';
                delete bookingModal.dataset.ccPrevZIndex;
                delete bookingModal.dataset.ccRaisedAboveDaySchedule;
            } catch (e) {
                // ignore
            }
        }

        function openBookingModal(event) {
            const modal = document.getElementById('bookingModal');
            document.getElementById('clientName').textContent = event.extendedProps.client_name || 'Unknown';
            document.getElementById('lessonType').textContent = event.extendedProps.lesson_type || 'N/A';
            document.getElementById('lessonTime').textContent = `${event.start.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})} - ${event.end.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})}`;
            document.getElementById('paymentMethod').textContent = event.extendedProps.payment_method || 'N/A';

            _ccRaiseBookingModalAboveDaySchedule(modal);
            modal.style.display = 'flex';

            document.getElementById('closeBookingBtn').onclick = () => {
                modal.style.display = 'none';
                _ccRestoreBookingModalZIndex(modal);
            };

            document.getElementById('viewClientBookingsBtn').onclick = () => {
                modal.style.display = 'none';
                _ccRestoreBookingModalZIndex(modal);
                // Later this could redirect to the client’s profile page:
                // window.location.href = `/coach/clients/${event.extendedProps.client_id}/bookings/`;
                alert('Show all bookings for this client');
            };
        }

    function openTimeCirclesModal(date, increment = 30, hourBlockSize = 1, rangesOrStart = null, endTime = null) {
        const modal = document.getElementById('timeCirclesModal');
        const panel = document.getElementById('timeCirclesModalPanel');
        const container = document.getElementById('timeCirclesContainer');
        const title = document.getElementById('circleModalTitle');

        const chooser = document.getElementById('ccDayScheduleMemberChooser');
        const chooserDesc = document.getElementById('ccDayScheduleChooserDesc');
        const chooseServicesBtn = document.getElementById('ccDayScheduleChooseServicesBtn');
        const chooseAppointmentsBtn = document.getElementById('ccDayScheduleChooseAppointmentsBtn');

        const servicesPanel = document.getElementById('ccDayScheduleMemberServices');
        const servicesList = document.getElementById('ccDayScheduleMemberServicesList');
        const backFromServicesBtn = document.getElementById('ccDayScheduleBackToChooserFromServices');

        const apptsPanel = document.getElementById('ccDayScheduleMemberAppointments');
        const apptsList = document.getElementById('ccDayScheduleMemberAppointmentsList');
        const backFromApptsBtn = document.getElementById('ccDayScheduleBackToChooserFromAppointments');

        const settingsBox = document.getElementById('clientTimeSettings');
        const durationEl = document.getElementById('ccDayScheduleHourBlockValue');
        const incrementEl = document.getElementById('ccDayScheduleIncrementValue');
        const changeInEditServiceBtn = document.getElementById('ccChangeInEditServiceBtn');

        if (!modal || !container || !title) return;

        // If the selected service has no remaining availability, keep the Day Schedule read-only.
        try {
            const isSvcScope = !!(SELECTED_MEMBER && String(SELECTED_MEMBER).startsWith('svc:'));
            if (isSvcScope && window.__ccServiceScopeNoAvailability) {
                try { if (typeof ccShowSvcNoAvailabilityClickModal === 'function') ccShowSvcNoAvailabilityClickModal(); } catch (e) {}
                return;
            }
        } catch (e) { /* ignore */ }

        // Ensure the modal is attached to <body> so it can overlay the site header.
        try {
            if (modal.parentElement && modal.parentElement !== document.body) {
                document.body.appendChild(modal);
            }
        } catch (e) {}

        // Lock background scroll while modal is open (prevents scrolling the page behind the modal).
        try {
            if (!document.body.dataset.ccTimeCirclesScrollLock) {
                document.body.dataset.ccTimeCirclesScrollLock = '1';
                const y = window.scrollY || window.pageYOffset || 0;
                document.body.dataset.ccTimeCirclesScrollY = String(y);
                document.body.style.position = 'fixed';
                document.body.style.top = `-${y}px`;
                document.body.style.left = '0';
                document.body.style.right = '0';
                document.body.style.width = '100%';
            }
        } catch (e) {}

        function _ccUnlockTimeCirclesScroll(){
            try {
                if (!document.body.dataset.ccTimeCirclesScrollLock) return;
                const y = Number(document.body.dataset.ccTimeCirclesScrollY || '0') || 0;
                delete document.body.dataset.ccTimeCirclesScrollLock;
                delete document.body.dataset.ccTimeCirclesScrollY;
                document.body.style.position = '';
                document.body.style.top = '';
                document.body.style.left = '';
                document.body.style.right = '';
                document.body.style.width = '';
                window.scrollTo(0, y);
            } catch (e) {}
        }

        function primeEditServiceLink(){
            try {
                if (!changeInEditServiceBtn) return;
                let svcId = null;
                try {
                    if (typeof SELECTED_MEMBER === 'string' && SELECTED_MEMBER.startsWith('svc:')) svcId = SELECTED_MEMBER.slice(4);
                } catch (e) {}
                if (!svcId) {
                    try {
                        const storedSel = localStorage.getItem('cc_selected_member');
                        if (storedSel && String(storedSel).startsWith('svc:')) svcId = String(storedSel).slice(4);
                    } catch (e) { svcId = null; }
                }
                if (!svcId) {
                    try { svcId = (window && window.__ccDayScheduleServiceId) ? String(window.__ccDayScheduleServiceId) : null; } catch (e) { svcId = null; }
                }
                if (!svcId) {
                    try { svcId = localStorage.getItem('cc_auto_open_service'); } catch (e) { svcId = null; }
                }
                if (svcId) {
                    const url = String(EDIT_SERVICE_URL_TEMPLATE).replace('/0/edit/', '/' + String(svcId) + '/edit/') + '#ccClientSlotSettings';
                    changeInEditServiceBtn.href = url;
                    show(changeInEditServiceBtn, 'block');
                } else {
                    hide(changeInEditServiceBtn);
                }
            } catch (e) {}
        }

        // Base open state
        modal.style.display = 'flex';
        try { if (panel) panel.scrollTop = 0; } catch (e) {}
        title.textContent = `Schedule for ${formatDateLong(date)}`;
        container.innerHTML = '';
        if (servicesList) servicesList.innerHTML = '';
        if (apptsList) apptsList.innerHTML = '';

        // Make the Edit Service button appear immediately when possible.
        primeEditServiceLink();

        function hide(el){ if (el) el.style.display = 'none'; }
        function show(el, display='block'){ if (el) el.style.display = display; }

        function fmtDuration(mins){
            const m = Math.max(0, Number(mins) || 0);
            if (!m) return '—';
            const h = Math.floor(m / 60);
            const r = m % 60;
            if (h && r) return `${h} hr ${r} min`;
            if (h) return `${h} hr`;
            return `${r} min`;
        }

        function setSettingsForService(svc, eff){
            try {
                if (!settingsBox || !durationEl || !incrementEl || !changeInEditServiceBtn) return;
                const dur = Number((eff && eff.duration) || svc.duration || svc.duration_minutes || 0);
                const inc = Number((eff && eff.time_increment_minutes) || svc.time_increment_minutes || 30);
                durationEl.textContent = fmtDuration(dur);
                incrementEl.textContent = `${Math.max(1, inc)} min`;

                let svcId = (svc && svc.id != null) ? String(svc.id) : null;
                if (!svcId) {
                    try {
                        if (typeof SELECTED_MEMBER === 'string' && SELECTED_MEMBER.startsWith('svc:')) svcId = SELECTED_MEMBER.slice(4);
                    } catch (e) {}
                }
                if (!svcId) {
                    try {
                        const storedSel = localStorage.getItem('cc_selected_member');
                        if (storedSel && String(storedSel).startsWith('svc:')) svcId = String(storedSel).slice(4);
                    } catch (e) {}
                }
                if (!svcId) {
                    try { svcId = localStorage.getItem('cc_auto_open_service'); } catch (e) { svcId = null; }
                }

                if (svcId) {
                    const url = String(EDIT_SERVICE_URL_TEMPLATE).replace('/0/edit/', '/' + String(svcId) + '/edit/') + '#ccClientSlotSettings';
                    changeInEditServiceBtn.href = url;
                    show(changeInEditServiceBtn, 'block');
                } else {
                    hide(changeInEditServiceBtn);
                }
                show(settingsBox);
            } catch (e) {
                // keep UI functional even if service fields differ
                try { if (settingsBox) show(settingsBox); } catch (ee) {}
            }
        }

        function clearSettings(){
            try {
                if (durationEl) durationEl.textContent = '—';
                if (incrementEl) incrementEl.textContent = '—';
            } catch (e) {}
        }

        function getBookingsForService(dateStr, svcId){
            const out = [];
            if (!calendar || typeof calendar.getEvents !== 'function') return out;
            const [dayStart, dayEnd] = _getDayBoundsLocal(dateStr);
            let events = [];
            try { events = calendar.getEvents() || []; } catch (e) { events = []; }
            for (const ev of events) {
                try {
                    if (!_isRealBookingEvent(ev)) continue;
                    const xp = ev.extendedProps || {};
                    const bookingSvc = xp.service_id || xp.assigned_scope_service_id || xp.assigned_scope_service || xp.assigned_service_id || xp.service || ev.service_id || null;
                    if (bookingSvc == null) continue;
                    if (String(bookingSvc) !== String(svcId)) continue;
                    const s = ev.start || null;
                    const e = ev.end || ev.start || null;
                    if (!s) continue;
                    if (!(s < dayEnd && e > dayStart)) continue;
                    out.push(ev);
                } catch (e) { /* ignore */ }
            }
            try { out.sort((a,b) => (a.start?.getTime()||0) - (b.start?.getTime()||0)); } catch (e) {}
            return out;
        }

        function showBookingInfoFromEventApi(ev){
            try {
                const bookingModal = document.getElementById('bookingModal');
                if (!bookingModal) return;
                const xp = ev.extendedProps || {};
                const startTime = ev.start || null;
                const endTime = ev.end || ev.start || null;

                const clientName = xp.client_name || xp.client || 'Unknown';
                document.getElementById('clientName').textContent = clientName;
                document.getElementById('lessonType').textContent = ev.title || 'Booking';

                if (startTime && endTime) {
                    document.getElementById('lessonTime').textContent = `${startTime.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})} - ${endTime.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}`;
                } else {
                    document.getElementById('lessonTime').textContent = 'Invalid time';
                }
                document.getElementById('paymentMethod').textContent = xp.payment_method || 'N/A';

                _ccRaiseBookingModalAboveDaySchedule(bookingModal);
                bookingModal.style.display = 'flex';
                document.getElementById('closeBookingBtn').onclick = () => {
                    bookingModal.style.display = 'none';
                    _ccRestoreBookingModalZIndex(bookingModal);
                };
                document.getElementById('viewClientBookingsBtn').onclick = () => {
                    bookingModal.style.display = 'none';
                    _ccRestoreBookingModalZIndex(bookingModal);
                    window.location.href = `/bus/${orgSlug}/bookings/`;
                };
            } catch (e) {
                console.warn('show booking info failed', e);
            }
        }

        function _svcToIsoLocal(dateStr, hh, mm, ss) {
            try {
                const parts = String(dateStr).split('-');
                const y = Number(parts[0]);
                const m = Number(parts[1]);
                const d = Number(parts[2]);
                const pad = n => String(n).padStart(2, '0');
                return `${y}-${pad(m)}-${pad(d)}T${pad(hh)}:${pad(mm)}:${pad(ss || 0)}`;
            } catch (e) {
                return `${dateStr}T${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:00`;
            }
        }

        function _svcIsoToLocalMinutes(isoStr) {
            try {
                const m = String(isoStr || '').match(/T(\d{2}):(\d{2})/);
                if (!m) return null;
                const h = parseInt(m[1], 10);
                const mm = parseInt(m[2], 10);
                if (isNaN(h) || isNaN(mm)) return null;
                return h * 60 + mm;
            } catch (e) {
                return null;
            }
        }

        function _svcLabelFromMin(totalMin) {
            const h24 = Math.floor(totalMin / 60);
            const m = totalMin % 60;
            const ampm = h24 >= 12 ? 'PM' : 'AM';
            let h = h24 % 12; if (h === 0) h = 12;
            return `${h}:${String(m).padStart(2,'0')} ${ampm}`;
        }

        async function fetchServiceScopeSlots(svc) {
            try {
                if (!svc || !svc.slug) return { eff: null, slots: [] };
                let eff = null;
                try {
                    const effUrl = `/bus/${orgSlug}/services/${svc.slug}/effective/?date=${encodeURIComponent(date)}`;
                    const effResp = await fetch(effUrl, { credentials: 'same-origin' });
                    if (effResp.ok) eff = await effResp.json();
                } catch (e) { eff = null; }

                const useFixed = (eff && typeof eff.use_fixed_increment === 'boolean') ? !!eff.use_fixed_increment : !!svc.use_fixed_increment;
                const inc = Math.max(5, Number((eff && eff.time_increment_minutes) || svc.time_increment_minutes || 30));
                let allowEndsForAvail = false;
                try {
                    allowEndsForAvail = (eff && typeof eff.allow_ends_after_availability === 'boolean') ? !!eff.allow_ends_after_availability : !!svc.allow_ends_after_availability;
                } catch (e) { allowEndsForAvail = false; }

                const edgeVal = (function(){
                    try {
                        const raw = localStorage.getItem('edge_buffers_' + svc.slug);
                        if (raw === '1' || raw === 'true') return 1;
                        if (raw === '0' || raw === 'false') return 0;
                    } catch (e) {}
                    return 0;
                })();

                const startIso = _svcToIsoLocal(date, 0, 0, 0);
                const endIso = _svcToIsoLocal(date, 23, 59, 59);
                const incQuery = useFixed ? '' : `&inc=${inc}`;
                const cacheBuster = `&_t=${Date.now()}`;
                const availUrl = `/bus/${orgSlug}/services/${svc.slug}/availability/?start=${encodeURIComponent(startIso)}&end=${encodeURIComponent(endIso)}${incQuery}&edge_buffers=${edgeVal}&allow_ends_after_availability=${allowEndsForAvail?1:0}${cacheBuster}`;
                const resp = await fetch(availUrl, { credentials: 'same-origin' });
                if (!resp.ok) return { eff, slots: [] };
                const slots = await resp.json();
                return { eff, slots: Array.isArray(slots) ? slots : [] };
            } catch (e) {
                console.error('service-scope availability fetch failed', e);
                return { eff: null, slots: [] };
            }
        }

        function renderServiceSlots(dateStr, svc, slots){
            container.innerHTML = '';
            const svcId = svc && svc.id != null ? String(svc.id) : null;
            const bookingsForDate = (svcId != null) ? getBookingsForService(dateStr, svcId) : [];

            if (!slots || !slots.length) {
                const empty = document.createElement('div');
                empty.style.color = '#6b7280';
                empty.textContent = 'No available times on this day.';
                container.appendChild(empty);
                return;
            }

            const startToEnd = new Map();
            for (const s of slots) {
                const sm = _svcIsoToLocalMinutes(s.start);
                const em = _svcIsoToLocalMinutes(s.end);
                if (sm != null && em != null && em > sm) startToEnd.set(sm, em);
            }
            const validStarts = Array.from(startToEnd.keys()).sort((a,b)=>a-b);
            if (!validStarts.length) {
                const empty = document.createElement('div');
                empty.style.color = '#6b7280';
                empty.textContent = 'No available times on this day.';
                container.appendChild(empty);
                return;
            }

            const hours = [];
            const hourMap = new Map();
            for (const sm of validStarts) {
                const hourStart = Math.floor(sm/60) * 60;
                if (!hourMap.has(hourStart)) {
                    hourMap.set(hourStart, []);
                    hours.push(hourStart);
                }
                hourMap.get(hourStart).push(sm);
            }

            for (const hourStart of hours) {
                const row = document.createElement('div');
                row.style.display = 'flex';
                row.style.alignItems = 'center';
                row.style.justifyContent = 'space-between';
                row.style.gap = '8px';
                row.style.borderBottom = '1px solid #ccc';

                const hourLabel = document.createElement('div');
                hourLabel.style.width = '70px';
                hourLabel.style.fontWeight = 'bold';
                const labelDate = parseYMD(dateStr);
                labelDate.setHours(Math.floor(hourStart/60), hourStart%60, 0, 0);
                const labelOpts = { hour: 'numeric', minute: (hourStart%60!==0?'2-digit':undefined), hour12: true };
                hourLabel.textContent = labelDate.toLocaleString(undefined, labelOpts);
                row.appendChild(hourLabel);

                const circlesContainer = document.createElement('div');
                circlesContainer.className = 'circles-for-hour';
                circlesContainer.style.display = 'flex';
                circlesContainer.style.flexWrap = 'wrap';
                circlesContainer.style.gap = '8px';
                circlesContainer.style.marginLeft = 'auto';

                for (const sm of (hourMap.get(hourStart) || [])) {
                    const endMin = startToEnd.get(sm);
                    const timeLabel = _svcLabelFromMin(sm);
                    const circle = document.createElement('div');

                    const slotDate = parseYMD(dateStr);
                    slotDate.setHours(Math.floor(sm/60), sm%60, 0, 0);
                    const slotEndDate = new Date(slotDate.getTime() + Math.max(1, (endMin - sm)) * 60000);
                    const now = new Date();

                    const booking = bookingsForDate.find(b => {
                        try {
                            const bs = b.start || null;
                            const be = b.end || b.start || null;
                            if (!bs || !be) return false;
                            return slotDate.getTime() < be.getTime() && slotEndDate.getTime() > bs.getTime();
                        } catch (e) { return false; }
                    });

                    if (booking) {
                        circle.className = 'time-circle booked';
                        circle.textContent = 'Booked';
                        circle.dataset.time = timeLabel;
                        circle.addEventListener('click', () => { showBookingInfoFromEventApi(booking); });
                    } else if (slotDate < now) {
                        circle.className = 'time-circle blocked';
                        circle.textContent = timeLabel;
                        circle.dataset.time = timeLabel;
                        circle.style.background = '#6c757d';
                        circle.style.cursor = 'not-allowed';
                        circle.addEventListener('click', () => { alert(`This slot (${timeLabel}) is in the past.`); });
                    } else {
                        circle.className = 'time-circle open';
                        circle.textContent = timeLabel;
                        circle.dataset.time = timeLabel;
                        circle.addEventListener('click', () => { alert(`Slot: ${timeLabel} is available`); });
                    }

                    circlesContainer.appendChild(circle);
                }

                row.appendChild(circlesContainer);
                container.appendChild(row);
            }

            if (container.lastElementChild) container.lastElementChild.style.borderBottom = 'none';
        }

        function normalizeRanges(){
            let rangesArr = [];
            try {
                if (Array.isArray(rangesOrStart)) rangesArr = rangesOrStart.slice();
                else if (rangesOrStart && typeof rangesOrStart === 'object') rangesArr = [rangesOrStart];
                else if (typeof rangesOrStart === 'string' && endTime) rangesArr = [{ start: rangesOrStart, end: endTime }];
            } catch (e) { rangesArr = []; }

            if (!rangesArr || !rangesArr.length) {
                try {
                    rangesArr = _weeklyDefaultRangesForDate(date);
                } catch (e) { rangesArr = []; }
            }

            try {
                const seen = new Set();
                const uniq = [];
                for (const r of rangesArr) {
                    const s = (r && r.start) ? String(r.start).trim() : '';
                    const e = (r && r.end) ? String(r.end).trim() : '';
                    const key = `${s}-${e}`;
                    if (!seen.has(key)) {
                        seen.add(key);
                        if (s && e) uniq.push({ start: s, end: e });
                    }
                }
                return uniq;
            } catch (e) {
                return rangesArr;
            }
        }

        function renderGenericRanges(dateStr, rangesArr, incMinutes, blockHours){
            container.innerHTML = '';
            const bookingsForDate = _getBookingsForDateInScope(dateStr);

            const blockMinutes = Math.max(1, Number(blockHours) || 1) * 60;
            const currentIncrement = Math.max(1, Number(incMinutes) || 30);

            for (const range of (rangesArr || [])) {
                let startTotalMinutes = 6 * 60;
                let endTotalMinutes = 22 * 60;
                try {
                    if (range.start) {
                        const parts = String(range.start).split(':');
                        const sh = parseInt(parts[0], 10);
                        const sm = parts.length > 1 ? parseInt(parts[1], 10) : 0;
                        if (!isNaN(sh)) startTotalMinutes = sh * 60 + (isNaN(sm) ? 0 : sm);
                    }
                    if (range.end) {
                        const parts = String(range.end).split(':');
                        const eh = parseInt(parts[0], 10);
                        const em = parts.length > 1 ? parseInt(parts[1], 10) : 0;
                        if (!isNaN(eh)) endTotalMinutes = eh * 60 + (isNaN(em) ? 0 : em);
                    }
                } catch (e) { /* ignore */ }

                for (let blockStart = startTotalMinutes; blockStart < endTotalMinutes; blockStart += blockMinutes) {
                    const row = document.createElement('div');
                    row.style.display = 'flex';
                    row.style.alignItems = 'center';
                    row.style.justifyContent = 'space-between';
                    row.style.gap = '8px';
                    row.style.borderBottom = '1px solid #ccc';

                    const blockLabel = document.createElement('div');
                    blockLabel.style.width = '70px';
                    blockLabel.style.fontWeight = 'bold';
                    const labelDate = parseYMD(dateStr);
                    const startHourForLabel = Math.floor(blockStart / 60);
                    labelDate.setHours(startHourForLabel, 0, 0, 0);
                    blockLabel.textContent = labelDate.toLocaleString(undefined, { hour: 'numeric', hour12: true });
                    row.appendChild(blockLabel);

                    const circlesContainer = document.createElement('div');
                    circlesContainer.className = 'circles-for-hour';
                    circlesContainer.style.display = 'flex';
                    circlesContainer.style.flexWrap = 'wrap';
                    circlesContainer.style.gap = '8px';
                    circlesContainer.style.marginLeft = 'auto';

                    for (let offset = 0; offset < blockMinutes; offset += currentIncrement) {
                        const totalMinutes = blockStart + offset;
                        if (totalMinutes >= endTotalMinutes) break;
                        const hour = Math.floor(totalMinutes / 60);
                        const min = totalMinutes % 60;
                        const ampm = hour >= 12 ? 'PM' : 'AM';
                        let displayHour = hour % 12;
                        if (displayHour === 0) displayHour = 12;
                        const timeLabel = `${displayHour}:${String(min).padStart(2, '0')} ${ampm}`;

                        const circle = document.createElement('div');
                        const slotDate = parseYMD(dateStr);
                        slotDate.setHours(hour, min, 0, 0);
                        const slotEndDate = new Date(slotDate.getTime() + (currentIncrement * 60000));
                        const now = new Date();

                        const booking = bookingsForDate.find(b => {
                            try {
                                const bs = b.start || null;
                                const be = b.end || b.start || null;
                                if (!bs || !be) return false;
                                return slotDate.getTime() < be.getTime() && slotEndDate.getTime() > bs.getTime();
                            } catch (e) { return false; }
                        });

                        if (booking) {
                            circle.className = 'time-circle booked';
                            circle.textContent = 'Booked';
                            circle.dataset.time = timeLabel;
                            circle.addEventListener('click', () => { showBookingInfoFromEventApi(booking); });
                        } else if (slotDate < now) {
                            circle.className = 'time-circle blocked';
                            circle.textContent = timeLabel;
                            circle.dataset.time = timeLabel;
                            circle.style.background = '#6c757d';
                            circle.style.cursor = 'not-allowed';
                            circle.addEventListener('click', () => { alert(`This slot (${timeLabel}) is in the past.`); });
                        } else {
                            circle.className = 'time-circle open';
                            circle.textContent = timeLabel;
                            circle.dataset.time = timeLabel;
                            circle.addEventListener('click', () => { alert(`Slot: ${timeLabel} is available`); });
                        }

                        circlesContainer.appendChild(circle);
                    }

                    row.appendChild(circlesContainer);
                    container.appendChild(row);
                }
            }

            if (container.lastElementChild) container.lastElementChild.style.borderBottom = 'none';
            if (!container.childElementCount) {
                const empty = document.createElement('div');
                empty.style.color = '#6b7280';
                empty.textContent = 'No times to display.';
                container.appendChild(empty);
            }
        }

        function showChooser(){
            show(chooser);
            hide(servicesPanel);
            hide(apptsPanel);
            hide(container);
            hide(settingsBox);
            clearSettings();
            try { if (panel) chooser.scrollIntoView({ behavior: 'auto', block: 'start' }); } catch (e) {}
        }

        function showServicesListForMember(mid){
            hide(chooser);
            show(servicesPanel);
            hide(apptsPanel);
            hide(container);
            hide(settingsBox);
            clearSettings();

            if (!servicesList) return;
            servicesList.innerHTML = '';

            const midStr = String(mid);
            const allAssigned = (Array.isArray(SERVICES) ? SERVICES : []).filter(s => {
                try {
                    const assigned = (typeof getAssignedMembersForService === 'function') ? (getAssignedMembersForService(s) || []) : [];
                    return assigned.some(x => String(x) === midStr);
                } catch (e) { return false; }
            });
            const solo = [];
            const group = [];
            for (const s of allAssigned) {
                const assigned = (typeof getAssignedMembersForService === 'function') ? (getAssignedMembersForService(s) || []) : [];
                if (assigned.length >= 2) group.push(s);
                else solo.push(s);
            }
            solo.sort((a,b) => String(a.name||'').localeCompare(String(b.name||'')));
            group.sort((a,b) => String(a.name||'').localeCompare(String(b.name||'')));

            function addHeader(text){
                const h = document.createElement('div');
                h.style.fontSize = '12px';
                h.style.color = 'var(--gray-700)';
                h.style.textTransform = 'uppercase';
                h.style.letterSpacing = '0.5px';
                h.style.marginTop = servicesList.childElementCount ? '10px' : '0px';
                h.textContent = text;
                servicesList.appendChild(h);
            }
            function addEmpty(text){
                const empty = document.createElement('div');
                empty.style.color = 'var(--gray-600)';
                empty.style.fontSize = '13px';
                empty.style.padding = '6px 0 2px 0';
                empty.textContent = text;
                servicesList.appendChild(empty);
            }
            function addServiceButton(svc){
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.style.display = 'block';
                btn.style.width = '100%';
                btn.style.textAlign = 'left';
                btn.style.padding = '10px 12px';
                btn.style.borderRadius = '10px';
                btn.style.border = '1px solid var(--gray-200)';
                btn.style.background = 'white';
                btn.style.cursor = 'pointer';
                btn.style.fontWeight = '700';
                btn.textContent = svc.name || `Service ${svc.id}`;
                btn.addEventListener('click', async () => {
                    try {
                        hide(servicesPanel);
                        show(container, 'flex');
                        const { eff, slots } = await fetchServiceScopeSlots(svc);
                        setSettingsForService(svc, eff);
                        renderServiceSlots(date, svc, slots);
                        try { if (panel) container.scrollIntoView({ behavior: 'smooth', block: 'start' }); } catch (e) {}
                    } catch (e) {
                        console.error('failed to render selected service day schedule', e);
                    }
                });
                servicesList.appendChild(btn);
            }

            if (!solo.length && !group.length) {
                addEmpty('No services are assigned to this member.');
                return;
            }

            addHeader('Solo services');
            if (!solo.length) addEmpty('No solo services.');
            else solo.forEach(addServiceButton);

            addHeader('Group services');
            if (!group.length) addEmpty('No group services.');
            else group.forEach(addServiceButton);

            try { if (panel) servicesPanel.scrollIntoView({ behavior: 'smooth', block: 'start' }); } catch (e) {}
        }

        function showServicesListForOverallPro(){
            hide(chooser);
            show(servicesPanel);
            hide(apptsPanel);
            hide(container);
            hide(settingsBox);
            clearSettings();

            if (!servicesList) return;
            servicesList.innerHTML = '';

            const all = (Array.isArray(SERVICES) ? SERVICES.slice() : [])
                .filter(s => s && (s.is_active === undefined || !!s.is_active));
            all.sort((a,b) => String(a.name||'').localeCompare(String(b.name||'')));

            if (!all.length) {
                const empty = document.createElement('div');
                empty.style.color = 'var(--gray-600)';
                empty.style.fontSize = '13px';
                empty.textContent = 'No services found.';
                servicesList.appendChild(empty);
                return;
            }

            for (const svc of all) {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.style.display = 'block';
                btn.style.width = '100%';
                btn.style.textAlign = 'left';
                btn.style.padding = '10px 12px';
                btn.style.borderRadius = '10px';
                btn.style.border = '1px solid var(--gray-200)';
                btn.style.background = 'white';
                btn.style.cursor = 'pointer';
                btn.style.fontWeight = '700';
                btn.textContent = svc.name || `Service ${svc.id}`;
                btn.addEventListener('click', async () => {
                    try {
                        hide(servicesPanel);
                        show(container, 'flex');
                        const { eff, slots } = await fetchServiceScopeSlots(svc);
                        setSettingsForService(svc, eff);
                        renderServiceSlots(date, svc, slots);
                        try { if (panel) container.scrollIntoView({ behavior: 'smooth', block: 'start' }); } catch (e) {}
                    } catch (e) {
                        console.error('failed to render selected service day schedule', e);
                    }
                });
                servicesList.appendChild(btn);
            }

            try { if (panel) servicesPanel.scrollIntoView({ behavior: 'smooth', block: 'start' }); } catch (e) {}
        }

        function showAppointmentsForMember(dateStr){
            hide(chooser);
            hide(servicesPanel);
            show(apptsPanel);
            hide(container);
            hide(settingsBox);
            clearSettings();

            if (!apptsList) return;
            apptsList.innerHTML = '';

            const bookings = _getBookingsForDateInScope(dateStr) || [];
            if (!bookings.length){
                const empty = document.createElement('div');
                empty.style.color = 'var(--gray-600)';
                empty.style.fontSize = '13px';
                empty.textContent = 'No appointments on this day.';
                apptsList.appendChild(empty);
                return;
            }

            for (const ev of bookings){
                const row = document.createElement('button');
                row.type = 'button';
                row.style.display = 'block';
                row.style.width = '100%';
                row.style.textAlign = 'left';
                row.style.padding = '12px';
                row.style.borderRadius = '10px';
                row.style.border = '1px solid var(--gray-200)';
                row.style.background = 'white';
                row.style.cursor = 'pointer';

                const xp = ev.extendedProps || {};
                const start = ev.start;
                const end = ev.end || ev.start;
                const time = (start && end)
                    ? `${start.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})} - ${end.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}`
                    : 'Time unknown';
                const client = xp.client_name || xp.client || '';
                const titleText = ev.title || 'Booking';

                const line1 = document.createElement('div');
                line1.style.fontWeight = '800';
                line1.style.color = 'var(--gray-900)';
                line1.textContent = `${time} — ${titleText}`;
                row.appendChild(line1);

                if (client){
                    const line2 = document.createElement('div');
                    line2.style.fontSize = '13px';
                    line2.style.color = 'var(--gray-600)';
                    line2.textContent = `Client: ${client}`;
                    row.appendChild(line2);
                }

                row.addEventListener('click', () => { showBookingInfoFromEventApi(ev); });
                apptsList.appendChild(row);
            }

            try { if (panel) apptsPanel.scrollIntoView({ behavior: 'smooth', block: 'start' }); } catch (e) {}
        }

        // Wire back buttons
        try {
            if (backFromServicesBtn) backFromServicesBtn.onclick = () => showChooser();
            if (backFromApptsBtn) backFromApptsBtn.onclick = () => showChooser();
        } catch (e) {}

        // Close modal
        try {
            const closeBtn = document.getElementById('closeCirclesBtn');
            if (closeBtn) closeBtn.onclick = () => { modal.style.display = 'none'; _ccUnlockTimeCirclesScroll(); };
        } catch (e) {}

        // Click outside the panel closes the modal (and unlocks scroll)
        try {
            modal.onclick = (ev) => {
                try {
                    if (!panel) return;
                    if (ev && ev.target === modal) {
                        modal.style.display = 'none';
                        _ccUnlockTimeCirclesScroll();
                    }
                } catch (e) {}
            };
        } catch (e) {}

        // Add circle styles if not present
        if (!document.getElementById('timeCirclesStyle')) {
            const style = document.createElement('style');
            style.id = 'timeCirclesStyle';
            style.innerHTML = `
                .time-circle {
                    width: 80px; height: 80px; border-radius: 50%;
                    display: flex; justify-content: center; align-items: center;
                    cursor: pointer; font-size: 13px; color: white; transition: transform 0.1s ease;
                }
                .time-circle.open { background: #28a745; }
                .time-circle.booked { background: #dc3545; }
                .time-circle.blocked { background: #6c757d; }
                .time-circle:hover { transform: scale(1.1); }
            `;
            document.head.appendChild(style);
        }

        // Branch by scope
        const selStr = (SELECTED_MEMBER == null) ? '' : String(SELECTED_MEMBER);
        const isMemberScope = !!(SELECTED_MEMBER && !selStr.startsWith('svc:') && selStr !== 'overall');
        const selectedSvc = (typeof _ccSelectedServiceObj === 'function') ? _ccSelectedServiceObj() : null;

        // Pro overall scope: use the same chooser UX as Team member scope.
        const isProOverallScope = !!(IS_PRO && !IS_TEAM && (!selStr || selStr === 'overall') && !selectedSvc);

        if (isMemberScope || isProOverallScope) {
            showChooser();
            try {
                if (chooserDesc) chooserDesc.textContent = isProOverallScope
                    ? 'Choose what to view for this day:'
                    : 'Choose what to view for this member on this day:';
                if (chooseServicesBtn) {
                    chooseServicesBtn.textContent = isProOverallScope
                        ? 'Choose a service view'
                        : 'View services assigned to this member';
                    chooseServicesBtn.onclick = () => isProOverallScope
                        ? showServicesListForOverallPro()
                        : showServicesListForMember(String(SELECTED_MEMBER));
                }
                if (chooseAppointmentsBtn) chooseAppointmentsBtn.onclick = () => showAppointmentsForMember(date);
            } catch (e) {}
            return;
        }

        if (selectedSvc) {
            // Service-scope: parity with public availability
            hide(chooser);
            hide(servicesPanel);
            hide(apptsPanel);
            show(container, 'flex');
            (async () => {
                const { eff, slots } = await fetchServiceScopeSlots(selectedSvc);
                setSettingsForService(selectedSvc, eff);
                renderServiceSlots(date, selectedSvc, slots);
            })();
            return;
        }

        // Org scope (or non-service selection): render basic schedule based on weekly availability
        hide(chooser);
        hide(servicesPanel);
        hide(apptsPanel);
        show(container, 'flex');
        hide(settingsBox);
        clearSettings();
        const rangesArr = normalizeRanges();
        renderGenericRanges(date, rangesArr, increment, hourBlockSize);
    }

    calendarEl.addEventListener('mousedown', e => {
        try {
            if (typeof _ccSuppressMouseDownUntil === 'number' && Date.now() < _ccSuppressMouseDownUntil) return;
        } catch (_) {}
        if (e.button !== 0) return;
        // Allow starting a drag from any rendered day cell (available OR unavailable),
        // but we will ignore past days below.
        const cell = e.target.closest('.fc-daygrid-day');
        if (!cell) return;

        const date = cell.dataset.date;
        const isPast = isPastDate(date);

        // Fully-booked days cannot be overridden (don’t start selection/dragging).
        try {
            if (!isPast && (typeof _ccFullyBookedProtectionEnabled === 'function' && _ccFullyBookedProtectionEnabled()) && window.__ccFullyBookedOutDates && window.__ccFullyBookedOutDates.has(String(date))) {
                ccToastFullyBooked([String(date)]);
                return;
            }
        } catch (e) { /* ignore */ }

        // Check for mixed selection immediately
        if (isPast && [...selectedDates].some(d => !isPastDate(d)) ||
            !isPast && [...selectedDates].some(d => isPastDate(d))) 
        {
            alert("You can only select past days or available days — not both at the same time.");
            // 🔹 reset drag state immediately
            isDragging = false;
            dragStartDate = null;
            dragMode = null;
            dragStartIsUnavailable = false;
            document.querySelectorAll('.fc-daygrid-day-number.temp-highlight').forEach(el => el.classList.remove('temp-highlight'));
            return;
        }

        // Handle past day click
        if (isPast) {
            openPastDayModal(date); // open modal
            return; // do not start dragging
        }

        // Start drag for future/available days
        isDragging = true;
        dragStartDate = date;
        dragMode = selectedDates.has(date) ? "deselect" : "select";

        // Record whether the drag started on an unavailable cell so we only
        // highlight cells of the same availability type during the drag.
        try {
            const numEl = cell.querySelector('.fc-daygrid-day-number');
            dragStartIsUnavailable = cell.classList.contains('fc-day-unavailable') || (numEl && numEl.classList.contains('unavailable-number'));
        } catch (e) { dragStartIsUnavailable = false; }

        // Immediate toggle for the first cell
        toggleDateSelection(date, dragMode === "select");
    });

    calendarEl.addEventListener('mousemove', e => {
        if (!isDragging || !dragStartDate) return;

        // During dragging, include any day cells (we'll only highlight those
        // matching the start cell's availability type).
        const cell = e.target.closest('.fc-daygrid-day');
        if (!cell) return;
        const currentDate = cell.dataset.date;

        // Skip if mixed past/future detected
        const isPast = isPastDate(currentDate);
        if (isPast && [...selectedDates].some(d => !isPastDate(d)) ||
            !isPast && [...selectedDates].some(d => isPastDate(d))) 
        {
            isDragging = false;
            dragStartDate = null;
            dragMode = null;
            dragStartIsUnavailable = false;
            document.querySelectorAll('.fc-daygrid-day-number.temp-highlight').forEach(el => el.classList.remove('temp-highlight'));
            return;
        }

        const start = parseYMD(dragStartDate);
        const end = parseYMD(currentDate);
        const minDate = start < end ? start : end;
        const maxDate = start > end ? start : end;

        const selector = dragStartIsUnavailable ? '.fc-daygrid-day.fc-day-unavailable' : '.fc-daygrid-day.fc-day-available';
        const blockedDuringDrag = [];
        document.querySelectorAll(selector).forEach(c => {
            const dateStr = c.dataset.date;
            const numberEl = c.querySelector('.fc-daygrid-day-number');
            if (!numberEl || !dateStr) return;

            // Skip fully-booked days during drag selection and remember them for a toast.
            try {
                if ((typeof _ccFullyBookedProtectionEnabled === 'function' && _ccFullyBookedProtectionEnabled()) && window.__ccFullyBookedOutDates && window.__ccFullyBookedOutDates.has(String(dateStr))) {
                    numberEl.classList.remove('temp-highlight');
                    numberEl.classList.remove('selected');
                    blockedDuringDrag.push(String(dateStr));
                    return;
                }
            } catch (e) { /* ignore */ }

            const date = parseYMD(dateStr);
            if (date >= minDate && date <= maxDate) {
                numberEl.classList.add('temp-highlight');
                if (dragMode === 'select') numberEl.classList.add('selected');
                else numberEl.classList.remove('selected');
            } else {
                numberEl.classList.remove('temp-highlight');
                if (dragMode === 'select' && !selectedDates.has(dateStr)) numberEl.classList.remove('selected');
                if (dragMode === 'deselect' && selectedDates.has(dateStr)) numberEl.classList.add('selected');
            }
        });

        // Stash blocked dates for mouseup toast (avoid spamming per-mousemove)
        try {
            if (!window.__ccDragBlockedFullyBooked) window.__ccDragBlockedFullyBooked = new Set();
            for (const d of blockedDuringDrag) window.__ccDragBlockedFullyBooked.add(d);
        } catch (e) { /* ignore */ }
    });

    document.addEventListener('mouseup', () => {
        if (!isDragging) return;

        // Commit the ranged temp highlights.
        document.querySelectorAll('.fc-daygrid-day-number.temp-highlight').forEach(el => {
            el.classList.remove('temp-highlight');
            const date = el.closest('.fc-daygrid-day').dataset.date;
            if (dragMode === 'select') selectedDates.add(date);
            else if (dragMode === 'deselect') selectedDates.delete(date);
        });

        isDragging = false;
        dragStartDate = null;
        dragMode = null;
        dragStartIsUnavailable = false;

        updateClearButton();
        updateSelectButtonText();

        // If any fully-booked days were skipped during this drag, silently drop them.
        // Toasting here is too noisy; the user will be told when they explicitly click a
        // fully-booked day or try to open the modal/save with blocked days.
        try {
            if (window.__ccDragBlockedFullyBooked) window.__ccDragBlockedFullyBooked.clear();
        } catch (e) { /* ignore */ }
    });

    function saveNewlySelectedDates() {
        const selectedStartTime = document.getElementById('startTime')?.value || "09:00";
        const selectedEndTime = document.getElementById('endTime')?.value || "17:00";
        const datesArray = Array.from(selectedDates);
        const overrideTarget = (ccOverrideTarget() || null);

        // Fully-booked days cannot be overridden.
        try {
            if (typeof _ccFullyBookedProtectionEnabled === 'function' && _ccFullyBookedProtectionEnabled()) {
                const blocked = (datesArray || []).filter(d => window.__ccFullyBookedOutDates && window.__ccFullyBookedOutDates.has(String(d)));
                if (blocked && blocked.length) {
                    ccToastFullyBooked(blocked);
                    return;
                }
            }
        } catch (e) { /* ignore */ }

        // Prevent applying overrides that would exclude existing bookings.
        try {
            const rangesToCheck = [{ start: selectedStartTime, end: selectedEndTime }];
            const bad = [];
            for (const d of datesArray) {
                const verdict = _validateOverrideAgainstBookings(d, rangesToCheck);
                if (!verdict.ok) {
                    bad.push(verdict.message || (`Override blocked for ${d} due to existing booking(s).`));
                    if (bad.length >= 5) break;
                }
            }
            if (bad.length) {
                alert(bad.join('\n\n'));
                return;
            }
        } catch (e) { /* ignore */ }

        // Pre-clean: remove existing overrides for these dates to avoid duplicates
        fetch(`/bus/${orgSlug}/bookings/batch_delete/`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
            body: JSON.stringify({ dates: datesArray, target: overrideTarget })
        }).then(r => {
            return r.json().catch(() => null);
        }).then(data => {
        }).catch(err => console.warn('batch_delete pre-clean failed', err)).finally(() => {
            // Optimistically add per-date background events so they override defaults immediately
            try {
                datesArray.forEach(d => {
                    try {
                        calendar.addEvent({ start: d + 'T' + selectedStartTime, end: d + 'T' + selectedEndTime, display: 'background', color: '#d0f0d0', extendedProps: Object.assign({ is_per_date: true, override_type: 'available', optimistic: true }, getScopePropsForSelection(overrideTarget)) });
                    } catch (e) { /* ignore */ }
                });
            } catch (e) { console.warn('optimistic add failed', e); }

            const _payload = {
                dates: datesArray,  // e.g. ['2025-11-10', '2025-11-11']
                start_time: selectedStartTime,
                end_time: selectedEndTime,
                target: overrideTarget
            };
            fetch(`/bus/${orgSlug}/bookings/batch_create/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken
            },
            body: JSON.stringify(_payload)
        })
        .then(async (res) => {
            const { data, text } = await _ccReadJsonOrText(res);
            if (!res.ok) {
                const msg = (data && (data.error || data.message)) || (String(text || '').trim()) || `Server returned ${res.status}`;
                // Roll back optimistic background events for these dates.
                try {
                    calendar.getEvents().forEach(ev => {
                        try {
                            const xp = ev.extendedProps || {};
                            if (ev.display !== 'background' || !xp.is_per_date || !xp.optimistic) return;
                            const start = String(ev.startStr || '');
                            const datePart = start.split('T')[0];
                            if (datesArray.includes(datePart)) ev.remove();
                        } catch (e) { /* ignore */ }
                    });
                } catch (e) {}
                try { _showOverridesSaveBanner(msg, { status: res.status, data: data || null }); } catch (e) {}
                return;
            }
            // Refresh events to reconcile with server truth (server may attach ids/changes)
            try { calendar.refetchEvents(); } catch(e) { console.warn('refetchEvents failed', e); }
        })
        .catch(err => { console.error(err); });
        });
    }

    function toUTCDate(dateStr) {
        const d = parseYMD(dateStr);
        return new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
    }


    selectBtn.addEventListener('click', () => {
        const dates = Array.from(selectedDates).sort(); // ['2025-11-01', '2025-11-02', ...]
        
        // ✅ Check if no days are selected
        if (dates.length === 0) {
            alert("Drag to highlight multiple days on the calendar. Select only one to view the schedule for that day.");
            return; // stop further execution
        }

        // Trial/Basic: per-date overrides are not available. Keep this modal view-only.
        if (typeof ccEnforceOverridesLock === 'function') {
            try { ccEnforceOverridesLock(); } catch(e) {}
        }

        // Fully-booked days cannot be overridden. Block the modal from opening.
        try {
            // Only enforce this in service scope; otherwise "unavailable" does not mean "fully booked".
            if (!(typeof _ccFullyBookedProtectionEnabled === 'function' && _ccFullyBookedProtectionEnabled())) {
                // noop
            } else {
            const blocked = [];
            for (const d of (dates || [])) {
                const ds = String(d);
                let isBlocked = false;
                try {
                    if (window.__ccFullyBookedOutDates && window.__ccFullyBookedOutDates.has(ds)) isBlocked = true;
                } catch (e) {}
                if (!isBlocked) {
                    try {
                        // Booking-window exclusions (min notice / max booking days)
                        let inWindow = true;
                        try {
                            const eff = (typeof _ccSvcEffectiveForSelectedScope === 'function') ? _ccSvcEffectiveForSelectedScope() : null;
                            const minNoticeHours = Math.max(0, Number((eff && eff.min_notice_hours) || 0));
                            const maxBookingDays = Math.max(0, Number((eff && eff.max_booking_days) || 0));
                            const orgNow = (typeof _ccNowInOrgTimezone === 'function') ? _ccNowInOrgTimezone() : new Date();
                            const orgTodayMidnight = new Date(orgNow.getFullYear(), orgNow.getMonth(), orgNow.getDate(), 0, 0, 0, 0);
                            if (minNoticeHours > 0) {
                                const earliest = new Date(orgNow.getTime() + (minNoticeHours * 3600000));
                                const earliestYMD = formatYMD(earliest);
                                if (ds < String(earliestYMD)) inWindow = false;
                            }
                            if (maxBookingDays > 0) {
                                const latest = new Date(orgTodayMidnight.getTime() + (maxBookingDays * 86400000));
                                const latestYMD = formatYMD(latest);
                                if (ds > String(latestYMD)) inWindow = false;
                            }
                        } catch (e) { inWindow = true; }

                        // Fallback check (in case the cache is stale)
                        if (inWindow && !_isFullDayBlockingPerDateOverrideInCurrentScope(ds) && _isDayMarkedUnavailable(ds) && !_isClosedByWeeklyDefaults(ds)) {
                            const bookings = _getBookingsForDateInSelectedService(ds) || [];
                            if (bookings.length > 0) isBlocked = true;
                        }
                    } catch (e) {}
                }
                if (isBlocked) blocked.push(ds);
            }

            if (blocked.length) {
                // Auto-deselect blocked days so the user can proceed with the rest.
                try {
                    for (const b of blocked) selectedDates.delete(String(b));
                    try { reapplySelections(); } catch(e) {}
                    try { updateClearButton(); } catch(e) {}
                    try { updateSelectButtonText(); } catch(e) {}
                } catch (e) {}
                ccToastFullyBooked(blocked);
                return;
            }
            }
        } catch (e) { /* ignore */ }
        

        const modal = document.getElementById('timeModal');
        const viewDayBtn = document.getElementById('viewDayBtn');
        const summary = document.getElementById('selectedDaysSummary');

        // Helper to format "YYYY-MM-DD" into "Month DDth"
        function formatDateStr(dateStr) {
            const [year, month, day] = dateStr.split('-');
            const date = parseYMD(`${year}-${month}-${day}`);
            const monthName = date.toLocaleString(undefined, { month: 'long' });
            const dayNum = parseInt(day);
            let suffix = "th";
            if (dayNum === 1 || dayNum === 21 || dayNum === 31) suffix = "st";
            else if (dayNum === 2 || dayNum === 22) suffix = "nd";
            else if (dayNum === 3 || dayNum === 23) suffix = "rd";
            return `${monthName} ${dayNum}${suffix}`;
        }

        // Helper to check if two dates are consecutive
        function areConsecutive(prevStr, currStr) {
            const prevDate = parseYMD(prevStr);
            const currDate = parseYMD(currStr);
            const diffDays = (currDate - prevDate) / (1000 * 60 * 60 * 24);
            return diffDays === 1;
        }

        const ranges = [];
        let rangeStart = dates[0];
        let prev = dates[0];

        for (let i = 1; i < dates.length; i++) {
            const curr = dates[i];

            const prevDate = parseYMD(prev);
            const currDate = parseYMD(curr);

            const sameMonth = prevDate.getMonth() === currDate.getMonth();
            const consecutive = (currDate - prevDate) / (1000 * 60 * 60 * 24) === 1;

            if (consecutive && sameMonth) {
                prev = curr; // continue range
            } else {
                // Push the previous range
                if (rangeStart === prev) {
                    ranges.push(formatDateStr(rangeStart));
                } else {
                    ranges.push(`${formatDateStr(rangeStart)}-${formatDateStr(prev).split(' ')[1]}`);
                }
                rangeStart = curr;
                prev = curr;
            }
        }

        // Push the final range
        if (rangeStart === prev) {
            ranges.push(formatDateStr(rangeStart));
        } else {
            ranges.push(`${formatDateStr(rangeStart)}-${formatDateStr(prev).split(' ')[1]}`);
        }

        // Display summary
        if (dates.length === 1) {
            summary.textContent = `Selected day: ${formatDateStr(dates[0])}`;
            // Only show the View Day Schedule button if the selected day is not marked unavailable and not past
            try {
                const cell = document.querySelector(`.fc-daygrid-day[data-date="${dates[0]}"]`);
                const num = cell ? cell.querySelector('.fc-daygrid-day-number') : null;
                const isUnavailable = cell && (cell.classList.contains('fc-day-unavailable') || (num && num.classList.contains('unavailable-number')));
                const saveBtnEl = document.getElementById('saveTimeBtn');
                if (!isUnavailable && !isPastDate(dates[0])) {
                    viewDayBtn.style.display = 'inline-block';
                    if (saveBtnEl) saveBtnEl.style.display = 'inline-block';
                } else {
                    viewDayBtn.style.display = 'none';
                    if (saveBtnEl) saveBtnEl.style.display = 'none';
                }
            } catch (e) { try { viewDayBtn.style.display = 'none'; const saveBtnEl = document.getElementById('saveTimeBtn'); if (saveBtnEl) saveBtnEl.style.display = 'none'; } catch(ex) {} }
            selectBtn.textContent = "Select Day";

            // Populate ranges UI (below) — do not use single modalStart/modalEnd inputs.

            // Ensure the time inputs are hidden when the date is fully unavailable
            try { setModalTimeRowVisibility(dates[0]); } catch (e) { /* ignore */ }

                // If per-date timed overrides exist, populate the modalRangesContainer and prefer those times
                try {
                    const rangesContainer = document.getElementById('modalRangesContainer');
                    rangesContainer.innerHTML = '';
                    const overrides = findPerDateTimedOverrides(dates[0]);
                    if (overrides && overrides.length > 0) {
                        // populate rows from overrides (dedupe identical start-end pairs)
                        const seen = new Set();
                        overrides.forEach(o => {
                            try {
                                const key = `${o.start}-${o.end}`;
                                if (!seen.has(key)) {
                                    seen.add(key);
                                    rangesContainer.appendChild(createModalRangeRow(o.start, o.end));
                                }
                            } catch (e) { /* ignore row errors */ }
                        });
                    } else {
                        // populate rows from weekly defaults if multiple ranges exist, otherwise single default
                        const d = parseYMD(dates[0]);
                        const dow = d.getDay();
                        const info = defaultAvailability[dow] || {};
                        const ranges = info.ranges && info.ranges.length ? info.ranges : (info.start && info.end ? [`${info.start}-${info.end}`] : []);
                        if (ranges && ranges.length) {
                            ranges.forEach(r => {
                                try {
                                    const parts = r.split('-');
                                    const s = parts[0] ? parts[0].trim() : '09:00';
                                    const e = parts[1] ? parts[1].trim() : '17:00';
                                    rangesContainer.appendChild(createModalRangeRow(s, e));
                                } catch (e) {}
                            });
                        } else {
                            // fallback single row: use weekly defaults or sensible times
                            try {
                                const parts = (info.start && info.end) ? [info.start, info.end] : ['09:00','17:00'];
                                const s = (parts[0]||'09:00').trim();
                                const e = (parts[1]||'17:00').trim();
                                rangesContainer.appendChild(createModalRangeRow(s, e));
                            } catch (e) {
                                rangesContainer.appendChild(createModalRangeRow('09:00','17:00'));
                            }
                        }
                    }

                    // wire Add Range button to append a blank row
                    const addBtn = document.getElementById('addModalRangeBtn');
                    if (addBtn) {
                        addBtn.onclick = () => rangesContainer.appendChild(createModalRangeRow('09:00','17:00'));
                    }
                } catch (e) { console.warn('populate modal ranges failed', e); }

            // Show Make Available button if this single selected day is currently unavailable
            try {
                const makeAvailableBtn = document.getElementById('makeAvailableBtn');
                if (makeAvailableBtn) {
                    const cell = document.querySelector(`.fc-daygrid-day[data-date="${dates[0]}"]`);
                    const num = cell ? cell.querySelector('.fc-daygrid-day-number') : null;
                    const isUnavailable = cell && (cell.classList.contains('fc-day-unavailable') || (num && num.classList.contains('unavailable-number')));
                    // Only show Make Available for future unavailable days
                    if (isUnavailable && !isPastDate(dates[0])) {
                        makeAvailableBtn.style.display = 'inline-block';
                        makeAvailableBtn.onclick = async () => {
                            if (!CAN_USE_OVERRIDES) {
                                ccPromptOverridesUpgrade();
                                return;
                            }
                            if (!confirm(`Make ${dates[0]} available?`)) return;
                                    try {
                                        const overrideTarget = (ccOverrideTarget() || null);
                                        const defaultRange = ccDefaultRangeForTargetDate(overrideTarget, dates[0]);
                                        if (!defaultRange) {
                                            const msg = `Couldn't save override: no valid default time range exists for ${dates[0]} within staff/overall availability. Open staff availability first, then retry.`;
                                            try { modal.style.display = 'none'; } catch (e) {}
                                            try { setTimeout(() => { ccShowOverrideBannerGuaranteed(msg, { status: 400, data: null }); }, 0); } catch (e) {}
                                            try { await calendar.refetchEvents(); } catch(e){}
                                            try { updateUnavailableDays(); } catch(e){}
                                            return;
                                        }
                                        const res = await fetch(`/bus/${orgSlug}/bookings/batch_delete/`, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                                            body: JSON.stringify({ dates: [dates[0]], target: overrideTarget })
                                });
                                const { data, text } = await _ccReadJsonOrText(res);
                                if (res.ok) {
                                    // Persist a default available range immediately so "Make Available" actually
                                    // creates a per-date override (otherwise users expect availability to save
                                    // but nothing is created until they click Save inside the editor).
                                    let _createdStart = (defaultRange.start || '09:00');
                                    let _createdEnd = (defaultRange.end || '17:00');
                                    try {
                                        const createRes = await fetch(`/bus/${orgSlug}/bookings/batch_create/`, {
                                            method: 'POST',
                                            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                                            body: JSON.stringify({ dates: [dates[0]], start_time: defaultRange.start, end_time: defaultRange.end, target: overrideTarget })
                                        });
                                        let { data: createData, text: createText } = await _ccReadJsonOrText(createRes);
                                        let finalCreateOk = createRes.ok;
                                        let finalStatus = createRes.status;

                                        // If rejected because the requested range is too wide, and the server provided
                                        // debug allowed windows, auto-retry with the first allowed window.
                                        if (!finalCreateOk) {
                                            try {
                                                if (createData && createData.debug && Array.isArray(createData.debug.allowed_windows) && createData.debug.allowed_windows.length) {
                                                    console.warn('batch_create debug', createData.debug);
                                                    const first = createData.debug.allowed_windows[0];
                                                    const firstRange = (first && (first.range || '')) ? String(first.range) : '';
                                                    if (firstRange && firstRange.includes('-')) {
                                                        const parts = firstRange.split('-');
                                                        const retryStart = (parts[0] || '').trim();
                                                        const retryEnd = (parts[1] || '').trim();
                                                        if (retryStart && retryEnd) {
                                                            const retryRes = await fetch(`/bus/${orgSlug}/bookings/batch_create/`, {
                                                                method: 'POST',
                                                                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                                                                body: JSON.stringify({ dates: [dates[0]], start_time: retryStart, end_time: retryEnd, target: overrideTarget })
                                                            });
                                                            const retryParsed = await _ccReadJsonOrText(retryRes);
                                                            if (retryRes.ok) {
                                                                finalCreateOk = true;
                                                                finalStatus = retryRes.status;
                                                                createData = retryParsed.data;
                                                                createText = retryParsed.text;
                                                                _createdStart = retryStart;
                                                                _createdEnd = retryEnd;
                                                            } else {
                                                                // keep original failure payload for messaging
                                                                finalCreateOk = false;
                                                                finalStatus = retryRes.status;
                                                            }
                                                        }
                                                    }
                                                }
                                            } catch (e) {
                                                // ignore retry failures and fall through to error banner
                                            }
                                        }

                                        if (!finalCreateOk) {
                                            let msg = (createData && (createData.error || createData.message)) || (String(createText || '').trim()) || `Server returned ${finalStatus}`;
                                            try {
                                                if (createData && createData.debug) {
                                                    console.warn('batch_create debug', createData.debug);
                                                    const req = (createData.debug && createData.debug.requested) ? createData.debug.requested : null;
                                                    const first = (createData.debug && createData.debug.allowed_windows && createData.debug.allowed_windows.length) ? createData.debug.allowed_windows[0] : null;
                                                    if (req && (req.range || req.start) && first && (first.range || first.start)) {
                                                        msg = `${msg} (debug: requested ${req.range || ''}; allowed starts ${first.range || ''})`;
                                                    }
                                                }
                                            } catch (e) { /* ignore */ }
                                            // Close modal so the banner is visible (banner sits behind modal overlay).
                                            try { modal.style.display = 'none'; } catch (e) {}
                                            try { setTimeout(() => { ccShowOverrideBannerGuaranteed(msg, { status: finalStatus, data: createData || null }); }, 0); } catch (e) {}
                                            // Reconcile with server (delete may have succeeded, create failed).
                                            try { await calendar.refetchEvents(); } catch(e){}
                                            try { updateUnavailableDays(); } catch(e){}
                                            return;
                                        }
                                    } catch (e) {
                                        console.warn('makeAvailable batch_create failed', e);
                                        try { modal.style.display = 'none'; } catch (e) {}
                                        try { ccShowToastSafe('error', 'Error making available (create step failed).'); } catch (e) {}
                                        try { await calendar.refetchEvents(); } catch(e){}
                                        try { updateUnavailableDays(); } catch(e){}
                                        return;
                                    }

                                    // Remove any full-day block for this date
                                    try {
                                        calendar.getEvents().forEach(ev => {
                                            try {
                                                if (ev.display === 'background' && ev.startStr && ev.startStr.startsWith(dates[0])) ev.remove();
                                            } catch (e) { /* ignore per-event errors */ }
                                        });
                                    } catch (e) { /* ignore */ }

                                    // Add a green background event for this date to mark it as available (optimistic UI)
                                        try {
                                        // Mark this optimistic available background as a per-date override
                                            calendar.addEvent({
                                                start: dates[0] + 'T' + _createdStart,
                                                end: dates[0] + 'T' + _createdEnd,
                                                display: 'background',
                                                color: '#d0f0d0',
                                                extendedProps: Object.assign({ is_per_date: true, override_type: 'available', optimistic: true }, getScopePropsForSelection(overrideTarget))
                                            });
                                    } catch (e) { /* ignore */ }

                                    // Update classes immediately
                                    try { updateUnavailableDays(); } catch (e) {}
                                    try { if (typeof _invalidateServiceScopeParityCache === 'function') _invalidateServiceScopeParityCache(); } catch (e) {}
                                    try { if (typeof refreshServiceScopeMonthParity === 'function' && SELECTED_MEMBER && String(SELECTED_MEMBER).startsWith('svc:')) await refreshServiceScopeMonthParity(); } catch (e) {}
                                    try { calendar.refetchEvents(); } catch (e) {}

                                    // Exit out of the modal (match Make Unavailable behavior)
                                    try { modal.style.display = 'none'; } catch (e) {}
                                    try {
                                        selectedDates.clear();
                                        document.querySelectorAll('.fc-daygrid-day-number.selected').forEach(el => el.classList.remove('selected'));
                                        updateClearButton();
                                        updateSelectButtonText();
                                    } catch (e) {}
                                    try { ccShowToastSafe('success', 'Date made available.'); } catch (e) {}
                                } else {
                                    const msg = (data && (data.error || data.message)) || (String(text || '').trim()) || `Server returned ${res.status}`;
                                    try { modal.style.display = 'none'; } catch (e) {}
                                    try { setTimeout(() => { ccShowOverrideBannerGuaranteed(msg, { status: res.status, data: data || null }); }, 0); } catch (e) {}
                                    try { await calendar.refetchEvents(); } catch(e){}
                                    try { updateUnavailableDays(); } catch(e){}
                                }
                            } catch (err) {
                                console.error('Make available failed', err);
                                try { modal.style.display = 'none'; } catch (e) {}
                                try { ccShowToastSafe('error', 'Error making available: ' + (err && err.message ? err.message : String(err))); } catch (e) {}
                                try { await calendar.refetchEvents(); } catch(e){}
                                try { updateUnavailableDays(); } catch(e){}
                            }
                        };
                    } else {
                        makeAvailableBtn.style.display = 'none';
                    }
                }
            } catch (e) { /* ignore */ }
                } else {
            // Ensure any leftover single-day "make available" notice is removed
            try {
                const notice = document.getElementById('makeAvailableNotice'); if (notice) notice.remove();
            } catch (e) {}

            // Hide per-day ranges UI and add/save/view/make-available buttons for multi-day selection
            try {
                const rangesContainer = document.getElementById('modalRangesContainer'); if (rangesContainer) rangesContainer.style.display = 'none';
                const addBtn = document.getElementById('addModalRangeBtn'); if (addBtn) addBtn.style.display = 'none';
                const saveBtn = document.getElementById('saveTimeBtn'); if (saveBtn) saveBtn.style.display = 'none';
                const viewBtn = document.getElementById('viewDayBtn'); if (viewBtn) viewBtn.style.display = 'none';
                const makeAvailableBtn = document.getElementById('makeAvailableBtn'); if (makeAvailableBtn) makeAvailableBtn.style.display = 'none';
            } catch (e) { /* ignore */ }

            summary.textContent = `${dates.length} days selected: ${ranges.join(', ')}`;
            viewDayBtn.style.display = 'none';
            selectBtn.textContent = "Select Days";

            // If multiple days selected, offer "Make Available" when ALL selected
            // days are currently unavailable (and none are in the past).
            try {
                const makeAvailableBtn = document.getElementById('makeAvailableBtn');
                if (makeAvailableBtn) {
                    const allUnavailable = dates.every(d => {
                        try {
                            if (isPastDate(d)) return false;
                            const c = document.querySelector(`.fc-daygrid-day[data-date="${d}"]`);
                            const n = c ? c.querySelector('.fc-daygrid-day-number') : null;
                            return c && (c.classList.contains('fc-day-unavailable') || (n && n.classList.contains('unavailable-number')));
                        } catch (e) { return false; }
                    });

                    if (allUnavailable) {
                        makeAvailableBtn.style.display = 'inline-block';
                        makeAvailableBtn.onclick = async () => {
                            if (!CAN_USE_OVERRIDES) {
                                ccPromptOverridesUpgrade();
                                return;
                            }
                            if (!confirm(`Make ${dates.length} selected day(s) available?`)) return;
                            try {
                                // Compute groups (start/end per date) up-front so we can optimistically update UI
                                const groups = {}; // key -> { start, end, dates: [] }
                                const failedDates = [];
                                for (const d of dates) {
                                    try {
                                        const overrideTarget = (ccOverrideTarget() || null);
                                        const r = ccDefaultRangeForTargetDate(overrideTarget, d);
                                        if (!r) { failedDates.push(d); continue; }
                                        const start = r.start;
                                        const end = r.end;
                                        const key = `${start}|${end}`;
                                        if (!groups[key]) groups[key] = { start, end, dates: [] };
                                        groups[key].dates.push(d);
                                    } catch (e) { console.warn('grouping date failed', d, e); }
                                }

                                const createableDates = Object.values(groups).reduce((acc, g) => acc.concat(g.dates || []), []);
                                if (!createableDates.length) {
                                    const msg = `Couldn't save override: no valid default time range exists for the selected date(s) within staff/overall availability. Open staff availability first, then retry.`;
                                    try { modal.style.display = 'none'; } catch (e) {}
                                    try { setTimeout(() => { ccShowOverrideBannerGuaranteed(msg, { status: 400, data: null }); }, 0); } catch (e) {}
                                    try { await calendar.refetchEvents(); } catch(e){}
                                    try { updateUnavailableDays(); } catch(e){}
                                    return;
                                }

                                // First, remove any per-day blocks or avails that explicitly block these dates
                                const overrideTarget = (ccOverrideTarget() || null);
                                const delRes = await fetch(`/bus/${orgSlug}/bookings/batch_delete/`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                                    body: JSON.stringify({ dates: createableDates, target: overrideTarget })
                                });
                                const { data: delData, text: delText } = await _ccReadJsonOrText(delRes);
                                if (!delRes.ok) {
                                    const msg = (delData && (delData.error || delData.message)) || (String(delText || '').trim()) || `Server returned ${delRes.status}`;
                                    // Close the modal so the banner is actually visible.
                                    try { modal.style.display = 'none'; } catch (e) {}
                                    // Defer banner until after the modal closes (some modal flows disable page scroll).
                                    try { setTimeout(() => { ccShowOverrideBannerGuaranteed(msg, { status: delRes.status, data: delData || null }); }, 0); } catch (e) {}
                                    // Re-fetch server state to revert
                                    try { await calendar.refetchEvents(); } catch(e){}
                                    try { updateUnavailableDays(); } catch(e){}
                                    return;
                                }

                                // For each group, call batch_create to add per-date available overrides
                                const creationPromises = Object.values(groups).map(g => {
                                    return fetch(`/bus/${orgSlug}/bookings/batch_create/`, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                                        body: JSON.stringify({ dates: g.dates, start_time: g.start, end_time: g.end, target: overrideTarget })
                                    }).then(async (r) => {
                                        const { data, text } = await _ccReadJsonOrText(r);
                                        return { ok: r.ok, status: r.status, data, text };
                                    });
                                });

                                const creationResults = await Promise.all(creationPromises);
                                // If any creation failed, surface a message but continue to refresh UI
                                const failed = creationResults.filter(r => !r.ok);
                                if (failed.length) {
                                    console.warn('Some per-date creation requests failed', failed);
                                    const first = failed[0] || {};
                                    let msg = (first.data && (first.data.error || first.data.message)) || (String(first.text || '').trim()) || `Server returned ${first.status || ''}`;
                                    try {
                                        if (first.data && first.data.debug) {
                                            console.warn('batch_create debug', first.data.debug);
                                            const req = (first.data.debug && first.data.debug.requested) ? first.data.debug.requested : null;
                                            const aw = (first.data.debug && first.data.debug.allowed_windows && first.data.debug.allowed_windows.length) ? first.data.debug.allowed_windows[0] : null;
                                            if (req && (req.range || req.start) && aw && (aw.range || aw.start)) {
                                                msg = `${msg} (debug: requested ${req.range || ''}; allowed starts ${aw.range || ''})`;
                                            }
                                        }
                                    } catch (e) { /* ignore */ }
                                    // Close the modal so the banner is actually visible.
                                    try { modal.style.display = 'none'; } catch (e) {}
                                    // Defer banner until after the modal closes (some modal flows disable page scroll).
                                    try { setTimeout(() => { ccShowOverrideBannerGuaranteed(msg, { status: first.status || 400, data: first.data || null }); }, 0); } catch (e) {}
                                }

                                // Refresh UI from server to reconcile authoritative state
                                try { await calendar.refetchEvents(); } catch(e){}
                                try { updateUnavailableDays(); } catch(e){}
                                try { if (typeof _invalidateServiceScopeParityCache === 'function') _invalidateServiceScopeParityCache(); } catch (e) {}
                                try { if (typeof refreshServiceScopeMonthParity === 'function' && SELECTED_MEMBER && String(SELECTED_MEMBER).startsWith('svc:')) await refreshServiceScopeMonthParity(); } catch (e) {}
                                if (!failed.length) {
                                    try { ccShowToastSafe('success', 'Selected days made available.'); } catch (e) {}
                                }
                                if (failedDates.length) {
                                    try { ccShowToastSafe('warning', `Skipped ${failedDates.length} day(s) without any valid availability window.`); } catch (e) {}
                                }
                            } catch (err) {
                                console.error('Make available failed', err);
                                try { modal.style.display = 'none'; } catch (e) {}
                                try { ccShowToastSafe('error', (err && err.message) ? err.message : String(err)); } catch (e) {}
                                try { await calendar.refetchEvents(); } catch(e){}
                                try { updateUnavailableDays(); } catch(e){}
                            }
                            // close modal
                            modal.style.display = 'none';
                        };
                    } else {
                        makeAvailableBtn.style.display = 'none';
                    }
                }
            } catch (e) { /* ignore */ }
        }

        modal.style.display = 'flex';

        // Final UI lock after any conditional button toggles above.
        if (typeof ccEnforceOverridesLock === 'function') {
            try { ccEnforceOverridesLock(); } catch(e) {}
        }

        // Handle "View Day Schedule"
        viewDayBtn.onclick = () => {
            modal.style.display = 'none';
            // Build ranges to pass to the day schedule modal: prefer per-date overrides, fall back to weekly defaults
            let ranges = findPerDateTimedOverrides(dates[0]);
            if (!ranges || ranges.length === 0) {
                const d = parseYMD(dates[0]);
                const dow = d.getDay();
                const info = defaultAvailability[dow] || {};
                const rs = info.ranges && info.ranges.length ? info.ranges : (info.start && info.end ? [`${info.start}-${info.end}`] : []);
                ranges = rs.map(r => {
                    const parts = r.split('-');
                    return { start: (parts[0]||'09:00').trim(), end: (parts[1]||'17:00').trim() };
                });
            }
            openTimeCirclesModal(dates[0], 30, 1, ranges);
        };

        // Show Make Unavailable button for the selected dates (only when none are already unavailable and none are past)
        const makeUnavailableBtn = document.getElementById('makeUnavailableBtn');
        if (makeUnavailableBtn) {
            const anyPast = dates.some(d => isPastDate(d));
            const anyAlreadyUnavailable = dates.some(d => {
                try {
                    const c = document.querySelector(`.fc-daygrid-day[data-date="${d}"]`);
                    const n = c ? c.querySelector('.fc-daygrid-day-number') : null;
                    return c && (c.classList.contains('fc-day-unavailable') || (n && n.classList.contains('unavailable-number')));
                } catch (e) { return false; }
            });

            makeUnavailableBtn.style.display = (anyPast || anyAlreadyUnavailable) ? 'none' : 'inline-block';

            makeUnavailableBtn.onclick = async () => {
                if (!CAN_USE_OVERRIDES) {
                    ccPromptOverridesUpgrade();
                    return;
                }
                // Prevent blocking any day that already has bookings in this scope.
                try {
                    const bad = [];
                    for (const d of dates) {
                        const verdict = _validateOverrideAgainstBookings(d, null);
                        if (!verdict.ok) {
                            bad.push(verdict.message || (`Can’t block ${d} because there’s already a booking.`));
                            if (bad.length >= 5) break;
                        }
                    }
                    if (bad.length) {
                        alert(bad.join('\n\n'));
                        return;
                    }
                } catch (e) { /* ignore */ }
                if (!confirm(`Mark ${dates.length} selected day(s) as unavailable? This will block each selected day.`)) return;
                try {
                    const overrideTarget = (ccOverrideTarget() || null);
                    const res = await fetch(`/bus/${orgSlug}/bookings/batch_create/`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                        body: JSON.stringify({ dates: dates, start_time: '00:00', end_time: '23:59', is_blocking: true, target: overrideTarget })
                    });
                    const data = await res.json().catch(() => null);
                    if (res.ok) {
                        // Apply UI changes immediately for responsiveness
                        dates.forEach(d => applyPerDateUnavailable(d));
                        try { calendar.refetchEvents(); } catch(e){}
                        try { updateUnavailableDays(); } catch(e){}
                        alert('Selected days marked unavailable.');
                        // Clear selection after making unavailable
                        selectedDates.clear();
                        document.querySelectorAll('.fc-daygrid-day-number.selected').forEach(el => el.classList.remove('selected'));
                        updateClearButton();
                        updateSelectButtonText();
                    } else {
                        const msg = (data && (data.error || data.message)) || `Server returned ${res.status}`;
                        alert('Error marking unavailable: ' + msg);
                    }
                } catch (err) {
                    console.error('Make unavailable failed', err);
                    alert('Error: ' + (err && err.message ? err.message : String(err)));
                }
                modal.style.display = 'none';
            };
        }

        // Handle "Save" button: create calendar-level overrides (do NOT change defaults)
        document.getElementById('saveTimeBtn').onclick = async () => {
            if (!CAN_USE_OVERRIDES) {
                ccPromptOverridesUpgrade();
                return;
            }
            // Gather ranges from modalRangesContainer if present, otherwise fall back to single inputs
            const ranges = [];
            try {
                const rangesContainer = document.getElementById('modalRangesContainer');
                if (rangesContainer) {
                    const rows = Array.from(rangesContainer.querySelectorAll('.modal-range-row'));
                    for (const r of rows) {
                        try {
                            const s = r.querySelector('.modal-range-start').value;
                            const e = r.querySelector('.modal-range-end').value;
                            if (s && e && s < e) ranges.push({ start: s, end: e });
                        } catch (ie) { /* ignore invalid rows */ }
                    }
                }
            } catch (e) { /* ignore */ }

            if (ranges.length === 0) {
                // If the coach explicitly removed all ranges for a single selected date,
                // treat this action as "mark the date unavailable" instead of silently
                // falling back to weekly defaults.
                if (dates.length === 1) {
                    const theDate = dates[0];
                    // Prevent blocking a day that already has bookings in this scope.
                    try {
                        const verdict = _validateOverrideAgainstBookings(theDate, null);
                        if (!verdict.ok) { alert(verdict.message || 'This day already has a booking.'); return; }
                    } catch (e) { /* ignore */ }
                    if (!confirm(`No time ranges provided. Mark ${theDate} as unavailable for the whole day?`)) return;
                    try {
                        const overrideTarget = (ccOverrideTarget() || null);
                        const res = await fetch(`/bus/${orgSlug}/bookings/batch_create/`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                            body: JSON.stringify({ dates: [theDate], start_time: '00:00', end_time: '23:59', is_blocking: true, target: overrideTarget })
                        });
                        const data = await res.json().catch(() => null);
                        if (res.ok) {
                            // Apply UI changes immediately for responsiveness
                            applyPerDateUnavailable(theDate);
                            try { await calendar.refetchEvents(); } catch (e) {}
                            try { updateUnavailableDays(); } catch (e) {}
                            alert('Date marked unavailable.');
                        } else {
                            const msg = (data && (data.error || data.message)) || `Server returned ${res.status}`;
                            alert('Error marking unavailable: ' + msg);
                        }
                    } catch (err) {
                        console.error('Make unavailable failed', err);
                        alert('Error: ' + (err && err.message ? err.message : String(err)));
                    }
                    modal.style.display = 'none';
                    // Clear selection for single-date
                    try { selectedDates.delete(dates[0]); document.querySelectorAll('.fc-daygrid-day-number.selected').forEach(el => el.classList.remove('selected')); updateClearButton(); updateSelectButtonText(); } catch(e){}
                    return;
                }

                // Otherwise fallback to weekly defaults for the first selected date, otherwise sensible times
                try {
                    const d = parseYMD(dates[0]);
                    const dow = d.getDay();
                    const info = defaultAvailability[dow] || {};
                    const rs = info.ranges && info.ranges.length ? info.ranges : (info.start && info.end ? [`${info.start}-${info.end}`] : []);
                    if (rs && rs.length) {
                        const parts = rs[0].split('-');
                        const s = (parts[0]||'09:00').trim();
                        const e = (parts[1]||'17:00').trim();
                        if (s && e && s < e) ranges.push({ start: s, end: e });
                    } else {
                        const s = document.getElementById('startTime')?.value || '09:00';
                        const e = document.getElementById('endTime')?.value || '17:00';
                        if (s && e && s < e) ranges.push({ start: s, end: e });
                    }
                } catch (e) {
                    // final fallback
                    ranges.push({ start: '09:00', end: '17:00' });
                }
            }

            if (ranges.length === 0) return alert('No valid ranges to save.');

            // Deduplicate and enforce no overlap/duplicates (modal selection flow)
            try {
                const uniqueRanges = [];
                const seen = new Set();
                for (const rr of ranges) {
                    const k = `${rr.start}-${rr.end}`;
                    if (!seen.has(k)) { seen.add(k); uniqueRanges.push(rr); }
                }
                const intervals = uniqueRanges.map(rr => ({
                    start: rr.start,
                    end: rr.end,
                    startMin: _minutesFromTimeStr(rr.start),
                    endMin: _minutesFromTimeStr(rr.end),
                }));
                const verdict = _ccValidateIntervalsNoOverlap(intervals);
                if (!verdict.ok) {
                    _ccToastRangeError(verdict.message);
                    return;
                }
                // replace ranges with unique
                ranges.length = 0;
                uniqueRanges.forEach(r => ranges.push(r));
            } catch (e) { /* ignore */ }

            // Prevent saving ranges that would exclude existing bookings.
            try {
                const bad = [];
                for (const d of dates) {
                    const verdict = _validateOverrideAgainstBookings(d, ranges);
                    if (!verdict.ok) {
                        bad.push(verdict.message || (`Can’t save overrides for ${d} due to existing booking(s).`));
                        if (bad.length >= 5) break;
                    }
                }
                if (bad.length) {
                    alert(bad.join('\n\n'));
                    return;
                }
            } catch (e) { /* ignore */ }

            try {
                // First remove existing per-date overrides for these dates
                try {
                    const overrideTarget = (ccOverrideTarget() || null);
                    const delRes = await fetch(`/bus/${orgSlug}/bookings/batch_delete/`, {
                        method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken }, body: JSON.stringify({ dates: dates, target: overrideTarget })
                    });
                    // ignore result details — we'll refetch after creating
                } catch (e) { /* ignore delete errors */ }

                    // Now create each (already unique+validated) range for each selected date
                    for (const r of ranges) {
                    try {
                        const overrideTarget = (ccOverrideTarget() || null);
                        // optimistic UI addition
                        dates.forEach(d => {
                                            try { calendar.addEvent({ start: d + 'T' + r.start, end: d + 'T' + r.end, display: 'background', color: '#d0f0d0', extendedProps: Object.assign({ is_per_date: true, override_type: 'available', optimistic: true }, getScopePropsForSelection(overrideTarget)) }); } catch(e) {}
                        });

                        const res = await fetch(`/bus/${orgSlug}/bookings/batch_create/`, {
                            method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                            body: JSON.stringify({ dates: dates, start_time: r.start, end_time: r.end, target: overrideTarget })
                        });
                        const data = await res.json().catch(() => null);
                        if (!res.ok) {
                            const msg = (data && (data.error || data.message)) || `Server returned ${res.status}`;
                            console.warn('Error creating range', r, msg);
                        }
                    } catch (err) { console.error('range create failed', err); }
                }

                try { await calendar.refetchEvents(); } catch(e){}
                alert('Saved overrides for selected day(s).');
            } catch (err) {
                console.error('Save failed', err);
                alert('Error saving overrides: ' + (err && err.message ? err.message : String(err)));
            }

            // close modal but do not mutate defaultAvailability
            modal.style.display = 'none';
        };

        // Wire Reset-to-default button for the currently selected dates
        const resetBtn = document.getElementById('resetToDefaultBtn');
        resetBtn.onclick = async () => {
            if (!CAN_USE_OVERRIDES) {
                ccPromptOverridesUpgrade();
                return;
            }
            if (!confirm('Reset selected day(s) to weekly defaults? This will remove per-day overrides (client-side).')) return;
            try {
                // Work on a copy of dates
                const targets = dates.slice();

                // Prevent reset if weekly defaults would exclude existing bookings.
                try {
                    const bad = [];
                    for (const d of targets) {
                        const weekly = _weeklyDefaultRangesForDate(d);
                        const verdict = _validateOverrideAgainstBookings(d, weekly);
                        if (!verdict.ok) {
                            bad.push(verdict.message || (`Reset blocked for ${d} due to existing booking(s).`));
                            if (bad.length >= 5) break;
                        }
                    }
                    if (bad.length) {
                        alert(bad.join('\n\n'));
                        return;
                    }
                } catch (e) { /* ignore */ }

                // Remove client-side background events for these dates so UI immediately reflects defaults
                calendar.getEvents().forEach(ev => {
                    try {
                        if (ev.display === 'background' && ev.startStr) {
                            const evDate = (ev.startStr || '').split('T')[0];
                            for (const d of targets) {
                                if (evDate === d) {
                                    ev.remove();
                                    break;
                                }
                            }
                        }
                    } catch(e) { /* ignore per-event errors */ }
                });

                // Clear per-day classes for the targets so updateUnavailableDays can recompute
                targets.forEach(d => {
                    try {
                        const cell = document.querySelector(`.fc-daygrid-day[data-date="${d}"]`);
                        if (!cell) return;
                        cell.classList.remove('fc-day-unavailable');
                        cell.classList.remove('fc-day-available');
                        const num = cell.querySelector('.fc-daygrid-day-number');
                        if (num) {
                            num.classList.remove('unavailable-number');
                            num.classList.remove('selected');
                        }
                    } catch(e) { /* ignore per-cell errors */ }
                });

                // Re-sync defaults to calendar for visual fallback (over the current view)
                try { syncAvailabilityToCalendar(); } catch(e) { console.warn('sync failed', e); }

                // Ensure classes reflect the newly-synced defaults
                try { updateUnavailableDays(); } catch(e) { console.warn('updateUnavailableDays failed', e); }

                // Best-effort: ask server to remove per-day overrides if endpoint exists
                try {
                    const overrideTarget = (ccOverrideTarget() || null);
                    const res = await fetch(`/bus/${orgSlug}/bookings/batch_delete/`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                        body: JSON.stringify({ dates: targets, target: overrideTarget, mode: 'reset' })
                    });
                    if (res.ok) {
                        try { await res.json(); } catch(e) {}
                        // If server acknowledged deletion, refetch to ensure server-side state matches UI
                        try { await calendar.refetchEvents(); } catch(e) { console.warn('refetch after delete failed', e); }
                        alert('Reset completed. Calendar now shows weekly defaults.');
                    } else {
                        // Endpoint may not exist; fall back to client-only reset
                        console.warn('Server reset failed or endpoint missing', res.status);
                        alert('Reset applied locally. Server may require an endpoint to persist this change.');
                        try { await calendar.refetchEvents(); } catch(e) {}
                    }
                } catch (err) {
                    console.warn('batch_delete request failed', err);
                    alert('Reset applied locally. Server request failed.');
                    try { await calendar.refetchEvents(); } catch(e) {}
                }

                // Ensure the selection UI is cleared after reset
                try {
                    selectedDates.clear();
                    document.querySelectorAll('.fc-daygrid-day-number.selected').forEach(el => el.classList.remove('selected'));
                    updateClearButton();
                    updateSelectButtonText();
                } catch (e) { console.warn('clearing selection UI failed', e); }
            } catch (err) {
                console.error('Reset failed', err);
                alert('Reset failed: ' + (err && err.message ? err.message : String(err)));
            }

            modal.style.display = 'none';
        };

        // Handle "Cancel" button
        document.getElementById('closeTimeBtn').onclick = () => {
            modal.style.display = 'none';
        };

        // Add Range in Set Available Time modal (selection flow)
        try {
            const addBtn = document.getElementById('addModalRangeBtn');
            if (addBtn) {
                addBtn.onclick = () => {
                    if (!CAN_USE_OVERRIDES) {
                        ccPromptOverridesUpgrade();
                        return;
                    }
                    _ccAddModalRangeNoOverlap(document.getElementById('modalRangesContainer'), 60);
                };
            }
        } catch (e) { /* ignore */ }
    });

    document.getElementById('selectAllBtn').addEventListener('click', () => {
        // Select all future (non-past) days in the currently rendered month view.
        const cells = document.querySelectorAll('.fc-daygrid-day');

        // Block if any past day is selected (keep selection homogenous)
        if ([...selectedDates].some(d => isPastDate(d))) {
            alert("You can only select past days or available days — not both at the same time.");
            return;
        }

        // Mark that the user used Highlight All so modal logic can hide Make Available
        window._highlightAll = true;

        cells.forEach(cell => {
            const dateStr = cell.dataset.date;
            if (!dateStr) return;
            if (isPastDate(dateStr)) return; // skip past

            const numberEl = cell.querySelector('.fc-daygrid-day-number');
            if (!numberEl) return;
            numberEl.classList.add('selected');
            selectedDates.add(dateStr);
        });

        updateClearButton();
        updateSelectButtonText();
    });

    clearBtn.addEventListener('click', () => {
        document.querySelectorAll('.fc-daygrid-day-number.selected').forEach(el => {
            el.classList.remove('selected');
        });
        selectedDates.clear();
        updateClearButton();

        selectBtn.textContent = "Select Day";
    });

    // --- MODAL HANDLING LOGIC ---
    const timeModal = document.getElementById('timeModal');
    const saveTimeBtn = document.getElementById('saveTimeBtn');
    const closeTimeBtn = document.getElementById('closeTimeBtn');
    const selectedDaysSummary = document.getElementById('selectedDaysSummary');

});
    // Sync the cc-wave animations across sections by setting a shared negative
    // animation-delay equal to the elapsed phase of the animation duration.
    // This keeps all gradients visually in-step even if elements mount at
    // slightly different times.
    (function syncCcWave() {
        try {
            // Read duration from CSS var if present, fallback to 14s
            const root = document.documentElement;
            const cssRaw = getComputedStyle(root).getPropertyValue('--cc-wave-duration') || '14s';
            const cssDur = parseFloat(cssRaw);
            const dur = Number(cssDur) || 14; // seconds

            // Set a single initial offset so elements mounted at different times
            // appear visually in-step. Avoid updating this every animation frame
            // (which forces repaints each frame) — recompute only when the page
            // becomes visible again to keep CPU usage low.
            function setOffsetOnce() {
                const nowSec = performance.now() / 1000; // high-res
                const elapsed = nowSec % dur; // seconds into animation
                const offset = `-${elapsed.toFixed(3)}s`;
                root.style.setProperty('--cc-wave-offset', offset);
            }

            setOffsetOnce();
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) setOffsetOnce();
            });
        } catch (e) { /* fail silently */ }
    })();

</script>
{% endblock %}


