{% extends 'calendar_app/base.html' %}
{% block title %}Calendar{% endblock %}
{% block extra_head %}
<!-- Select2 Styles + JS -->
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>

<!-- FullCalendar Styles -->
<link href="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.8/main.min.css" rel="stylesheet" />

<!-- FullCalendar JS -->
<script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.8/index.global.min.js"></script>
{% endblock %}

{% block content %}

<div style="margin-bottom:32px;">
  <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
    <div style="text-align:center; flex:1;">
      <h1 class="calendar-title" style="font-size:32px; font-weight:800; margin:0 0 8px 0; letter-spacing:-0.5px;">Calendar</h1>
      <p style="color:var(--gray-600); font-size:15px; margin:0;">Manage your availability and view bookings</p>
    </div>
  </div>
</div>

<!-- Assets moved to extra_head -->

<style>
/* Modern color palette */
:root {
    --primary-500: #3b82f6;
    --primary-600: #2563eb;
    --primary-700: #1d4ed8;
    --success-500: #10b981;
    --success-600: #059669;
    --danger-500: #ef4444;
    --danger-600: #dc2626;
    --gray-50: #f9fafb;
    --gray-100: #f3f4f6;
    --gray-200: #e5e7eb;
    --gray-300: #d1d5db;
    --gray-600: #4b5563;
    --gray-700: #374151;
    --gray-900: #111827;
    --cc-wave-duration: 14s;
    --cc-page-gutter: 16px; /* default page gutter for consistent side padding */
    --cc-inner-max: 1180px;
}

/* Calendar base styling with modern card design */
#calendar {
    width: 100%;
    margin: auto;
    height: auto;
    border: none !important;
    background-color: white;
    padding: 24px;
    border-radius: 16px;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
}

/* Remove all calendar borders/grid lines */
.fc-scrollgrid { border-color: transparent !important; }
.fc-scrollgrid td:last-of-type { border-right-color: transparent !important; }
.fc-scrollgrid-section.fc-scrollgrid-section-body td[role='presentation'] { border-bottom-color: transparent !important; }
[role='row']:last-of-type td { border-bottom-color: transparent !important; }
th[role='presentation'] { border-right-color: transparent !important; }
.fc { border: none !important; }
.fc .fc-daygrid-day,
.fc .fc-daygrid-body,
.fc .fc-scrollgrid,
.fc .fc-col-header-cell,
.fc .fc-daygrid-day-frame { border: none !important; }

/* Hide extra frame cells that appear below the last week */
.fc-daygrid-day-frame {
    background: transparent !important;
}

/* Hide day cells that are outside the current month */
.fc-day-other {
    display: none !important;
}

/* Ensure grid sections have no grey background */
.fc .fc-daygrid-body,
.fc .fc-scrollgrid-section-body,
.fc .fc-scrollgrid {
    background: transparent !important;
}

/* Push calendar grid down while keeping header/title at top */
.fc .fc-view-harness { margin-top: 100px; }

/* Day number circle */
.fc-daygrid-day-frame {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
}

/* Top border color wave for section cards */
.section-card, .cc-page > .section-card, .border.rounded-lg, .section-card .section-title {
    position: relative;
}
.section-card::before, .border.rounded-lg::before {
    content: '';
    display: block;
    position: absolute;
    left: 0;
    right: 0;
    top: -6px;
    height: 6px;
    border-top-left-radius: 12px;
    border-top-right-radius: 12px;
    /* Use the canonical per-date overrides gradient */
    background: linear-gradient(to right, var(--primary-500), var(--success-500), var(--danger-500));
    background-size: 400% 100%;
    /* smooth oscillation using multi-stop keyframes (no alternate) */
    animation: cc-wave var(--cc-wave-duration, 14s) ease-in-out infinite;
    animation-delay: var(--cc-wave-offset, 0s);
    z-index: 2;
}
@keyframes cc-wave {
    0% { background-position: 0% 50%; }
    25% { background-position: 50% 50%; }
    50% { background-position: 100% 50%; }
    75% { background-position: 50% 50%; }
    100% { background-position: 0% 50%; }
}

/* Apply animated top-border gradient to main sections at all screen sizes */
/* Make top gradient part of each container's rounded top by clipping
   the pseudo-element to the container and using the container's radius. */
#defaultAvailabilityContainer,
#bookingsInlineSection,
#calendar,
#timeModal,
#timeCirclesModal {
    position: relative;
    overflow: hidden; /* clip the ::before gradient to container border-radius */
}

#defaultAvailabilityContainer::before,
#bookingsInlineSection::before,
#calendar::before,
#timeModal::before,
#timeCirclesModal::before {
    content: '';
    display: block;
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    height: 6px;
    /* inherit the container's top border radius so the gradient visually
       appears as part of the container (prevents the 'hat' effect). */
    border-top-left-radius: inherit;
    border-top-right-radius: inherit;
    background: linear-gradient(to right, var(--primary-500), var(--success-500), var(--danger-500));
    background-size: 400% 100%;
    animation: cc-wave var(--cc-wave-duration, 14s) ease-in-out infinite;
    animation-delay: var(--cc-wave-offset, 0s);
    z-index: 50;
    pointer-events: none;
}

/* Mobile-friendly adjustments */
@media (max-width: 768px) {
        --cc-page-gutter: 16px; 
        Default Weekly Availability keeps desktop baseline styles */
    #bookingsInlineSection,
    #calendar,
    #timeModal,
    #timeCirclesModal {
        position: relative; /* ensure pseudo-element positions relative to container */
    }

    /* Place the gradient inside the container (top:0) so it's not clipped on desktop.
       Use a CSS var for animation-delay so we can sync multiple elements from JS. */
    #bookingsInlineSection::before,
    #calendar::before,
    #timeModal::before,
    #timeCirclesModal::before {
        content: '';
        display: block;
        position: absolute;
        right: 0;
        top: 0; /* inside the container to avoid being clipped by overflow */
        height: 6px;
        border-top-left-radius: 12px;
        border-top-right-radius: 12px;
            background: linear-gradient(to right, var(--primary-500), var(--success-500), var(--danger-500));
            background-size: 400% 100%;
            animation: cc-wave var(--cc-wave-duration, 14s) ease-in-out infinite;
            /* allow external sync via --cc-wave-offset */
            animation-delay: var(--cc-wave-offset, 0s);
        z-index: 50;
        pointer-events: none;
    }
    #calendar { padding: 12px; }
    .fc .fc-view-harness { margin-top: 80px; }
    .fc-daygrid-day-number { width: 40px; height: 40px; font-size: 1.1rem; }
    .time-circle { width: 56px !important; height: 56px !important; font-size: 12px !important; }
}
.fc-daygrid-day-number {
    position: absolute;
    margin-top: 100%;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: flex;
    align-items: center;
    justify-content: center;
    width: 50px;
    height: 50px;
    font-size: 1.5rem;
    border-radius: 50% !important;
    font-weight: 600;
    transition: transform 0.2s ease, background-color 0.2s ease;
}

/* Ensure time-circle elements remain circular */
.time-circle { border-radius: 50% !important; overflow: visible; }

/* Pointer for available day numbers */
.fc-day-available .fc-daygrid-day-number { cursor: pointer !important; }
.fc-day-unavailable .fc-daygrid-day-number { cursor: pointer !important; }

/* Available day number - modern gradient */
.fc-day-available .fc-daygrid-day-number {
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(37, 99, 235, 0.15));
    border: 2px solid var(--primary-500);
    color: var(--primary-600);
    box-shadow: 0 2px 4px rgba(59, 130, 246, 0.1);
}

/* Hover effect - enhanced */
.fc-day-available .fc-daygrid-day-number:hover {
    transform: translate(-50%, -50%) scale(1.15);
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(37, 99, 235, 0.25));
    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
}

/* Selected day number - vibrant */
.fc-daygrid-day-number.selected {
    background: linear-gradient(135deg, var(--primary-500), var(--primary-600));
    color: white;
    transform: translate(-50%, -50%) scale(1.25);
    box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4);
    border-color: var(--primary-700);
}

/* Prevent frame highlighting */
  .fc-daygrid-day.fc-day-available {
      background: transparent !important;
  }

    /* Hover effect */
  .fc-daygrid-day-number:hover {
      transform: translate(-50%, -50%) scale(1.2);
  }

  /* Temporary highlight during drag - available days */
.fc-day-available .fc-daygrid-day-number.temp-highlight {
    background-color: rgba(0, 123, 255, 0.5);
    color: white;
    transform: translate(-50%, -50%) scale(1.3);
}

/* Temporary highlight during drag - unavailable days */
    .fc-day-unavailable .fc-daygrid-day-number.temp-highlight {
        background: linear-gradient(135deg, rgba(45, 45, 45, 0.8), rgba(26, 26, 26, 0.9));
        color: white;
        transform: translate(-50%, -50%) scale(1.3);
        border-color: #000000;
}

/* Removed: centralized mobile rules for availability UI — will be replaced with scoped media below */
/* (rules targeting .availability-ui removed) */


/* Current day styling - highlighted */
.fc-day-today { background-color: transparent !important; }
.fc .fc-day-today .fc-daygrid-day-number {
    background: linear-gradient(135deg, var(--primary-500), var(--primary-600));
    color: white;
    font-weight: bold;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    line-height: 28px;
    text-align: center;
    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.35);
    animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
    0%, 100% { box-shadow: 0 4px 12px rgba(59, 130, 246, 0.35); }
    50% { box-shadow: 0 6px 16px rgba(59, 130, 246, 0.5); }
}

/* Modern calendar buttons */
#calendar-controls {
    display: flex;
    justify-content: center;
    gap: 12px;
    margin-bottom: 20px;
    background: linear-gradient(to bottom, rgba(255,255,255,0.95), rgba(255,255,255,0.9));
    backdrop-filter: blur(8px);
    padding: 16px;
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.08), 0 0 1px rgba(0,0,0,0.05);
}
.calendar-btn {
    background-color: var(--primary-500);
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
.calendar-btn:hover { 
    background-color: var(--primary-600); 
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
}
.calendar-btn:active { transform: translateY(0); }
.calendar-btn:disabled { 
    background-color: var(--gray-300); 
    cursor: not-allowed; 
    transform: none;
    box-shadow: none;
}

/* Nav button shared style (kept minimal since inline styles are applied) */
#topNav .nav-btn:hover { 
    transform: translateY(-1px);
    background: var(--primary-600);
}
#topNav .nav-btn:active { transform: translateY(0); }

.fc-daygrid-day-number.selected::after,
.fc-daygrid-day-number.temp-highlight::after {
    content: none !important; /* removes any text overlay */
}
.fc-daygrid-event {
  display: none !important;  /* hides event text labels from calendar cells */
}
#timeModal, #bookingModal {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.6);
  backdrop-filter: blur(4px);
  justify-content: center;
  align-items: center;
  z-index: 9999;
  animation: fadeIn 0.2s ease-out;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes modalSlideUp {
  from { 
    opacity: 0;
    transform: translateY(20px);
  }
  to { 
    opacity: 1;
    transform: translateY(0);
  }
}

/* Button hover effects */
button:not(:disabled):hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.15) !important;
}
button:not(:disabled):active {
  transform: translateY(0);
}
#timeCirclesContainer > div {
  border-bottom: 1px solid #ccc;  
  padding-bottom: 40px;

}

#timeCirclesContainer > div:first-child {
  padding-top: 20px;
}

/* Remove line from the last row */
#timeCirclesContainer > div:last-child {
  border-bottom: none;
}

.fc-daygrid-day-number.selected.past-day {
    background-color: #ccc !important; /* grey circle for real past-day + selected */
    color: #fff !important;
    border: 2px solid #999 !important;
    
}

.fc-daygrid-day-number.past-day {
    /* show a circular outline for past days rather than a filled block */
    background-color: #7d7d7d28 !important;
    color: #4f4b4bff !important; /* muted text color */
    font-weight: 600;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    line-height: 46px;
    text-align: center;
    border: 2px solid #dcdcdc; /* subtle circle outline */
}

/* Unavailable day number (distinct from past-day) */
.fc-daygrid-day-number.unavailable-number {
    /* Grey circular outline for unavailable future days, number stays visible */
    background-color: #69696990 !important;
    color: #393535ff !important; /* visible but muted */
    font-weight: 600;
    border: 2px solid #454545ff;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    line-height: 46px;
    text-align: center;
}

/* Selected unavailable day - dark grey/black with white numbers */
.fc-daygrid-day-number.unavailable-number.selected {
    background: linear-gradient(135deg, #2d2d2d, #1a1a1a) !important;
    color: white !important;
    border-color: #000000 !important;
    transform: translate(-50%, -50%) scale(1.25) !important;
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.5) !important;
}

/* When an unavailable day is selected via fc-day-unavailable class */
.fc-day-unavailable .fc-daygrid-day-number.selected {
    background: linear-gradient(135deg, #2d2d2d, #1a1a1a) !important;
    color: white !important;
    transform: translate(-50%, -50%) scale(1.25) !important;
    border: 2px solid #000000 !important;
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.5) !important;
}

/* Overrides header styling */
.overrides-header { text-align:center; margin:0 0 10px; }
.overrides-base { font-weight:500; }
.overrides-month { font-weight:700; font-size:1.25em; }

/* Modern select and input styling */
select, input[type="time"], input[type="number"] {
    padding: 6px 10px;
    border: 2px solid var(--gray-300);
    border-radius: 6px;
    font-size: 13px;
    color: var(--gray-900);
    background: white;
    transition: all 0.2s ease;
    outline: none;
}

select:focus, input[type="time"]:focus, input[type="number"]:focus {
  border-color: var(--primary-500);
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

select:hover, input[type="time"]:hover, input[type="number"]:hover {
  border-color: var(--gray-400);
}

/* Time input wrapper for relative positioning */
.time-input-container {
  position: relative;
  display: inline-block;
}


/* Range row layout adjustments to prevent action buttons overlapping inputs on small screens */
.range-row {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: nowrap;
}
.range-row .time-input-container {
    flex: 0 0 auto;
    min-width: 0; /* allow mobile overrides to control width; avoid forcing large widths on desktop */
}
.range-start, .range-end, .modal-range-start, .modal-range-end {
    text-align: center;
    padding: 6px 8px;
    border-radius: 8px;
    border: 1px solid var(--gray-300);
    background: white;
    font-weight: 600;
    min-width: 0; /* allow responsive rules to set exact widths per breakpoint */
}
.remove-range-btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 3px 6px;
    border: none;
    background: #dc3545;
    color: white;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 600;
    font-size: 12px;
}
.remove-range-btn .remove-icon { font-size: 14px; line-height: 1; }
    .remove-range-btn .remove-text { display: none; }
/* Position the unavailable checkbox slightly lower and to the right
   so it visually aligns near the remove button across all devices. */
.unavailable-checkbox {
    position: relative;
    top: 6px; /* move down */
    left: 6px; /* move right */
    width: 18px;
    height: 18px;
}
.add-range-btn {
    padding: 6px 10px !important;
    background: #007bff !important;
    color: white !important;
    border: none !important;
    border-radius: 6px !important;
    cursor: pointer !important;
    font-weight: 600;
    font-size: 13px;
}

/* Removed mobile @media rules that targeted availability-specific classes so
   Default Weekly Availability keeps desktop baseline styles. */


/* Custom Time Picker Dropdown */
.custom-time-picker {
  position: absolute;
  top: calc(100% + 5px);
  left: 0;
  background: white;
  border: 1px solid var(--gray-300);
  border-radius: 12px;
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15), 0 4px 10px rgba(0, 0, 0, 0.1);
  z-index: 1000;
  padding: 16px;
  min-width: 280px;
  display: none;
  animation: slideDown 0.2s ease-out;
}

@keyframes slideDown {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.custom-time-picker.active {
  display: block;
}

.time-picker-header {
  font-size: 13px;
  font-weight: 600;
  color: var(--gray-700);
  margin-bottom: 12px;
  text-align: center;
}

.time-picker-display {
  font-size: 32px;
  font-weight: 700;
  text-align: center;
  color: var(--primary-600);
  margin-bottom: 16px;
  font-variant-numeric: tabular-nums;
  letter-spacing: 0.05em;
}

.time-picker-selectors {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
}

.time-selector {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.time-selector-label {
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  color: var(--gray-600);
  text-align: center;
  letter-spacing: 0.5px;
}

.time-scroll-container {
  height: 180px;
  overflow-y: auto;
  border: 1px solid var(--gray-200);
  border-radius: 8px;
  background: var(--gray-50);
  padding: 4px;
}

.time-scroll-container::-webkit-scrollbar {
  width: 6px;
}

.time-scroll-container::-webkit-scrollbar-track {
  background: transparent;
}

.time-scroll-container::-webkit-scrollbar-thumb {
  background: var(--gray-300);
  border-radius: 3px;
}

.time-option {
  padding: 10px;
  text-align: center;
  cursor: pointer;
  border-radius: 6px;
  font-size: 15px;
  font-weight: 500;
  transition: all 0.15s ease;
  color: var(--gray-700);
}

.time-option:hover {
  background: white;
  color: var(--primary-600);
}

.time-option.selected {
  background: var(--primary-500);
  color: white;
  font-weight: 600;
}

.time-picker-actions {
  display: flex;
  gap: 8px;
  margin-top: 12px;
}

.time-picker-btn {
  flex: 1;
  padding: 10px;
  border: none;
  border-radius: 8px;
  font-weight: 600;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.15s ease;
}

.time-picker-btn.confirm {
  background: var(--primary-500);
  color: white;
}

.time-picker-btn.confirm:hover {
  background: var(--primary-600);
  transform: translateY(-1px);
  box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
}

.time-picker-btn.cancel {
  background: var(--gray-200);
  color: var(--gray-700);
}

.time-picker-btn.cancel:hover {
  background: var(--gray-300);
}

/* Keep default browser scrollbars for the main page.
     Note: We still style only the time picker scrollers via .time-scroll-container::-webkit-scrollbar above. */

/* Improved table row hover */
#overridesTable tbody tr:hover {
  background: var(--gray-50);
  transition: background 0.15s ease;
}

#defaultAvailabilityTable tr:hover {
  background: var(--gray-50);
  transition: background 0.15s ease;
}


/* Per-date Overrides: enhanced card styling */
#overridesContainer {
    position: relative;
    overflow: hidden;
    font-family: "Inter", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
}
#overridesContainer::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 6px;
    /* Use the canonical per-date overrides gradient and animate it (in sync) */
    background: linear-gradient(to right, var(--primary-500), var(--success-500), var(--danger-500));
    background-size: 400% 100%;
    animation: cc-wave var(--cc-wave-duration, 14s) ease-in-out infinite;
    animation-delay: var(--cc-wave-offset, 0s);
    z-index: 50;
    pointer-events: none;
}

/* Overrides table visuals */
#overridesTable {
    border-collapse: separate;
    border-spacing: 0;
}
#overridesTable thead tr {
    background: linear-gradient(to right, rgba(59, 130, 246, 0.08), rgba(16, 185, 129, 0.08));
}
#overridesTable th {
    padding: 10px;
    text-align: left;
    font-weight: 700;
    font-size: 12.5px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--gray-700);
}
#overridesTable td {
    padding: 10px;
    border-bottom: 1px solid var(--gray-100);
    font-size: 13px;
    color: var(--gray-700);
}

/* Default Weekly Availability: prevent overflow and keep content visible */
#defaultAvailabilityContainer table { table-layout: fixed; width: 100%; }
#defaultAvailabilityContainer th, #defaultAvailabilityContainer td { white-space: nowrap; overflow: visible; }
/* Allow time range cells to wrap naturally but keep day names intact */
#defaultAvailabilityContainer tbody td:first-child { white-space: nowrap; }
#defaultAvailabilityContainer tbody td:not(:first-child) { white-space: normal; }
/* Subtle borders between day rows with padding for spacing */
#defaultAvailabilityContainer tbody tr { border-bottom: 1px solid var(--gray-200); }
#defaultAvailabilityContainer tbody tr:last-child { border-bottom: none; }
#defaultAvailabilityContainer tbody td { padding-top: 16px; padding-bottom: 16px; }


/* Type badges */
.type-badge {
    display: inline-block;
    padding: 6px 10px;
    border-radius: 999px;
    font-weight: 600;
    font-size: 12px;
}
.type-badge.available {
    background: rgba(16, 185, 129, 0.15);
    color: var(--success-600);
    border: 1px solid rgba(16, 185, 129, 0.25);
}
.type-badge.blocked {
    background: rgba(239, 68, 68, 0.15);
    color: var(--danger-600);
    border: 1px solid rgba(239, 68, 68, 0.25);
}

/* Action buttons */
#overridesTable button.overrides-btn {
    padding: 8px 12px;
    border-radius: 8px;          /* slightly smaller buttons */
    background: var(--primary-500);
    color: white;
    border: none;
    font-weight: 600;
    cursor: pointer;
    transition: transform 0.15s ease, box-shadow 0.2s ease, background-color 0.2s ease;
    box-shadow: 0 1px 3px rgba(0,0,0,0.12);
}
#overridesTable button.overrides-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 6px 12px rgba(59, 130, 246, 0.30);
    background: var(--primary-600);
}
#overridesTable button.overrides-btn:active {
    transform: translateY(0);
}

/* Fallback: if a button in overrides table has no inner text, show its data-label */
#overridesTable button.overrides-btn:empty::after {
    content: attr(data-label);
}

</style>
<style>
/* Animated, stylish calendar title */
.calendar-title {
    /* Match available day circle highlight (primary blue gradient) */
    background: linear-gradient(135deg, var(--primary-500), var(--primary-600));
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    background-size: 200% auto;
    animation: titleGradientShift 8s ease-in-out infinite, titleFloatIn 600ms ease-out both;
    filter: drop-shadow(0 1px 0 rgba(0,0,0,0.06));
}
/* Per-date overrides month label: match available day circle highlight */
#overridesHeaderMonth {
    background: linear-gradient(135deg, var(--primary-500), var(--primary-600));
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent !important; /* override inline color */
    background-size: 200% auto;
    animation: titleGradientShift 8s ease-in-out infinite;
}
@keyframes titleGradientShift {
    0% { background-position: 0% center; }
    50% { background-position: 100% center; }
    100% { background-position: 0% center; }
}
@keyframes titleFloatIn {
    0% { opacity: 0; transform: translateY(6px); }
    100% { opacity: 1; transform: translateY(0); }
}

/* Mobile Responsive Styles */
@media (max-width: 768px) {
    /* Title adjustments */
    .calendar-title {
        font-size: 24px !important;
    }
    /* Remove extra top offset on mobile since controls are not overlaid */
    .fc .fc-view-harness { margin-top: 0 !important; }

    /* Slightly smaller day circles on mobile */
    .fc-daygrid-day-number,
    .fc .fc-day-today .fc-daygrid-day-number,
    .fc-daygrid-day-number.past-day,
    .fc-daygrid-day-number.unavailable-number {
        width: 40px !important;
        height: 40px !important;
        font-size: 1.25rem !important;
        line-height: 36px !important;
    }
    /* Reduce hover/selected scale to match smaller size */
    .fc-daygrid-day-number:hover { transform: translate(-50%, -50%) scale(1.1) !important; }
    .fc-daygrid-day-number.selected { transform: translate(-50%, -50%) scale(1.15) !important; }
    
    /* Per-date Overrides Table */
    #overridesContainer {
        padding: 16px !important;
        margin-top: 16px !important;
        overflow-x: auto;
    }
    
    #overridesTable {
        font-size: 11px;
        min-width: 600px;
    }
    
    #overridesTable th {
        padding: 8px !important;
        font-size: 10px !important;
    }
    
    #overridesTable td {
        padding: 8px !important;
        font-size: 11px !important;
    }
    
    #overridesTable button {
        padding: 6px 8px !important;
        font-size: 11px !important;
    }

    /* Removed nested desktop @media that touched .range-row to avoid
       any accidental mobile/medium interactions. */

    /* Default Weekly Availability: responsive rules removed per request. */
    /* (Removed mobile/medium @media blocks and small-screen overrides that targeted
       #defaultAvailabilityContainer, .range-row, .range-start, .range-end,
       .remove-range-btn, .unavailable-checkbox so desktop styles are the baseline.) */
    
    /* Calendar Container */
    div[style*="flex:2 1 640px"] {
        flex: 1 1 100% !important;
        min-width: 100% !important;
        margin-bottom: 16px !important;
    }
    
    #calendar {
        padding: 12px !important;
        height: auto !important;
        min-height: 420px !important;
    }
    
    /* Calendar Controls */
    /* Place controls inline under month title; simplified styling */
    #calendar-controls {
        position: static !important;
        transform: none !important;
        margin-bottom: 12px;
        flex-wrap: wrap;
        justify-content: center;
        background: transparent !important;
        box-shadow: none !important;
        padding: 8px !important;
    }
    
    .calendar-btn {
        padding: 8px 12px !important;
        font-size: 12px !important;
    }
    
    /* Main flex container */
    #weeklyCalendarRow { gap: 16px !important; flex-wrap: wrap !important; }
}

/* Landscape Mobile (tablets in landscape, large phones) */
@media (max-width: 1200px) and (min-width: 769px) {
    #weeklyCalendarRow { flex-wrap: wrap !important; }
    /* Default availability responsive settings removed */
    
    div[style*="flex:2 1 640px"] {
        flex: 1 1 500px !important;
        min-width: 500px !important;
    }
}

/* Small phones (portrait) */
@media (max-width: 480px) {
    #overridesContainer,
    #calendar {
        border-radius: 12px !important;
    }
    
    .calendar-title {
        font-size: 20px !important;
    }
    
    /* Default availability time input mobile sizing removed */
    
    #calendar-controls {
        gap: 6px !important;
    }
    
    .calendar-btn {
        padding: 6px 10px !important;
        font-size: 11px !important;
    }
}

/* Full width on mobile - override base.html max-width containers */
@media (max-width: 768px) {
    /* Prevent horizontal scrolling */
    html, body {
        overflow-x: hidden;
        width: 100%;
        max-width: 100vw;
    }
    
    body {
        padding: 0;
        margin: 0;
    }
    
    /* Make main content full width */
    main.max-w-6xl,
    main.max-w-7xl,
    main {
        max-width: 100vw !important;
        width: 100% !important;
        padding: 12px !important;
        margin: 0 !important;
        box-sizing: border-box !important;
    }
    
    /* Make header full width */
    header {
        width: 100% !important;
        max-width: 100vw !important;
        box-sizing: border-box !important;
    }
    
    header .max-w-7xl,
    header > div {
        max-width: 100% !important;
        width: 100% !important;
        padding-left: 12px !important;
        padding-right: 12px !important;
        box-sizing: border-box !important;
    }
    
    /* Make footer full width */
    footer {
        width: 100% !important;
        max-width: 100vw !important;
        box-sizing: border-box !important;
    }
    
    footer .max-w-7xl,
    footer > div {
        max-width: 100% !important;
        width: 100% !important;
        padding-left: 12px !important;
        padding-right: 12px !important;
        box-sizing: border-box !important;
    }
    
    /* Remove extra margins on cards and prevent overflow */
    #overridesContainer,
    #calendar {
        margin-left: 0 !important;
        margin-right: 0 !important;
        width: 100% !important;
        max-width: 100% !important;
        box-sizing: border-box !important;
        overflow-x: visible !important;
    }
    
    /* Title stays fixed, only table wrapper scrolls */
    #overridesTableWrapper {
        overflow-x: auto !important;
        -webkit-overflow-scrolling: touch !important;
    }
    
    #overridesTable {
        min-width: 600px !important;
    }
    
    /* Full width page title container */
    div[style*="margin-bottom:32px; text-align:center"] {
        margin-bottom: 16px !important;
        padding: 0 !important;
        width: 100% !important;
        box-sizing: border-box !important;
    }
    
    /* Default availability media rules removed */
}

/* Widen layout on desktop: use more of the screen width */
@media (min-width: 1025px) {
    /* Expand base containers from base.html */
    main.max-w-6xl,
    main.max-w-7xl,
    main {
        max-width: 95vw !important;
        width: 95vw !important;
        padding-left: 16px !important;
        padding-right: 16px !important;
        box-sizing: border-box !important;
    }
    header .max-w-7xl,
    header > div,
    footer .max-w-7xl,
    footer > div {
        max-width: 95vw !important;
        width: 95vw !important;
        padding-left: 16px !important;
        padding-right: 16px !important;
        box-sizing: border-box !important;
    }
    /* Increase gap between weekly availability and calendar on wide screens */
    #weeklyCalendarRow { gap: 60px !important; }
    /* Make calendar fill column height */
    #calendar { height: 100% !important; }
}

/* Keep a consistent horizontal gutter (side padding) for medium viewports
   so content doesn't touch the right edge as the layout narrows. This
   preserves the current visual spacing until the availability column must
   wrap on small screens. */
@media (min-width: 481px) and (max-width: 1200px) {
    main.max-w-6xl,
    main.max-w-7xl,
    main {
        padding-left: 12px !important;
        padding-right: 12px !important;
        box-sizing: border-box !important;
    }
    header .max-w-7xl,
    header > div,
    footer .max-w-7xl,
    footer > div {
        padding-left: 12px !important;
        padding-right: 12px !important;
        box-sizing: border-box !important;
    }
    /* Add a small inner gutter for the two-column calendar/availability row */
    #weeklyCalendarRow {
        padding-left: 12px !important;
        padding-right: 12px !important;
        box-sizing: border-box !important;
    }
}


</style>

<style>
/* Removed: minimal mobile-only availability rules targeting .availability-ui */
</style>

<style>
/* Center content column and prevent edge leakage across wide and medium viewports */
@media (min-width: 900px) {
    :root { 
        --cc-page-gutter: 16px; 
        --cc-inner-max: 1180px; 
    }

    main.max-w-6xl,
    main.max-w-7xl,
    main {
        width: 100% !important;
        margin-left: auto !important;
        margin-right: auto !important;
        padding-left: var(--cc-page-gutter) !important;
        padding-right: var(--cc-page-gutter) !important;
        box-sizing: border-box !important;
    }

    header .max-w-7xl,
    header > div,
    footer .max-w-7xl,
    footer > div {
        max-width: var(--cc-inner-max) !important;
        margin-left: auto !important;
        margin-right: auto !important;
        padding-left: var(--cc-page-gutter) !important;
        padding-right: var(--cc-page-gutter) !important;
        box-sizing: border-box !important;
    }

    /* Align the main cards to the centered column and allow them to shrink */
    #overridesContainer,
    #weeklyCalendarRow,
    #defaultAvailabilityContainer,
    #calendar,
    #bookingsInlineSection {
        max-width: 100% !important;
        margin-left: 0 !important;
        margin-right: 0 !important;
        box-sizing: border-box !important;
    }

    /* Override inline min-widths (set on elements via style attributes) so they
       don't push past the centered column and leak to the viewport edge. */
    #defaultAvailabilityContainer, div[style*="flex:2 1 640px"] {
        min-width: 0 !important;
        max-width: 100% !important;
        box-sizing: border-box !important;
    }

    /* Keep weekly row aligned with the centered column */
    #weeklyCalendarRow { padding-left: 0 !important; padding-right: 0 !important; box-sizing: border-box !important; }
}
</style>

<!-- Controls will be overlaid inside the calendar area -->
<!-- Removed mobile/medium @media rules that targeted the Default Weekly Availability UI -->
<!-- Per-date Overrides Table - Modern Card (moved to top) -->
<div id="overridesContainer" style="margin-top:24px; padding:24px; background:white; border:none; border-radius:16px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);">
    <h3 id="overridesHeader" class="overrides-header" style="margin:0 0 20px 0; font-size:18px; font-weight:700; color:var(--gray-900);">
        <span class="overrides-base" style="font-weight:600;">Per-date Overrides for </span><span id="overridesHeaderMonth" class="overrides-month" style="color:var(--primary-600);"></span>
    </h3>
    <div id="overridesTableWrapper" style="overflow-x:auto; -webkit-overflow-scrolling:touch;">
        <table id="overridesTable" style="width:100%; border-collapse:collapse;">
            <thead>
                <tr style="text-align:left; border-bottom:2px solid var(--gray-200); background:var(--gray-50);">
                    <th style="padding:12px; width:16%; font-weight:600; font-size:13px; text-transform:uppercase; letter-spacing:0.5px; color:var(--gray-600);">Date</th>
                    <th style="padding:12px; width:16%; font-weight:600; font-size:13px; text-transform:uppercase; letter-spacing:0.5px; color:var(--gray-600);">Type</th>
                    <th style="padding:12px; width:38%; font-weight:600; font-size:13px; text-transform:uppercase; letter-spacing:0.5px; color:var(--gray-600);">Time Ranges</th>
                    <th style="padding:12px; width:15%; font-weight:600; font-size:13px; text-transform:uppercase; letter-spacing:0.5px; color:var(--gray-600); text-align:center;">Reset All</th>
                    <th style="padding:12px; width:15%; font-weight:600; font-size:13px; text-transform:uppercase; letter-spacing:0.5px; color:var(--gray-600);">Group Actions</th>
                </tr>
            </thead>
            <tbody id="overridesTableBody">
                <tr><td colspan="5" style="text-align:center; color:var(--gray-600); padding:24px; font-style:italic;">No per-date overrides</td></tr>
            </tbody>
        </table>
    </div>
</div>

<div id="weeklyCalendarRow" style="display:flex; gap:40px; align-items:stretch; flex-wrap:nowrap; margin-top:24px; width:100%;">
    <div id="defaultAvailabilityContainer" class="availability-ui" style="flex:1 1 540px; min-width:540px; margin-bottom:32px; padding:24px; background:white; border:none; border-radius:16px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);">
    <h3 style="margin:0 0 20px 0; font-size:18px; font-weight:700; color:var(--gray-900);">Default Weekly Availability</h3>
    <table style="width:100%; border-collapse:collapse;">
        <thead>
        <tr style="border-bottom:2px solid var(--gray-200); background:var(--gray-50);">
            <th style="padding:12px; text-align:left; font-weight:700; font-size:13px; text-transform:uppercase; letter-spacing:0.5px; color:var(--gray-900); width:20%;">Day</th>
            <th style="padding:12px; text-align:center; font-weight:700; font-size:13px; text-transform:uppercase; letter-spacing:0.5px; color:var(--gray-900); width:55%;" colspan="2">Time Ranges</th>
            <th style="padding:12px; text-align:center; font-weight:700; font-size:13px; text-transform:uppercase; letter-spacing:0.5px; color:var(--gray-900); width:25%;">Unavailable</th>
        </tr>
        </thead>
        <tbody id="defaultAvailabilityTable"></tbody>
    </table>
    <button id="saveDefaultAvailabilityBtn" 
            style="margin-top:20px; padding:12px 24px; background:var(--primary-500); color:white; border:none; border-radius:8px; font-weight:600; cursor:pointer; transition:all 0.2s ease; box-shadow:0 1px 3px rgba(0,0,0,0.1);">
        Save Defaults
    </button>
    </div>

        <!-- === Your Calendar === -->
        <div style="position:relative; flex:2 1 640px; min-width:640px; margin-bottom:32px; display:flex; flex-direction:column;">
            <div id="calendar" style="position:relative;"></div>
            <div id="calendar-controls" style="position:absolute; left:50%; transform:translateX(-50%); top:80px; display:flex; gap:10px; z-index:10;">
                <button id="selectDaysBtn" class="calendar-btn">Select Day</button>
                <button id="selectAllBtn" class="calendar-btn" style="background:var(--success-500);">Highlight All</button>
                <button id="clearSelectionBtn" class="calendar-btn" style="background:var(--danger-500);">Clear</button>
                <button id="retryInitCalendarBtn" class="calendar-btn" style="background:transparent; color:var(--primary-500); border:1px solid var(--primary-500);">Retry</button>
            </div>
        </div>
</div>
<!-- Inline Bookings Section -->
<style>
/* Apply horizontal scrolling for bookings only on small–medium screens */
@media (max-width: 1200px) {
    #bookingsScrollWrapper { overflow-x: auto; -webkit-overflow-scrolling: touch; }
    #bookingsScrollWrapper table { min-width: 720px; width: 100%; }
}
</style>

<style>
/* Small screens: match default availability gutters to other cards (safe, mobile-only) */
@media (max-width: 768px) {
    /* Match the inline padding used by other cards (24px) so edges align */
    #defaultAvailabilityContainer {
        width: 100% !important;
        box-sizing: border-box !important;
        padding-left: 24px !important;
        padding-right: 24px !important;
        margin-left: 0 !important;
        margin-right: 0 !important;
    }

    /* Ensure the inner table respects card padding and doesn't add extra left offset */
    #defaultAvailabilityContainer table {
        width: 100% !important;
        table-layout: fixed !important;
        margin-left: 0 !important;
        margin-right: 0 !important;
        box-sizing: border-box !important;
    }

    /* When the weekly row stacks, remove any row-level padding so cards line up */
    #weeklyCalendarRow {
        padding-left: 0 !important;
        padding-right: 0 !important;
        box-sizing: border-box !important;
    }
}
</style>

<style>
/* Emergency mobile overrides to prevent right-edge overflow caused by inline min-widths
     Only active on small viewports so desktop styles remain untouched. */
@media (max-width: 768px) {
    /* Force the weekly row to stack vertically so columns don't push past viewport */
    #weeklyCalendarRow {
        flex-direction: column !important;
        gap: 16px !important;
        padding-left: 0 !important;
        padding-right: 0 !important;
        box-sizing: border-box !important;
    }

    /* Allow both columns to shrink and fit the viewport */
    #defaultAvailabilityContainer,
    div[style*="flex:2 1 640px"],
    #calendar {
        min-width: 0 !important;
        width: 100% !important;
        box-sizing: border-box !important;
        margin-left: 0 !important;
        margin-right: 0 !important;
    }

    /* Ensure the table inside the availability card doesn't add extra width */
    #defaultAvailabilityContainer table {
        width: 100% !important;
        table-layout: fixed !important;
        margin-left: 0 !important;
        margin-right: 0 !important;
        box-sizing: border-box !important;
    }

    /* Reduce any large fixed min-widths applied elsewhere to prevent overflow */
    [style*="min-width:540px"], [style*="min-width:640px"], [style*="min-width:600px"] {
        min-width: 0 !important;
        max-width: 100% !important;
    }
}
</style>

<style>
/* Mobile-only: compact and left-align contents inside Default Weekly Availability */
@media (max-width: 768px) {
    /* Make the card contents align left and use slightly smaller spacing */
    #defaultAvailabilityContainer {
        text-align: left !important;
        padding-left: 16px !important;
        padding-right: 16px !important;
        box-sizing: border-box !important;
        /* base font-size for the card so everything is smaller */
        font-size: 12px !important;
    }

    /* Headings and table text smaller */
    #defaultAvailabilityContainer h3 {
        font-size: 14px !important;
        margin-bottom: 10px !important;
        text-align: left !important;
    }
    /* day label and other tds slightly smaller */
    #defaultAvailabilityContainer table th,
    #defaultAvailabilityContainer table td {
        font-size: 11px !important;
        padding: 6px 6px !important;
        vertical-align: middle !important;
    }
    /* specifically reduce the first column (day name) padding and size */
    #defaultAvailabilityContainer tbody td:first-child {
        font-size: 11px !important;
        padding-top: 6px !important;
        padding-bottom: 6px !important;
        white-space: nowrap !important;
    }

    /* Compact range rows and inputs */
    #defaultAvailabilityContainer .range-row {
        gap: 6px !important;
        align-items: center !important;
        justify-content: flex-start !important;
        flex-wrap: nowrap !important;
    }
    #defaultAvailabilityContainer .range-row .time-input-container {
        display: inline-block !important;
    }
    #defaultAvailabilityContainer .range-start,
    #defaultAvailabilityContainer .range-end {
        padding: 3px !important;
        font-size: 9px !important;
        border-radius: 6px !important;
        min-width: 0 !important;
        width: auto !important; /* compact but wide enough for times like 09:00 AM */
        box-sizing: border-box !important;
    }

    /* Smaller action buttons */
    #defaultAvailabilityContainer .add-range-btn {
        padding: 6px 8px !important;
        font-size: 12px !important;
        border-radius: 6px !important;
    }
    #defaultAvailabilityContainer .remove-range-btn {
        padding: 2px 6px !important;
        font-size: 12px !important;
        border-radius: 4px !important;
    }

    /* Nudge the checkbox a bit less on small screens */
    #defaultAvailabilityContainer .unavailable-checkbox {
        top: 4px !important;
        left: 4px !important;
        width: 16px !important;
        height: 16px !important;
    }

    /* Ensure the time-picker appended to body doesn't overflow the card visually */
    #defaultAvailabilityContainer .time-input-container .custom-time-picker { max-width: 280px !important; }
}
</style>

<div id="bookingsInlineSection" style="margin-top:24px; padding:24px; background:white; border:none; border-radius:16px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);">
    <div style="display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap; margin-bottom:12px;">
        <h3 style="margin:0; font-size:18px; font-weight:700; color:var(--gray-900);">Bookings</h3>
        <div style="display:flex; gap:8px; align-items:center;">
            <input id="bookingsSearchInline" type="text" placeholder="Search name or email" style="padding:8px 10px; border:1px solid var(--gray-300); border-radius:6px; font-size:13px;" />
            <button id="bookingsRefreshBtn" type="button" style="padding:8px 12px; background:var(--primary-500); color:white; border:none; border-radius:8px; font-weight:600; cursor:pointer;">Refresh</button>
        </div>
    </div>
    <div id="bookingsScrollWrapper">
    <table style="width:100%; border-collapse:collapse;">
        <thead>
            <tr style="border-bottom:2px solid var(--gray-200); background:var(--gray-50);">
                <th style="padding:10px; text-align:left; font-size:13px; font-weight:700; color:var(--gray-900);">Date & Time</th>
                <th style="padding:10px; text-align:left; font-size:13px; font-weight:700; color:var(--gray-900);">Client</th>
                <th style="padding:10px; text-align:left; font-size:13px; font-weight:700; color:var(--gray-900);">Service</th>
                <th style="padding:10px; text-align:left; font-size:13px; font-weight:700; color:var(--gray-900);">Status</th>
                <th style="padding:10px; text-align:left; font-size:13px; font-weight:700; color:var(--gray-900);">Actions</th>
            </tr>
        </thead>
        <tbody id="bookingsInlineTBody">
            <tr><td colspan="5" style="text-align:center; color:var(--gray-600); padding:16px;">Loading…</td></tr>
        </tbody>
    </table>
    </div>
</div>
<!-- Time Frame Modal -->
<!-- ========================= -->
<!-- TIME MODAL (Availability) -->
<!-- ========================= -->
<div id="timeModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.6); backdrop-filter:blur(4px);
    justify-content:center; align-items:center; z-index:9999;">
  <div style="background:white; padding:32px; border-radius:20px; width:440px; text-align:center; box-shadow:0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04); animation:modalSlideUp 0.3s ease-out;">
    <h3 style="margin:0 0 12px 0; font-size:22px; font-weight:700; color:var(--gray-900);">Set Available Time</h3>
    <p id="selectedDaysSummary" style="font-size:14px; color:var(--gray-600); margin-bottom:24px; line-height:1.5;"></p>

                <!-- Per-date ranges UI (each row shows Start / End on the left) -->
        <!-- Multiple ranges container for per-date overrides -->
        <div id="modalRangesContainer" class="availability-ui" style="display:flex; flex-direction:column; gap:8px; margin-top:12px;"></div>
        <div style="display:flex; justify-content:center; gap:8px; margin-top:8px;">
            <button type="button" id="addModalRangeBtn" style="padding:6px 10px; background:#007bff; color:white; border:none; border-radius:6px; cursor:pointer;">Add Range</button>
        </div>

    <div style="margin-top:24px; display:flex; justify-content:center; gap:10px; flex-wrap:wrap;">
      <button id="saveTimeBtn" 
              style="background:var(--primary-500); color:white; border:none; padding:12px 24px; 
                      border-radius:10px; cursor:pointer; font-weight:600; transition:all 0.2s ease; box-shadow:0 1px 3px rgba(0,0,0,0.1);">Save</button>
          <button id="resetToDefaultBtn" 
              style="background:var(--gray-600); color:white; border:none; padding:12px 24px; 
                  border-radius:10px; cursor:pointer; font-weight:600; transition:all 0.2s ease; box-shadow:0 1px 3px rgba(0,0,0,0.1);">Reset to default</button>
              <button id="makeUnavailableBtn"
                  style="background:var(--gray-700); color:white; border:none; padding:12px 24px; 
                         border-radius:10px; cursor:pointer; font-weight:600; transition:all 0.2s ease; box-shadow:0 1px 3px rgba(0,0,0,0.1); display:none;">Make Unavailable</button>
              <button id="makeAvailableBtn"
                  style="background:#06b6d4; color:white; border:none; padding:12px 24px; 
                         border-radius:10px; cursor:pointer; font-weight:600; transition:all 0.2s ease; box-shadow:0 1px 3px rgba(0,0,0,0.1); display:none;">Make Available</button>
      <button id="viewDayBtn" 
              style="background:var(--success-500); color:white; border:none; padding:12px 24px; 
                      border-radius:10px; cursor:pointer; font-weight:600; transition:all 0.2s ease; box-shadow:0 1px 3px rgba(0,0,0,0.1); display:none;">View Day Schedule</button>
      <button id="closeTimeBtn" 
              style="background:var(--gray-200); color:var(--gray-700); border:none; padding:12px 24px; border-radius:10px; cursor:pointer; font-weight:600; transition:all 0.2s ease;">Cancel</button>
    </div>    
  </div>
</div>


<!--==========================-->
<!--TIME CIRCLES-->
<!--==========================-->
<div id="timeCirclesModal" style="display:none; flex-direction:column; padding:10px; position:fixed; inset:0; 
     background:rgba(0,0,0,0.6); backdrop-filter:blur(4px); justify-content:center; align-items:center; z-index:10000; animation:fadeIn 0.2s ease-out;">
  <div style="background:white; padding:40px; border-radius:20px; width:640px; max-height:85vh; overflow-y:auto; position:relative; box-shadow:0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04); animation:modalSlideUp 0.3s ease-out;">

    <!-- Client-Facing Settings -->
    <div id="clientTimeSettings" style="margin-bottom: 32px; padding:20px; border-radius:12px; background:var(--gray-50);">
      <h3 style="margin:0 0 16px 0; font-size:16px; font-weight:700; color:var(--gray-900);">Client View Settings</h3>
      <div style="display:flex; gap:20px; align-items:center; flex-wrap:wrap;">
        <div>
          <label for="clientBlockSelect">Hour Block:</label><br>
          <select id="clientBlockSelect">
            <option value="1">1 Hour</option>
            <option value="2">2 Hours</option>
            <option value="3">3 Hours</option>
          </select>
        </div>
        <div>
          <label for="clientIncrementSelect">Increment:</label><br>
          <select id="clientIncrementSelect">
            <option value="15">15 min</option>
            <option value="30" selected>30 min</option>
            <option value="45">45 min</option>
            <option value="60">60 min</option>
          </select>
        </div>
        <div>
          <button id="saveClientSettingsBtn" 
                  style="padding:10px 20px; background:var(--primary-500); color:white; border:none; border-radius:8px; font-weight:600; cursor:pointer; transition:all 0.2s ease; box-shadow:0 1px 3px rgba(0,0,0,0.1);">
            Save for Client View
          </button>
        </div>
      </div>
    </div>

    <!-- Coach Preview Section -->
    <div id="coachTimeSettings" style="margin-bottom: 32px; padding:20px; border-radius:12px; background:var(--gray-50); flex-direction: column;">
        <h3 style="margin:0 0 16px 0; font-size:16px; font-weight:700; color:var(--gray-900);">Coach Preview Settings</h3>
        <div style="display:flex; gap:20px; align-items:center; flex-wrap:wrap;">
            <div>
            <label>Hour Block:</label><br>
            <select id="hourBlockSelect">
                <option value="1">1 Hour</option>
                <option value="2">2 Hours</option>
                <option value="3">3 Hours</option>
                <option value="custom">Custom</option>
            </select>
            </div>
            <div>
            <label>Increment:</label><br>
            <select id="incrementSelect">
                <option value="15">15 min</option>
                <option value="30" selected>30 min</option>
                <option value="45">45 min</option>
                <option value="60">60 min</option>
                <option value="custom">Custom</option>
            </select>
            </div>
        </div>

        <!-- Add these right below the dropdowns -->
        <div id="customBlockInputContainer" style="display:none; margin-top:10px; gap:5px; align-items:center;">
            <input type="number" id="customBlockInput" placeholder="Minutes" min="15"/>
            <button id="applyCustomBlockBtn">Apply</button>
        </div>

        <div id="customIncrementContainer" style="display:none; margin-top:10px; gap:5px; align-items:center;">
            <input type="number" id="customIncrementInput" placeholder="Minutes" min="5"/>
            <button id="applyCustomIncrementBtn">Apply</button>
        </div>
        </div>

    <!-- Circle Title & Container -->
    <div id="circleModalTitle" style="font-weight:bold; font-size:16px;"></div>
    <div id="timeCirclesContainer" style="display:flex; flex-direction:column; gap:40px;"></div>

    <!-- Close "X" -->
    <button id="closeCirclesBtn" 
            style="position:absolute; top:10px; right:10px; background:none; border:none; font-size:20px; cursor:pointer;">✖</button>

  </div>
</div>

<!-- ========================= -->
<!-- BOOKING MODAL (Client Info) -->
<!-- ========================= -->
<div id="bookingModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.6); backdrop-filter:blur(4px); justify-content:center; align-items:center; z-index:10000; animation:fadeIn 0.2s ease-out;">
  <div style="background:white; padding:32px; border-radius:20px; width:480px; box-shadow:0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04); animation:modalSlideUp 0.3s ease-out;">
    <h3 id="bookingTitle" style="margin:0 0 20px 0; font-size:22px; font-weight:700; color:var(--gray-900);">Booking Details</h3>
    <div style="margin-bottom:16px; padding:16px; background:var(--gray-50); border-radius:12px;">
      <p style="margin:8px 0; color:var(--gray-700);"><strong style="color:var(--gray-900); font-weight:600;">Client:</strong> <span id="clientName"></span></p>
      <p style="margin:8px 0; color:var(--gray-700);"><strong style="color:var(--gray-900); font-weight:600;">Lesson Type:</strong> <span id="lessonType"></span></p>
      <p style="margin:8px 0; color:var(--gray-700);"><strong style="color:var(--gray-900); font-weight:600;">Time:</strong> <span id="lessonTime"></span></p>
      <p style="margin:8px 0; color:var(--gray-700);"><strong style="color:var(--gray-900); font-weight:600;">Payment:</strong> <span id="paymentMethod"></span></p>
    </div>

    <div style="margin-top:24px; display:flex; justify-content:space-between; gap:12px;">
      <button id="viewClientBookingsBtn" 
              style="flex:1; background:var(--primary-500); color:white; border:none; padding:12px 20px; border-radius:10px; cursor:pointer; font-weight:600; transition:all 0.2s ease; box-shadow:0 1px 3px rgba(0,0,0,0.1);">
        View All Bookings
      </button>
      <button id="closeBookingBtn" 
              style="background:var(--gray-200); color:var(--gray-700); border:none; padding:12px 20px; border-radius:10px; cursor:pointer; font-weight:600; transition:all 0.2s ease;">
        Close
      </button>
    </div>
  </div>
</div>


{% endblock %}

<!-- -------------------------
     Calendar JS
------------------------- -->
{% block extra_scripts %}
<script>
document.addEventListener('DOMContentLoaded', function() {
        // Quick debug indicator to confirm the script runs
        try { console.log('edit_coach_profile: DOMContentLoaded start'); } catch(e){}
        // Helper to read CSRF token from cookie (used by fetch calls)
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }
        const csrftoken = getCookie('csrftoken');
        // -----------------------------
        // 1️⃣ Initialize default availability from server (fall back to sensible defaults)
        // -----------------------------
        const serverAvail = {{ coach_availability_json|default:"{}"|safe }} || {};
        const weekdayNames = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];

        // Build defaultAvailability with all days unavailable initially
        const defaultAvailability = {};
        for (let i = 0; i < 7; i++) {
            defaultAvailability[i] = { start: '09:00', end: '17:00', unavailable: true, ranges: [] };
        }

        // Server may return either:
        // 1) an array of records: [{ day_of_week: 0..6, ranges: [...], unavailable: boolean }, ...]
        // 2) a mapping object: { "Sunday": ["09:00-17:00"], "Tuesday": [...] }
        if (Array.isArray(serverAvail)) {
            serverAvail.forEach(item => {
                // Expect backend to use 0=Sunday..6=Saturday. Accept numeric strings too.
                let dayIndex = null;
                if (typeof item.day_of_week === 'number') dayIndex = item.day_of_week;
                else if (typeof item.day_of_week === 'string' && item.day_of_week.trim() !== '') dayIndex = parseInt(item.day_of_week, 10);
                if (isNaN(dayIndex) || dayIndex === null) return;
                dayIndex = ((dayIndex % 7) + 7) % 7; // normalize to 0..6

                defaultAvailability[dayIndex].unavailable = !!item.unavailable;
                defaultAvailability[dayIndex].ranges = item.ranges || [];

                if (item.ranges?.length > 0) {
                    const [start, end] = item.ranges[0].split("-");
                    defaultAvailability[dayIndex].start = start;
                    defaultAvailability[dayIndex].end = end;
                }
            });
        } else if (serverAvail && typeof serverAvail === 'object') {
            // serverAvail is a dict keyed by weekday names
            Object.entries(serverAvail).forEach(([dayName, slots]) => {
                try {
                    const dn = String(dayName).trim();
                    const idx = weekdayNames.indexOf(dn);
                    if (idx === -1) return;
                    if (!Array.isArray(slots) || slots.length === 0) {
                        // empty means unavailable
                        defaultAvailability[idx].unavailable = true;
                        defaultAvailability[idx].ranges = [];
                    } else {
                        defaultAvailability[idx].unavailable = false;
                        defaultAvailability[idx].ranges = slots;
                        const first = slots[0];
                        if (first && first.includes('-')) {
                            const [s,e] = first.split('-');
                            defaultAvailability[idx].start = s.trim();
                            defaultAvailability[idx].end = e.trim();
                        }
                    }
                } catch (e) { /* ignore malformed entries */ }
            });
        }

    // -----------------------------
    // 2️⃣ Helper: is date in the past
    // -----------------------------
    function isPastDate(dateStr) {
        const today = new Date();
        const date = parseYMD(dateStr);
        const todayMidnight = new Date(today.getFullYear(), today.getMonth(), today.getDate());
        return date < todayMidnight;
    }

    
    function updateUnavailableDays() {
        // Compute per-date full-day blocks from background events (so per-date overrides take precedence)
        const blockedDates = new Set();
        const availableOverrideDates = new Set();
        try {
            calendar.getEvents().forEach(ev => {
                try {
                    const props = ev.extendedProps || {};
                    if (props.override_type === 'blocked') {
                        blockedDates.add(ev.startStr.split('T')[0]);
                    } else if (props.override_type === 'available') {
                        availableOverrideDates.add(ev.startStr.split('T')[0]);
                    }
                } catch (e) { /* ignore per-event parse errors */ }
            });
        } catch (e) { /* ignore if calendar.getEvents fails */ }

        document.querySelectorAll('.fc-daygrid-day').forEach(dayCell => {
            const dateStr = dayCell.dataset.date; // e.g., "2025-11-19"
            if (!dateStr) return;
            const dayIndex = parseYMD(dateStr).getDay(); // 0=Sunday..6=Saturday (local parse)
            const isPast = isPastDate(dateStr);

            // Past dates should be visually distinct (greyed circle) but NOT treated as
            // "unavailable" in the sense of future availability settings. Unavailable
            // is a future-facing user setting and should not be applied retroactively.
            if (isPast) {
                dayCell.classList.remove('fc-day-unavailable');
                dayCell.classList.remove('fc-day-available');
                dayCell.classList.add('fc-day-past');
                const num = dayCell.querySelector('.fc-daygrid-day-number');
                if (num) {
                    num.classList.add('past-day');
                    num.classList.remove('unavailable-number');
                    num.style.cursor = 'default';
                }
                return; // skip further unavailable/available processing for past dates
            }

            // Use classes to indicate available/unavailable so styles remain consistent
            // Precedence: per-date full-day blocks (unavailable) > per-date available overrides > weekly defaults
            if (blockedDates.has(dateStr)) {
                dayCell.classList.add('fc-day-unavailable');
                dayCell.classList.remove('fc-day-available');
                const num = dayCell.querySelector('.fc-daygrid-day-number');
                if (num) {
                    num.classList.add('unavailable-number');
                    num.style.cursor = 'pointer';
                }
            } else if (availableOverrideDates.has(dateStr)) {
                dayCell.classList.add('fc-day-available');
                dayCell.classList.remove('fc-day-unavailable');
                const num = dayCell.querySelector('.fc-daygrid-day-number');
                if (num) {
                    num.classList.remove('unavailable-number');
                    num.style.cursor = 'pointer';
                }
            } else if (defaultAvailability[dayIndex]?.unavailable) {
                dayCell.classList.add('fc-day-unavailable');
                dayCell.classList.remove('fc-day-available');
                const num = dayCell.querySelector('.fc-daygrid-day-number');
                if (num) {
                    num.classList.add('unavailable-number');
                    num.style.cursor = 'pointer';
                }
            } else {
                dayCell.classList.add('fc-day-available');
                dayCell.classList.remove('fc-day-unavailable');
                const num = dayCell.querySelector('.fc-daygrid-day-number');
                if (num) {
                    num.classList.remove('unavailable-number');
                    num.style.cursor = 'pointer';
                }
            }
        });
        // After updating day classes, refresh the overrides table so it reflects per-date overrides
        try { renderOverridesTable(); } catch (e) { console.warn('renderOverridesTable failed', e); }
    }

    // -----------------------------
    // 3️⃣ Render default availability table
    // -----------------------------
    // Global Custom Time Picker accessible across contexts
    function createCustomTimePickerGlobal(inputElement) {
        const picker = document.createElement('div');
        picker.className = 'custom-time-picker';

        const [initialHour, initialMinute] = (inputElement.value || '09:00').split(':');
        let selectedHour = initialHour;
        let selectedMinute = initialMinute;

        const isStart = inputElement.classList.contains('modal-range-start') || inputElement.classList.contains('range-start');
        const headerText = isStart ? 'Start Time' : 'End Time';

        picker.innerHTML = `
            <div class="time-picker-header">${headerText}</div>
            <div class="time-picker-display">${formatDisplayTime(selectedHour, selectedMinute)}</div>
            <div class="time-picker-selectors">
                <div class="time-selector">
                    <div class="time-selector-label">Hour</div>
                    <div class="time-scroll-container" data-type="hour"></div>
                </div>
                <div class="time-selector">
                    <div class="time-selector-label">Minute</div>
                    <div class="time-scroll-container" data-type="minute"></div>
                </div>
            </div>
            <div class="time-picker-actions">
                <button class="time-picker-btn cancel">Cancel</button>
                <button class="time-picker-btn confirm">Confirm</button>
            </div>
        `;

        const hourContainer = picker.querySelector('[data-type="hour"]');
        for (let h = 0; h < 24; h++) {
            const hourStr = String(h).padStart(2, '0');
            const opt = document.createElement('div');
            opt.className = 'time-option';
            if (hourStr === selectedHour) opt.classList.add('selected');
            opt.textContent = formatHour(h);
            opt.addEventListener('click', () => {
                hourContainer.querySelectorAll('.time-option').forEach(o => o.classList.remove('selected'));
                opt.classList.add('selected');
                selectedHour = hourStr;
                updateDisplay();
                opt.scrollIntoView({ behavior: 'smooth', block: 'center' });
            });
            hourContainer.appendChild(opt);
        }

        const minuteContainer = picker.querySelector('[data-type="minute"]');
        for (let m = 0; m < 60; m++) {
            const minStr = String(m).padStart(2, '0');
            const opt = document.createElement('div');
            opt.className = 'time-option';
            if (minStr === selectedMinute) opt.classList.add('selected');
            opt.textContent = minStr;
            opt.addEventListener('click', () => {
                minuteContainer.querySelectorAll('.time-option').forEach(o => o.classList.remove('selected'));
                opt.classList.add('selected');
                selectedMinute = minStr;
                updateDisplay();
                opt.scrollIntoView({ behavior: 'smooth', block: 'center' });
            });
            minuteContainer.appendChild(opt);
        }

        function updateDisplay() {
            picker.querySelector('.time-picker-display').textContent = formatDisplayTime(selectedHour, selectedMinute);
        }
        function formatHour(h) {
            if (h === 0) return '12 AM';
            if (h < 12) return `${h} AM`;
            if (h === 12) return '12 PM';
            return `${h - 12} PM`;
        }
        function formatDisplayTime(h, m) {
            const hour = parseInt(h);
            const ampm = hour >= 12 ? 'PM' : 'AM';
            const h12 = hour === 0 ? 12 : (hour > 12 ? hour - 12 : hour);
            return `${h12}:${m} ${ampm}`;
        }

        setTimeout(() => {
            hourContainer.querySelector('.selected')?.scrollIntoView({ block: 'center' });
            minuteContainer.querySelector('.selected')?.scrollIntoView({ block: 'center' });
        }, 50);

        picker.querySelector('.confirm').addEventListener('click', (e) => {
            e.stopPropagation();
            inputElement.value = `${selectedHour}:${selectedMinute}`;
            picker.remove();
        });
        picker.querySelector('.cancel').addEventListener('click', (e) => {
            e.stopPropagation();
            picker.remove();
        });
        setTimeout(() => {
            document.addEventListener('click', function closeOnOutside(e) {
                if (!picker.contains(e.target) && e.target !== inputElement) {
                    picker.remove();
                    document.removeEventListener('click', closeOnOutside);
                }
            });
        }, 100);

        return picker;
    }

    function displayDefaultAvailability() {
        const container = document.getElementById("defaultAvailabilityTable");
        container.innerHTML = "";
        const days = ["Sunday", "Monday","Tuesday","Wednesday","Thursday","Friday", "Saturday"];

        // Custom Time Picker Creator
        function createCustomTimePicker(inputElement) {
            const picker = document.createElement('div');
            picker.className = 'custom-time-picker';
            
            const [initialHour, initialMinute] = (inputElement.value || '09:00').split(':');
            let selectedHour = initialHour;
            let selectedMinute = initialMinute;
            
            picker.innerHTML = `
                <div class="time-picker-header">Select Time</div>
                <div class="time-picker-display">${formatDisplayTime(selectedHour, selectedMinute)}</div>
                <div class="time-picker-selectors">
                    <div class="time-selector">
                        <div class="time-selector-label">Hour</div>
                        <div class="time-scroll-container" data-type="hour"></div>
                    </div>
                    <div class="time-selector">
                        <div class="time-selector-label">Minute</div>
                        <div class="time-scroll-container" data-type="minute"></div>
                    </div>
                </div>
                <div class="time-picker-actions">
                    <button class="time-picker-btn cancel">Cancel</button>
                    <button class="time-picker-btn confirm">Confirm</button>
                </div>
            `;
            
            // Populate hours (0-23)
            const hourContainer = picker.querySelector('[data-type="hour"]');
            for (let h = 0; h < 24; h++) {
                const hourStr = String(h).padStart(2, '0');
                const opt = document.createElement('div');
                opt.className = 'time-option';
                if (hourStr === selectedHour) opt.classList.add('selected');
                opt.textContent = formatHour(h);
                opt.addEventListener('click', () => {
                    hourContainer.querySelectorAll('.time-option').forEach(o => o.classList.remove('selected'));
                    opt.classList.add('selected');
                    selectedHour = hourStr;
                    updateDisplay();
                    opt.scrollIntoView({ behavior: 'smooth', block: 'center' });
                });
                hourContainer.appendChild(opt);
            }
            
            // Populate minutes (00-59)
            const minuteContainer = picker.querySelector('[data-type="minute"]');
            for (let m = 0; m < 60; m++) {
                const minStr = String(m).padStart(2, '0');
                const opt = document.createElement('div');
                opt.className = 'time-option';
                if (minStr === selectedMinute) opt.classList.add('selected');
                opt.textContent = minStr;
                opt.addEventListener('click', () => {
                    minuteContainer.querySelectorAll('.time-option').forEach(o => o.classList.remove('selected'));
                    opt.classList.add('selected');
                    selectedMinute = minStr;
                    updateDisplay();
                    opt.scrollIntoView({ behavior: 'smooth', block: 'center' });
                });
                minuteContainer.appendChild(opt);
            }
            
            function updateDisplay() {
                picker.querySelector('.time-picker-display').textContent = formatDisplayTime(selectedHour, selectedMinute);
            }
            
            function formatHour(h) {
                if (h === 0) return '12 AM';
                if (h < 12) return `${h} AM`;
                if (h === 12) return '12 PM';
                return `${h - 12} PM`;
            }
            
            function formatDisplayTime(h, m) {
                const hour = parseInt(h);
                const ampm = hour >= 12 ? 'PM' : 'AM';
                const h12 = hour === 0 ? 12 : (hour > 12 ? hour - 12 : hour);
                return `${h12}:${m} ${ampm}`;
            }
            
            // Scroll selected items into view
            setTimeout(() => {
                hourContainer.querySelector('.selected')?.scrollIntoView({ block: 'center' });
                minuteContainer.querySelector('.selected')?.scrollIntoView({ block: 'center' });
            }, 50);
            
            // Confirm button
            picker.querySelector('.confirm').addEventListener('click', (e) => {
                e.stopPropagation();
                inputElement.value = `${selectedHour}:${selectedMinute}`;
                picker.remove();
            });
            
            // Cancel button
            picker.querySelector('.cancel').addEventListener('click', (e) => {
                e.stopPropagation();
                picker.remove();
            });
            
            // Close on outside click
            setTimeout(() => {
                document.addEventListener('click', function closeOnOutside(e) {
                    if (!picker.contains(e.target) && e.target !== inputElement) {
                        picker.remove();
                        document.removeEventListener('click', closeOnOutside);
                    }
                });
            }, 100);
            
            return picker;
        }

        // Helper to create a single range row (start/end + remove)
        function createRangeRow(dayIndex, startVal = '', endVal = '') {
            const row = document.createElement('div');
            row.className = 'range-row';

            // Wrap start input in positioned container
            const startContainer = document.createElement('div');
            startContainer.className = 'time-input-container';
            
            const start = document.createElement('input');
            start.type = 'time';
            start.className = 'range-start';
            start.value = startVal || '09:00';
            start.readOnly = true;
            start.style.cursor = 'pointer';
            
            start.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                // Remove any existing pickers
                document.querySelectorAll('.custom-time-picker').forEach(p => p.remove());
                
                const picker = (typeof createCustomTimePickerGlobal === 'function' ? createCustomTimePickerGlobal : createCustomTimePicker)(start);
                picker.classList.add('active');
                startContainer.appendChild(picker);
            });
            
            startContainer.appendChild(start);

            // Wrap end input in positioned container
            const endContainer = document.createElement('div');
            endContainer.className = 'time-input-container';
            
            const end = document.createElement('input');
            end.type = 'time';
            end.className = 'range-end';
            end.value = endVal || '17:00';
            end.readOnly = true;
            end.style.cursor = 'pointer';
            
            end.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                // Remove any existing pickers
                document.querySelectorAll('.custom-time-picker').forEach(p => p.remove());
                
                const picker = (typeof createCustomTimePickerGlobal === 'function' ? createCustomTimePickerGlobal : createCustomTimePicker)(end);
                picker.classList.add('active');
                endContainer.appendChild(picker);
            });
            
            endContainer.appendChild(end);

            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'remove-range-btn';
            removeBtn.setAttribute('aria-label', 'Remove range');
            removeBtn.innerHTML = '<span class="remove-icon" aria-hidden="true">✖</span>';
            removeBtn.addEventListener('click', () => row.remove());

            row.appendChild(startContainer);
            row.appendChild(endContainer);
            row.appendChild(removeBtn);

            return row;
        }

        days.forEach((dayName, i) => {
            const dayIndex = i;
            const row = document.createElement('tr');

            row.innerHTML = `
                <td style="vertical-align:top; padding-top:10px; white-space:nowrap;">${dayName}</td>
                <td colspan="2" style="vertical-align:top; padding-left:24px;">
                    <div id="ranges-container-${dayIndex}" style="display:flex; flex-direction:column; gap:4px;"></div>
                    <div style="margin-top:6px;"><button type="button" class="add-range-btn" data-day="${dayIndex}" style="padding:6px 10px; background:#007bff; color:white; border:none; border-radius:6px; cursor:pointer;">Add range</button></div>
                </td>
                <td style="text-align:right; vertical-align:top; padding-top:18px; padding-right:8px;"><input type="checkbox" class="unavailable-checkbox" data-day="${dayIndex}" ${defaultAvailability[dayIndex].unavailable ? "checked" : ""}></td>
            `;

            container.appendChild(row);

            const rangesContainer = document.getElementById(`ranges-container-${dayIndex}`);
            const existing = defaultAvailability[dayIndex].ranges || [];
            if (existing.length) {
                existing.forEach(r => {
                    const parts = r.split('-');
                    const s = parts[0] ? parts[0].trim() : '09:00';
                    const e = parts[1] ? parts[1].trim() : '17:00';
                    rangesContainer.appendChild(createRangeRow(dayIndex, s, e));
                });
            } else {
                // if not unavailable, add a single blank row
                if (!defaultAvailability[dayIndex].unavailable) {
                    rangesContainer.appendChild(createRangeRow(dayIndex, defaultAvailability[dayIndex].start || '09:00', defaultAvailability[dayIndex].end || '17:00'));
                }
            }

            // Add button handler
            const addBtn = row.querySelector('.add-range-btn');
            addBtn.addEventListener('click', () => {
                rangesContainer.appendChild(createRangeRow(dayIndex, '09:00', '17:00'));
            });
        });

        // Handle unavailable checkbox toggles (disable ranges UI when unavailable)
        // NOTE: do NOT apply changes to the calendar immediately here. Changes should
        // be saved by clicking the Save Defaults button. This prevents premature
        // application of availability while the user is still editing the defaults.
        document.querySelectorAll('.unavailable-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', function() {
                const day = this.dataset.day;
                // Update the in-memory defaultAvailability but do not mutate calendar yet
                defaultAvailability[day].unavailable = this.checked;
                const containerEl = document.getElementById(`ranges-container-${day}`);
                const addBtn = document.querySelector(`.add-range-btn[data-day='${day}']`);
                if (this.checked) {
                    // hide/disable ranges
                    containerEl.style.opacity = '0.5';
                    containerEl.querySelectorAll('input').forEach(i => i.disabled = true);
                    addBtn.disabled = true;
                } else {
                    containerEl.style.opacity = '1';
                    // If there are no existing range rows (user just toggled available), add a default range row
                    if (!containerEl.querySelectorAll('.range-row').length) {
                        const start = defaultAvailability[day].start || '09:00';
                        const end = defaultAvailability[day].end || '17:00';
                        containerEl.appendChild(createRangeRow(day, start, end));
                    }
                    containerEl.querySelectorAll('input').forEach(i => i.disabled = false);
                    addBtn.disabled = false;
                }
                // Do not call updateUnavailableDays() here; wait for Save Defaults to apply
            });
            // Trigger initial state (this will only set UI inputs; calendar not updated until save)
            checkbox.dispatchEvent(new Event('change'));
        });

        // Save handler (use onclick to avoid duplicate listeners)
        const saveBtn = document.getElementById('saveDefaultAvailabilityBtn');
        saveBtn.onclick = async function() {
            // Build payload from dynamic inputs
            const payload = [];
            for (let day = 0; day < 7; day++) {
                const containerEl = document.getElementById(`ranges-container-${day}`);
                const rows = containerEl ? Array.from(containerEl.querySelectorAll('.range-row')) : [];
                const ranges = [];
                let invalid = false;
                for (const r of rows) {
                    const s = r.querySelector('.range-start').value;
                    const e = r.querySelector('.range-end').value;
                    if (!s || !e) continue;
                    if (s >= e) {
                        alert(`Invalid range for ${days[day]}: start must be before end (${s} >= ${e})`);
                        invalid = true;
                        break;
                    }
                    ranges.push(`${s}-${e}`);
                }
                if (invalid) return;
                const unavailable = !!document.querySelector(`.unavailable-checkbox[data-day='${day}']`).checked;
                // Backend accepts day names or numeric; send full day name for clarity
                payload.push({ day: days[day], ranges: ranges, unavailable: unavailable });
            }

            // Debug: show payload about to be sent to server (days sent as names)
            console.log('Saving weekly availability payload (day names):', JSON.parse(JSON.stringify(payload)));

            try {
                const res = await fetch(`/bus/${orgSlug}/availability/save/`, {
                    method: 'POST',
                    credentials: 'same-origin',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrftoken
                    },
                    body: JSON.stringify({ availability: payload })
                });

                const data = await res.json().catch(() => null);
                if (res.ok && data && data.success) {
                    alert('Weekly availability saved!');

                    // Update local defaultAvailability from payload so the UI reflects saved values immediately
                    try {
                        payload.forEach(item => {
                            let dayIdx = null;
                            if (typeof item.day === 'number') dayIdx = item.day;
                            else if (typeof item.day === 'string') {
                                const name = item.day.trim();
                                // try to match full weekday name first
                                const idx = weekdayNames.indexOf(name);
                                if (idx !== -1) dayIdx = idx;
                                else {
                                    // try numeric string
                                    const asNum = parseInt(name, 10);
                                    if (!isNaN(asNum)) dayIdx = ((asNum % 7) + 7) % 7;
                                }
                            }
                            if (dayIdx === null || typeof dayIdx !== 'number' || isNaN(dayIdx)) return;
                            // apply values
                            defaultAvailability[dayIdx].unavailable = !!item.unavailable;
                            defaultAvailability[dayIdx].ranges = Array.isArray(item.ranges) ? item.ranges.slice() : [];
                            if (defaultAvailability[dayIdx].ranges && defaultAvailability[dayIdx].ranges.length) {
                                const first = defaultAvailability[dayIdx].ranges[0];
                                if (first && first.includes('-')) {
                                    const [s,e] = first.split('-');
                                    defaultAvailability[dayIdx].start = s.trim();
                                    defaultAvailability[dayIdx].end = e.trim();
                                }
                            }
                        });
                    } catch (e) { console.warn('Failed to update local defaults after save', e); }

                    // Re-render inputs and calendar backgrounds immediately
                    try { displayDefaultAvailability(); } catch (e) { console.warn('displayDefaultAvailability failed', e); }
                    try { syncAvailabilityToCalendar(); } catch (e) { console.warn('syncAvailabilityToCalendar failed', e); }
                    try { updateUnavailableDays(); } catch (e) { console.warn('updateUnavailableDays failed', e); }
                    // Also refetch server events to pick up any server-side overrides
                    try { calendar.refetchEvents(); } catch (e) { /* ignore */ }
                } else {
                    const msg = (data && (data.error || data.message)) || `Server returned ${res.status}`;
                    alert('Error saving availability: ' + msg);
                }
            } catch (err) {
                console.error('Save failed', err);
                alert('Error saving availability: ' + err.message);
            }
        };
    }

    const calendarEl = document.getElementById('calendar');
    const clearBtn = document.getElementById('clearSelectionBtn');
    const selectBtn = document.getElementById('selectDaysBtn');
     const retryInitBtn = document.getElementById('retryInitCalendarBtn');
    if (retryInitBtn) retryInitBtn.addEventListener('click', () => { try { location.reload(); } catch(e){} });
    
    const orgSlug = "{{ organization.slug }}";
    const orgTimezone = "{{ org_timezone }}";  // e.g., 'America/Los_Angeles'
     
    if (!calendarEl) return;

    let selectedDates = new Set();
    let isDragging = false;
    let dragStartDate = null;
    let dragMode = null;
    let dragStartIsUnavailable = false;

    let calendar = null;
    try {
        calendar = new FullCalendar.Calendar(calendarEl, {
        initialView: 'dayGridMonth',
        height: 'auto',
        selectable: false, // disable default selection highlight
        editable: false,
        events: `/bus/${orgSlug}/events/`,
        headerToolbar: { left: 'prev', center: 'title', right: 'next' },
        showNonCurrentDates: false,
        dayMaxEvents: true,
        eventsSet: function(events) {
            // After events load/refetch, recompute override/past/unavailable visuals & table
            try { updateUnavailableDays(); } catch(e) { console.warn('eventsSet updateUnavailableDays failed', e); }
            try { if (typeof renderOverridesTable === 'function') renderOverridesTable(); } catch(e) { console.warn('eventsSet renderOverridesTable failed', e); }
            try { styleOverridesTable(); } catch(e) { /* ignore */ }
            try { if (typeof renderInlineBookings === 'function') renderInlineBookings(); } catch(e) { console.warn('eventsSet renderInlineBookings failed', e); }
            try {
                const span = document.getElementById('overridesHeaderMonth');
                if (span && calendar) {
                    const currentDate = calendar.getDate ? calendar.getDate() : new Date();
                    const monthName = currentDate.toLocaleString('default', { month: 'long' });
                    span.textContent = monthName;
                }
            } catch (e) { /* ignore */ }
        },

         // Handle selection in timeGridDay view
        select: function(info) {
            if (calendar.view.type === 'timeGridDay') {
                handleTimeSlotSelection(info);
            }
        },

        // Handle click on existing event (a booked session)
        datesSet: function() {
            try {
                // Compute per-date full-day blocks from background events so per-date overrides
                // (created via make_unavailable) take precedence over weekly defaults.
                const blockedDates = new Set();
                const availableOverrideDates = new Set();
                try {
                    calendar.getEvents().forEach(ev => {
                        try {
                            const props = ev.extendedProps || {};
                            if (props.override_type === 'blocked') {
                                const s = ev.startStr.split('T')[0];
                                blockedDates.add(s);
                            } else if (props.override_type === 'available') {
                                const s = ev.startStr.split('T')[0];
                                availableOverrideDates.add(s);
                            }
                        } catch (e) { /* ignore single event errors */ }
                    });
                } catch (e) { /* ignore if calendar.getEvents fails */ }

                document.querySelectorAll('.fc-daygrid-day').forEach(dayCell => {
                    const dateStr = dayCell.dataset.date;
                    if (!dateStr) return;
                    const dow = parseYMD(dateStr).getDay(); // 0=Sunday (local parse)
                    const info = defaultAvailability[dow] || {};


                                // Hide trailing weeks comprised only of out-of-month days
                                try { hideTrailingOtherRows(); } catch (e) { /* ignore */ }
                    // Precedence: per-date full-day blocks (unavailable) > per-date available overrides > weekly defaults
                    if (blockedDates.has(dateStr)) {
                        dayCell.classList.add('fc-day-unavailable');
                        dayCell.classList.remove('fc-day-available');
                    } else if (availableOverrideDates.has(dateStr)) {
                        dayCell.classList.add('fc-day-available');
                        dayCell.classList.remove('fc-day-unavailable');
                    } else if (info.unavailable) {
                        dayCell.classList.add('fc-day-unavailable');
                        dayCell.classList.remove('fc-day-available');
                    } else {
                        dayCell.classList.add('fc-day-available');
                        dayCell.classList.remove('fc-day-unavailable');
                    }

                    // ensure frame transparent (we use classes for styling)
                    dayCell.style.background = 'transparent';
                    // Ensure the day number is always clickable so coaches can create per-day overrides
                    const numberEl = dayCell.querySelector('.fc-daygrid-day-number');
                    if (numberEl) {
                        // Even if default is unavailable, make cursor pointer so it's clear it's interactive
                        numberEl.style.cursor = 'pointer';
                        // No per-element onclick here — we use a single delegated pointerup handler
                    }
                });
            } catch (err) {
                console.error('datesSet handler error', err);
            }
        }
        });
    } catch (err) {
        console.error('FullCalendar initialization failed', err);
        calendarEl.innerHTML = '<div style="color:#721c24;background:#f8d7da;border:1px solid #f5c6cb;padding:12px;border-radius:6px;">Calendar failed to initialize. Check browser console for errors (see server console too).</div>';
        return; // abort further calendar-related setup to avoid runtime errors
    }

    // Render the calendar so DOM/date cells exist for later manipulation
    try { calendar.render(); } catch (e) { console.warn('calendar.render failed', e); }

    // Relocate calendar controls below the month title on mobile, revert on desktop
    function relocateCalendarControls() {
        const controls = document.getElementById('calendar-controls');
        const cal = document.getElementById('calendar');
        if (!controls || !cal) return;
        const isMobile = window.matchMedia('(max-width: 768px)').matches;
        const toolbar = cal.querySelector('.fc-header-toolbar');
        if (isMobile && toolbar) {
            if (controls.dataset.inHeader !== '1') {
                controls.dataset.inHeader = '1';
                // Ensure inline layout
                controls.style.position = 'static';
                controls.style.left = '';
                controls.style.top = '';
                controls.style.transform = 'none';
                toolbar.insertAdjacentElement('afterend', controls);
            }
        } else {
            if (controls.dataset.inHeader === '1') {
                controls.dataset.inHeader = '';
                const parent = cal.parentElement; // calendar column container
                if (parent) parent.appendChild(controls);
                // Restore desktop overlay positioning
                controls.style.position = 'absolute';
                controls.style.left = '50%';
                controls.style.top = '80px';
                controls.style.transform = 'translateX(-50%)';
            }
        }
    }
    try { relocateCalendarControls(); } catch (e) {}
    try { window.addEventListener('resize', relocateCalendarControls); } catch (e) {}

    // Remove trailing extra rows made of only other-month days
    try { hideTrailingOtherRows(); } catch (e) { /* ignore */ }

    // Initial styling for overrides table (badges + animated buttons)
    try { styleOverridesTable(); } catch (e) { /* ignore */ }

    // Inline bookings: render bookings for the current visible calendar range
    function renderInlineBookings() {
        const tbody = document.getElementById('bookingsInlineTBody');
        if (!tbody || !calendar) return;

        const view = calendar.view;
        const rangeStart = view && view.activeStart ? view.activeStart : null;
        const rangeEnd = view && view.activeEnd ? view.activeEnd : null;

        // Gather events already loaded in calendar and filter to real bookings only
        let events = [];
        try { events = calendar.getEvents() || []; } catch (e) { events = []; }
        const bookings = events.filter(ev => {
            try {
                const xp = ev.extendedProps || {};
                if (xp.is_blocking || xp.is_per_date || ev.display === 'background') return false;
                if (rangeStart && ev.start < rangeStart) return false;
                if (rangeEnd && ev.start >= rangeEnd) return false;
                return true;
            } catch (_) { return false; }
        }).sort((a,b) => (a.start?.getTime()||0) - (b.start?.getTime()||0));

        const search = (document.getElementById('bookingsSearchInline')?.value || '').toLowerCase();
        const filtered = bookings.filter(ev => {
            const xp = ev.extendedProps || {};
            const name = (xp.client_name || xp.customer_name || '').toLowerCase();
            const email = (xp.client_email || xp.customer_email || '').toLowerCase();
            return !search || name.includes(search) || email.includes(search);
        });

        tbody.innerHTML = '';
        if (filtered.length === 0) {
            tbody.innerHTML = '<tr><td colspan="5" style="text-align:center; color:var(--gray-600); padding:16px;">No bookings for this period</td></tr>';
            return;
        }

        const todayStr = new Date().toDateString();
        filtered.forEach(ev => {
            const tr = document.createElement('tr');
            tr.style.borderBottom = '1px solid var(--gray-200)';

            const xp = ev.extendedProps || {};
            const client = xp.client_name || xp.customer_name || '—';
            const email = xp.client_email || xp.customer_email || '';
            const service = ev.title || xp.service_name || '—';
            const start = ev.start;
            const end = ev.end || null;

            let status = 'Upcoming';
            if (start) {
                const startDay = start.toDateString();
                if (startDay === todayStr) status = 'Today';
                else if (start < new Date()) status = 'Past';
            }

            const tdDT = document.createElement('td');
            tdDT.style.padding = '10px';
            tdDT.innerHTML = start ? `<div style="font-weight:600;">${start.toLocaleDateString()}</div><div style="font-size:13px; color:var(--gray-600);">${start.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}${end ? ' - ' + end.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}) : ''}</div>` : '—';

            const tdClient = document.createElement('td');
            tdClient.style.padding = '10px';
            tdClient.innerHTML = `<div style="font-weight:600;">${client}</div><div style="font-size:13px; color:var(--gray-600);">${email}</div>`;

            const tdService = document.createElement('td');
            tdService.style.padding = '10px';
            tdService.textContent = service;

            const tdStatus = document.createElement('td');
            tdStatus.style.padding = '10px';
            const badgeMap = { Today: ['#d4edda','#155724'], Past:['#d6d8db','#383d41'], Upcoming:['#d1ecf1','#0c5460'] };
            const [bg, fg] = badgeMap[status] || ['#eee','#444'];
            tdStatus.innerHTML = `<span style="padding:4px 8px; border-radius:4px; font-size:12px; font-weight:600; background:${bg}; color:${fg};">${status}</span>`;

            const tdActions = document.createElement('td');
            tdActions.style.padding = '10px';
            const viewBtn = document.createElement('button');
            viewBtn.type = 'button';
            viewBtn.textContent = 'View';
            viewBtn.style.cssText = 'padding:6px 10px; background:var(--primary-500); color:white; border:none; border-radius:6px; cursor:pointer;';
            viewBtn.onclick = () => {
                try { openBookingModal(ev); } catch (e) { console.error('openBookingModal failed', e); }
            };
            tdActions.appendChild(viewBtn);

            tr.appendChild(tdDT);
            tr.appendChild(tdClient);
            tr.appendChild(tdService);
            tr.appendChild(tdStatus);
            tr.appendChild(tdActions);
            tbody.appendChild(tr);
        });
    }

    // Search and manual refresh handlers
    try {
        document.getElementById('bookingsSearchInline')?.addEventListener('input', () => renderInlineBookings());
        document.getElementById('bookingsRefreshBtn')?.addEventListener('click', () => renderInlineBookings());
    } catch (_) {}

    // Initial render
    try { renderInlineBookings(); } catch (_) {}

    // Render the default availability UI and sync backgrounds to the calendar
    try { displayDefaultAvailability(); } catch (e) { console.warn('displayDefaultAvailability failed', e); }
    try { syncAvailabilityToCalendar(); } catch (e) { console.warn('syncAvailabilityToCalendar failed', e); }
    try { updateUnavailableDays(); } catch (e) { console.warn('updateUnavailableDays failed', e); }
    try { reapplySelections(); } catch (e) { /* optional */ }
    try { updateClearButton(); } catch (e) { /* optional */ }

    // Minimal runtime fix: on small viewports, make sure the availability
    // container's min-height is at least as tall as its content so nothing
    // visually leaks out. This only runs on page load and on resize for
    // viewports <= 768px.
    (function ensureAvailabilityContainerFits() {
        function apply() {
            try {
                if (window.innerWidth > 768) return;
                const el = document.getElementById('defaultAvailabilityContainer');
                if (!el) return;
                // Use scrollHeight to measure content; add small padding safety.
                const wanted = Math.max(el.scrollHeight + 24, 520);
                el.style.minHeight = wanted + 'px';
                // Keep overflow hidden so the top-gradient (::before) is clipped
                // to the container's border-radius and doesn't produce a 'hat' effect.
                el.style.overflow = 'hidden';
            } catch (err) { /* ignore */ }
        }
        // Run after next paint to allow layout to settle
        requestAnimationFrame(() => setTimeout(apply, 0));
        // Also adjust on viewport resizes (debounced)
        let t = null;
        window.addEventListener('resize', () => {
            clearTimeout(t);
            t = setTimeout(apply, 120);
        });
    })();

    // Save client-facing view settings to localStorage so public profile can read them
    try {
        const saveClientBtn = document.getElementById('saveClientSettingsBtn');
        if (saveClientBtn) {
            saveClientBtn.onclick = () => {
                try {
                    const block = document.getElementById('clientBlockSelect')?.value;
                    const increment = document.getElementById('clientIncrementSelect')?.value;
                    const payload = { block: Number(block || 1), increment: Number(increment || 30) };
                    const key = `client_view_settings`;
                    localStorage.setItem(key, JSON.stringify(payload));
                    alert('Client view settings saved — public page will use these when viewing a day.');
                } catch (err) {
                    console.error('save client settings failed', err);
                    alert('Unable to save client view settings locally.');
                }
            };
        }
    } catch (e) { console.warn('client settings save wiring failed', e); }

    // Ensure every day-number has a click handler that opens the proper modal
    function attachDayNumberClickHandlers() {
        document.querySelectorAll('.fc-daygrid-day').forEach(dayCell => {
            const dateStr = dayCell.dataset.date;
            if (!dateStr) return;
            const numberEl = dayCell.querySelector('.fc-daygrid-day-number');
            if (!numberEl) return;

            // Keep cursor interactive; actual click handling is done by delegated pointerup
            numberEl.style.cursor = 'pointer';
        });
    }

    try { attachDayNumberClickHandlers(); } catch (e) { console.warn('attachDayNumberClickHandlers failed', e); }

    // Use a single delegated pointerup handler to toggle selection or open past-day modal.
    calendarEl.addEventListener('pointerup', function(ev) {
        try {
            // If a drag is in progress, skip (drag logic will handle selection on mouseup)
            if (isDragging) return;

            const num = ev.target.closest('.fc-daygrid-day-number');
            if (!num) return;
            const dayCell = num.closest('.fc-daygrid-day');
            if (!dayCell) return;
            const dateStr = dayCell.dataset.date;
            if (!dateStr) return;

            // Past-day click -> open past-day modal
            if (isPastDate(dateStr)) {
                return openPastDayModal(dateStr);
            }

            // Toggle selection for any non-past day (available or unavailable)
            toggleDateSelection(dateStr);
        } catch (err) { console.error('delegated pointerup handler failed', err); }
    });

    // Parse a YYYY-MM-DD string into a local Date at midnight (avoids Date("YYYY-MM-DD") UTC parsing)
    function parseYMD(dateStr) {
            const parts = String(dateStr).split('-');
            if (parts.length !== 3) return new Date(dateStr);
            const y = parseInt(parts[0], 10);
            const m = parseInt(parts[1], 10) - 1;
            const d = parseInt(parts[2], 10);
            return new Date(y, m, d);
        }

        // Apply visual badges for type column and animated styles for action buttons
        function styleOverridesTable() {
            const tbody = document.getElementById('overridesTableBody');
            if (!tbody) return;
            // Wrap type text in badges
            Array.from(tbody.querySelectorAll('tr')).forEach(row => {
                const cells = row.children;
                if (!cells || cells.length < 2) return;
                const typeCell = cells[1]; // Date(0), Type(1), Time Ranges(2)...
                if (!typeCell) return;
                const raw = (typeCell.textContent || '').trim();
                if (!raw) return;
                const lower = raw.toLowerCase();
                let cls = 'type-badge';
                if (lower.includes('blocked') || lower.includes('unavailable')) cls += ' blocked';
                else if (lower.includes('available')) cls += ' available';
                // Avoid double-wrapping
                if (!typeCell.querySelector('.type-badge')) {
                    typeCell.innerHTML = `<span class="${cls}">${raw}</span>`;
                }
            });
            // Upgrade buttons with animation styles
            Array.from(tbody.querySelectorAll('button')).forEach(btn => {
                if (!btn.classList.contains('overrides-btn')) {
                    btn.classList.add('overrides-btn');
                }
            });
        }

        // Re-style badges/buttons whenever overrides table changes
        try {
            const overridesBody = document.getElementById('overridesTableBody');
            if (overridesBody) {
                const obs = new MutationObserver(() => { try { styleOverridesTable(); } catch(e){} });
                obs.observe(overridesBody, { childList: true, subtree: true });
            }
        } catch (e) { /* ignore */ }

        // Hide any week rows that contain only out-of-month cells (prevents grey frames below last week)
        function hideTrailingOtherRows() {
            try {
                document.querySelectorAll('.fc-daygrid-week').forEach(week => {
                    const cells = week.querySelectorAll('.fc-daygrid-day');
                    if (!cells.length) return;
                    const allOther = Array.from(cells).every(c => c.classList.contains('fc-day-other'));
                    week.style.display = allOther ? 'none' : '';
                });
            } catch (e) { /* ignore */ }
        }

        // Format a Date object into YYYY-MM-DD using local date components
        function formatYMD(d) {
            if (!(d instanceof Date)) d = new Date(d);
            const y = d.getFullYear();
            const m = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${y}-${m}-${day}`;
        }

        // Toggle the modal ranges container visibility based on whether the given date
        // is fully unavailable (weekly default or per-date full-day block).
        function setModalTimeRowVisibility(dateStr) {
            try {
                const rangesContainer = document.getElementById('modalRangesContainer');
                const noticeId = 'makeAvailableNotice';
                const prev = document.getElementById(noticeId);
                if (prev) prev.remove();

                if (!rangesContainer) return;

                const d = parseYMD(dateStr);
                const dow = d.getDay();
                const info = defaultAvailability[dow] || {};
                const firstRange = (info.ranges && info.ranges.length) ? info.ranges[0] : (info.start && info.end ? `${info.start}-${info.end}` : null);

                let hasPerDateBlocked = false;
                let hasPerDateAvailable = false;
                try {
                    const events = (typeof calendar.getEvents === 'function') ? calendar.getEvents() : [];
                    for (const ev of events) {
                        if (!ev || ev.display !== 'background') continue;
                        const props = ev.extendedProps || {};
                        if (!props.is_per_date) continue;
                        if (!ev.start) continue;
                        const evDate = formatYMD(ev.start);
                        if (evDate !== dateStr) continue;
                        const isFullDay = ev.startStr && ev.endStr && ev.startStr.endsWith('T00:00') && ev.endStr.endsWith('T23:59');
                        if (props.override_type === 'blocked' && isFullDay) {
                            hasPerDateBlocked = true;
                        } else if (props.override_type === 'available') {
                            hasPerDateAvailable = true;
                        }
                    }
                } catch (e) { /* ignore */ }

                // Precedence: per-date blocked > per-date available > weekly defaults
                let fullyUnavailable = hasPerDateBlocked || ((!!info.unavailable || (!firstRange && (!info.ranges || info.ranges.length === 0))) && !hasPerDateAvailable);
                try {
                    const cell = document.querySelector(`.fc-daygrid-day[data-date="${dateStr}"]`);
                    const num = cell ? cell.querySelector('.fc-daygrid-day-number') : null;
                    const cellUnavailable = cell && (cell.classList.contains('fc-day-unavailable') || (num && num.classList.contains('unavailable-number')));
                    if (cellUnavailable) fullyUnavailable = true;
                } catch (e) { /* ignore */ }

                if (fullyUnavailable) {
                    rangesContainer.style.display = 'none';
                    // Hide the Add Range button when the date is fully unavailable
                    try {
                        const addBtnEl = document.getElementById('addModalRangeBtn');
                        if (addBtnEl) addBtnEl.style.display = 'none';
                    } catch (e) { /* ignore */ }
                    const msg = document.createElement('div');
                    msg.id = noticeId;
                    msg.style.padding = '12px 0';
                    msg.style.fontWeight = '600';
                    msg.textContent = 'This date is currently fully unavailable; make it available to set times.';
                    const modalContent = document.getElementById('timeModal')?.querySelector('div[style*="padding"]') || document.getElementById('timeModal')?.firstElementChild;
                    if (modalContent) modalContent.insertBefore(msg, modalContent.querySelector('div') || modalContent.firstChild);
                } else {
                    rangesContainer.style.display = '';
                    // Ensure Add Range button is visible when date is available
                    try {
                        const addBtnEl = document.getElementById('addModalRangeBtn');
                        if (addBtnEl) addBtnEl.style.display = 'inline-block';
                    } catch (e) { /* ignore */ }
                }
            } catch (e) { console.warn('setModalTimeRowVisibility failed', e); }
        }

        function getCoachOccupiedDates() {
            const occupied = new Set();
            calendar.getEvents().forEach(event => {
                const start = event.startStr.split('T')[0];
                const end = event.endStr ? event.endStr.split('T')[0] : start;
                let curr = parseYMD(start);
                const last = parseYMD(end);
                while (curr <= last) {
                    occupied.add(formatYMD(curr));
                    curr.setDate(curr.getDate() + 1);
                }
            });
            return occupied;
        }

        // Apply a per-date unavailable UI immediately (client-side) by adding
        // a full-day background event and switching classes on the calendar cell.
        function applyPerDateUnavailable(dateStr) {
            try {
                // Add a background block for immediate visual feedback
                calendar.addEvent({
                    start: dateStr + 'T00:00',
                    end: dateStr + 'T23:59',
                    display: 'background',
                    color: '#e0e0e0',
                    extendedProps: { is_per_date: true, override_type: 'blocked' }
                });
            } catch (e) { console.warn('applyPerDateUnavailable addEvent failed', e); }

            const cell = document.querySelector(`.fc-daygrid-day[data-date="${dateStr}"]`);
            if (!cell) return;
            cell.classList.add('fc-day-unavailable');
            cell.classList.remove('fc-day-available');
            const num = cell.querySelector('.fc-daygrid-day-number');
            if (num) {
                num.classList.add('unavailable-number');
                num.classList.remove('past-day');
                num.style.cursor = 'pointer';
            }
        }

        

        // -----------------------------
        // 6️⃣ Sync default weekly availability to calendar
        // -----------------------------
        function syncAvailabilityToCalendar() {
            // 1️⃣ Clear existing background events that we previously added as defaults
            calendar.getEvents().forEach(e => {
                try {
                    if (e.display === 'background' && e.extendedProps && e.extendedProps.is_default) e.remove();
                } catch (e) { /* ignore */ }
            });

            const occupied = getCoachOccupiedDates();

            // Prefer to sync over the currently visible calendar range so
            // the visuals always match what the user sees (important when
            // the month view spans different weeks).
            const viewStart = (calendar.view && calendar.view.activeStart) ? new Date(calendar.view.activeStart) : new Date();
            const viewEnd = (calendar.view && calendar.view.activeEnd) ? new Date(calendar.view.activeEnd) : (() => { const d=new Date(); d.setMonth(d.getMonth()+1); return d; })();

            // Iterate each day in the visible range
            for (let d = new Date(viewStart); d < viewEnd; d.setDate(d.getDate() + 1)) {
                const dateStr = formatYMD(d);
                if (isPastDate(dateStr)) continue;
                if (occupied.has(dateStr)) continue; // keep booked days alone

                const dow = d.getDay(); // 0=Sunday
                const info = defaultAvailability[dow] || {};

                // If day is unavailable, block whole day (mark as default)
                if (info.unavailable) {
                    calendar.addEvent({ start: dateStr + 'T00:00', end: dateStr + 'T23:59', display: 'background', color: '#e0e0e0', extendedProps: { is_default: true } });
                } else {
                    const ranges = info.ranges || (info.start && info.end ? [`${info.start}-${info.end}`] : []);
                    ranges.forEach(range => {
                        const [s, e] = range.split('-');
                        if (!s || !e) return;
                        calendar.addEvent({ start: dateStr + 'T' + s.trim(), end: dateStr + 'T' + e.trim(), display: 'background', color: '#d0f0d0', extendedProps: { is_default: true } });
                    });
                }
            }
        }


    // 1️⃣ Function to mark past days grey
    function markPastDaysImmediately() {
        const calendarContainer = document.getElementById('calendar');
        if (!calendarContainer) return;

        // Avoid observing full calendar DOM changes (expensive).
        // Instead perform a single initial pass and rely on FullCalendar lifecycle
        // hooks (`eventsSet`, `datesSet`) which already call `updateUnavailableDays()`
        // when the calendar changes. Observing the entire subtree caused repeated
        // full DOM traversals and frequent calls to `updateUnavailableDays`, which
        // can be very CPU intensive when FullCalendar updates the view.
        (function applyPastClassesOnce() {
            document.querySelectorAll('.fc-daygrid-day').forEach(cell => {
                const dateStr = cell.dataset.date;
                const numberEl = cell.querySelector('.fc-daygrid-day-number');
                if (!numberEl) return;
                numberEl.classList.remove('past-day');
                if (isPastDate(dateStr)) numberEl.classList.add('past-day');
            });
            try { updateUnavailableDays(); } catch (e) { /* ignore errors during reapply */ }
        })();
    }

    // Return the first per-date timed override for a given date, or null.
    function findPerDateTimedOverride(dateStr) {
        try {
            const events = (typeof calendar.getEvents === 'function') ? calendar.getEvents() : [];
            for (const ev of events) {
                try {
                    if (!ev || ev.display !== 'background') continue;
                    if (!ev.extendedProps || !ev.extendedProps.is_per_date) continue;
                    if (!ev.start || !ev.end) continue;
                    const evDate = formatYMD(ev.start);
                    if (evDate !== dateStr) continue;
                    // Skip full-day blocks
                    const isFullDay = ev.startStr && ev.endStr && ev.startStr.endsWith('T00:00') && ev.endStr.endsWith('T23:59');
                    if (isFullDay) continue;
                    const sH = String(ev.start.getHours()).padStart(2, '0');
                    const sM = String(ev.start.getMinutes()).padStart(2, '0');
                    const eH = String(ev.end.getHours()).padStart(2, '0');
                    const eM = String(ev.end.getMinutes()).padStart(2, '0');
                    return { start: `${sH}:${sM}`, end: `${eH}:${eM}` };
                } catch (ie) { /* ignore */ }
            }
        } catch (e) { /* ignore */ }
        return null;
    }

    // Return all per-date timed overrides for a given date (array)
    function findPerDateTimedOverrides(dateStr) {
        const out = [];
        try {
            const events = (typeof calendar.getEvents === 'function') ? calendar.getEvents() : [];
            for (const ev of events) {
                try {
                    if (!ev || ev.display !== 'background') continue;
                    if (!ev.extendedProps || !ev.extendedProps.is_per_date) continue;
                    if (!ev.start || !ev.end) continue;
                    const evDate = formatYMD(ev.start);
                    if (evDate !== dateStr) continue;
                    const isFullDay = ev.startStr && ev.endStr && ev.startStr.endsWith('T00:00') && ev.endStr.endsWith('T23:59');
                    if (isFullDay) continue;
                    const sH = String(ev.start.getHours()).padStart(2, '0');
                    const sM = String(ev.start.getMinutes()).padStart(2, '0');
                    const eH = String(ev.end.getHours()).padStart(2, '0');
                    const eM = String(ev.end.getMinutes()).padStart(2, '0');
                    out.push({ start: `${sH}:${sM}`, end: `${eH}:${eM}` });
                } catch (ie) { /* ignore */ }
            }
        } catch (e) { /* ignore */ }
        return out;
    }

    // Create a UI row for a modal range (start/end + remove)
    function createModalRangeRow(startVal = '09:00', endVal = '17:00') {
        const row = document.createElement('div');
        row.className = 'modal-range-row';
        row.style.display = 'flex';
        row.style.alignItems = 'center';
        row.style.justifyContent = 'center';
        row.style.gap = '8px';

        const startLabel = document.createElement('label');
        startLabel.textContent = 'Start:';
        startLabel.style.minWidth = '45px';
        startLabel.style.textAlign = 'right';

        // Wrap the start input to position the custom picker relative to it
        const startContainer = document.createElement('div');
        startContainer.className = 'time-input-container';
        const start = document.createElement('input');
        start.type = 'time';
        start.className = 'modal-range-start';
        start.value = startVal;
        start.readOnly = true; // use custom time picker for consistency
        startContainer.appendChild(start);
        // Open custom picker on click
        start.style.cursor = 'pointer';
        start.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            try {
                document.querySelectorAll('.custom-time-picker').forEach(p => p.remove());
                const picker = (typeof createCustomTimePickerGlobal === 'function' ? createCustomTimePickerGlobal : createCustomTimePicker)(start);
                picker.classList.add('active');
                startContainer.appendChild(picker);
            } catch (err) { /* ignore */ }
        });

        const endLabel = document.createElement('label');
        endLabel.textContent = 'End:';
        endLabel.style.minWidth = '40px';
        endLabel.style.textAlign = 'right';

        // Wrap the end input to position the custom picker relative to it
        const endContainer = document.createElement('div');
        endContainer.className = 'time-input-container';
        const end = document.createElement('input');
        end.type = 'time';
        end.className = 'modal-range-end';
        end.value = endVal;
        end.readOnly = true; // use custom time picker for consistency
        endContainer.appendChild(end);
        // Open custom picker on click
        end.style.cursor = 'pointer';
        end.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            try {
                document.querySelectorAll('.custom-time-picker').forEach(p => p.remove());
                const picker = (typeof createCustomTimePickerGlobal === 'function' ? createCustomTimePickerGlobal : createCustomTimePicker)(end);
                picker.classList.add('active');
                endContainer.appendChild(picker);
            } catch (err) { /* ignore */ }
        });

        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.textContent = 'Remove';
        removeBtn.style.padding = '6px 8px';
        removeBtn.style.border = 'none';
        removeBtn.style.background = '#dc3545';
        removeBtn.style.color = 'white';
        removeBtn.style.borderRadius = '6px';
        removeBtn.style.cursor = 'pointer';
        removeBtn.onclick = () => row.remove();

        row.appendChild(startLabel);
        row.appendChild(startContainer);
        row.appendChild(endLabel);
        row.appendChild(endContainer);
        row.appendChild(removeBtn);
        return row;
    }

    // Call after calendar.render()
    markPastDaysImmediately();

    // Render a table of per-date overrides (available/unavailable) based on calendar background events
    function renderOverridesTable() {
        const tbody = document.getElementById('overridesTableBody');
        if (!tbody) return;
        tbody.innerHTML = '';

        // Update month label in header
        try {
            const span = document.getElementById('overridesHeaderMonth');
            if (span && calendar) {
                const currentDate = calendar.getDate ? calendar.getDate() : new Date();
                const monthName = currentDate.toLocaleString('default', { month: 'long' });
                span.textContent = monthName;
            }
        } catch (e) { /* ignore month label errors */ }

        // Header controls: normalize to 4 columns (Date, Type, Time Ranges, Actions); re-add Reset All button; no group actions
        try {
            const table = document.getElementById('overridesTable');
            const thead = table ? table.querySelector('thead') : null;
            const headerRow = thead ? thead.querySelector('tr') : null;
            if (headerRow) {
                // Trim extra columns if any
                while (headerRow.children.length > 4) {
                    headerRow.removeChild(headerRow.lastElementChild);
                }
                // Ensure headings
                if (headerRow.children[0]) headerRow.children[0].textContent = 'Date';
                if (headerRow.children[1]) headerRow.children[1].textContent = 'Type';
                if (headerRow.children[2]) headerRow.children[2].textContent = 'Time Ranges';
                // Intentionally omit label text for 4th column (Actions) per request
                if (headerRow.children[3]) headerRow.children[3].textContent = '';

                // Ensure Reset All Overrides button exists in 4th header cell
                const resetTh = headerRow.children[3];
                if (resetTh) {
                    // Center the button in the header cell
                    resetTh.style.textAlign = 'center';
                    // Avoid duplicates
                    const existing = resetTh.querySelector('#resetAllOverridesBtn');
                    if (!existing) {
                        const resetBtn = document.createElement('button');
                        resetBtn.id = 'resetAllOverridesBtn';
                        resetBtn.type = 'button';
                        resetBtn.textContent = 'Reset All Overrides';
                        resetBtn.style.padding = '6px 10px';
                        resetBtn.style.border = '1px solid #ccc';
                        resetBtn.style.borderRadius = '4px';
                        resetBtn.style.background = '#fff';
                        resetBtn.style.cursor = 'pointer';
                        resetTh.appendChild(resetBtn);

                        resetBtn.onclick = async () => {
                            if (!confirm('Reset ALL per-date overrides to weekly defaults?')) return;
                            const evs = (typeof calendar.getEvents === 'function') ? calendar.getEvents() : [];
                            const dates = [];
                            evs.forEach(ev => {
                                try {
                                    if (ev.display !== 'background') return;
                                    const isPer = ev.extendedProps && ev.extendedProps.is_per_date;
                                    if (!isPer) return;
                                    const s = ev.startStr || (ev.start ? ev.start.toISOString() : null);
                                    if (!s) return;
                                    const d = s.split('T')[0];
                                    if (dates.indexOf(d) === -1) dates.push(d);
                                } catch (e) {}
                            });

                            if (dates.length === 0) {
                                alert('No per-date overrides to reset.');
                                return;
                            }

                            try {
                                const res = await fetch(`/bus/${orgSlug}/bookings/batch_delete/`, {
                                    method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken }, body: JSON.stringify({ dates })
                                });
                                const data = await res.json().catch(() => null);
                                if (res.ok) {
                                    try { await calendar.refetchEvents(); } catch (e) {}
                                    try { updateUnavailableDays(); } catch (e) {}
                                    try { renderOverridesTable(); } catch (e) {}
                                    alert('All per-date overrides reset.');
                                } else {
                                    const msg = (data && (data.error || data.message)) || `Server returned ${res.status}`;
                                    alert('Error resetting: ' + msg);
                                }
                            } catch (err) {
                                console.error('Reset all failed', err);
                                alert('Error resetting: ' + (err && err.message ? err.message : String(err)));
                            }
                        };
                    }
                }
            }
        } catch (e) { /* ignore header setup errors */ }

        const events = (typeof calendar.getEvents === 'function') ? calendar.getEvents() : [];
        const perDate = {}; // date -> { rangesSet: Set, items: [] }

        function fmtTime(h, m) {
            const hh = parseInt(h,10);
            const mm = parseInt(m,10);
            const ampm = hh >= 12 ? 'PM' : 'AM';
            let hour = hh % 12;
            if (hour === 0) hour = 12;
            return `${hour}:${String(mm).padStart(2,'0')} ${ampm}`;
        }

        events.forEach(ev => {
            try {
                if (ev.display !== 'background') return;
                const props = ev.extendedProps || {};
                if (!props.is_per_date) return;
                const startStr = ev.startStr || (ev.start ? ev.start.toISOString() : null);
                if (!startStr) return;
                const date = startStr.split('T')[0];

                let sH = 0, sM = 0, eH = 23, eM = 59;
                if (ev.start && ev.start.getHours) { sH = ev.start.getHours(); sM = ev.start.getMinutes(); }
                else if (startStr.split('T')[1]) { const parts = startStr.split('T')[1].split(':'); sH = parseInt(parts[0]||'0',10); sM = parseInt(parts[1]||'0',10); }
                if (ev.end && ev.end.getHours) { eH = ev.end.getHours(); eM = ev.end.getMinutes(); }
                else if (ev.endStr && ev.endStr.split('T')[1]) { const parts = ev.endStr.split('T')[1].split(':'); eH = parseInt(parts[0]||'23',10); eM = parseInt(parts[1]||'59',10); }
                if (!perDate[date]) perDate[date] = { rangesSet: new Set(), items: [], blocked: false };
                const fullDay = (sH === 0 && sM === 0 && eH === 23 && eM === 59);
                if (props.override_type === 'blocked' && fullDay) {
                    perDate[date].blocked = true;
                } else {
                    const key = `${sH}:${sM}-${eH}:${eM}`;
                    if (!perDate[date].rangesSet.has(key)) {
                        perDate[date].rangesSet.add(key);
                        perDate[date].items.push({ startH: sH, startM: sM, endH: eH, endM: eM });
                    }
                }
            } catch (e) { /* ignore */ }
        });

        // Ensure earlier ranges render to the left: sort by ascending start time
        Object.keys(perDate).forEach(d => {
            const entry = perDate[d];
            if (entry && Array.isArray(entry.items)) {
                entry.items.sort((a,b) => (a.startH*60 + a.startM) - (b.startH*60 + b.startM));
            }
        });

        // cache for group ops
        window._perDateOverridesCache = perDate;

        const dates = Object.keys(perDate).sort();
        if (dates.length === 0) {
            const r = document.createElement('tr');
            r.innerHTML = '<td colspan="4" style="text-align:center; color:#666; padding:12px;">No per-date overrides</td>';
            tbody.appendChild(r);
            return;
        }

        dates.forEach(d => {
            const entry = perDate[d];
            const items = entry.items;
            const type = entry.blocked ? 'Blocked' : 'Available';
            let times = '';
            if (entry.blocked) {
                times = 'Blocked (Full Day)';
            } else if (items.length === 0) {
                times = 'No ranges';
            } else {
                const rngs = items.map(it => fmtTime(it.startH, it.startM) + ' - ' + fmtTime(it.endH, it.endM));
                times = rngs.join('; ');
            }

            const row = document.createElement('tr');
            row.style.borderBottom = '1px solid #eee';
            row.setAttribute('data-date', d);

            const tdDate = document.createElement('td');
            tdDate.style.padding = '8px';
            // Format YYYY-MM-DD as Mon D, YYYY (e.g., Nov 9, 2025)
            try {
                const parts = d.split('-');
                if (parts.length === 3) {
                    const y = parseInt(parts[0],10), m = parseInt(parts[1],10)-1, day = parseInt(parts[2],10);
                    const dt = new Date(y, m, day);
                    const monthShort = dt.toLocaleString('default', { month: 'short' });
                    tdDate.textContent = `${monthShort} ${day}, ${y}`;
                } else {
                    tdDate.textContent = d;
                }
            } catch (e) { tdDate.textContent = d; }
            const tdType = document.createElement('td'); tdType.style.padding = '8px'; tdType.textContent = type;
            const tdTimes = document.createElement('td'); tdTimes.style.padding = '8px'; tdTimes.textContent = times;
            const tdAction = document.createElement('td'); tdAction.style.padding = '8px';
            const tdSelect = document.createElement('td'); tdSelect.style.padding = '8px';

            const resetBtn = document.createElement('button');
            resetBtn.type = 'button';
            resetBtn.textContent = 'Reset';
            resetBtn.setAttribute('data-label', 'Reset');
            resetBtn.classList.add('overrides-btn');
            // Use class-based styling; avoid inline white background which can hide white text
            resetBtn.style.padding = '';
            resetBtn.style.border = '';
            resetBtn.style.borderRadius = '';
            resetBtn.style.background = '';
            resetBtn.style.cursor = '';
            try { if (isPastDate(d)) { resetBtn.disabled = true; resetBtn.title = 'Cannot reset past dates'; resetBtn.style.opacity = '0.6'; resetBtn.style.cursor = 'not-allowed'; } } catch(e) {}

            resetBtn.onclick = async () => {
                if (!confirm(`Reset ${d} to weekly defaults? This will remove per-date overrides for this date.`)) return;
                resetBtn.disabled = true;
                try {
                    const res = await fetch(`/bus/${orgSlug}/bookings/batch_delete/`, {
                        method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken }, body: JSON.stringify({ dates: [d] })
                    });
                    const data = await res.json().catch(() => null);
                    if (res.ok) {
                        try { calendar.getEvents().forEach(ev => { try { if (ev.display === 'background' && ev.startStr && ev.startStr.startsWith(d)) ev.remove(); } catch(e){} }); } catch(e){}
                        try { await calendar.refetchEvents(); } catch(e){}
                        try { updateUnavailableDays(); } catch(e){}
                        try { renderOverridesTable(); } catch(e){}
                        alert('Reset to weekly defaults completed.');
                    } else {
                        const msg = (data && (data.error || data.message)) || `Server returned ${res.status}`;
                        alert('Error resetting: ' + msg);
                        try { await calendar.refetchEvents(); } catch(e){}
                        try { updateUnavailableDays(); } catch(e){}
                    }
                } catch (err) {
                    console.error('Reset request failed', err);
                    alert('Error: ' + (err && err.message ? err.message : String(err)));
                    try { await calendar.refetchEvents(); } catch(e){}
                    try { updateUnavailableDays(); } catch(e){}
                } finally { try { resetBtn.disabled = isPastDate(d); } catch(e) { resetBtn.disabled = false; } }
            };

            const selectBtn = document.createElement('button');
            selectBtn.type = 'button';
            selectBtn.className = 'override-select-btn';
            selectBtn.textContent = 'Select';
            selectBtn.setAttribute('data-label', 'Select');
            selectBtn.classList.add('overrides-btn');
            // Use class-based styling; avoid inline white background which can hide white text
            selectBtn.style.padding = '';
            selectBtn.style.border = '';
            selectBtn.style.borderRadius = '';
            selectBtn.style.background = '';
            selectBtn.style.cursor = '';
            selectBtn.onclick = () => {
                try { openMakeAvailableModal(d); } catch (e) { console.error('Failed to open edit modal for', d, e); }
            };

            tdSelect.appendChild(selectBtn);
            tdAction.appendChild(resetBtn);
            row.appendChild(tdDate); row.appendChild(tdType); row.appendChild(tdTimes); row.appendChild(tdAction); row.appendChild(tdSelect);
            tbody.appendChild(row);
        });
    }

    // Bulk edit modal using the existing timeModal
    async function openBulkEditModal(dates, initRanges) {
        const modal = document.getElementById('timeModal');
        const rangesContainer = document.getElementById('modalRangesContainer');
        const addBtn = document.getElementById('addModalRangeBtn');
        const saveBtnEl = document.getElementById('saveTimeBtn');
        const closeBtnEl = document.getElementById('closeTimeBtn');
        const makeUnavailableBtn = document.getElementById('makeUnavailableBtn');

        try { rangesContainer.innerHTML = ''; } catch(e) {}
        if (Array.isArray(initRanges) && initRanges.length) {
            const seen = new Set();
            initRanges.forEach(r => {
                try {
                    const [s,e] = r.split('-');
                    const key = `${s}-${e}`;
                    if (!seen.has(key)) { seen.add(key); rangesContainer.appendChild(createModalRangeRow(s,e)); }
                } catch (er) {}
            });
        } else {
            rangesContainer.appendChild(createModalRangeRow('09:00','17:00'));
        }
        if (addBtn) addBtn.onclick = () => rangesContainer.appendChild(createModalRangeRow('09:00','17:00'));

        // Adjust visibility for bulk: always show ranges; hide makeUnavailable (use Delete Selected instead)
        try { rangesContainer.style.display = ''; } catch(e){}
        try { if (makeUnavailableBtn) makeUnavailableBtn.style.display = 'none'; } catch(e){}

        modal.style.display = 'flex';

        // Temporarily override handlers
        const prevSave = saveBtnEl.onclick;
        const prevClose = closeBtnEl.onclick;
        let restored = false;
        function restoreHandlers() { if (restored) return; restored = true; saveBtnEl.onclick = prevSave; closeBtnEl.onclick = prevClose; }

        saveBtnEl.onclick = async () => {
            // Gather ranges
            const rows = Array.from(rangesContainer.querySelectorAll('.modal-range-row'));
            const ranges = [];
            for (const r of rows) {
                try {
                    const s = r.querySelector('.modal-range-start').value;
                    const e = r.querySelector('.modal-range-end').value;
                    if (s && e && s < e) ranges.push({ start: s, end: e });
                } catch (ie) {}
            }
            // Deduplicate
            const unique = [];
            const seen = new Set();
            for (const rr of ranges) { const k = `${rr.start}-${rr.end}`; if (!seen.has(k)) { seen.add(k); unique.push(rr); } }

            try {
                // Remove existing overrides for these dates
                await fetch(`/bus/${orgSlug}/bookings/batch_delete/`, { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken }, body: JSON.stringify({ dates }) });

                if (unique.length === 0) {
                    // No ranges -> simply deleted (reverts to weekly defaults)
                } else {
                    // Create new ranges; batch by each distinct range across all selected dates
                    for (const rr of unique) {
                        await fetch(`/bus/${orgSlug}/bookings/batch_create/`, {
                            method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                            body: JSON.stringify({ dates, start_time: rr.start, end_time: rr.end })
                        });
                    }
                }
                try { await calendar.refetchEvents(); } catch(e){}
                try { updateUnavailableDays(); } catch(e){}
                try { renderOverridesTable(); } catch(e){}
                alert('Bulk update applied.');
            } catch (err) {
                console.error('Bulk update failed', err);
                alert('Error applying bulk update.');
            }

            modal.style.display = 'none';
            restoreHandlers();
        };
        closeBtnEl.onclick = () => { modal.style.display = 'none'; restoreHandlers(); };
    }

    function updateClearButton() {
        clearBtn.style.display = selectedDates.size > 0 ? 'inline-block' : 'none';
        // Reset select button text if no dates selected
        if (selectedDates.size === 0) {
            selectBtn.textContent = "Select Day";
        }
    }

    // Open a small modal to make a single (previously-unavailable) date available
    function openMakeAvailableModal(dateStr) {
        const modal = document.getElementById('timeModal');
        const rangesContainer = document.getElementById('modalRangesContainer');
        const addBtn = document.getElementById('addModalRangeBtn');
        const saveBtnEl = document.getElementById('saveTimeBtn');
        const closeBtnEl = document.getElementById('closeTimeBtn');

        // Clear existing rows
        try { rangesContainer.innerHTML = ''; } catch (e) { /* ignore */ }

        // Populate ranges: prefer per-date overrides, otherwise weekly defaults, otherwise sensible fallback
            try {
                const overrides = findPerDateTimedOverrides(dateStr);
                if (overrides && overrides.length) {
                    // dedupe overrides by start-end
                    const seen = new Set();
                    // sort by ascending start time
                    const sorted = overrides.slice().sort((a,b) => {
                        const [ah, am] = (a.start||'00:00').split(':').map(x=>parseInt(x,10)||0);
                        const [bh, bm] = (b.start||'00:00').split(':').map(x=>parseInt(x,10)||0);
                        return (ah*60+am) - (bh*60+bm);
                    });
                    sorted.forEach(o => {
                        try {
                            const k = `${o.start}-${o.end}`;
                            if (!seen.has(k)) { seen.add(k); rangesContainer.appendChild(createModalRangeRow(o.start, o.end)); }
                        } catch (er) { /* ignore */ }
                    });
                } else {
                const d = parseYMD(dateStr);
                const dow = d.getDay();
                const info = defaultAvailability[dow] || {};
                const ranges = info.ranges && info.ranges.length ? info.ranges : (info.start && info.end ? [`${info.start}-${info.end}`] : []);
                if (ranges && ranges.length) {
                    // sort by ascending start time
                    const sortedRanges = ranges.slice().sort((ra, rb) => {
                        try {
                            const [sa] = ra.split('-'); const [sb] = rb.split('-');
                            const [ah, am] = (sa||'00:00').split(':').map(x=>parseInt(x,10)||0);
                            const [bh, bm] = (sb||'00:00').split(':').map(x=>parseInt(x,10)||0);
                            return (ah*60+am) - (bh*60+bm);
                        } catch (er) { return 0; }
                    });
                    sortedRanges.forEach(r => {
                        try {
                            const parts = r.split('-');
                            const s = (parts[0]||'09:00').trim();
                            const e = (parts[1]||'17:00').trim();
                            rangesContainer.appendChild(createModalRangeRow(s, e));
                        } catch (er) { /* ignore row parse errors */ }
                    });
                } else {
                    rangesContainer.appendChild(createModalRangeRow('09:00','17:00'));
                }
            }
        } catch (e) { rangesContainer.appendChild(createModalRangeRow('09:00','17:00')); }

        // Wire Add Range
        if (addBtn) addBtn.onclick = () => rangesContainer.appendChild(createModalRangeRow('09:00','17:00'));

        // Decide visibility based on fully-unavailable status
        try { setModalTimeRowVisibility(dateStr); } catch (e) { /* ignore */ }

        // Ensure Save/Add buttons reflect current ranges visibility (important after optimistic updates)
        try {
            const rangesVisible = (document.getElementById('modalRangesContainer')?.style.display !== 'none');
            const saveBtn = document.getElementById('saveTimeBtn');
            const addBtnEl = document.getElementById('addModalRangeBtn');
            if (saveBtn) saveBtn.style.display = rangesVisible ? 'inline-block' : 'none';
            if (addBtnEl) addBtnEl.style.display = rangesVisible ? 'inline-block' : 'none';
        } catch (e) { /* ignore */ }

        modal.style.display = 'flex';

        // Temporarily override handlers
        const prevSave = saveBtnEl.onclick;
        const prevClose = closeBtnEl.onclick;
        let restored = false;
        function restoreHandlers() {
            if (restored) return; restored = true;
            saveBtnEl.onclick = prevSave;
            closeBtnEl.onclick = prevClose;
        }

        // Show Make Unavailable button for single-date modal
        const makeUnavailableBtn = document.getElementById('makeUnavailableBtn');
        if (makeUnavailableBtn) {
            makeUnavailableBtn.style.display = 'inline-block';
            const prevMakeUnavailable = makeUnavailableBtn.onclick;
            let restoredMake = false;
            function restoreMake() { if (restoredMake) return; restoredMake = true; makeUnavailableBtn.onclick = prevMakeUnavailable; }

            makeUnavailableBtn.onclick = async () => {
                if (!confirm(`Mark ${dateStr} as unavailable? This will block the whole day.`)) return;
                try {
                    const res = await fetch(`/bus/${orgSlug}/bookings/batch_create/`, { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken }, body: JSON.stringify({ dates: [dateStr], start_time: '00:00', end_time: '23:59', is_blocking: true }) });
                    const data = await res.json().catch(() => null);
                    if (res.ok) {
                        applyPerDateUnavailable(dateStr);
                        try { calendar.refetchEvents(); } catch(e){}
                        try { updateUnavailableDays(); } catch(e){}
                        alert('Date marked unavailable.');
                    } else {
                        const msg = (data && (data.error || data.message)) || `Server returned ${res.status}`;
                        alert('Error marking unavailable: ' + msg);
                    }
                } catch (err) { console.error('Make unavailable failed', err); alert('Error: ' + (err && err.message ? err.message : String(err))); }
                modal.style.display = 'none';
                restoreHandlers();
                restoreMake();
            };
        }

        // Save: collect ranges and create per-date overrides for this single date
        saveBtnEl.onclick = async () => {
            const rows = Array.from(rangesContainer.querySelectorAll('.modal-range-row'));
            const ranges = [];
            for (const r of rows) {
                try {
                    const s = r.querySelector('.modal-range-start').value;
                    const e = r.querySelector('.modal-range-end').value;
                    if (s && e && s < e) ranges.push({ start: s, end: e });
                } catch (ie) { /* ignore */ }
            }

            // If coach removed all ranges for this single date, treat it as "make unavailable"
            if (ranges.length === 0) {
                if (!confirm(`No time ranges provided. Mark ${dateStr} as unavailable for the whole day?`)) return;
                try {
                    const res = await fetch(`/bus/${orgSlug}/bookings/batch_create/`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                        body: JSON.stringify({ dates: [dateStr], start_time: '00:00', end_time: '23:59', is_blocking: true })
                    });
                    const data = await res.json().catch(() => null);
                    if (res.ok) {
                        // Apply UI changes immediately
                        applyPerDateUnavailable(dateStr);
                        try { await calendar.refetchEvents(); } catch (e) {}
                        try { updateUnavailableDays(); } catch (e) {}
                        alert('Date marked unavailable.');
                    } else {
                        const msg = (data && (data.error || data.message)) || `Server returned ${res.status}`;
                        alert('Error marking unavailable: ' + msg);
                    }
                } catch (err) {
                    console.error('Make unavailable failed', err);
                    alert('Error: ' + (err && err.message ? err.message : String(err)));
                }

                modal.style.display = 'none';
                restoreHandlers();
                return;
            }

            // Deduplicate ranges by start-end to avoid creating duplicate per-date events
            const uniqueRanges = [];
            const seen = new Set();
            for (const rr of ranges) {
                try {
                    const k = `${rr.start}-${rr.end}`;
                    if (!seen.has(k)) { seen.add(k); uniqueRanges.push(rr); }
                } catch (e) { /* ignore malformed */ }
            }
            // replace ranges with unique set
            const rangesToCreate = uniqueRanges;

            try {
                // remove existing per-date overrides for the date
                try { await fetch(`/bus/${orgSlug}/bookings/batch_delete/`, { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken }, body: JSON.stringify({ dates: [dateStr] }) }); } catch(e){}

                // Remove existing optimistic background events for this date before adding new ones
                try {
                    calendar.getEvents().forEach(ev => {
                        if (ev.display === 'background' && ev.startStr.startsWith(dateStr + 'T')) {
                            const props = ev.extendedProps || {};
                            if (props.override_type === 'available' || props.is_per_date) {
                                ev.remove();
                            }
                        }
                    });
                } catch (e) { /* ignore removal errors */ }

                for (const r of rangesToCreate) {
                    try {
                        // optimistic UI
                        const res = await fetch(`/bus/${orgSlug}/bookings/batch_create/`, { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken }, body: JSON.stringify({ dates: [dateStr], start_time: r.start, end_time: r.end }) });
                        const data = await res.json().catch(() => null);
                        if (!res.ok) console.warn('Error creating per-date range', r, data);
                        else {
                            // On success add event (avoid transient duplicate before server cleanup)
                            try { calendar.addEvent({ start: dateStr + 'T' + r.start, end: dateStr + 'T' + r.end, display: 'background', color: '#d0f0d0', extendedProps: { is_per_date: true, override_type: 'available' } }); } catch(e){}
                        }
                    } catch (err) { console.error('range create failed', err); }
                }

                try { await calendar.refetchEvents(); } catch(e){}
                try { updateUnavailableDays(); } catch(e){}
                alert('Per-date availability saved.');
            } catch (err) { console.error('Save per-date failed', err); alert('Error saving: ' + (err && err.message ? err.message : String(err))); }

            modal.style.display = 'none';
            restoreHandlers();
        };

        closeBtnEl.onclick = () => { modal.style.display = 'none'; restoreHandlers(); try { window._highlightAll = false; } catch(e) {} };
    }

    function toggleDateSelection(dateStr) {
        const numberEl = document.querySelector(`.fc-daygrid-day[data-date="${dateStr}"] .fc-daygrid-day-number`);
        if (!numberEl) return;

        const isPast = isPastDate(dateStr);

        // --- Handle past-day logic ---
        if (isPast) {
            // If coach is already selecting future/present days, block it
            if ([...selectedDates].some(d => !isPastDate(d))) {
                alert("You can only select past days or available days — not both at the same time.");
                return;
            }

            // Instead of selecting, open details
            openPastDayModal(dateStr); // your custom function
            return;
        }

        // --- Handle available/future days ---
        // If currently has any past days selected, block this
        if ([...selectedDates].some(d => isPastDate(d))) {
            alert("You can only select past days or available days — not both at the same time.");
            return;
        }

        // Toggle highlight
        if (selectedDates.has(dateStr)) {
            selectedDates.delete(dateStr);
            numberEl.classList.remove('selected');
        } else {
            selectedDates.add(dateStr);
            numberEl.classList.add('selected');
        }

        updateClearButton();
        updateSelectButtonText();
    }

    // --- Add this function here ---
    function updateSelectButtonText() {
        const count = selectedDates.size;

        if (count === 0) {
            selectBtn.textContent = "Select Day";
        } else if (count === 1) {
            selectBtn.textContent = "Select Day";
        } else {
            selectBtn.textContent = `Select ${count} Days`;
        }
    }

        function resetClientViewStyles() {
            const clientSettings = document.getElementById("clientTimeSettings");
            clientSettings.style.display = "flex"; // show for present/future days
            clientSettings.style.flexDirection = "column"; // stack vertically
            clientSettings.style.gap = "10px";
            clientSettings.style.alignItems = "flex-start";
        }

        // This part runs once when the page loads
        function openPastDayModal(dateStr) {
            const modal = document.getElementById("timeCirclesModal");
            const container = document.getElementById("timeCirclesContainer");
            const title = document.getElementById("circleModalTitle");

            // Coach preference elements
            const coachHourBlockSelect = document.getElementById("hourBlockSelect");
            const coachIncrementSelect = document.getElementById("incrementSelect");
            const coachCustomBlockContainer = document.getElementById("customBlockInputContainer");
            const coachCustomBlockInput = document.getElementById("customBlockInput");
            const coachApplyCustomBlockBtn = document.getElementById("applyCustomBlockBtn");
            const coachCustomIncrementContainer = document.getElementById("customIncrementContainer");
            const coachCustomIncrementInput = document.getElementById("customIncrementInput");
            const coachApplyCustomIncrementBtn = document.getElementById("applyCustomIncrementBtn");

            // Hide client settings for past days
            document.getElementById("clientTimeSettings").style.display = "none";

            // Show modal
            modal.style.display = "flex";
            title.textContent = `Schedule for ${dateStr}`;
            container.innerHTML = "";

            // Initialize block size & increment
            let currentBlockSize = parseInt(coachHourBlockSelect.value);
            let currentIncrement = parseInt(coachIncrementSelect.value);

            // Render grid function
            function renderGrid(blockSize) {
                container.innerHTML = "";
                const startHour = 6;
                const endHour = 22;
                const blockMinutes = blockSize * 60;

                for (let blockStartHour = startHour; blockStartHour < endHour; blockStartHour += blockSize) {
                    const row = document.createElement("div");
                    row.style.display = "flex";
                    row.style.alignItems = "center";
                    row.style.justifyContent = "space-between";
                    row.style.gap = "8px";
            

                    // Hour label
                    const blockLabel = document.createElement("div");
                    const labelDate = parseYMD(dateStr);
                    labelDate.setHours(blockStartHour, 0, 0, 0);
                    blockLabel.textContent = labelDate.toLocaleString(undefined, { hour: 'numeric', hour12: true });
                    blockLabel.style.width = "70px";
                    blockLabel.style.fontWeight = "bold";
                    row.appendChild(blockLabel);

                    // Circles container
                    const circlesContainer = document.createElement("div");
                    circlesContainer.style.display = "flex";
                    circlesContainer.style.flexWrap = "wrap";
                    circlesContainer.style.gap = "8px";
                    circlesContainer.style.marginLeft = "auto"; // push only circles to right

                    for (let minutes = 0; minutes < blockMinutes; minutes += currentIncrement) {
                        const totalMinutes = blockStartHour*60 + minutes;
                        let hour = Math.floor(totalMinutes / 60);
                        const min = totalMinutes % 60;
                        const ampm = hour >= 12 ? "PM" : "AM";
                        hour = hour % 12;
                        if (hour === 0) hour = 12;
                        const timeLabel = `${hour}:${min.toString().padStart(2,'0')} ${ampm}`;

                        const circle = document.createElement("div");
                        circle.className = "time-circle open";
                        circle.textContent = timeLabel;
                        circle.dataset.time = timeLabel;

                        // Grey out past times (read-only)
                        const now = new Date();
                        const slotDate = parseYMD(dateStr);
                        slotDate.setHours(blockStartHour, min, 0, 0);
                        if (slotDate < now) circle.style.background = "#6c757d";

                        // Read-only click
                        circle.addEventListener("click", () => {
                            alert(`This slot (${timeLabel}) is read-only.`);
                        });

                        circlesContainer.appendChild(circle);
                    }

                    row.appendChild(circlesContainer);
                    container.appendChild(row);
                }

                if (container.lastElementChild) container.lastElementChild.style.borderBottom = "none";
            }

            renderGrid(currentBlockSize);

            // Coach hour block / increment handlers
            coachHourBlockSelect.onchange = () => {
                if (coachHourBlockSelect.value === "custom") coachCustomBlockContainer.style.display = "flex";
                else {
                    coachCustomBlockContainer.style.display = "none";
                    currentBlockSize = parseInt(coachHourBlockSelect.value);
                    renderGrid(currentBlockSize);
                }
            };
            coachApplyCustomBlockBtn.onclick = () => {
                const val = parseInt(coachCustomBlockInput.value);
                if (isNaN(val) || val < 15) return alert("Enter valid minutes 15+");
                coachCustomBlockContainer.style.display = "none";
                currentBlockSize = val / 60;
                renderGrid(currentBlockSize);
            };

            coachIncrementSelect.onchange = () => {
                if (coachIncrementSelect.value === "custom") coachCustomIncrementContainer.style.display = "flex";
                else {
                    coachCustomIncrementContainer.style.display = "none";
                    currentIncrement = parseInt(coachIncrementSelect.value);
                    renderGrid(currentBlockSize);
                }
            };
            coachApplyCustomIncrementBtn.onclick = () => {
                const val = parseInt(coachCustomIncrementInput.value);
                if (isNaN(val) || val < 5) return alert("Enter valid increment 5+");
                coachCustomIncrementContainer.style.display = "none";
                currentIncrement = val;
                renderGrid(currentBlockSize);
            };

            // Close button works
            document.getElementById("closeCirclesBtn").onclick = () => {
                modal.style.display = "none";
                document.getElementById("clientTimeSettings").style.display = "flex"; // restore client settings
            };

            // Add circle CSS if not already
            if (!document.getElementById("timeCirclesStyle")) {
                const style = document.createElement("style");
                style.id = "timeCirclesStyle";
                style.innerHTML = `
                    .time-circle {
                        width: 80px; height: 80px; border-radius: 50%;
                        display: flex; justify-content: center; align-items: center;
                        cursor: pointer; font-size: 13px; color: white; transition: transform 0.1s ease;
                    }
                    .time-circle.open { background: #28a745; }
                    .time-circle.booked { background: #dc3545; }
                    .time-circle.blocked { background: #6c757d; }
                    .time-circle:hover { transform: scale(1.1); }
                `;
                document.head.appendChild(style);
            }
        }


    function reapplySelections() {
        // Reapply selection highlights for any non-past day that is in selectedDates.
        // This includes both available and unavailable future days so selections
        // persist across FullCalendar re-renders.
        document.querySelectorAll('.fc-daygrid-day').forEach(cell => {
            const dateStr = cell.dataset.date;
            if (!dateStr) return;
            if (isPastDate(dateStr)) return; // skip past days
            if (selectedDates.has(dateStr)) {
                const numberEl = cell.querySelector('.fc-daygrid-day-number');
                if (numberEl) numberEl.classList.add('selected');
            } else {
                const numberEl = cell.querySelector('.fc-daygrid-day-number');
                if (numberEl) numberEl.classList.remove('selected');
            }
        });
    }

    function handleTimeSlotSelection(info) {
        const start = info.startStr;
        const end = info.endStr;

        // Example modal: ask whether to mark as available or block off
        const choice = confirm(`Mark time ${start} - ${end} as available? Click Cancel to block off.`);

        const color = choice ? '#4CAF50' : '#E74C3C'; // green for available, red for blocked

        calendar.addEvent({
            start: start,
            end: end,
            display: 'background',
            backgroundColor: color
        });

        // You can also send this to the backend via AJAX later
    }

        function openBookingModal(event) {
            const modal = document.getElementById('bookingModal');
            document.getElementById('clientName').textContent = event.extendedProps.client_name || 'Unknown';
            document.getElementById('lessonType').textContent = event.extendedProps.lesson_type || 'N/A';
            document.getElementById('lessonTime').textContent = `${event.start.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})} - ${event.end.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})}`;
            document.getElementById('paymentMethod').textContent = event.extendedProps.payment_method || 'N/A';

            modal.style.display = 'flex';

            document.getElementById('closeBookingBtn').onclick = () => {
                modal.style.display = 'none';
            };

            document.getElementById('viewClientBookingsBtn').onclick = () => {
                modal.style.display = 'none';
                // Later this could redirect to the client’s profile page:
                // window.location.href = `/coach/clients/${event.extendedProps.client_id}/bookings/`;
                alert('Show all bookings for this client');
            };
        }

    function openTimeCirclesModal(date, increment = 30, hourBlockSize = 1, rangesOrStart = null, endTime = null) {
        const modal = document.getElementById("timeCirclesModal");
        const container = document.getElementById("timeCirclesContainer");
        const title = document.getElementById("circleModalTitle");

        const coachHourBlockSelect = document.getElementById("hourBlockSelect");
        const coachIncrementSelect = document.getElementById("incrementSelect");
        const coachCustomBlockContainer = document.getElementById("customBlockInputContainer");
        const coachCustomBlockInput = document.getElementById("customBlockInput");
        const coachApplyCustomBlockBtn = document.getElementById("applyCustomBlockBtn");
        const coachCustomIncrementContainer = document.getElementById("customIncrementContainer");
        const coachCustomIncrementInput = document.getElementById("customIncrementInput");
        const coachApplyCustomIncrementBtn = document.getElementById("applyCustomIncrementBtn");

        resetClientViewStyles();

        modal.style.display = "flex";
        title.textContent = `Schedule for ${date}`;
        

        let currentBlockSize = hourBlockSize;
        let currentIncrement = increment;

        // Fetch bookings for this date
        let bookingsForDate = [];
        
        // Helper: parse ISO with offset directly to browser-local time
        // Booking "start"/"end" are ISO strings with timezone info
        const convertOrgTimeToBrowser = (isoStr) => {
            try { return new Date(isoStr); } catch { return null; }
        };
        
        const fetchBookings = async () => {
            try {
                const startStr = `${date}T00:00:00`;
                const endStr = `${date}T23:59:59`;
                const response = await fetch(`/bus/${orgSlug}/events/?start=${encodeURIComponent(startStr)}&end=${encodeURIComponent(endStr)}&_t=${Date.now()}`);
                if (response.ok) {
                    const allEvents = await response.json();
                    // Keep only real service bookings (exclude per-date overrides entirely)
                    bookingsForDate = allEvents.filter(e => {
                        const xp = e.extendedProps || {};
                        return !xp.is_blocking && !xp.is_per_date;
                    });
                }
            } catch (error) {
                console.error('Failed to fetch bookings:', error);
            }
        };

        // Normalize ranges: rangesOrStart may be an array of ranges or a single start string (backwards-compat)
        let rangesArr = [];
        try {
            if (Array.isArray(rangesOrStart)) {
                rangesArr = rangesOrStart.slice();
            } else if (rangesOrStart && typeof rangesOrStart === 'object') {
                rangesArr = [rangesOrStart];
            } else if (typeof rangesOrStart === 'string' && endTime) {
                rangesArr = [{ start: rangesOrStart, end: endTime }];
            }
        } catch (e) { rangesArr = []; }

        // If no ranges provided, derive from default weekly availability
        if (!rangesArr || rangesArr.length === 0) {
            try {
                const d = parseYMD(date);
                const dow = d.getDay();
                const info = defaultAvailability[dow] || {};
                const rs = info.ranges && info.ranges.length ? info.ranges : (info.start && info.end ? [`${info.start}-${info.end}`] : []);
                rangesArr = (rs || []).map(r => {
                    const parts = String(r).split('-');
                    return { start: (parts[0]||'09:00').trim(), end: (parts[1]||'17:00').trim() };
                });
            } catch (e) { rangesArr = [{ start: '09:00', end: '17:00' }]; }
        }

        // Deduplicate rangesArr by start-end to avoid duplicate rendering
        try {
            const seen = new Set();
            const uniq = [];
            for (const r of rangesArr) {
                try {
                    const s = (r && r.start) ? String(r.start).trim() : '';
                    const e = (r && r.end) ? String(r.end).trim() : '';
                    const key = `${s}-${e}`;
                    if (!seen.has(key)) { seen.add(key); uniq.push({ start: s || '09:00', end: e || '17:00' }); }
                } catch (ie) { /* ignore malformed */ }
            }
            rangesArr = uniq;
        } catch (e) { /* ignore dedupe errors */ }

        // Function to show booking details in a modal
        function showBookingInfo(booking) {
            const bookingModal = document.getElementById('bookingModal');
            if (!bookingModal) return;

            // Convert booking times from org timezone to user's browser timezone
            const startTime = convertOrgTimeToBrowser(booking.start);
            const endTime = convertOrgTimeToBrowser(booking.end);
            
            document.getElementById('clientName').textContent = booking.extendedProps.client_name || 'Unknown';
            document.getElementById('lessonType').textContent = booking.title || 'Booking';
            
            if (startTime && endTime) {
                document.getElementById('lessonTime').textContent = `${startTime.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})} - ${endTime.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})}`;
            } else {
                document.getElementById('lessonTime').textContent = 'Invalid time';
            }
            
            document.getElementById('paymentMethod').textContent = booking.extendedProps.payment_method || 'N/A';

            bookingModal.style.display = 'flex';

            document.getElementById('closeBookingBtn').onclick = () => {
                bookingModal.style.display = 'none';
            };

            document.getElementById('viewClientBookingsBtn').onclick = () => {
                bookingModal.style.display = 'none';
                // Could navigate to bookings list filtered by this client
                window.location.href = `/bus/${orgSlug}/bookings/`;
            };
        }

        function renderGrid(blockSize) {
            container.innerHTML = "";
            const blockMinutes = Math.max(1, blockSize) * 60;

            // Render per supplied range so multiple discontiguous ranges are supported
            for (const range of rangesArr) {
                // compute start/end minutes for this range
                let startTotalMinutes = 6 * 60;
                let endTotalMinutes = 22 * 60;
                try {
                    if (range.start) {
                        const parts = String(range.start).split(':');
                        const sh = parseInt(parts[0], 10);
                        const sm = parts.length > 1 ? parseInt(parts[1], 10) : 0;
                        if (!isNaN(sh)) startTotalMinutes = sh * 60 + (isNaN(sm) ? 0 : sm);
                    }
                    if (range.end) {
                        const parts = String(range.end).split(':');
                        const eh = parseInt(parts[0], 10);
                        const em = parts.length > 1 ? parseInt(parts[1], 10) : 0;
                        if (!isNaN(eh)) endTotalMinutes = eh * 60 + (isNaN(em) ? 0 : em);
                    }
                } catch (e) { /* ignore parse errors */ }

                for (let blockStart = startTotalMinutes; blockStart < endTotalMinutes; blockStart += blockMinutes) {
                    const row = document.createElement('div');
                    row.style.display = 'flex';
                    row.style.alignItems = 'center';
                    row.style.justifyContent = 'space-between';
                    row.style.gap = '8px';
                    row.style.borderBottom = '1px solid #ccc';

                    const blockLabel = document.createElement('div');
                    blockLabel.style.width = '70px';
                    blockLabel.style.fontWeight = 'bold';
                    const labelDate = parseYMD(date);
                    const startHourForLabel = Math.floor(blockStart / 60);
                    labelDate.setHours(startHourForLabel, 0, 0, 0);
                    if (blockMinutes > 60) {
                        const endLabelDate = parseYMD(date);
                        const endHourForLabel = Math.min(23, Math.floor((blockStart + blockMinutes) / 60));
                        endLabelDate.setHours(endHourForLabel, 0, 0, 0);
                        blockLabel.textContent = `${labelDate.toLocaleString(undefined, { hour: 'numeric', hour12: true })} - ${endLabelDate.toLocaleString(undefined, { hour: 'numeric', hour12: true })}`;
                    } else {
                        blockLabel.textContent = labelDate.toLocaleString(undefined, { hour: 'numeric', hour12: true });
                    }
                    row.appendChild(blockLabel);

                    const circlesContainer = document.createElement('div');
                    circlesContainer.className = 'circles-for-hour';
                    circlesContainer.style.display = 'flex';
                    circlesContainer.style.flexWrap = 'wrap';
                    circlesContainer.style.gap = '8px';
                    circlesContainer.style.marginLeft = 'auto';

                    for (let offset = 0; offset < blockMinutes; offset += currentIncrement) {
                        const totalMinutes = blockStart + offset;
                        if (totalMinutes >= endTotalMinutes) break;
                        const hour = Math.floor(totalMinutes / 60);
                        const min = totalMinutes % 60;

                        const ampm = hour >= 12 ? 'PM' : 'AM';
                        let displayHour = hour % 12;
                        if (displayHour === 0) displayHour = 12;
                        const timeLabel = `${displayHour}:${String(min).padStart(2, '0')} ${ampm}`;

                        const circle = document.createElement('div');
                        const slotDate = parseYMD(date);
                        slotDate.setHours(hour, min, 0, 0);
                        const slotEndDate = new Date(slotDate.getTime() + (increment * 60000));
                        const now = new Date();

                        // Check if this slot overlaps with any booking
                        // A slot overlaps if: slot_start < booking_end AND slot_end > booking_start
                        const booking = bookingsForDate.find(b => {
                            try {
                                // Convert booking times from org timezone to browser timezone
                                const bookingStart = convertOrgTimeToBrowser(b.start);
                                const bookingEnd = convertOrgTimeToBrowser(b.end);
                                
                                if (!bookingStart || !bookingEnd) return false;
                                
                                // Compare timestamps
                                const overlaps = slotDate.getTime() < bookingEnd.getTime() && slotEndDate.getTime() > bookingStart.getTime();
                                
                                return overlaps;
                            } catch (e) { 
                                console.error('Error checking booking overlap:', e);
                                return false; 
                            }
                        });

                        if (booking) {
                            // Slot is booked
                            circle.className = 'time-circle booked';
                            circle.textContent = 'Booked';
                            circle.dataset.time = timeLabel;
                            circle.dataset.bookingId = booking.id;

                            circle.addEventListener('click', () => {
                                showBookingInfo(booking);
                            });
                        } else if (slotDate < now) {
                            // Past time slot
                            circle.className = 'time-circle blocked';
                            circle.textContent = timeLabel;
                            circle.dataset.time = timeLabel;
                            circle.style.background = '#6c757d';
                            circle.style.cursor = 'not-allowed';

                            circle.addEventListener('click', () => {
                                alert(`This slot (${timeLabel}) is in the past.`);
                            });
                        } else {
                            // Available slot
                            circle.className = 'time-circle open';
                            circle.textContent = timeLabel;
                            circle.dataset.time = timeLabel;

                            circle.addEventListener('click', () => {
                                alert(`Slot: ${timeLabel} is available`);
                            });
                        }

                        circlesContainer.appendChild(circle);
                    }

                    row.appendChild(circlesContainer);
                    container.appendChild(row);
                }
            }

            if (container.lastElementChild) container.lastElementChild.style.borderBottom = 'none';
        }

        // Fetch bookings first, then render grid
        fetchBookings().then(() => {
            renderGrid(currentBlockSize);
        });

        // Handle coach settings - refetch bookings when re-rendering
        coachHourBlockSelect.onchange = () => {
            if (coachHourBlockSelect.value === "custom") coachCustomBlockContainer.style.display = "flex";
            else {
                coachCustomBlockContainer.style.display = "none";
                currentBlockSize = parseInt(coachHourBlockSelect.value);
                fetchBookings().then(() => renderGrid(currentBlockSize));
            }
        };
        coachApplyCustomBlockBtn.onclick = () => {
            const val = parseInt(coachCustomBlockInput.value);
            if (isNaN(val) || val<15) return alert("Enter valid minutes 15+");
            coachCustomBlockContainer.style.display="none";
            currentBlockSize = val/60;
            fetchBookings().then(() => renderGrid(currentBlockSize));
        };
        coachIncrementSelect.onchange = () => {
            if (coachIncrementSelect.value==="custom") coachCustomIncrementContainer.style.display="flex";
            else {
                coachCustomIncrementContainer.style.display="none";
                currentIncrement = parseInt(coachIncrementSelect.value);
                fetchBookings().then(() => renderGrid(currentBlockSize));
            }
        };
        coachApplyCustomIncrementBtn.onclick = () => {
            const val = parseInt(coachCustomIncrementInput.value);
            if (isNaN(val) || val<5) return alert("Enter valid increment 5+");
            coachCustomIncrementContainer.style.display="none";
            currentIncrement = val;
            fetchBookings().then(() => renderGrid(currentBlockSize));
        };

        // Close modal
        document.getElementById("closeCirclesBtn").onclick = () => {
            modal.style.display = "none";
        };

        // Add circle styles if not present
        if (!document.getElementById("timeCirclesStyle")) {
            const style = document.createElement("style");
            style.id = "timeCirclesStyle";
            style.innerHTML = `
                .time-circle {
                    width: 80px; height: 80px; border-radius: 50%;
                    display: flex; justify-content: center; align-items: center;
                    cursor: pointer; font-size: 13px; color: white; transition: transform 0.1s ease;
                }
                .time-circle.open { background: #28a745; }
                .time-circle.booked { background: #dc3545; }
                .time-circle.blocked { background: #6c757d; }
                .time-circle:hover { transform: scale(1.1); }
            `;
            document.head.appendChild(style);
        }
    }

    calendarEl.addEventListener('mousedown', e => {
        if (e.button !== 0) return;
        // Allow starting a drag from any rendered day cell (available OR unavailable),
        // but we will ignore past days below.
        const cell = e.target.closest('.fc-daygrid-day');
        if (!cell) return;

        const date = cell.dataset.date;
        const isPast = isPastDate(date);

        // Check for mixed selection immediately
        if (isPast && [...selectedDates].some(d => !isPastDate(d)) ||
            !isPast && [...selectedDates].some(d => isPastDate(d))) 
        {
            alert("You can only select past days or available days — not both at the same time.");
            // 🔹 reset drag state immediately
            isDragging = false;
            dragStartDate = null;
            dragMode = null;
            dragStartIsUnavailable = false;
            document.querySelectorAll('.fc-daygrid-day-number.temp-highlight').forEach(el => el.classList.remove('temp-highlight'));
            return;
        }

        // Handle past day click
        if (isPast) {
            openPastDayModal(date); // open modal
            return; // do not start dragging
        }

        // Start drag for future/available days
        isDragging = true;
        dragStartDate = date;
        dragMode = selectedDates.has(date) ? "deselect" : "select";

        // Record whether the drag started on an unavailable cell so we only
        // highlight cells of the same availability type during the drag.
        try {
            const numEl = cell.querySelector('.fc-daygrid-day-number');
            dragStartIsUnavailable = cell.classList.contains('fc-day-unavailable') || (numEl && numEl.classList.contains('unavailable-number'));
        } catch (e) { dragStartIsUnavailable = false; }

        // Immediate toggle for the first cell
        toggleDateSelection(date, dragMode === "select");
    });

    calendarEl.addEventListener('mousemove', e => {
        if (!isDragging || !dragStartDate) return;

        // During dragging, include any day cells (we'll only highlight those
        // matching the start cell's availability type).
        const cell = e.target.closest('.fc-daygrid-day');
        if (!cell) return;
        const currentDate = cell.dataset.date;

        // Skip if mixed past/future detected
        const isPast = isPastDate(currentDate);
        if (isPast && [...selectedDates].some(d => !isPastDate(d)) ||
            !isPast && [...selectedDates].some(d => isPastDate(d))) 
        {
            isDragging = false;
            dragStartDate = null;
            dragMode = null;
            dragStartIsUnavailable = false;
            document.querySelectorAll('.fc-daygrid-day-number.temp-highlight').forEach(el => el.classList.remove('temp-highlight'));
            return;
        }

        const start = parseYMD(dragStartDate);
        const end = parseYMD(currentDate);
        const minDate = start < end ? start : end;
        const maxDate = start > end ? start : end;

        const selector = dragStartIsUnavailable ? '.fc-daygrid-day.fc-day-unavailable' : '.fc-daygrid-day.fc-day-available';
        document.querySelectorAll(selector).forEach(c => {
            const dateStr = c.dataset.date;
            const numberEl = c.querySelector('.fc-daygrid-day-number');
            if (!numberEl || !dateStr) return;

            const date = parseYMD(dateStr);
            if (date >= minDate && date <= maxDate) {
                numberEl.classList.add('temp-highlight');
                if (dragMode === 'select') numberEl.classList.add('selected');
                else numberEl.classList.remove('selected');
            } else {
                numberEl.classList.remove('temp-highlight');
                if (dragMode === 'select' && !selectedDates.has(dateStr)) numberEl.classList.remove('selected');
                if (dragMode === 'deselect' && selectedDates.has(dateStr)) numberEl.classList.add('selected');
            }
        });
    });

    document.addEventListener('mouseup', () => {
        if (!isDragging) return;

        document.querySelectorAll('.fc-daygrid-day-number.temp-highlight').forEach(el => {
            el.classList.remove('temp-highlight');
            const date = el.closest('.fc-daygrid-day').dataset.date;
            if (dragMode === 'select') selectedDates.add(date);
            else if (dragMode === 'deselect') selectedDates.delete(date);
        });

        isDragging = false;
        dragStartDate = null;
        dragMode = null;
        dragStartIsUnavailable = false;

        updateClearButton();
        updateSelectButtonText();
    });

    function saveNewlySelectedDates() {
        const selectedStartTime = document.getElementById('startTime')?.value || "09:00";
        const selectedEndTime = document.getElementById('endTime')?.value || "17:00";
        const datesArray = Array.from(selectedDates);
        // Pre-clean: remove existing overrides for these dates to avoid duplicates
        fetch(`/bus/${orgSlug}/bookings/batch_delete/`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
            body: JSON.stringify({ dates: datesArray })
        }).catch(err => console.warn('batch_delete pre-clean failed', err)).finally(() => {
            // Optimistically add per-date background events so they override defaults immediately
            try {
                datesArray.forEach(d => {
                    try {
                        calendar.addEvent({ start: d + 'T' + selectedStartTime, end: d + 'T' + selectedEndTime, display: 'background', color: '#d0f0d0', extendedProps: { is_per_date: true } });
                    } catch (e) { /* ignore */ }
                });
            } catch (e) { console.warn('optimistic add failed', e); }

            fetch(`/bus/${orgSlug}/bookings/batch_create/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken
            },
            body: JSON.stringify({
                dates: datesArray,  // e.g. ['2025-11-10', '2025-11-11']
                start_time: selectedStartTime,
                end_time: selectedEndTime
            })
        })
        .then(r => r.json())
        .then(data => {
            console.log('created', data);
            // Refresh events to reconcile with server truth (server may attach ids/changes)
            try { calendar.refetchEvents(); } catch(e) { console.warn('refetchEvents failed', e); }
        })
        .catch(err => console.error(err));
        });
    }

    function toUTCDate(dateStr) {
        const d = parseYMD(dateStr);
        return new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
    }


    selectBtn.addEventListener('click', () => {
        const dates = Array.from(selectedDates).sort(); // ['2025-11-01', '2025-11-02', ...]
        
        // ✅ Check if no days are selected
        if (dates.length === 0) {
            alert("Drag to highlight multiple days on the calendar. Select only one to view the schedule for that day. Select a past date to view previous bookings for records.");
            return; // stop further execution
        }
        

        const modal = document.getElementById('timeModal');
        const viewDayBtn = document.getElementById('viewDayBtn');
        const summary = document.getElementById('selectedDaysSummary');

        // Helper to format "YYYY-MM-DD" into "Month DDth"
        function formatDateStr(dateStr) {
            const [year, month, day] = dateStr.split('-');
            const date = parseYMD(`${year}-${month}-${day}`);
            const monthName = date.toLocaleString(undefined, { month: 'long' });
            const dayNum = parseInt(day);
            let suffix = "th";
            if (dayNum === 1 || dayNum === 21 || dayNum === 31) suffix = "st";
            else if (dayNum === 2 || dayNum === 22) suffix = "nd";
            else if (dayNum === 3 || dayNum === 23) suffix = "rd";
            return `${monthName} ${dayNum}${suffix}`;
        }

        // Helper to check if two dates are consecutive
        function areConsecutive(prevStr, currStr) {
            const prevDate = parseYMD(prevStr);
            const currDate = parseYMD(currStr);
            const diffDays = (currDate - prevDate) / (1000 * 60 * 60 * 24);
            return diffDays === 1;
        }

        const ranges = [];
        let rangeStart = dates[0];
        let prev = dates[0];

        for (let i = 1; i < dates.length; i++) {
            const curr = dates[i];

            const prevDate = parseYMD(prev);
            const currDate = parseYMD(curr);

            const sameMonth = prevDate.getMonth() === currDate.getMonth();
            const consecutive = (currDate - prevDate) / (1000 * 60 * 60 * 24) === 1;

            if (consecutive && sameMonth) {
                prev = curr; // continue range
            } else {
                // Push the previous range
                if (rangeStart === prev) {
                    ranges.push(formatDateStr(rangeStart));
                } else {
                    ranges.push(`${formatDateStr(rangeStart)}-${formatDateStr(prev).split(' ')[1]}`);
                }
                rangeStart = curr;
                prev = curr;
            }
        }

        // Push the final range
        if (rangeStart === prev) {
            ranges.push(formatDateStr(rangeStart));
        } else {
            ranges.push(`${formatDateStr(rangeStart)}-${formatDateStr(prev).split(' ')[1]}`);
        }

        // Display summary
        if (dates.length === 1) {
            summary.textContent = `Selected day: ${formatDateStr(dates[0])}`;
            // Only show the View Day Schedule button if the selected day is not marked unavailable and not past
            try {
                const cell = document.querySelector(`.fc-daygrid-day[data-date="${dates[0]}"]`);
                const num = cell ? cell.querySelector('.fc-daygrid-day-number') : null;
                const isUnavailable = cell && (cell.classList.contains('fc-day-unavailable') || (num && num.classList.contains('unavailable-number')));
                const saveBtnEl = document.getElementById('saveTimeBtn');
                if (!isUnavailable && !isPastDate(dates[0])) {
                    viewDayBtn.style.display = 'inline-block';
                    if (saveBtnEl) saveBtnEl.style.display = 'inline-block';
                } else {
                    viewDayBtn.style.display = 'none';
                    if (saveBtnEl) saveBtnEl.style.display = 'none';
                }
            } catch (e) { try { viewDayBtn.style.display = 'none'; const saveBtnEl = document.getElementById('saveTimeBtn'); if (saveBtnEl) saveBtnEl.style.display = 'none'; } catch(ex) {} }
            selectBtn.textContent = "Select Day";

            // Populate ranges UI (below) — do not use single modalStart/modalEnd inputs.

            // Ensure the time inputs are hidden when the date is fully unavailable
            try { setModalTimeRowVisibility(dates[0]); } catch (e) { /* ignore */ }

                // If per-date timed overrides exist, populate the modalRangesContainer and prefer those times
                try {
                    const rangesContainer = document.getElementById('modalRangesContainer');
                    rangesContainer.innerHTML = '';
                    const overrides = findPerDateTimedOverrides(dates[0]);
                    if (overrides && overrides.length > 0) {
                        // populate rows from overrides (dedupe identical start-end pairs)
                        const seen = new Set();
                        overrides.forEach(o => {
                            try {
                                const key = `${o.start}-${o.end}`;
                                if (!seen.has(key)) {
                                    seen.add(key);
                                    rangesContainer.appendChild(createModalRangeRow(o.start, o.end));
                                }
                            } catch (e) { /* ignore row errors */ }
                        });
                    } else {
                        // populate rows from weekly defaults if multiple ranges exist, otherwise single default
                        const d = parseYMD(dates[0]);
                        const dow = d.getDay();
                        const info = defaultAvailability[dow] || {};
                        const ranges = info.ranges && info.ranges.length ? info.ranges : (info.start && info.end ? [`${info.start}-${info.end}`] : []);
                        if (ranges && ranges.length) {
                            ranges.forEach(r => {
                                try {
                                    const parts = r.split('-');
                                    const s = parts[0] ? parts[0].trim() : '09:00';
                                    const e = parts[1] ? parts[1].trim() : '17:00';
                                    rangesContainer.appendChild(createModalRangeRow(s, e));
                                } catch (e) {}
                            });
                        } else {
                            // fallback single row: use weekly defaults or sensible times
                            try {
                                const parts = (info.start && info.end) ? [info.start, info.end] : ['09:00','17:00'];
                                const s = (parts[0]||'09:00').trim();
                                const e = (parts[1]||'17:00').trim();
                                rangesContainer.appendChild(createModalRangeRow(s, e));
                            } catch (e) {
                                rangesContainer.appendChild(createModalRangeRow('09:00','17:00'));
                            }
                        }
                    }

                    // wire Add Range button to append a blank row
                    const addBtn = document.getElementById('addModalRangeBtn');
                    if (addBtn) {
                        addBtn.onclick = () => rangesContainer.appendChild(createModalRangeRow('09:00','17:00'));
                    }
                } catch (e) { console.warn('populate modal ranges failed', e); }

            // Show Make Available button if this single selected day is currently unavailable
            try {
                const makeAvailableBtn = document.getElementById('makeAvailableBtn');
                if (makeAvailableBtn) {
                    const cell = document.querySelector(`.fc-daygrid-day[data-date="${dates[0]}"]`);
                    const num = cell ? cell.querySelector('.fc-daygrid-day-number') : null;
                    const isUnavailable = cell && (cell.classList.contains('fc-day-unavailable') || (num && num.classList.contains('unavailable-number')));
                    // Only show Make Available for future unavailable days
                    if (isUnavailable && !isPastDate(dates[0])) {
                        makeAvailableBtn.style.display = 'inline-block';
                        makeAvailableBtn.onclick = async () => {
                            if (!confirm(`Make ${dates[0]} available and open editor?`)) return;
                            try {
                                const res = await fetch(`/bus/${orgSlug}/bookings/batch_delete/`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                                    body: JSON.stringify({ dates: [dates[0]] })
                                });
                                const data = await res.json().catch(() => null);
                                if (res.ok) {
                                    // Remove any full-day block for this date
                                    try {
                                        calendar.getEvents().forEach(ev => {
                                            try {
                                                if (ev.display === 'background' && ev.startStr && ev.startStr.startsWith(dates[0])) ev.remove();
                                            } catch (e) { /* ignore per-event errors */ }
                                        });
                                    } catch (e) { /* ignore */ }

                                    // Add a green background event for this date to mark it as available (optimistic UI)
                                    try {
                                        // Mark this optimistic available background as a per-date override
                                        calendar.addEvent({
                                            start: dates[0] + 'T09:00',
                                            end: dates[0] + 'T17:00',
                                            display: 'background',
                                            color: '#d0f0d0',
                                            extendedProps: { is_per_date: true }
                                        });
                                    } catch (e) { /* ignore */ }

                                    // Update classes immediately
                                    try { updateUnavailableDays(); } catch (e) {}
                                    try { calendar.refetchEvents(); } catch (e) {}

                                    // Close the current selection modal and open the per-day available editor
                                    try { modal.style.display = 'none'; } catch (e) {}
                                    // Ensure modal buttons reflect the new available state: show View Day Schedule, hide Make Available
                                    try {
                                        const viewDayBtn = document.getElementById('viewDayBtn');
                                        const makeAvailableBtnEl = document.getElementById('makeAvailableBtn');
                                        const makeUnavailableBtnEl = document.getElementById('makeUnavailableBtn');
                                        if (viewDayBtn) viewDayBtn.style.display = 'inline-block';
                                        if (makeAvailableBtnEl) makeAvailableBtnEl.style.display = 'none';
                                        if (makeUnavailableBtnEl) makeUnavailableBtnEl.style.display = 'inline-block';
                                    } catch(e){}
                                    openMakeAvailableModal(dates[0]);
                                } else {
                                    const msg = (data && (data.error || data.message)) || `Server returned ${res.status}`;
                                    alert('Error making available: ' + msg);
                                }
                            } catch (err) {
                                console.error('Make available failed', err);
                                alert('Error: ' + (err && err.message ? err.message : String(err)));
                            }
                        };
                    } else {
                        makeAvailableBtn.style.display = 'none';
                    }
                }
            } catch (e) { /* ignore */ }
                } else {
            // Ensure any leftover single-day "make available" notice is removed
            try {
                const notice = document.getElementById('makeAvailableNotice'); if (notice) notice.remove();
            } catch (e) {}

            // Hide per-day ranges UI and add/save/view/make-available buttons for multi-day selection
            try {
                const rangesContainer = document.getElementById('modalRangesContainer'); if (rangesContainer) rangesContainer.style.display = 'none';
                const addBtn = document.getElementById('addModalRangeBtn'); if (addBtn) addBtn.style.display = 'none';
                const saveBtn = document.getElementById('saveTimeBtn'); if (saveBtn) saveBtn.style.display = 'none';
                const viewBtn = document.getElementById('viewDayBtn'); if (viewBtn) viewBtn.style.display = 'none';
                const makeAvailableBtn = document.getElementById('makeAvailableBtn'); if (makeAvailableBtn) makeAvailableBtn.style.display = 'none';
            } catch (e) { /* ignore */ }

            summary.textContent = `${dates.length} days selected: ${ranges.join(', ')}`;
            viewDayBtn.style.display = 'none';
            selectBtn.textContent = "Select Days";

            // If multiple days selected, offer "Make Available" when ALL selected
            // days are currently unavailable (and none are in the past).
            try {
                const makeAvailableBtn = document.getElementById('makeAvailableBtn');
                if (makeAvailableBtn) {
                    const allUnavailable = dates.every(d => {
                        try {
                            if (isPastDate(d)) return false;
                            const c = document.querySelector(`.fc-daygrid-day[data-date="${d}"]`);
                            const n = c ? c.querySelector('.fc-daygrid-day-number') : null;
                            return c && (c.classList.contains('fc-day-unavailable') || (n && n.classList.contains('unavailable-number')));
                        } catch (e) { return false; }
                    });

                    if (allUnavailable) {
                        makeAvailableBtn.style.display = 'inline-block';
                        makeAvailableBtn.onclick = async () => {
                            if (!confirm(`Make ${dates.length} selected day(s) available?`)) return;
                            try {
                                // Compute groups (start/end per date) up-front so we can optimistically update UI
                                const groups = {}; // key -> { start, end, dates: [] }
                                for (const d of dates) {
                                    try {
                                        const dow = parseYMD(d).getDay();
                                        const info = defaultAvailability[dow] || {};
                                        let start = '09:00', end = '17:00';
                                        if (info.ranges && info.ranges.length) {
                                            const first = info.ranges[0];
                                            if (first && first.includes('-')) {
                                                const parts = first.split('-');
                                                start = parts[0].trim(); end = parts[1].trim();
                                            }
                                        } else if (info.start && info.end) {
                                            start = info.start; end = info.end;
                                        }
                                        const key = `${start}|${end}`;
                                        if (!groups[key]) groups[key] = { start, end, dates: [] };
                                        groups[key].dates.push(d);
                                    } catch (e) { console.warn('grouping date failed', d, e); }
                                }

                                // Optimistic UI: remove grey blocks and mark days available immediately
                                try {
                                    for (const d of dates) {
                                        // remove any full-day grey background events for this date
                                        calendar.getEvents().forEach(ev => {
                                            try {
                                                if (ev.display === 'background' && ev.startStr && ev.startStr.startsWith(d) && (ev.backgroundColor === '#e0e0e0' || ev.color === '#e0e0e0')) {
                                                    ev.remove();
                                                }
                                            } catch (e) { /* ignore per-event */ }
                                        });

                                        // add a per-date available background using the date's default time
                                        const dow = parseYMD(d).getDay();
                                        const info = defaultAvailability[dow] || {};
                                        let s = '09:00', e = '17:00';
                                        if (info.ranges && info.ranges.length) {
                                            const first = info.ranges[0];
                                            if (first && first.includes('-')) {
                                                const parts = first.split('-'); s = parts[0].trim(); e = parts[1].trim();
                                            }
                                        } else if (info.start && info.end) { s = info.start; e = info.end; }

                                        try {
                                            calendar.addEvent({ start: d + 'T' + s, end: d + 'T' + e, display: 'background', color: '#d0f0d0', extendedProps: { is_per_date: true } });
                                        } catch (ee) { /* ignore addEvent errors */ }

                                        // Update day cell classes immediately
                                        try {
                                            const cell = document.querySelector(`.fc-daygrid-day[data-date="${d}"]`);
                                            if (cell) {
                                                cell.classList.remove('fc-day-unavailable');
                                                cell.classList.add('fc-day-available');
                                                const num = cell.querySelector('.fc-daygrid-day-number');
                                                if (num) {
                                                    num.classList.remove('unavailable-number');
                                                    num.style.cursor = 'pointer';
                                                }
                                            }
                                        } catch (e) { /* ignore per-cell errors */ }
                                    }
                                } catch (e) { console.warn('optimistic UI update failed', e); }

                                // First, remove any per-day blocks or avails that explicitly block these dates
                                const delRes = await fetch(`/bus/${orgSlug}/bookings/batch_delete/`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                                    body: JSON.stringify({ dates: dates })
                                });
                                const delData = await delRes.json().catch(() => null);
                                if (!delRes.ok) {
                                    const msg = (delData && (delData.error || delData.message)) || `Server returned ${delRes.status}`;
                                    alert('Error making available (cleanup step): ' + msg);
                                    // Re-fetch server state to revert optimistic edits
                                    try { await calendar.refetchEvents(); } catch(e){}
                                    try { updateUnavailableDays(); } catch(e){}
                                    return;
                                }

                                // For each group, call batch_create to add per-date available overrides
                                const creationPromises = Object.values(groups).map(g => {
                                    return fetch(`/bus/${orgSlug}/bookings/batch_create/`, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                                        body: JSON.stringify({ dates: g.dates, start_time: g.start, end_time: g.end })
                                    }).then(r => r.json().catch(() => null).then(data => ({ ok: r.ok, data })));
                                });

                                const creationResults = await Promise.all(creationPromises);
                                // If any creation failed, surface a message but continue to refresh UI
                                const failed = creationResults.filter(r => !r.ok);
                                if (failed.length) {
                                    console.warn('Some per-date creation requests failed', failed);
                                    alert('Some dates could not be made available. Check console for details.');
                                }

                                // Refresh UI from server to reconcile authoritative state
                                try { await calendar.refetchEvents(); } catch(e){}
                                try { updateUnavailableDays(); } catch(e){}
                                alert('Selected days made available.');
                            } catch (err) {
                                console.error('Make available failed', err);
                                alert('Error: ' + (err && err.message ? err.message : String(err)));
                                try { await calendar.refetchEvents(); } catch(e){}
                                try { updateUnavailableDays(); } catch(e){}
                            }
                            // close modal
                            modal.style.display = 'none';
                        };
                    } else {
                        makeAvailableBtn.style.display = 'none';
                    }
                }
            } catch (e) { /* ignore */ }
        }

        modal.style.display = 'flex';

        // Handle "View Day Schedule"
        viewDayBtn.onclick = () => {
            modal.style.display = 'none';
            // Build ranges to pass to the day schedule modal: prefer per-date overrides, fall back to weekly defaults
            let ranges = findPerDateTimedOverrides(dates[0]);
            if (!ranges || ranges.length === 0) {
                const d = parseYMD(dates[0]);
                const dow = d.getDay();
                const info = defaultAvailability[dow] || {};
                const rs = info.ranges && info.ranges.length ? info.ranges : (info.start && info.end ? [`${info.start}-${info.end}`] : []);
                ranges = rs.map(r => {
                    const parts = r.split('-');
                    return { start: (parts[0]||'09:00').trim(), end: (parts[1]||'17:00').trim() };
                });
            }
            openTimeCirclesModal(dates[0], 30, 1, ranges);
        };

        // Show Make Unavailable button for the selected dates (only when none are already unavailable and none are past)
        const makeUnavailableBtn = document.getElementById('makeUnavailableBtn');
        if (makeUnavailableBtn) {
            const anyPast = dates.some(d => isPastDate(d));
            const anyAlreadyUnavailable = dates.some(d => {
                try {
                    const c = document.querySelector(`.fc-daygrid-day[data-date="${d}"]`);
                    const n = c ? c.querySelector('.fc-daygrid-day-number') : null;
                    return c && (c.classList.contains('fc-day-unavailable') || (n && n.classList.contains('unavailable-number')));
                } catch (e) { return false; }
            });

            makeUnavailableBtn.style.display = (anyPast || anyAlreadyUnavailable) ? 'none' : 'inline-block';

            makeUnavailableBtn.onclick = async () => {
                if (!confirm(`Mark ${dates.length} selected day(s) as unavailable? This will block each selected day.`)) return;
                try {
                    const res = await fetch(`/bus/${orgSlug}/bookings/batch_create/`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                        body: JSON.stringify({ dates: dates, start_time: '00:00', end_time: '23:59', is_blocking: true })
                    });
                    const data = await res.json().catch(() => null);
                    if (res.ok) {
                        // Apply UI changes immediately for responsiveness
                        dates.forEach(d => applyPerDateUnavailable(d));
                        try { calendar.refetchEvents(); } catch(e){}
                        try { updateUnavailableDays(); } catch(e){}
                        alert('Selected days marked unavailable.');
                        // Clear selection after making unavailable
                        selectedDates.clear();
                        document.querySelectorAll('.fc-daygrid-day-number.selected').forEach(el => el.classList.remove('selected'));
                        updateClearButton();
                        updateSelectButtonText();
                    } else {
                        const msg = (data && (data.error || data.message)) || `Server returned ${res.status}`;
                        alert('Error marking unavailable: ' + msg);
                    }
                } catch (err) {
                    console.error('Make unavailable failed', err);
                    alert('Error: ' + (err && err.message ? err.message : String(err)));
                }
                modal.style.display = 'none';
            };
        }

        // Handle "Save" button: create calendar-level overrides (do NOT change defaults)
        document.getElementById('saveTimeBtn').onclick = async () => {
            // Gather ranges from modalRangesContainer if present, otherwise fall back to single inputs
            const ranges = [];
            try {
                const rangesContainer = document.getElementById('modalRangesContainer');
                if (rangesContainer) {
                    const rows = Array.from(rangesContainer.querySelectorAll('.modal-range-row'));
                    for (const r of rows) {
                        try {
                            const s = r.querySelector('.modal-range-start').value;
                            const e = r.querySelector('.modal-range-end').value;
                            if (s && e && s < e) ranges.push({ start: s, end: e });
                        } catch (ie) { /* ignore invalid rows */ }
                    }
                }
            } catch (e) { /* ignore */ }

            if (ranges.length === 0) {
                // If the coach explicitly removed all ranges for a single selected date,
                // treat this action as "mark the date unavailable" instead of silently
                // falling back to weekly defaults.
                if (dates.length === 1) {
                    const theDate = dates[0];
                    if (!confirm(`No time ranges provided. Mark ${theDate} as unavailable for the whole day?`)) return;
                    try {
                        const res = await fetch(`/bus/${orgSlug}/bookings/batch_create/`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                            body: JSON.stringify({ dates: [theDate], start_time: '00:00', end_time: '23:59', is_blocking: true })
                        });
                        const data = await res.json().catch(() => null);
                        if (res.ok) {
                            // Apply UI changes immediately for responsiveness
                            applyPerDateUnavailable(theDate);
                            try { await calendar.refetchEvents(); } catch (e) {}
                            try { updateUnavailableDays(); } catch (e) {}
                            alert('Date marked unavailable.');
                        } else {
                            const msg = (data && (data.error || data.message)) || `Server returned ${res.status}`;
                            alert('Error marking unavailable: ' + msg);
                        }
                    } catch (err) {
                        console.error('Make unavailable failed', err);
                        alert('Error: ' + (err && err.message ? err.message : String(err)));
                    }
                    modal.style.display = 'none';
                    // Clear selection for single-date
                    try { selectedDates.delete(dates[0]); document.querySelectorAll('.fc-daygrid-day-number.selected').forEach(el => el.classList.remove('selected')); updateClearButton(); updateSelectButtonText(); } catch(e){}
                    return;
                }

                // Otherwise fallback to weekly defaults for the first selected date, otherwise sensible times
                try {
                    const d = parseYMD(dates[0]);
                    const dow = d.getDay();
                    const info = defaultAvailability[dow] || {};
                    const rs = info.ranges && info.ranges.length ? info.ranges : (info.start && info.end ? [`${info.start}-${info.end}`] : []);
                    if (rs && rs.length) {
                        const parts = rs[0].split('-');
                        const s = (parts[0]||'09:00').trim();
                        const e = (parts[1]||'17:00').trim();
                        if (s && e && s < e) ranges.push({ start: s, end: e });
                    } else {
                        const s = document.getElementById('startTime')?.value || '09:00';
                        const e = document.getElementById('endTime')?.value || '17:00';
                        if (s && e && s < e) ranges.push({ start: s, end: e });
                    }
                } catch (e) {
                    // final fallback
                    ranges.push({ start: '09:00', end: '17:00' });
                }
            }

            if (ranges.length === 0) return alert('No valid ranges to save.');

            try {
                // First remove existing per-date overrides for these dates
                try {
                    const delRes = await fetch(`/bus/${orgSlug}/bookings/batch_delete/`, {
                        method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken }, body: JSON.stringify({ dates: dates })
                    });
                    // ignore result details — we'll refetch after creating
                } catch (e) { /* ignore delete errors */ }

                    // Deduplicate ranges by start-end to avoid creating duplicates
                    const uniqueRanges = [];
                    const seenRanges = new Set();
                    for (const rr of ranges) {
                        try {
                            const key = `${rr.start}-${rr.end}`;
                            if (!seenRanges.has(key)) { seenRanges.add(key); uniqueRanges.push(rr); }
                        } catch (e) { /* ignore malformed range */ }
                    }

                    // Now create each unique range for each selected date
                    for (const r of uniqueRanges) {
                    try {
                        // optimistic UI addition
                        dates.forEach(d => {
                            try { calendar.addEvent({ start: d + 'T' + r.start, end: d + 'T' + r.end, display: 'background', color: '#d0f0d0', extendedProps: { is_per_date: true } }); } catch(e) {}
                        });

                        const res = await fetch(`/bus/${orgSlug}/bookings/batch_create/`, {
                            method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                            body: JSON.stringify({ dates: dates, start_time: r.start, end_time: r.end })
                        });
                        const data = await res.json().catch(() => null);
                        if (!res.ok) {
                            const msg = (data && (data.error || data.message)) || `Server returned ${res.status}`;
                            console.warn('Error creating range', r, msg);
                        }
                    } catch (err) { console.error('range create failed', err); }
                }

                try { await calendar.refetchEvents(); } catch(e){}
                alert('Saved overrides for selected day(s).');
            } catch (err) {
                console.error('Save failed', err);
                alert('Error saving overrides: ' + (err && err.message ? err.message : String(err)));
            }

            // close modal but do not mutate defaultAvailability
            modal.style.display = 'none';
        };

        // Wire Reset-to-default button for the currently selected dates
        const resetBtn = document.getElementById('resetToDefaultBtn');
        resetBtn.onclick = async () => {
            if (!confirm('Reset selected day(s) to weekly defaults? This will remove per-day overrides (client-side).')) return;
            try {
                // Work on a copy of dates
                const targets = dates.slice();

                // Remove client-side background events for these dates so UI immediately reflects defaults
                calendar.getEvents().forEach(ev => {
                    try {
                        if (ev.display === 'background' && ev.startStr) {
                            const evDate = (ev.startStr || '').split('T')[0];
                            for (const d of targets) {
                                if (evDate === d) {
                                    ev.remove();
                                    break;
                                }
                            }
                        }
                    } catch(e) { /* ignore per-event errors */ }
                });

                // Clear per-day classes for the targets so updateUnavailableDays can recompute
                targets.forEach(d => {
                    try {
                        const cell = document.querySelector(`.fc-daygrid-day[data-date="${d}"]`);
                        if (!cell) return;
                        cell.classList.remove('fc-day-unavailable');
                        cell.classList.remove('fc-day-available');
                        const num = cell.querySelector('.fc-daygrid-day-number');
                        if (num) {
                            num.classList.remove('unavailable-number');
                            num.classList.remove('selected');
                        }
                    } catch(e) { /* ignore per-cell errors */ }
                });

                // Re-sync defaults to calendar for visual fallback (over the current view)
                try { syncAvailabilityToCalendar(); } catch(e) { console.warn('sync failed', e); }

                // Ensure classes reflect the newly-synced defaults
                try { updateUnavailableDays(); } catch(e) { console.warn('updateUnavailableDays failed', e); }

                // Best-effort: ask server to remove per-day overrides if endpoint exists
                try {
                    const res = await fetch(`/bus/${orgSlug}/bookings/batch_delete/`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                        body: JSON.stringify({ dates: targets })
                    });
                    if (res.ok) {
                        try { await res.json(); } catch(e) {}
                        // If server acknowledged deletion, refetch to ensure server-side state matches UI
                        try { await calendar.refetchEvents(); } catch(e) { console.warn('refetch after delete failed', e); }
                        alert('Reset completed. Calendar now shows weekly defaults.');
                    } else {
                        // Endpoint may not exist; fall back to client-only reset
                        console.warn('Server reset failed or endpoint missing', res.status);
                        alert('Reset applied locally. Server may require an endpoint to persist this change.');
                        try { await calendar.refetchEvents(); } catch(e) {}
                    }
                } catch (err) {
                    console.warn('batch_delete request failed', err);
                    alert('Reset applied locally. Server request failed.');
                    try { await calendar.refetchEvents(); } catch(e) {}
                }

                // Ensure the selection UI is cleared after reset
                try {
                    selectedDates.clear();
                    document.querySelectorAll('.fc-daygrid-day-number.selected').forEach(el => el.classList.remove('selected'));
                    updateClearButton();
                    updateSelectButtonText();
                } catch (e) { console.warn('clearing selection UI failed', e); }
            } catch (err) {
                console.error('Reset failed', err);
                alert('Reset failed: ' + (err && err.message ? err.message : String(err)));
            }

            modal.style.display = 'none';
        };

        // Handle "Cancel" button
        document.getElementById('closeTimeBtn').onclick = () => {
            modal.style.display = 'none';
        };
    });

    document.getElementById('selectAllBtn').addEventListener('click', () => {
        // Select all future (non-past) days in the currently rendered month view.
        const cells = document.querySelectorAll('.fc-daygrid-day');

        // Block if any past day is selected (keep selection homogenous)
        if ([...selectedDates].some(d => isPastDate(d))) {
            alert("You can only select past days or available days — not both at the same time.");
            return;
        }

        // Mark that the user used Highlight All so modal logic can hide Make Available
        window._highlightAll = true;

        cells.forEach(cell => {
            const dateStr = cell.dataset.date;
            if (!dateStr) return;
            if (isPastDate(dateStr)) return; // skip past

            const numberEl = cell.querySelector('.fc-daygrid-day-number');
            if (!numberEl) return;
            numberEl.classList.add('selected');
            selectedDates.add(dateStr);
        });

        updateClearButton();
        updateSelectButtonText();
    });

    clearBtn.addEventListener('click', () => {
        document.querySelectorAll('.fc-daygrid-day-number.selected').forEach(el => {
            el.classList.remove('selected');
        });
        selectedDates.clear();
        updateClearButton();

        selectBtn.textContent = "Select Day";
    });

    // --- MODAL HANDLING LOGIC ---
    const timeModal = document.getElementById('timeModal');
    const saveTimeBtn = document.getElementById('saveTimeBtn');
    const closeTimeBtn = document.getElementById('closeTimeBtn');
    const selectedDaysSummary = document.getElementById('selectedDaysSummary');

});
    // Sync the cc-wave animations across sections by setting a shared negative
    // animation-delay equal to the elapsed phase of the animation duration.
    // This keeps all gradients visually in-step even if elements mount at
    // slightly different times.
    (function syncCcWave() {
        try {
            // Read duration from CSS var if present, fallback to 14s
            const root = document.documentElement;
            const cssRaw = getComputedStyle(root).getPropertyValue('--cc-wave-duration') || '14s';
            const cssDur = parseFloat(cssRaw);
            const dur = Number(cssDur) || 14; // seconds

            // Set a single initial offset so elements mounted at different times
            // appear visually in-step. Avoid updating this every animation frame
            // (which forces repaints each frame) — recompute only when the page
            // becomes visible again to keep CPU usage low.
            function setOffsetOnce() {
                const nowSec = performance.now() / 1000; // high-res
                const elapsed = nowSec % dur; // seconds into animation
                const offset = `-${elapsed.toFixed(3)}s`;
                root.style.setProperty('--cc-wave-offset', offset);
            }

            setOffsetOnce();
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) setOffsetOnce();
            });
        } catch (e) { /* fail silently */ }
    })();

</script>
{% endblock %}


