{% extends 'calendar_app/base.html' %}
{% load tz %}
{% block title %}Calendar{% endblock %}
{% block extra_head %}
<!-- Select2 Styles + JS -->
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>

<!-- FullCalendar Styles -->
<link href="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.8/main.min.css" rel="stylesheet" />

<!-- FullCalendar JS -->
<script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.8/index.global.min.js"></script>
{% endblock %}

{% block content %}

<div style="margin-bottom:32px;">
    <div style="display:flex; justify-content:center; align-items:center; margin-bottom:12px; flex-direction:column;">
        <div style="text-align:center;">
            <h1 class="calendar-title" style="font-size:32px; font-weight:800; margin:0 0 8px 0; letter-spacing:-0.5px;">Calendar</h1>
            <p style="color:var(--gray-600); font-size:15px; margin:0;">Manage your availability and view bookings</p>
        </div>
        {% if is_team_plan %}
            <div style="width:min(460px, 92vw); margin-top:12px; text-align:center;">
                <label for="memberSelect" style="display:block;font-size:12px;color:var(--gray-600);margin-bottom:6px;">Showing calendar for</label>
                <!-- Keep a hidden select in the DOM for legacy initialization code that enumerates members. -->
                <select id="memberSelect" style="display:none" aria-hidden="true">
                    {% for m in members_list %}
                        {% with fname=m.user__first_name lname=m.user__last_name email=m.user__email %}
                            <option value="{{ m.id }}">{% if fname or lname %}{{ fname }} {{ lname }}{% else %}{{ email }}{% endif %}</option>
                        {% endwith %}
                    {% endfor %}
                </select>

                <!-- New nested scope menu: Members -> Personal Services -->
                <div id="ccScopeMenuRoot" style="position:relative; display:inline-block; width:100%; text-align:left;">
                    <button id="ccScopeMenuButton" type="button" style="width:100%; padding:10px 12px; border-radius:10px; border:1px solid var(--gray-200); background:white; box-shadow: 0 1px 2px rgba(16,24,40,0.04); font-size:14px; color:var(--gray-900); display:flex; align-items:center; justify-content:space-between; gap:10px;">
                        <span id="ccScopeMenuButtonLabel" style="flex:1; min-width:0; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Select member</span>
                        <span style="color:var(--gray-600); font-size:16px; line-height:1;">▾</span>
                    </button>

                    <div id="ccScopeMenu" style="display:none; position:absolute; left:0; top:calc(100% + 6px); width:100%; background:white; border:1px solid var(--gray-200); border-radius:12px; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15), 0 4px 10px rgba(0, 0, 0, 0.1); z-index:10001; overflow:hidden;">
                        <div id="ccScopeMenuMembers" style="max-height:280px; overflow:auto;"></div>
                    </div>

                    <div id="ccScopeSubmenu" style="display:none; position:absolute; left:100%; top:calc(100% + 6px); width:100%; background:white; border:1px solid var(--gray-200); border-radius:12px; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15), 0 4px 10px rgba(0, 0, 0, 0.1); z-index:10002; overflow:hidden;">
                        <div id="ccScopeSubmenuInner" style="max-height:280px; overflow:auto;"></div>
                    </div>
                </div>

                    <!-- Mobile tweaks: make the "Set Available Time" modal smaller and scale contents down -->
                    <style>
                    @media (max-width: 480px) {
                        /* Shrink the modal card to fit narrow viewports while keeping proportions */
                        #timeModal > div {
                            width: min(92vw, 380px) !important;
                            padding: 14px !important;
                            border-radius: 12px !important;
                            box-shadow: 0 14px 20px rgba(0,0,0,0.12) !important;
                            max-height: 86vh !important;
                            overflow: auto !important;
                            -webkit-overflow-scrolling: touch !important;
                            font-size: 0.92rem !important; /* slightly reduce base text size inside modal */
                        }
                        #timeModal h3 { font-size: 18px !important; margin-bottom:8px !important; }
                        #timeModal p { font-size: 13px !important; margin-bottom:12px !important; }
                        /* Reduce padding on action buttons so they fit on one line when possible */
                        #timeModal button {
                            padding: 8px 12px !important;
                            border-radius: 8px !important;
                            font-size: 13px !important;
                        }
                        /* Make inputs and selects a bit smaller and responsive */
                        #timeModal input, #timeModal select {
                            font-size: 13px !important;
                            padding: 6px 8px !important;
                            box-sizing: border-box !important;
                        }
                        /* Tighten ranges container spacing */
                        #modalRangesContainer { gap:6px !important; margin-top:8px !important; }
                        #addModalRangeBtn { padding:6px 10px !important; font-size:13px !important; }

                        /* Ensure modal range rows shrink correctly and inputs do not overflow */
                        #timeModal .modal-range-row { gap:6px !important; justify-content:flex-start !important; align-items:center !important; }
                        #timeModal .modal-range-row label { min-width: 26px !important; width: auto !important; font-size:11px !important; text-align:right !important; }
                        /* Give more horizontal room to time inputs while keeping them responsive */
                        #timeModal .modal-range-row .time-input-container { flex: 1 1 260px !important; min-width: 0 !important; }
                        #timeModal .modal-range-row input[type="time"],
                        #timeModal .modal-range-row .modal-range-start,
                        #timeModal .modal-range-row .modal-range-end {
                            width: 100% !important;
                            max-width: 260px !important;
                            padding: 4px 6px !important;
                            font-size: 12px !important; /* smaller time text */
                            line-height: 20px !important;
                            box-sizing: border-box !important;
                            text-align: center !important;
                        }
                        /* Make the remove and action buttons smaller to save space */
                        #timeModal .modal-range-row button,
                        #timeModal button {
                            padding:6px 8px !important;
                            font-size:11px !important;
                            border-radius:8px !important;
                        }
                        /* Ensure the remove button doesn't push inputs off-screen */
                        #timeModal .modal-range-row button.remove-range-btn, #timeModal .modal-range-row > button {
                            flex: 0 0 auto !important;
                            margin-left: 8px !important;
                        }
                        /* Tweak webkit datetime fields to match smaller font/line-height */
                        #timeModal input[type="time"]::-webkit-datetime-edit-hour-field,
                        #timeModal input[type="time"]::-webkit-datetime-edit-minute-field,
                        #timeModal input[type="time"]::-webkit-datetime-edit-text {
                            font-size: 12px !important;
                            line-height: 20px !important;
                        }
                    }
                    </style>

                    <!-- Additional mobile fix: ensure time input values are not clipped (line-height/appearance) -->
                    <style>
                    @media (max-width:480px) {
                        #timeModal input[type="time"] {
                            height: 36px !important;
                            line-height: 36px !important;
                            font-size: 14px !important;
                            color: var(--gray-900) !important;
                            padding: 6px 8px !important;
                            box-sizing: border-box !important;
                            -webkit-appearance: none !important;
                            appearance: none !important;
                            text-align: center !important;
                            overflow: visible !important;
                        }
                        /* WebKit internal fields for time inputs */
                        #timeModal input[type="time"]::-webkit-datetime-edit,
                        #timeModal input[type="time"]::-webkit-datetime-edit-fields-wrapper,
                        #timeModal input[type="time"]::-webkit-datetime-edit-hour-field,
                        #timeModal input[type="time"]::-webkit-datetime-edit-minute-field,
                        #timeModal input[type="time"]::-webkit-datetime-edit-text {
                            color: var(--gray-900) !important;
                            font-size: 14px !important;
                            line-height: 36px !important;
                            padding: 0 !important;
                        }
                    }
                    </style>

                <style>
                /* Mobile: make the scope submenu open beneath the menu (full-width)
                   instead of off to the right where it can overflow the viewport. */
                @media (max-width: 480px) {
                    #ccScopeMenu, #ccScopeSubmenu {
                        left: 0 !important;
                        right: auto !important;
                        top: calc(100% + 6px) !important;
                        width: 100% !important;
                        box-shadow: 0 8px 20px rgba(0,0,0,0.12) !important;
                        border-radius: 10px !important;
                        position: absolute !important;
                        transform: none !important;
                    }
                    /* Ensure inner scroll areas fit the mobile viewport comfortably */
                    #ccScopeSubmenuInner, #ccScopeMenuMembers { max-height: 320px !important; overflow:auto !important; }
                }
                </style>

                <div style="margin-top:6px; display:flex; justify-content:center;">
                    <span id="memberScopeBadge" style="font-size:12px;color:var(--gray-600);padding:6px 10px;border-radius:999px;border:1px solid var(--gray-200);background:transparent;">Showing org defaults</span>
                </div>
            </div>
        {% endif %}
    </div>
        <!-- Inline Audit Modal -->
        <div id="inlineAuditModal" style="display:none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); justify-content: center; align-items: center; z-index: 10000; padding: 20px;">
            <div style="background: white; padding: 18px; border-radius: 10px; max-width: 640px; width: 100%;">
                <button onclick="closeInlineAudit()" style="position: absolute; right: 18px; top: 14px; border: none; background: none; font-size: 22px; cursor: pointer;">×</button>
                <h4 style="margin:0 0 10px 0;">Audit Details</h4>
                <div id="inlineAuditContent" style="white-space:pre-wrap; background:#f8f9fa; padding:12px; border-radius:6px; max-height:60vh; overflow:auto;"></div>
                <div style="display:flex; justify-content:flex-end; margin-top:12px;"><button onclick="closeInlineAudit()" style="padding:8px 12px; background:#6c757d; color:white; border:none; border-radius:6px;">Close</button></div>
            </div>
        </div>
  </div>
</div>
<script>
// Wire bookings visible-rows select for calendar page after DOM is ready
document.addEventListener('DOMContentLoaded', function(){
    const key = 'cc_bookings_visible_rows';
    const sel = document.getElementById('bookingsVisibleRowsSelect');
    const customInput = document.getElementById('bookingsVisibleRowsCustomInput');
    const container = document.getElementById('bookingsInlineSection');
    const scrollWrapper = document.getElementById('bookingsScrollWrapper');
    const auditWrapper = container ? container.querySelector('.inline-audit-wrapper') : null;

    function apply(v){
        try{
            const defaultVal = Number(getComputedStyle(container || document.documentElement).getPropertyValue('--bookings-visible-default')) || 10;
            if (!scrollWrapper) return;
            if (v === 'all'){
                scrollWrapper.classList.add('cc-visible-all');
                if (auditWrapper) auditWrapper.classList.add('cc-visible-all');
                scrollWrapper.style.removeProperty('--bookings-visible-rows');
            } else {
                scrollWrapper.classList.remove('cc-visible-all');
                if (auditWrapper) auditWrapper.classList.remove('cc-visible-all');
                const n = Number(v) || defaultVal;
                scrollWrapper.style.setProperty('--bookings-visible-rows', String(n));
                if (auditWrapper) auditWrapper.style.setProperty('--bookings-visible-rows', String(n));
            }
            if (sel) sel.value = String(v);
            if (customInput){
                if (sel && sel.value === 'custom'){ customInput.style.display = 'inline-block'; customInput.focus(); } else { customInput.style.display = 'none'; }
            }
        }catch(e){ console.error(e); }
    }

    function setAndStore(v){ try{ window.localStorage.setItem(key, String(v)); }catch(e){} apply(v); }

    try{
        const stored = window.localStorage.getItem(key);
        if (stored) apply(stored); else apply(sel ? sel.value : String(Number(getComputedStyle(container || document.documentElement).getPropertyValue('--bookings-visible-default')) || 10));
    }catch(e){ apply(sel ? sel.value : '10'); }

    if (sel){
        sel.addEventListener('change', function(){
            const v = this.value;
            if (v === 'custom'){
                if (customInput){ customInput.style.display = 'inline-block'; customInput.focus(); }
                return;
            }
            setAndStore(v);
        });
    }

    if (customInput){
        customInput.addEventListener('change', function(){
            const n = Math.max(1, Number(this.value) || 10);
            setAndStore(String(n));
                if (sel) sel.value = 'custom';
        });
        customInput.addEventListener('keyup', function(e){ if (e.key === 'Enter') this.dispatchEvent(new Event('change')); });
    }
});
</script>

<!-- Assets moved to extra_head -->

<style>
/* Modern color palette */
:root {
    --primary-500: #3b82f6;
    --primary-600: #2563eb;
    --primary-700: #1d4ed8;
    --success-500: #10b981;
    --success-600: #059669;
    --danger-500: #ef4444;
    --danger-600: #dc2626;
    --gray-50: #f9fafb;
    --gray-100: #f3f4f6;
    --gray-200: #e5e7eb;
    --gray-300: #d1d5db;
    --gray-600: #4b5563;
    --gray-700: #374151;
    --gray-900: #111827;
    --cc-wave-duration: 14s;
    --cc-page-gutter: 16px; /* default page gutter for consistent side padding */
    --cc-inner-max: 1180px;
}

/* Calendar base styling with modern card design */
#calendar {
    width: 100%;
    margin: auto;
    height: auto;
    border: none !important;
    background-color: white;
    padding: 24px;
    border-radius: 16px;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
}

/* Calendar loading overlay (service-scope parity) */
#calendar.cc-calendar-loading .fc {
    opacity: 0.45;
    filter: grayscale(1);
    pointer-events: none;
}
#calendar .cc-calendar-loading-overlay {
    position: absolute;
    inset: 0;
    display: none;
    z-index: 120;
    background: rgba(255, 255, 255, 0.72);
    backdrop-filter: blur(2px);
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: 10px;
    text-align: center;
    pointer-events: auto;
}
#calendar.cc-calendar-loading .cc-calendar-loading-overlay {
    display: flex;
}
.cc-calendar-spinner {
    width: 40px;
    height: 40px;
    border-radius: 999px;
    border: 4px solid var(--gray-200);
    border-top-color: var(--primary-500);
    animation: cc-calendar-spin 0.8s linear infinite;
}
@keyframes cc-calendar-spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}
.cc-calendar-loading-text {
    color: var(--gray-700);
    font-weight: 600;
    font-size: 14px;
}

/* Improved member/service select styling */
#memberSelect {
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    background: white url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="%23343a40" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"/></svg>') no-repeat right 10px center/12px 12px;
    padding: 10px 36px 10px 12px;
    border-radius: 10px;
    border: 1px solid var(--gray-200);
    box-shadow: 0 1px 2px rgba(16,24,40,0.04);
    font-size: 14px;
    color: var(--gray-900);
}

#memberSelect option {
    padding: 6px 8px;
}

#memberSelect.optgroup-service {
    font-weight: 600;
}

/* Remove all calendar borders/grid lines */
.fc-scrollgrid { border-color: transparent !important; }
.fc-scrollgrid td:last-of-type { border-right-color: transparent !important; }
.fc-scrollgrid-section.fc-scrollgrid-section-body td[role='presentation'] { border-bottom-color: transparent !important; }
[role='row']:last-of-type td { border-bottom-color: transparent !important; }
th[role='presentation'] { border-right-color: transparent !important; }
.fc { border: none !important; }
.fc .fc-daygrid-day,
.fc .fc-daygrid-body,
.fc .fc-scrollgrid,
.fc .fc-col-header-cell,
.fc .fc-daygrid-day-frame { border: none !important; }

/* Hide extra frame cells that appear below the last week */
.fc-daygrid-day-frame {
    background: transparent !important;
}

/* Hide day cells that are outside the current month */
.fc-day-other {
    display: none !important;
}

/* Ensure grid sections have no grey background */
.fc .fc-daygrid-body,
.fc .fc-scrollgrid-section-body,
.fc .fc-scrollgrid {
    background: transparent !important;
}

/* Push calendar grid down while keeping header/title at top */
.fc .fc-view-harness { margin-top: 100px; }

/* Day number circle */
.fc-daygrid-day-frame {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
}

/* Top border color wave for section cards */
.section-card, .cc-page > .section-card, .border.rounded-lg, .section-card .section-title {
    position: relative;
}
.section-card::before, .border.rounded-lg::before {
    content: '';
    display: block;
    position: absolute;
    left: 0;
    right: 0;
    top: -6px;
    height: 6px;
    border-top-left-radius: 12px;
    border-top-right-radius: 12px;
    /* Use the canonical per-date overrides gradient */
    background: linear-gradient(to right, var(--primary-500), var(--success-500), var(--danger-500));
    background-size: 400% 100%;
    /* smooth oscillation using multi-stop keyframes (no alternate) */
    animation: cc-wave var(--cc-wave-duration, 14s) ease-in-out infinite;
    animation-delay: var(--cc-wave-offset, 0s);
    z-index: 0;
}
@keyframes cc-wave {
    0% { background-position: 0% 50%; }
    25% { background-position: 50% 50%; }
    50% { background-position: 100% 50%; }
    75% { background-position: 50% 50%; }
    100% { background-position: 0% 50%; }
}

/* Apply animated top-border gradient to main sections at all screen sizes */
/* Make top gradient part of each container's rounded top by clipping
   the pseudo-element to the container and using the container's radius. */
#defaultAvailabilityContainer,
#bookingsInlineSection,
#calendar,
#timeModal,
#timeCirclesModal {
    position: relative;
    overflow: hidden; /* clip the ::before gradient to container border-radius */
}

#defaultAvailabilityContainer::before,
#bookingsInlineSection::before,
#calendar::before,
#timeModal::before,
#timeCirclesModal::before {
    content: '';
    display: block;
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    height: 6px;
    /* inherit the container's top border radius so the gradient visually
       appears as part of the container (prevents the 'hat' effect). */
    border-top-left-radius: inherit;
    border-top-right-radius: inherit;
    background: linear-gradient(to right, var(--primary-500), var(--success-500), var(--danger-500));
    background-size: 400% 100%;
    animation: cc-wave var(--cc-wave-duration, 14s) ease-in-out infinite;
    animation-delay: var(--cc-wave-offset, 0s);
    z-index: 0;
    pointer-events: none;
}

/* Mobile-friendly adjustments */
@media (max-width: 768px) {
        --cc-page-gutter: 16px; 
        Default Weekly Availability keeps desktop baseline styles */
    #bookingsInlineSection,
    #calendar,
    #timeModal,
    #timeCirclesModal {
        position: relative; /* ensure pseudo-element positions relative to container */
    }

    /* Place the gradient inside the container (top:0) so it's not clipped on desktop.
       Use a CSS var for animation-delay so we can sync multiple elements from JS. */
    #bookingsInlineSection::before,
    #calendar::before,
    #timeModal::before,
    #timeCirclesModal::before {
        content: '';
        display: block;
        position: absolute;
        right: 0;
        top: 0; /* inside the container to avoid being clipped by overflow */
        height: 6px;
        border-top-left-radius: 12px;
        border-top-right-radius: 12px;
            background: linear-gradient(to right, var(--primary-500), var(--success-500), var(--danger-500));
            background-size: 400% 100%;
            animation: cc-wave var(--cc-wave-duration, 14s) ease-in-out infinite;
            /* allow external sync via --cc-wave-offset */
            animation-delay: var(--cc-wave-offset, 0s);
        z-index: 0;
        pointer-events: none;
    }
    #calendar { padding: 12px; }
    .fc .fc-view-harness { margin-top: 80px; }
    /* Slightly smaller day circles on mobile to fit narrow columns */
    .fc-daygrid-day-number { width: 36px; height: 36px; font-size: 14px !important; }
    /* Ensure past / unavailable / today variants honor mobile sizing */
    .fc-daygrid-day-number.past-day,
    .fc-daygrid-day-number.unavailable-number,
    .fc .fc-day-today .fc-daygrid-day-number {
        width: 36px !important;
        height: 36px !important;
        line-height: 36px !important;
        font-size: 14px !important;
    }
    /* Nav buttons: enforce square buttons and center icon */
    .fc .fc-prev-button, .fc .fc-next-button {
        width: 40px;
        height: 40px;
        padding: 0;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border-radius: 8px;
        box-sizing: border-box;
    }
    /* Reset button line-height to avoid baseline offset (don't zero font-size) */
    .fc .fc-button { line-height: 0; }
    .fc .fc-button svg, .fc .fc-button .fc-icon { width: 14px; height: 14px; display: block; margin: 0; transform: none; }
    /* Ensure any inner wrapper/span fills the button and centers its contents */
    .fc .fc-prev-button > *,
    .fc .fc-next-button > *,
    .fc .fc-prev-button > .fc-icon, .fc .fc-next-button > .fc-icon,
    .fc .fc-prev-button svg, .fc .fc-next-button svg {
        width: 100%;
        height: 100%;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        margin: 0 !important;
        padding: 0 !important;
    }
    .time-circle { width: 56px !important; height: 56px !important; font-size: 12px !important; }
}
.fc-daygrid-day-number {
    position: absolute;
    margin-top: 100%;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: flex;
    align-items: center;
    justify-content: center;
    width: 50px;
    height: 50px;
    font-size: 1.5rem;
    border-radius: 50% !important;
    font-weight: 600;
    transition: transform 0.2s ease, background-color 0.2s ease;
}

/* Ensure time-circle elements remain circular */
.time-circle { border-radius: 50% !important; overflow: visible; }

/* Pointer for available day numbers */
.fc-day-available .fc-daygrid-day-number { cursor: pointer !important; }
.fc-day-unavailable .fc-daygrid-day-number { cursor: pointer !important; }

/* Available day number - modern gradient */
.fc-day-available .fc-daygrid-day-number {
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(37, 99, 235, 0.15));
    border: 2px solid var(--primary-500);
    color: var(--primary-600);
    box-shadow: 0 2px 4px rgba(59, 130, 246, 0.1);
}

/* Hover effect - enhanced */
.fc-day-available .fc-daygrid-day-number:hover {
    transform: translate(-50%, -50%) scale(1.15);
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(37, 99, 235, 0.25));
    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
}

/* Selected day number - vibrant */
.fc-daygrid-day-number.selected {
    background: linear-gradient(135deg, var(--primary-500), var(--primary-600));
    color: white;
    transform: translate(-50%, -50%) scale(1.25);
    box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4);
    border-color: var(--primary-700);
}

/* Prevent frame highlighting */
  .fc-daygrid-day.fc-day-available {
      background: transparent !important;
  }

    /* Hover effect */
  .fc-daygrid-day-number:hover {
      transform: translate(-50%, -50%) scale(1.2);
  }

  /* Temporary highlight during drag - available days */
.fc-day-available .fc-daygrid-day-number.temp-highlight {
    background-color: rgba(0, 123, 255, 0.5);
    color: white;
    transform: translate(-50%, -50%) scale(1.3);
}

/* Temporary highlight during drag - unavailable days */
    .fc-day-unavailable .fc-daygrid-day-number.temp-highlight {
        background: linear-gradient(135deg, rgba(45, 45, 45, 0.8), rgba(26, 26, 26, 0.9));
        color: white;
        transform: translate(-50%, -50%) scale(1.3);
        border-color: #000000;
}

/* Removed: centralized mobile rules for availability UI — will be replaced with scoped media below */
/* (rules targeting .availability-ui removed) */


/* Current day styling - highlighted */
.fc-day-today { background-color: transparent !important; }
.fc .fc-day-today .fc-daygrid-day-number {
    background: linear-gradient(135deg, var(--primary-500), var(--primary-600));
    color: white;
    font-weight: bold;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    line-height: 28px;
    text-align: center;
    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.35);
    animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
    0%, 100% { box-shadow: 0 4px 12px rgba(59, 130, 246, 0.35); }
    50% { box-shadow: 0 6px 16px rgba(59, 130, 246, 0.5); }
}

/* Modern calendar buttons */
#calendar-controls {
    display: flex;
    justify-content: center;
    gap: 12px;
    margin-bottom: 20px;
    background: linear-gradient(to bottom, rgba(255,255,255,0.95), rgba(255,255,255,0.9));
    backdrop-filter: blur(8px);
    padding: 16px;
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.08), 0 0 1px rgba(0,0,0,0.05);
}
.calendar-btn {
    background-color: var(--primary-500);
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
.calendar-btn:hover { 
    background-color: var(--primary-600); 
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
}
.calendar-btn:active { transform: translateY(0); }
.calendar-btn:disabled { 
    background-color: var(--gray-300); 
    cursor: not-allowed; 
    transform: none;
    box-shadow: none;
}

/* Nav button shared style (kept minimal since inline styles are applied) */
#topNav .nav-btn:hover { 
    transform: translateY(-1px);
    background: var(--primary-600);
}
#topNav .nav-btn:active { transform: translateY(0); }

.fc-daygrid-day-number.selected::after,
.fc-daygrid-day-number.temp-highlight::after {
    content: none !important; /* removes any text overlay */
}
.fc-daygrid-event {
  display: none !important;  /* hides event text labels from calendar cells */
}
#timeModal, #bookingModal {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.6);
  backdrop-filter: blur(4px);
  justify-content: center;
  align-items: center;
  z-index: 9999;
  animation: fadeIn 0.2s ease-out;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes modalSlideUp {
  from { 
    opacity: 0;
    transform: translateY(20px);
  }
  to { 
    opacity: 1;
    transform: translateY(0);
  }
}

/* Button hover effects */
button:not(:disabled):hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.15) !important;
}
button:not(:disabled):active {
  transform: translateY(0);
}
#timeCirclesContainer > div {
  border-bottom: 1px solid #ccc;  
  padding-bottom: 40px;

}

#timeCirclesContainer > div:first-child {
  padding-top: 20px;
}

/* Remove line from the last row */
#timeCirclesContainer > div:last-child {
  border-bottom: none;
}

.fc-daygrid-day-number.selected.past-day {
    background-color: #ccc !important; /* grey circle for real past-day + selected */
    color: #fff !important;
    border: 2px solid #999 !important;
    
}

.fc-daygrid-day-number.past-day {
    /* show a circular outline for past days rather than a filled block */
    background-color: #7d7d7d28 !important;
    color: #4f4b4bff !important; /* muted text color */
    font-weight: 600;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    line-height: 46px;
    text-align: center;
    border: 2px solid #dcdcdc; /* subtle circle outline */
}

/* Unavailable day number (distinct from past-day) */
.fc-daygrid-day-number.unavailable-number {
    /* Grey circular outline for unavailable future days, number stays visible */
    background-color: #69696990 !important;
    color: #393535ff !important; /* visible but muted */
    font-weight: 600;
    border: 2px solid #454545ff;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    line-height: 46px;
    text-align: center;
}

/* Selected unavailable day - dark grey/black with white numbers */
.fc-daygrid-day-number.unavailable-number.selected {
    background: linear-gradient(135deg, #2d2d2d, #1a1a1a) !important;
    color: white !important;
    border-color: #000000 !important;
    transform: translate(-50%, -50%) scale(1.25) !important;
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.5) !important;
}

/* When an unavailable day is selected via fc-day-unavailable class */
.fc-day-unavailable .fc-daygrid-day-number.selected {
    background: linear-gradient(135deg, #2d2d2d, #1a1a1a) !important;
    color: white !important;
    transform: translate(-50%, -50%) scale(1.25) !important;
    border: 2px solid #000000 !important;
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.5) !important;
}

/* Overrides header styling */
.overrides-header { text-align:center; margin:0 0 10px; }
.overrides-base { font-weight:500; }
.overrides-month { font-weight:700; font-size:1.25em; }

/* Modern select and input styling */
select, input[type="time"], input[type="number"] {
    padding: 6px 10px;
    border: 2px solid var(--gray-300);
    border-radius: 6px;
    font-size: 13px;
    color: var(--gray-900);
    background: white;
    transition: all 0.2s ease;
    outline: none;
}

select:focus, input[type="time"]:focus, input[type="number"]:focus {
  border-color: var(--primary-500);
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

select:hover, input[type="time"]:hover, input[type="number"]:hover {
  border-color: var(--gray-400);
}

/* Time input wrapper for relative positioning */
.time-input-container {
  position: relative;
  display: inline-block;
}


/* Range row layout adjustments to prevent action buttons overlapping inputs on small screens */
.range-row {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: nowrap;
}
.range-row .time-input-container {
    flex: 0 0 auto;
    min-width: 0; /* allow mobile overrides to control width; avoid forcing large widths on desktop */
}
.range-start, .range-end, .modal-range-start, .modal-range-end {
    text-align: center;
    padding: 6px 8px;
    border-radius: 8px;
    border: 1px solid var(--gray-300);
    background: white;
    font-weight: 600;
    min-width: 0; /* allow responsive rules to set exact widths per breakpoint */
}
.remove-range-btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 3px 6px;
    border: none;
    background: #dc3545;
    color: white;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 600;
    font-size: 12px;
}
.remove-range-btn .remove-icon { font-size: 14px; line-height: 1; }
    .remove-range-btn .remove-text { display: none; }
/* Position the unavailable checkbox slightly lower and to the right
   so it visually aligns near the remove button across all devices. */
.unavailable-checkbox {
    position: relative;
    top: 6px; /* move down */
    left: 6px; /* move right */
    width: 18px;
    height: 18px;
}
.add-range-btn {
    padding: 6px 10px !important;
    background: #007bff !important;
    color: white !important;
    border: none !important;
    border-radius: 6px !important;
    cursor: pointer !important;
    font-weight: 600;
    font-size: 13px;
}

/* Removed mobile @media rules that targeted availability-specific classes so
   Default Weekly Availability keeps desktop baseline styles. */


/* Custom Time Picker Dropdown */
.custom-time-picker {
  position: absolute;
  top: calc(100% + 5px);
  left: 0;
  background: white;
  border: 1px solid var(--gray-300);
  border-radius: 12px;
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15), 0 4px 10px rgba(0, 0, 0, 0.1);
  z-index: 1000;
  padding: 16px;
  min-width: 280px;
  display: none;
  animation: slideDown 0.2s ease-out;
}

@keyframes slideDown {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.custom-time-picker.active {
  display: block;
}

.time-picker-header {
  font-size: 13px;
  font-weight: 600;
  color: var(--gray-700);
  margin-bottom: 12px;
  text-align: center;
}

.time-picker-display {
  font-size: 32px;
  font-weight: 700;
  text-align: center;
  color: var(--primary-600);
  margin-bottom: 16px;
  font-variant-numeric: tabular-nums;
  letter-spacing: 0.05em;
}

.time-picker-selectors {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
}

.time-selector {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.time-selector-label {
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  color: var(--gray-600);
  text-align: center;
  letter-spacing: 0.5px;
}

.time-scroll-container {
  height: 180px;
  overflow-y: auto;
  border: 1px solid var(--gray-200);
  border-radius: 8px;
  background: var(--gray-50);
  padding: 4px;
}

.time-scroll-container::-webkit-scrollbar {
  width: 6px;
}

.time-scroll-container::-webkit-scrollbar-track {
  background: transparent;
}

.time-scroll-container::-webkit-scrollbar-thumb {
  background: var(--gray-300);
  border-radius: 3px;
}

.time-option {
  padding: 10px;
  text-align: center;
  cursor: pointer;
  border-radius: 6px;
  font-size: 15px;
  font-weight: 500;
  transition: all 0.15s ease;
  color: var(--gray-700);
}

.time-option:hover {
  background: white;
  color: var(--primary-600);
}

.time-option.selected {
  background: var(--primary-500);
  color: white;
  font-weight: 600;
}

.time-picker-actions {
  display: flex;
  gap: 8px;
  margin-top: 12px;
}

.time-picker-btn {
  flex: 1;
  padding: 10px;
  border: none;
  border-radius: 8px;
  font-weight: 600;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.15s ease;
}

.time-picker-btn.confirm {
  background: var(--primary-500);
  color: white;
}

.time-picker-btn.confirm:hover {
  background: var(--primary-600);
  transform: translateY(-1px);
  box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
}

.time-picker-btn.cancel {
  background: var(--gray-200);
  color: var(--gray-700);
}

.time-picker-btn.cancel:hover {
  background: var(--gray-300);
}

/* Keep default browser scrollbars for the main page.
     Note: We still style only the time picker scrollers via .time-scroll-container::-webkit-scrollbar above. */

/* Improved table row hover */
#overridesTable tbody tr:hover {
  background: var(--gray-50);
  transition: background 0.15s ease;
}

#defaultAvailabilityTable tr:hover {
  background: var(--gray-50);
  transition: background 0.15s ease;
}


/* Per-date Overrides: enhanced card styling */
#overridesContainer {
    position: relative;
    overflow: hidden;
    font-family: "Inter", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
}
#overridesContainer::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 6px;
    /* Use the canonical per-date overrides gradient and animate it (in sync) */
    background: linear-gradient(to right, var(--primary-500), var(--success-500), var(--danger-500));
    background-size: 400% 100%;
    animation: cc-wave var(--cc-wave-duration, 14s) ease-in-out infinite;
    animation-delay: var(--cc-wave-offset, 0s);
    z-index: 50;
    pointer-events: none;
}

/* Pro/Team-only feature: when locked, keep visible but greyed out */
.cc-overrides-disabled {
    opacity: 0.55;
}
.cc-overrides-disabled * {
    pointer-events: none;
}
.cc-overrides-lock-overlay {
    position: absolute;
    inset: 0;
    z-index: 60;
    background: transparent;
    pointer-events: auto;
}
.cc-overrides-disabled button,
.cc-overrides-disabled a {
    cursor: not-allowed;
}

/* Overrides table visuals */
#overridesTable {
    border-collapse: separate;
    border-spacing: 0;
}
#overridesTable thead tr {
    background: linear-gradient(to right, rgba(59, 130, 246, 0.08), rgba(16, 185, 129, 0.08));
}
#overridesTable th {
    padding: 10px;
    text-align: left;
    font-weight: 700;
    font-size: 12.5px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--gray-700);
}
#overridesTable td {
    padding: 10px;
    border-bottom: 1px solid var(--gray-100);
    font-size: 13px;
    color: var(--gray-700);
}

/* Default Weekly Availability: prevent overflow and keep content visible */
#defaultAvailabilityContainer table { table-layout: fixed; width: 100%; }
#defaultAvailabilityContainer th, #defaultAvailabilityContainer td { white-space: nowrap; overflow: visible; }
/* Allow time range cells to wrap naturally but keep day names intact */
#defaultAvailabilityContainer tbody td:first-child { white-space: nowrap; }
#defaultAvailabilityContainer tbody td:not(:first-child) { white-space: normal; }
/* Subtle borders between day rows with padding for spacing */
#defaultAvailabilityContainer tbody tr { border-bottom: 1px solid var(--gray-200); }
#defaultAvailabilityContainer tbody tr:last-child { border-bottom: none; }
#defaultAvailabilityContainer tbody td { padding-top: 16px; padding-bottom: 16px; }


/* Type badges */
.type-badge {
    display: inline-block;
    padding: 6px 10px;
    border-radius: 999px;
    font-weight: 600;
    font-size: 12px;
}
.type-badge.available {
    background: rgba(16, 185, 129, 0.15);
    color: var(--success-600);
    border: 1px solid rgba(16, 185, 129, 0.25);
}
.type-badge.blocked {
    background: rgba(239, 68, 68, 0.15);
    color: var(--danger-600);
    border: 1px solid rgba(239, 68, 68, 0.25);
}

/* Action buttons */
#overridesTable button.overrides-btn {
    padding: 8px 12px;
    border-radius: 8px;          /* slightly smaller buttons */
    background: var(--primary-500);
    color: white;
    border: none;
    font-weight: 600;
    cursor: pointer;
    transition: transform 0.15s ease, box-shadow 0.2s ease, background-color 0.2s ease;
    box-shadow: 0 1px 3px rgba(0,0,0,0.12);
}
#overridesTable button.overrides-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 6px 12px rgba(59, 130, 246, 0.30);
    background: var(--primary-600);
}
#overridesTable button.overrides-btn:active {
    transform: translateY(0);
}

/* Fallback: if a button in overrides table has no inner text, show its data-label */
#overridesTable button.overrides-btn:empty::after {
    content: attr(data-label);
}

</style>

<style>
/* Very small phones: keep title + actions on single line and shrink buttons to fit */
@media (max-width: 480px) {
    /* prevent the header row from wrapping so title and actions remain inline;
       allow wrapping only to push the controls to a second row */
    #bookingsInlineSection > div:first-child {
        display: flex !important;
        align-items: center !important;
        justify-content: space-between !important;
        gap: 8px !important;
        flex-wrap: wrap !important;
    }

    /* allow the heading to shrink so the actions can fit and ensure it stays first */
    #bookingsInlineSection > div:first-child h3 {
        flex: 1 1 auto !important;
        min-width: 0 !important;
        margin: 0 8px 0 0 !important;
        font-size: 16px !important;
        line-height: 1.1 !important;
        order: 1 !important;
    }

    /* keep the two action buttons grouped and small, and place them after the title */
    #bookingsInlineSection > div:first-child .bookings-top-actions {
        display: flex !important;
        gap: 6px !important;
        flex: 0 0 auto !important;
        align-items: center !important;
        order: 2 !important;
        margin-left: auto !important;
    }

    /* Make both buttons compact and equal height */
    #bookingsInlineSection > div:first-child a#bookingsViewAllBtn,
    #bookingsInlineSection > div:first-child button#bookingsRefreshBtn {
        padding: 4px 6px !important;
        font-size: 12px !important;
        height: 32px !important;
        min-width: 56px !important;
        border-radius: 6px !important;
        line-height: 1 !important;
        white-space: nowrap !important;
    }

    /* Ensure search + rows controls drop to a second row but keep inputs aligned */
    #bookingsInlineSection > div:first-child .bookings-controls {
        order: 3 !important;
        flex: 1 1 100% !important;
        width: 100% !important;
        margin-top: 8px !important;
        gap: 8px !important;
        align-items: center !important;
        justify-content: flex-start !important;
    }

    /* Slightly reduce select/input height to match compact buttons */
    #bookingsInlineSection > div:first-child .bookings-controls input,
    #bookingsInlineSection > div:first-child .bookings-controls select {
        height: 32px !important;
        padding: 6px 8px !important;
        font-size: 13px !important;
    }
}
</style>

<style>
/* Mobile-specific container height to ensure availability card has enough room */
@media (max-width: 768px) {
    #defaultAvailabilityContainer {
        min-height: 685px !important;
    }
}
</style>
<style>
/* Animated, stylish calendar title */
.calendar-title {
    /* Match available day circle highlight (primary blue gradient) */
    background: linear-gradient(135deg, var(--primary-500), var(--primary-600));
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    background-size: 200% auto;
    animation: titleGradientShift 8s ease-in-out infinite, titleFloatIn 600ms ease-out both;
    filter: drop-shadow(0 1px 0 rgba(0,0,0,0.06));
}
/* Per-date overrides month label: match available day circle highlight */
#overridesHeaderMonth {
    background: linear-gradient(135deg, var(--primary-500), var(--primary-600));
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent !important; /* override inline color */
    background-size: 200% auto;
    animation: titleGradientShift 8s ease-in-out infinite;
}
@keyframes titleGradientShift {
    0% { background-position: 0% center; }
    50% { background-position: 100% center; }
    100% { background-position: 0% center; }
}
@keyframes titleFloatIn {
    0% { opacity: 0; transform: translateY(6px); }
    100% { opacity: 1; transform: translateY(0); }
}

/* Mobile Responsive Styles */
@media (max-width: 768px) {
    /* Title adjustments */
    .calendar-title {
        font-size: 24px !important;
    }
    /* Remove extra top offset on mobile since controls are not overlaid */
    .fc .fc-view-harness { margin-top: 0 !important; }

    /* Slightly smaller day circles on mobile */
    .fc-daygrid-day-number,
    .fc .fc-day-today .fc-daygrid-day-number,
    .fc-daygrid-day-number.past-day,
    .fc-daygrid-day-number.unavailable-number {
        width: 40px !important;
        height: 40px !important;
        font-size: 1.25rem !important;
        line-height: 36px !important;
    }
    /* Reduce hover/selected scale to match smaller size */
    .fc-daygrid-day-number:hover { transform: translate(-50%, -50%) scale(1.1) !important; }
    .fc-daygrid-day-number.selected { transform: translate(-50%, -50%) scale(1.15) !important; }
    
    /* Per-date Overrides Table */
    #overridesContainer {
        padding: 16px !important;
        margin-top: 16px !important;
        overflow-x: auto;
    }
    
    #overridesTable {
        font-size: 11px;
        min-width: 600px;
    }
    
    #overridesTable th {
        padding: 8px !important;
        font-size: 10px !important;
    }
    
    #overridesTable td {
        padding: 8px !important;
        font-size: 11px !important;
    }
    
    #overridesTable button {
        padding: 6px 8px !important;
        font-size: 11px !important;
    }

    /* Removed nested desktop @media that touched .range-row to avoid
       any accidental mobile/medium interactions. */

    /* Default Weekly Availability: responsive rules removed per request. */
    /* (Removed mobile/medium @media blocks and small-screen overrides that targeted
       #defaultAvailabilityContainer, .range-row, .range-start, .range-end,
       .remove-range-btn, .unavailable-checkbox so desktop styles are the baseline.) */
    
    /* Calendar Container */
    div[style*="flex:2 1 640px"] {
        flex: 1 1 100% !important;
        min-width: 100% !important;
        margin-bottom: 16px !important;
    }
    
    #calendar {
        padding: 12px !important;
        height: auto !important;
        min-height: 420px !important;
    }
    
    /* Calendar Controls */
    /* Place controls inline under month title; simplified styling */
    #calendar-controls {
        position: static !important;
        transform: none !important;
        margin-bottom: 12px;
        flex-wrap: wrap;
        justify-content: center;
        background: transparent !important;
        box-shadow: none !important;
        padding: 8px !important;
    }
    
    .calendar-btn {
        padding: 8px 12px !important;
        font-size: 12px !important;
    }
    
    /* Main flex container */
    #weeklyCalendarRow { gap: 16px !important; flex-wrap: wrap !important; }
}

/* Landscape Mobile (tablets in landscape, large phones) */
@media (max-width: 1200px) and (min-width: 769px) {
    #weeklyCalendarRow { flex-wrap: wrap !important; }
    /* Default availability responsive settings removed */
    
    div[style*="flex:2 1 640px"] {
        flex: 1 1 500px !important;
        min-width: 500px !important;
    }
}

/* Small phones (portrait) */
@media (max-width: 480px) {
    #overridesContainer,
    #calendar {
        border-radius: 12px !important;
    }
    
    .calendar-title {
        font-size: 20px !important;
    }
    
    /* Default availability time input mobile sizing removed */
    
    #calendar-controls {
        gap: 6px !important;
    }
    
    .calendar-btn {
        padding: 6px 10px !important;
        font-size: 11px !important;
    }
}

/* Full width on mobile - override base.html max-width containers */
@media (max-width: 768px) {
    /* Prevent horizontal scrolling */
    html, body {
        overflow-x: hidden;
        width: 100%;
        max-width: 100vw;
    }
    
    body {
        padding: 0;
        margin: 0;
    }
    
    /* Make main content full width */
    main.max-w-6xl,
    main.max-w-7xl,
    main {
        max-width: 100vw !important;
        width: 100% !important;
        padding: 12px !important;
        margin: 0 !important;
        box-sizing: border-box !important;
    }
    

    
    /* Remove extra margins on cards and prevent overflow */
    #overridesContainer,
    #calendar {
        margin-left: 0 !important;
        margin-right: 0 !important;
        width: 100% !important;
        max-width: 100% !important;
        box-sizing: border-box !important;
        overflow-x: visible !important;
    }
    
    /* Title stays fixed, only table wrapper scrolls */
    #overridesTableWrapper {
        overflow-x: auto !important;
        -webkit-overflow-scrolling: touch !important;
    }
    
    #overridesTable {
        min-width: 600px !important;
    }
    
    /* Full width page title container */
    div[style*="margin-bottom:32px; text-align:center"] {
        margin-bottom: 16px !important;
        padding: 0 !important;
        width: 100% !important;
        box-sizing: border-box !important;
    }
    
    /* Default availability media rules removed */
}

/* Widen layout on desktop: use more of the screen width */
@media (min-width: 1025px) {
    /* Expand base containers from base.html */
    main.max-w-6xl,
    main.max-w-7xl,
    main {
        max-width: 95vw !important;
        width: 95vw !important;
        padding-left: 16px !important;
        padding-right: 16px !important;
        box-sizing: border-box !important;
    }

    /* Increase gap between weekly availability and calendar on wide screens */
    #weeklyCalendarRow { gap: 60px !important; }
    /* Make calendar fill column height */
    #calendar { height: 100% !important; }
}

/* Keep a consistent horizontal gutter (side padding) for medium viewports
   so content doesn't touch the right edge as the layout narrows. This
   preserves the current visual spacing until the availability column must
   wrap on small screens. */
@media (min-width: 481px) and (max-width: 1200px) {
    main.max-w-6xl,
    main.max-w-7xl,
    main {
        padding-left: 12px !important;
        padding-right: 12px !important;
        box-sizing: border-box !important;
    }

    /* Add a small inner gutter for the two-column calendar/availability row */
    #weeklyCalendarRow {
        padding-left: 12px !important;
        padding-right: 12px !important;
        box-sizing: border-box !important;
    }
}


</style>

<style>
/* Removed: minimal mobile-only availability rules targeting .availability-ui */
</style>

<style>
/* Center content column and prevent edge leakage across wide and medium viewports */
@media (min-width: 900px) {
    :root { 
        --cc-page-gutter: 16px; 
        --cc-inner-max: 1180px; 
    }

    main.max-w-6xl,
    main.max-w-7xl,
    main {
        width: 100% !important;
        margin-left: auto !important;
        margin-right: auto !important;
        padding-left: var(--cc-page-gutter) !important;
        padding-right: var(--cc-page-gutter) !important;
        box-sizing: border-box !important;
    }



    /* Align the main cards to the centered column and allow them to shrink */
    #overridesContainer,
    #weeklyCalendarRow,
    #defaultAvailabilityContainer,
    #calendar,
    #bookingsInlineSection {
        max-width: 100% !important;
        margin-left: 0 !important;
        margin-right: 0 !important;
        box-sizing: border-box !important;
    }

    /* Override inline min-widths (set on elements via style attributes) so they
       don't push past the centered column and leak to the viewport edge. */
    #defaultAvailabilityContainer, div[style*="flex:2 1 640px"] {
        min-width: 0 !important;
        max-width: 100% !important;
        box-sizing: border-box !important;
    }

    /* Keep weekly row aligned with the centered column */
    #weeklyCalendarRow { padding-left: 0 !important; padding-right: 0 !important; box-sizing: border-box !important; }
}
</style>

<!-- Controls will be overlaid inside the calendar area -->
<!-- Removed mobile/medium @media rules that targeted the Default Weekly Availability UI -->
<!-- Per-date Overrides Table - Modern Card (moved to top) -->
<div id="overridesContainer" class="{% if not can_use_overrides %}cc-overrides-disabled{% endif %}" style="margin-top:24px; padding:24px; background:white; border:none; border-radius:16px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);">
    {% if not can_use_overrides %}
        <div class="cc-overrides-lock-overlay" aria-hidden="true"></div>
    {% endif %}
    <h3 id="overridesHeader" class="overrides-header" style="margin:0 0 20px 0; font-size:18px; font-weight:700; color:var(--gray-900);">
        <span class="overrides-base" style="font-weight:600;">Per-date Overrides for </span>
                {% if is_team_plan %}
                    <span id="overridesHeaderSelection" class="overrides-month" style="color:var(--primary-600); font-size:inherit;"></span>
                    <span style="color:var(--gray-600);"> in </span>
                {% else %}
                    <span id="overridesHeaderSelection" style="display:none;"></span>
                {% endif %}
        <span id="overridesHeaderMonth" class="overrides-month" style="color:var(--primary-600);"></span>
    </h3>
    <div id="overridesTableWrapper" style="overflow-x:auto; -webkit-overflow-scrolling:touch;">
        <table id="overridesTable" style="width:100%; border-collapse:collapse;">
            <thead>
                <tr style="text-align:left; border-bottom:2px solid var(--gray-200); background:var(--gray-50);">
                    <th style="padding:12px; width:16%; font-weight:600; font-size:13px; text-transform:uppercase; letter-spacing:0.5px; color:var(--gray-600);">Date</th>
                    <th style="padding:12px; width:16%; font-weight:600; font-size:13px; text-transform:uppercase; letter-spacing:0.5px; color:var(--gray-600);">Type</th>
                    <th style="padding:12px; width:38%; font-weight:600; font-size:13px; text-transform:uppercase; letter-spacing:0.5px; color:var(--gray-600);">Time Ranges</th>
                    <th style="padding:12px; width:15%; font-weight:600; font-size:13px; text-transform:uppercase; letter-spacing:0.5px; color:var(--gray-600); text-align:center;">Reset All</th>
                    <th style="padding:12px; width:15%; font-weight:600; font-size:13px; text-transform:uppercase; letter-spacing:0.5px; color:var(--gray-600);">Group Actions</th>
                </tr>
            </thead>
            <tbody id="overridesTableBody">
                <tr><td colspan="5" style="text-align:center; color:var(--gray-600); padding:24px; font-style:italic;">No per-date overrides</td></tr>
            </tbody>
        </table>
    </div>
</div>

<div id="weeklyCalendarRow" style="display:flex; gap:40px; align-items:stretch; flex-wrap:nowrap; margin-top:24px; width:100%;">
        <div id="defaultAvailabilityContainer" class="availability-ui" style="flex:1 1 540px; min-width:540px; margin-bottom:32px; padding:24px; background:white; border:none; border-radius:16px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);">
                <div style="display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; margin:0 0 10px 0;">
                    <h3 style="margin:0; font-size:18px; font-weight:700; color:var(--gray-900);">Default Weekly Availability</h3>
                    <a id="cc-open-edit-service-from-calendar"
                       href="#"
                       style="display:none; padding:10px 12px; border-radius:10px; background:white; border:1px solid var(--primary-500); color:var(--primary-600); font-weight:700; cursor:pointer; text-decoration:none;">

        <!-- Compact bookings header controls for mobile so they fit comfortably -->
        <style>
        @media (max-width: 768px) {
            #bookingsInlineSection .booking-controls,
            #bookingsInlineSection .bookings-top,
            #bookingsInlineSection .bookings-actions {
                display: flex;
                gap: 8px;
                align-items: center;
                justify-content: flex-start;
                flex-wrap: nowrap;
            }

            #bookingsInlineSection .booking-controls .calendar-btn,
            #bookingsInlineSection .bookings-top .calendar-btn {
                padding: 8px 10px !important;
                font-size: 13px !important;
                border-radius: 8px !important;
                line-height: 1 !important;
                white-space: nowrap !important;
            }

            /* Make search input compact and allow it to shrink */
            #bookingsInlineSection .booking-controls input[type="search"],
            #bookingsInlineSection input.search,
            #bookingsInlineSection .search-input {
                padding: 8px 10px !important;
                font-size: 13px !important;
                min-width: 0 !important;
                flex: 1 1 auto !important;
                max-width: 280px !important;
            }

            /* Small square refresh/icon buttons */
            #bookingsInlineSection .refresh-btn,
            #bookingsInlineSection .refresh-button,
            #bookingsInlineSection button.refresh {
                width: 36px !important;
                height: 36px !important;
                padding: 6px !important;
                border-radius: 8px !important;
                display: inline-flex !important;
                align-items: center !important;
                justify-content: center !important;
            }
        }

        @media (max-width: 420px) {
            #bookingsInlineSection .booking-controls,
            #bookingsInlineSection .bookings-top {
                gap: 6px;
            }

            #bookingsInlineSection .booking-controls .calendar-btn,
            #bookingsInlineSection .bookings-top .calendar-btn {
                padding: 6px 8px !important;
                font-size: 12px !important;
            }

            #bookingsInlineSection .booking-controls input[type="search"],
            #bookingsInlineSection input.search {
                font-size: 12px !important;
                padding: 6px 8px !important;
                max-width: 180px !important;
            }
        }
        </style>
                        Open Edit Service
                    </a>
                </div>
                {% if is_team_plan %}
                    <div id="cc-weekly-interchange-note" style="margin:0 0 14px 0; font-size:13px; color:var(--gray-600); line-height:1.4;">
                        Tip: When you select a service scope, this weekly schedule is interchangeable with that service’s availability on the Edit Service page.
                    </div>
                {% endif %}
    <table style="width:100%; border-collapse:collapse;">
        <thead>
        <tr style="border-bottom:2px solid var(--gray-200); background:var(--gray-50);">
            <th style="padding:12px; text-align:left; font-weight:700; font-size:13px; text-transform:uppercase; letter-spacing:0.5px; color:var(--gray-900); width:20%;">Day</th>
            <th style="padding:12px; text-align:center; font-weight:700; font-size:13px; text-transform:uppercase; letter-spacing:0.5px; color:var(--gray-900); width:55%;" colspan="2">Time Ranges</th>
            <th style="padding:12px; text-align:center; font-weight:700; font-size:13px; text-transform:uppercase; letter-spacing:0.5px; color:var(--gray-900); width:25%;">Unavailable</th>
        </tr>
        </thead>
        <tbody id="defaultAvailabilityTable"></tbody>
    </table>
    <button id="saveDefaultAvailabilityBtn" 
            style="margin-top:20px; padding:12px 24px; background:var(--primary-500); color:white; border:none; border-radius:8px; font-weight:600; cursor:pointer; transition:all 0.2s ease; box-shadow:0 1px 3px rgba(0,0,0,0.1);">
        Save Defaults
    </button>
    </div>

        <!-- === Your Calendar === -->
        <div style="position:relative; flex:2 1 640px; min-width:640px; margin-bottom:32px; display:flex; flex-direction:column;">
            <div id="calendar" style="position:relative;"></div>
            <div id="calendar-controls" style="position:absolute; left:50%; transform:translateX(-50%); top:80px; display:flex; gap:10px; z-index:10;">
                <button id="selectDaysBtn" class="calendar-btn">Select Day</button>
                <button id="selectAllBtn" class="calendar-btn" style="background:var(--success-500);">Highlight All</button>
                <button id="clearSelectionBtn" class="calendar-btn" style="background:var(--danger-500);">Clear</button>
                <button id="retryInitCalendarBtn" class="calendar-btn" style="background:transparent; color:var(--primary-500); border:1px solid var(--primary-500);">Retry</button>
            </div>
        </div>
</div>
<!-- Inline Bookings Section -->
<style>
/* Apply horizontal scrolling for bookings only on small–medium screens */
@media (max-width: 1200px) {
    #bookingsScrollWrapper { overflow-x: auto; -webkit-overflow-scrolling: touch; }
    #bookingsScrollWrapper table { min-width: 720px; width: 100%; }
}
</style>

<style>
/* Small screens: match default availability gutters to other cards (safe, mobile-only) */
@media (max-width: 768px) {
    /* Match the inline padding used by other cards (24px) so edges align */
    #defaultAvailabilityContainer {
        width: 100% !important;
        box-sizing: border-box !important;
        padding-left: 24px !important;
        padding-right: 24px !important;
        margin-left: 0 !important;
        margin-right: 0 !important;
    }

    /* Ensure the inner table respects card padding and doesn't add extra left offset */
    #defaultAvailabilityContainer table {
        width: 100% !important;
        table-layout: fixed !important;
        margin-left: 0 !important;
        margin-right: 0 !important;
        box-sizing: border-box !important;
    }

    /* When the weekly row stacks, remove any row-level padding so cards line up */
    #weeklyCalendarRow {
        padding-left: 0 !important;
        padding-right: 0 !important;
        box-sizing: border-box !important;
    }
}
</style>

<style>
/* Emergency mobile overrides to prevent right-edge overflow caused by inline min-widths
     Only active on small viewports so desktop styles remain untouched. */
@media (max-width: 768px) {
    /* Force the weekly row to stack vertically so columns don't push past viewport */
    #weeklyCalendarRow {
        flex-direction: column !important;
        gap: 16px !important;
        padding-left: 0 !important;
        padding-right: 0 !important;
        box-sizing: border-box !important;
    }

    /* Allow both columns to shrink and fit the viewport */
    #defaultAvailabilityContainer,
    div[style*="flex:2 1 640px"],
    #calendar {
        min-width: 0 !important;
        width: 100% !important;
        box-sizing: border-box !important;
        margin-left: 0 !important;
        margin-right: 0 !important;
    }

    /* Ensure the table inside the availability card doesn't add extra width */
    #defaultAvailabilityContainer table {
        width: 100% !important;
        table-layout: fixed !important;
        margin-left: 0 !important;
        margin-right: 0 !important;
        box-sizing: border-box !important;
    }

    /* Reduce any large fixed min-widths applied elsewhere to prevent overflow */
    [style*="min-width:540px"], [style*="min-width:640px"], [style*="min-width:600px"] {
        min-width: 0 !important;
        max-width: 100% !important;
    }
}
</style>

<style>
/* Mobile-only: compact and left-align contents inside Default Weekly Availability */
@media (max-width: 768px) {
    /* Make the card contents align left and use slightly smaller spacing */
    #defaultAvailabilityContainer {
        text-align: left !important;
        padding-left: 16px !important;
        padding-right: 16px !important;
        box-sizing: border-box !important;
        /* base font-size for the card so everything is smaller */
        font-size: 12px !important;
    }

    /* Headings and table text smaller */
    #defaultAvailabilityContainer h3 {
        font-size: 14px !important;
        margin-bottom: 10px !important;
        text-align: left !important;
    }
    /* day label and other tds slightly smaller */
    #defaultAvailabilityContainer table th,
    #defaultAvailabilityContainer table td {
        font-size: 10px !important;
        padding: 6px 6px !important;
        vertical-align: middle !important;
    }
    /* specifically reduce the first column (day name) padding and size */
    #defaultAvailabilityContainer tbody td:first-child {
        font-size: 10px !important;
        padding-top: 6px !important;
        padding-bottom: 6px !important;
        white-space: nowrap !important;
    }

    /* Compact range rows and inputs */
    #defaultAvailabilityContainer .range-row {
        gap: 6px !important;
        align-items: center !important;
        justify-content: flex-start !important;
        flex-wrap: nowrap !important;
    }
    #defaultAvailabilityContainer .range-row .time-input-container {
        display: inline-block !important;
    }
    #defaultAvailabilityContainer .range-start,
    #defaultAvailabilityContainer .range-end {
        padding: 2px 6px !important;
        font-size: 8px !important;
        border-radius: 6px !important;
        min-width: 0 !important;
        width: 86px !important; /* compact width to help layout on narrow phones */
        box-sizing: border-box !important;
    }

    /* Smaller action buttons */
    #defaultAvailabilityContainer .add-range-btn {
        padding: 3px 6px !important;
        font-size: 10px !important;
        border-radius: 6px !important;
        min-height: 26px !important;
        line-height: 1 !important;
    }
    #defaultAvailabilityContainer .remove-range-btn {
        padding: 0 4px !important;
        font-size: 10px !important;
        border-radius: 4px !important;
        height: 24px !important;
        line-height: 24px !important;
        min-width: 32px !important;
    }

    /* Nudge the checkbox a bit less on small screens */
    #defaultAvailabilityContainer .unavailable-checkbox {
        top: 3px !important;
        left: 3px !important;
        width: 14px !important;
        height: 14px !important;
    }

    /* Ensure the time-picker appended to body doesn't overflow the card visually */
    #defaultAvailabilityContainer .time-input-container .custom-time-picker { max-width: 240px !important; }
}
</style>

<style>
/* Extra compact adjustments for very small phones (narrow portrait devices) */
@media (max-width: 420px) {
    /* Tighten spacing so both time inputs + actions fit on one line */
    #defaultAvailabilityContainer .range-row {
        gap: 4px !important;
    }
    #defaultAvailabilityContainer .range-start,
    #defaultAvailabilityContainer .range-end {
        width: 68px !important;
        padding: 2px !important;
        font-size: 7.5px !important;
    }

    /* Make the Add button extra compact on very small phones */
    #defaultAvailabilityContainer .add-range-btn {
        padding: 2px 5px !important;
        font-size: 9px !important;
        min-height: 22px !important;
        line-height: 1 !important;
    }

    /* Make the Remove button extra small and square on very small phones */
    #defaultAvailabilityContainer .remove-range-btn {
        font-size: 9px !important;
        height: 20px !important;
        line-height: 20px !important;
        border-radius: 6px !important;
        gap: 6px !important;
        min-width: 28px !important;
        justify-content: center !important;
    }

    /* Smaller unavailable checkbox */
    #defaultAvailabilityContainer .unavailable-checkbox {
        width: 12px !important;
        height: 12px !important;
        top: 2px !important;
        left: 2px !important;
    }

    /* Slightly reduce the time-picker width on very small viewports */
    #defaultAvailabilityContainer .time-input-container .custom-time-picker { max-width: 200px !important; }
    /* Extra-small phones: make day circles and nav arrows even smaller */
    .fc-daygrid-day-number { width: 32px !important; height: 32px !important; font-size: 13px !important; }
    .fc-daygrid-day-number.past-day,
    .fc-daygrid-day-number.unavailable-number,
    .fc .fc-day-today .fc-daygrid-day-number {
        width: 32px !important;
        height: 32px !important;
        line-height: 32px !important;
        font-size: 13px !important;
    }
    .fc .fc-prev-button, .fc .fc-next-button {
        width: 36px !important;
        height: 36px !important;
        padding: 0 !important;
        display: inline-flex !important;
        align-items: center !important;
        justify-content: center !important;
        border-radius: 6px !important;
        box-sizing: border-box !important;
    }
    .fc .fc-button { line-height: 0 !important; }
    .fc .fc-button svg, .fc .fc-button .fc-icon { width: 12px !important; height: 12px !important; display: block !important; margin: 0 !important; transform: none !important; }
    .fc .fc-prev-button > *,
    .fc .fc-next-button > *,
    .fc .fc-prev-button > .fc-icon, .fc .fc-next-button > .fc-icon,
    .fc .fc-prev-button svg, .fc .fc-next-button svg {
        width: 100% !important;
        height: 100% !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        margin: 0 !important;
        padding: 0 !important;
    }
    /* Tighten calendar controls spacing on very small phones */
    #calendar-controls { padding: 10px !important; gap: 8px !important; }
}
</style>

<!-- Tight, specific mobile rules for the bookings header controls (targets inline IDs) -->
<style>
@media (max-width: 768px) {
    /* make the control row non-wrapping and allow the search to shrink */
    #bookingsInlineSection > div:first-child {
        display: flex !important;
        gap: 8px !important;
        align-items: center !important;
        justify-content: space-between !important;
        flex-wrap: wrap !important;
    }

    /* compact the primary 'View all bookings' link and match Refresh size */
    #bookingsInlineSection > div:first-child a#bookingsViewAllBtn,
    #bookingsInlineSection > div:first-child button#bookingsRefreshBtn {
        padding: 6px 12px !important;
        font-size: 13px !important;
        min-width: 86px !important;
        height: 36px !important;
        border-radius: 8px !important;
        white-space: nowrap !important;
        display: inline-flex !important;
        align-items: center !important;
        justify-content: center !important;
    }

    /* allow search to flex and shrink so it doesn't force overflow; align inputs/selects */
    #bookingsInlineSection > div:first-child .bookings-controls input[type="search"],
    #bookingsInlineSection > div:first-child .bookings-controls input#bookingsSearchInline,
    #bookingsInlineSection > div:first-child .bookings-controls select,
    #bookingsInlineSection > div:first-child .bookings-controls input[type="number"] {
        padding: 6px 8px !important;
        font-size: 13px !important;
        min-width: 0 !important;
        flex: 1 1 auto !important;
        max-width: 220px !important;
        height: 36px !important;
        line-height: normal !important;
    }

    /* place controls (search + rows) on their own row beneath the title/actions */
    #bookingsInlineSection > div:first-child .bookings-controls {
        order: 3 !important;
        flex: 1 1 100% !important;
        width: 100% !important;
        margin-top: 8px !important;
        justify-content: flex-start !important;
        gap: 8px !important;
        align-items: center !important;
    }

    #bookingsInlineSection > div:first-child h3 {
        order: 1 !important;
        flex: 0 0 auto !important;
    }

    #bookingsInlineSection > div:first-child button#bookingsRefreshBtn {
        order: 2 !important;
        flex: 0 0 auto !important;
        margin-left: 8px !important;
    }
}

@media (max-width: 420px) {
    #bookingsInlineSection > div:first-child {
        gap: 6px !important;
    }
    #bookingsInlineSection > div:first-child a#bookingsViewAllBtn {
        padding: 6px 6px !important;
        font-size: 12px !important;
    }
    #bookingsInlineSection > div:first-child input#bookingsSearchInline {
        padding: 6px 8px !important;
        font-size: 12px !important;
        max-width: 140px !important;
    }
    #bookingsInlineSection > div:first-child button#bookingsRefreshBtn {
        min-width: 72px !important;
        height: 34px !important;
        padding: 6px 10px !important;
    }
}
</style>

<div id="bookingsInlineSection" style="margin-top:24px; padding:24px; background:white; border:none; border-radius:16px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);">
<style>
/* Final mobile overrides for bookings header (placed immediately before markup to beat earlier rules) */
@media (max-width: 480px) {
    #bookingsInlineSection > div:first-child a#bookingsViewAllBtn,
    #bookingsInlineSection > div:first-child button#bookingsRefreshBtn {
        padding: 3px 6px !important;
        font-size: 12px !important;
        height: 30px !important;
        min-width: 40px !important;
        border-radius: 6px !important;
        box-sizing: border-box !important;
    }
    #bookingsInlineSection > div:first-child .bookings-top-actions { margin-left: auto !important; }
    /* prefer full labels on slightly larger mobile widths */
    #bookingsInlineSection > div:first-child a#bookingsViewAllBtn .btn-full,
    #bookingsInlineSection > div:first-child button#bookingsRefreshBtn .btn-full { display: inline !important; }
    #bookingsInlineSection > div:first-child a#bookingsViewAllBtn .btn-short,
    #bookingsInlineSection > div:first-child button#bookingsRefreshBtn .btn-short { display: none !important; }
}

@media (max-width: 360px) {
    /* show short labels and compress buttons further */
    #bookingsInlineSection > div:first-child a#bookingsViewAllBtn .btn-full,
    #bookingsInlineSection > div:first-child button#bookingsRefreshBtn .btn-full { display: none !important; }
    #bookingsInlineSection > div:first-child a#bookingsViewAllBtn .btn-short,
    #bookingsInlineSection > div:first-child button#bookingsRefreshBtn .btn-short { display: inline !important; }
    #bookingsInlineSection > div:first-child a#bookingsViewAllBtn,
    #bookingsInlineSection > div:first-child button#bookingsRefreshBtn {
        padding: 2px 6px !important;
        min-width: 36px !important;
        height: 28px !important;
        font-size: 12px !important;
    }
}
</style>
    <div style="display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap; margin-bottom:12px;">
        <h3 style="margin:0; font-size:18px; font-weight:700; color:var(--gray-900);">Bookings</h3>
        <div class="bookings-top-actions" style="display:flex; gap:8px; align-items:center;">
            <a id="bookingsViewAllBtn" href="{% url 'calendar_app:bookings_list' organization.slug %}" style="padding:8px 12px; background:var(--primary-500); color:white; border:none; border-radius:8px; font-weight:600; text-decoration:none; display:inline-flex; align-items:center; justify-content:center;">View all bookings</a>
            <button id="bookingsRefreshBtn" type="button" style="padding:8px 12px; background:var(--primary-500); color:white; border:none; border-radius:8px; font-weight:600; cursor:pointer; display:inline-flex; align-items:center; justify-content:center;">Refresh</button>
        </div>
        <div class="bookings-controls" style="display:flex; gap:8px; align-items:center; flex:1 1 100%; width:100%; margin-top:8px;">
            <input id="bookingsSearchInline" type="text" placeholder="Search name or email" style="padding:8px 10px; border:1px solid var(--gray-300); border-radius:6px; font-size:13px; flex:1 1 auto; min-width:0;" />
            <label for="bookingsVisibleRowsSelect" style="margin-left:6px; font-size:13px; color:var(--gray-700);">Rows:</label>
            <select id="bookingsVisibleRowsSelect" style="padding:6px 8px; border-radius:6px; font-size:13px;">
                <option value="5">5</option>
                <option value="10">10</option>
                <option value="15">15</option>
                <option value="20">20</option>
                <option value="all">All</option>
                <option value="custom">Custom</option>
            </select>
            <input id="bookingsVisibleRowsCustomInput" type="number" min="1" placeholder="Rows" style="display:none; margin-left:6px; padding:6px 8px; width:90px; border-radius:6px;" />
        </div>
    </div>
    <style>
    /* bookings scroll sizing using CSS variables so JS can control visible rows */
    #bookingsInlineSection { --bookings-row-height: 56px; --bookings-visible-default: 10; }
    #bookingsScrollWrapper { --bookings-visible-rows: var(--bookings-visible, var(--bookings-visible-default)); max-height: calc(var(--bookings-row-height) * var(--bookings-visible-rows)); overflow:auto; }
    #bookingsScrollWrapper.cc-visible-all { max-height: none !important; }
    #bookingsInlineSection .inline-audit-wrapper { --bookings-visible-rows: var(--bookings-visible, var(--bookings-visible-default)); max-height: calc(var(--bookings-row-height) * var(--bookings-visible-rows)); overflow:auto; margin-top:8px; }
    #bookingsInlineSection .inline-audit-wrapper.cc-visible-all { max-height: none !important; }
    </style>
    <div id="bookingsScrollWrapper">
    <table style="width:100%; border-collapse:collapse;">
        <thead>
            <tr style="border-bottom:2px solid var(--gray-200); background:var(--gray-50);">
                <th style="padding:10px; text-align:left; font-size:13px; font-weight:700; color:var(--gray-900);">Date & Time</th>
                <th style="padding:10px; text-align:left; font-size:13px; font-weight:700; color:var(--gray-900);">Client</th>
                <th style="padding:10px; text-align:left; font-size:13px; font-weight:700; color:var(--gray-900);">Service</th>
                <th style="padding:10px; text-align:left; font-size:13px; font-weight:700; color:var(--gray-900);">Status</th>
                <th style="padding:10px; text-align:left; font-size:13px; font-weight:700; color:var(--gray-900);">Actions</th>
            </tr>
        </thead>
        <tbody id="bookingsInlineTBody">
            <tr><td colspan="5" style="text-align:center; color:var(--gray-600); padding:16px;">Loading…</td></tr>
        </tbody>
    </table>
    </div>
    <!-- Inline Audit Feed (recently deleted/cancelled) -->
    <div style="margin-top:16px;">
        <h4 style="margin:6px 0 8px 0; font-size:14px; font-weight:700; color:var(--gray-900);">Recent Deleted / Cancelled</h4>
        <div class="inline-audit-wrapper" style="font-size:13px; color:var(--gray-700);">
                {% if audit_entries %}
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; gap:8px;">
                    <label style="font-size:13px;"><input type="checkbox" id="auditInlineSelectAll"> Select all</label>
                    <div style="display:flex;gap:8px;"><button class="btn-sm btn-view" id="exportAuditInlineBtn">Export Selected (PDF)</button><button class="btn-sm btn-delete" id="deleteAuditInlineBtn">Delete Selected</button></div>
                </div>
                <ul style="list-style:none; padding:0; margin:0; display:flex; flex-direction:column; gap:8px;">
                {% for a in audit_entries %}
                    <li class="cc-inline-audit-row" data-service-id="{{ a.service.id|default:'' }}" style="display:flex; justify-content:space-between; align-items:center; gap:12px; padding:8px; border-radius:8px; background:var(--gray-50);">
                        <input type="checkbox" class="auditRowCbInline" value="{{ a.id }}" style="margin-right:8px;">
                    <div style="flex:1;">
                        <div style="font-weight:600;">{{ a.get_event_type_display|capfirst }}{% if a.booking_id %} — #{{ a.booking_id }}{% endif %}</div>
                        <div style="font-size:13px; color:var(--gray-600);">{{ a.service.name|default:'-' }} &middot; {% if a.start %}{% timezone organization.timezone %}{{ a.start|date:'M d, Y g:i A' }}{% endtimezone %}{% else %}-{% endif %}</div>
                    </div>
                    <div style="display:flex; gap:8px; align-items:center;">
                        <button class="btn-sm btn-view" onclick="openAuditInline(this)" data-snapshot='{{ a.booking_snapshot|escapejs }}'>View</button>
                    </div>
                </li>
                {% endfor %}
            </ul>
            <div id="inlineAuditEmptyScoped" style="color:var(--gray-600); display:none; padding:8px 0;">No recent audited deletions for this member/service.</div>
            {% else %}
                <div style="color:var(--gray-600);">No recent audited deletions.</div>
            {% endif %}
        </div>
    </div>
</div>
<!-- Time Frame Modal -->
<!-- ========================= -->
<!-- TIME MODAL (Availability) -->
<!-- ========================= -->
<div id="timeModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.6); backdrop-filter:blur(4px);
    justify-content:center; align-items:center; z-index:9999;">
  <div style="background:white; padding:32px; border-radius:20px; width:440px; text-align:center; box-shadow:0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04); animation:modalSlideUp 0.3s ease-out;">
    <h3 style="margin:0 0 12px 0; font-size:22px; font-weight:700; color:var(--gray-900);">Set Available Time</h3>
    <p id="selectedDaysSummary" style="font-size:14px; color:var(--gray-600); margin-bottom:24px; line-height:1.5;"></p>

                <!-- Per-date ranges UI (each row shows Start / End on the left) -->
        <!-- Multiple ranges container for per-date overrides -->
        <div id="modalRangesContainer" class="availability-ui" style="display:flex; flex-direction:column; gap:8px; margin-top:12px;"></div>
        <div style="display:flex; justify-content:center; gap:8px; margin-top:8px;">
            <button type="button" id="addModalRangeBtn" style="padding:6px 10px; background:#007bff; color:white; border:none; border-radius:6px; cursor:pointer;">Add Range</button>
        </div>

    <div style="margin-top:24px; display:flex; justify-content:center; gap:10px; flex-wrap:wrap;">
      <button id="saveTimeBtn" 
              style="background:var(--primary-500); color:white; border:none; padding:12px 24px; 
                      border-radius:10px; cursor:pointer; font-weight:600; transition:all 0.2s ease; box-shadow:0 1px 3px rgba(0,0,0,0.1);">Save</button>
          <button id="resetToDefaultBtn" 
              style="background:var(--gray-600); color:white; border:none; padding:12px 24px; 
                  border-radius:10px; cursor:pointer; font-weight:600; transition:all 0.2s ease; box-shadow:0 1px 3px rgba(0,0,0,0.1);">Reset to default</button>
              <button id="makeUnavailableBtn"
                  style="background:var(--gray-700); color:white; border:none; padding:12px 24px; 
                         border-radius:10px; cursor:pointer; font-weight:600; transition:all 0.2s ease; box-shadow:0 1px 3px rgba(0,0,0,0.1); display:none;">Make Unavailable</button>
              <button id="makeAvailableBtn"
                  style="background:#06b6d4; color:white; border:none; padding:12px 24px; 
                         border-radius:10px; cursor:pointer; font-weight:600; transition:all 0.2s ease; box-shadow:0 1px 3px rgba(0,0,0,0.1); display:none;">Make Available</button>
      <button id="viewDayBtn" 
              style="background:var(--success-500); color:white; border:none; padding:12px 24px; 
                      border-radius:10px; cursor:pointer; font-weight:600; transition:all 0.2s ease; box-shadow:0 1px 3px rgba(0,0,0,0.1); display:none;">View Day Schedule</button>
      <button id="closeTimeBtn" 
              style="background:var(--gray-200); color:var(--gray-700); border:none; padding:12px 24px; border-radius:10px; cursor:pointer; font-weight:600; transition:all 0.2s ease;">Cancel</button>
    </div>    
  </div>
</div>

<!-- =============================== -->
<!-- Overrides Upgrade Required Modal -->
<!-- =============================== -->
<div id="ccOverridesUpgradeModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.6); backdrop-filter:blur(4px); justify-content:center; align-items:center; z-index:10050;">
    <div style="background:white; padding:28px; border-radius:20px; width:440px; max-width:92vw; text-align:left; box-shadow:0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04); animation:modalSlideUp 0.3s ease-out;">
        <h3 style="margin:0 0 10px 0; font-size:20px; font-weight:800; color:var(--gray-900);">Upgrade required</h3>
        <p style="margin:0; font-size:14px; color:var(--gray-600); line-height:1.5;">A higher subscription plan is required to override days.</p>
        <div style="margin-top:20px; display:flex; justify-content:flex-end; gap:10px; flex-wrap:wrap;">
            <button id="ccOverridesUpgradeCancelBtn" type="button" style="background:var(--gray-200); color:var(--gray-700); border:none; padding:10px 16px; border-radius:10px; cursor:pointer; font-weight:700; transition:all 0.2s ease;">Cancel</button>
            <button id="ccOverridesUpgradeGoBtn" type="button" style="background:var(--primary-500); color:white; border:none; padding:10px 16px; border-radius:10px; cursor:pointer; font-weight:700; transition:all 0.2s ease; box-shadow:0 1px 3px rgba(0,0,0,0.1);">View pricing</button>
        </div>
    </div>
</div>


<!--==========================-->
<!--TIME CIRCLES-->
<!--==========================-->
<div id="timeCirclesModal" style="display:none; flex-direction:column; padding:10px; position:fixed; inset:0; 
     background:rgba(0,0,0,0.6); backdrop-filter:blur(4px); justify-content:center; align-items:center; z-index:10000; animation:fadeIn 0.2s ease-out;">
  <div style="background:white; padding:40px; border-radius:20px; width:640px; max-height:85vh; overflow-y:auto; position:relative; box-shadow:0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04); animation:modalSlideUp 0.3s ease-out;">

    <!-- Client-Facing Settings -->
    <div id="clientTimeSettings" style="margin-bottom: 32px; padding:20px; border-radius:12px; background:var(--gray-50);">
      <h3 style="margin:0 0 16px 0; font-size:16px; font-weight:700; color:var(--gray-900);">Client View Settings</h3>
      <div style="display:flex; gap:20px; align-items:center; flex-wrap:wrap;">
        <div>
          <label for="clientBlockSelect">Hour Block:</label><br>
          <select id="clientBlockSelect">
            <option value="1">1 Hour</option>
            <option value="2">2 Hours</option>
            <option value="3">3 Hours</option>
          </select>
        </div>
        <div>
          <label for="clientIncrementSelect">Increment:</label><br>
                    <select id="clientIncrementSelect">
                        <option value="15">15 min</option>
                        <option value="30" selected>30 min</option>
                        <option value="45">45 min</option>
                        <option value="60">60 min</option>
                        <option value="custom">Custom</option>
                    </select>
                    <span id="clientCustomIncrementContainer" style="display:none; margin-left:8px; gap:6px; align-items:center;">
                        <input type="number" id="clientCustomIncrementInput" placeholder="Minutes" min="5" style="width:84px;" />
                    </span>
        </div>
        <div>
          <button id="saveClientSettingsBtn" 
                  style="padding:10px 20px; background:var(--primary-500); color:white; border:none; border-radius:8px; font-weight:600; cursor:pointer; transition:all 0.2s ease; box-shadow:0 1px 3px rgba(0,0,0,0.1);">
            Save for Client View
          </button>
        </div>
      </div>
    </div>
        <div style="margin-top:6px; font-size:13px; color:var(--gray-600); font-style:italic;">
                These client view settings are synchronized with the Edit Service increment settings — changes here will update the Edit Service page and the public booking view, and vice versa.
        </div>

    <!-- Coach Preview Section -->
    <div id="coachTimeSettings" style="margin-bottom: 32px; padding:20px; border-radius:12px; background:var(--gray-50); flex-direction: column;">
        <h3 style="margin:0 0 16px 0; font-size:16px; font-weight:700; color:var(--gray-900);">Coach Preview Settings</h3>
        <div style="display:flex; gap:20px; align-items:center; flex-wrap:wrap;">
            <div>
            <label>Hour Block:</label><br>
            <select id="hourBlockSelect">
                <option value="1">1 Hour</option>
                <option value="2">2 Hours</option>
                <option value="3">3 Hours</option>
                <option value="custom">Custom</option>
            </select>
            </div>
            <div>
            <label>Increment:</label><br>
            <select id="incrementSelect">
                <option value="15">15 min</option>
                <option value="30" selected>30 min</option>
                <option value="45">45 min</option>
                <option value="60">60 min</option>
                <option value="custom">Custom</option>
            </select>
            </div>
        </div>

        <!-- Add these right below the dropdowns -->
        <div id="customBlockInputContainer" style="display:none; margin-top:10px; gap:5px; align-items:center;">
            <input type="number" id="customBlockInput" placeholder="Minutes" min="15"/>
            <button id="applyCustomBlockBtn">Apply</button>
        </div>

        <div id="customIncrementContainer" style="display:none; margin-top:10px; gap:5px; align-items:center;">
            <input type="number" id="customIncrementInput" placeholder="Minutes" min="5"/>
            <button id="applyCustomIncrementBtn">Apply</button>
        </div>
        </div>

    <!-- Circle Title & Container -->
    <div id="circleModalTitle" style="font-weight:bold; font-size:16px;"></div>
    <div id="timeCirclesContainer" style="display:flex; flex-direction:column; gap:40px;"></div>

    <!-- Close "X" -->
    <button id="closeCirclesBtn" 
            style="position:absolute; top:10px; right:10px; background:none; border:none; font-size:20px; cursor:pointer;">✖</button>

  </div>
</div>

<!-- ========================= -->
<!-- BOOKING MODAL (Client Info) -->
<!-- ========================= -->
<div id="bookingModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.6); backdrop-filter:blur(4px); justify-content:center; align-items:center; z-index:10000; animation:fadeIn 0.2s ease-out;">
  <div style="background:white; padding:32px; border-radius:20px; width:480px; box-shadow:0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04); animation:modalSlideUp 0.3s ease-out;">
    <h3 id="bookingTitle" style="margin:0 0 20px 0; font-size:22px; font-weight:700; color:var(--gray-900);">Booking Details</h3>
    <div style="margin-bottom:16px; padding:16px; background:var(--gray-50); border-radius:12px;">
      <p style="margin:8px 0; color:var(--gray-700);"><strong style="color:var(--gray-900); font-weight:600;">Client:</strong> <span id="clientName"></span></p>
      <p style="margin:8px 0; color:var(--gray-700);"><strong style="color:var(--gray-900); font-weight:600;">Lesson Type:</strong> <span id="lessonType"></span></p>
      <p style="margin:8px 0; color:var(--gray-700);"><strong style="color:var(--gray-900); font-weight:600;">Time:</strong> <span id="lessonTime"></span></p>
      <p style="margin:8px 0; color:var(--gray-700);"><strong style="color:var(--gray-900); font-weight:600;">Payment:</strong> <span id="paymentMethod"></span></p>
    </div>

    <div style="margin-top:24px; display:flex; justify-content:space-between; gap:12px;">
      <button id="viewClientBookingsBtn" 
              style="flex:1; background:var(--primary-500); color:white; border:none; padding:12px 20px; border-radius:10px; cursor:pointer; font-weight:600; transition:all 0.2s ease; box-shadow:0 1px 3px rgba(0,0,0,0.1);">
        View All Bookings
      </button>
      <button id="closeBookingBtn" 
              style="background:var(--gray-200); color:var(--gray-700); border:none; padding:12px 20px; border-radius:10px; cursor:pointer; font-weight:600; transition:all 0.2s ease;">
        Close
      </button>
    </div>
  </div>
</div>


{% endblock %}

<!-- -------------------------
     Calendar JS
------------------------- -->
{% block extra_scripts %}
<script>
document.addEventListener('DOMContentLoaded', function() {
        // Helper to read CSRF token from cookie (used by fetch calls)
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }
        const csrftoken = getCookie('csrftoken');

        // Ensure any fetch calls to our authenticated endpoints include
        // credentials by default so the session cookie is sent. Many existing
        // calls in this template call `fetch('/bus/...')` without options.
        // Monkeypatch window.fetch to inject `credentials: 'same-origin'`
        // for same-origin relative `/bus/` paths.
        (function ensureBusFetchCredentials(){
            try {
                const _origFetch = window.fetch.bind(window);
                window.fetch = function(input, init){
                    try{
                        // Resolve URL string when provided
                        const urlStr = (typeof input === 'string') ? input : (input && input.url) || '';
                        if (typeof urlStr === 'string' && urlStr.startsWith('/bus/')) {
                            init = init || {};
                            if (!('credentials' in init)) init.credentials = 'same-origin';
                        }
                    } catch(e) { /* non-fatal */ }
                    return _origFetch(input, init);
                };
            } catch(e) {
                // If monkeypatching fails, fall back to leaving fetch as-is.
                console.warn('Could not monkeypatch fetch for /bus/ credentials', e);
            }
        })();
        // -----------------------------
        // 1️⃣ Initialize default availability from server (fall back to sensible defaults)
        // -----------------------------
        const serverAvail = {{ coach_availability_json|default:"{}"|safe }} || {};
        // Per-member availability map (membership_id -> availability payload)
        const memberAvailMap = {{ member_availability_map|default:"{}"|safe }} || {};
        const weekdayNames = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];

        // Helper to build availability map from a server payload (same shape as coach_availability_json)
        function buildAvailabilityFromPayload(payload) {
            const out = {};
            for (let i = 0; i < 7; i++) out[i] = { start: '09:00', end: '17:00', unavailable: true, ranges: [] };

            if (Array.isArray(payload)) {
                    // Detect two common array shapes:
                    // 1) array of per-day objects: [{ day_of_week: 0, ranges: [...], unavailable: bool }, ...]
                    // 2) weekly-array: [ ['09:00-12:00'], [], ['10:00-11:00'], ... ] (index=0 => Sunday)
                    if (payload.length === 7 && (Array.isArray(payload[0]) || typeof payload[0] === 'string' || payload[0] === null)) {
                        // weekly-array shape
                        payload.forEach((slots, idx) => {
                            let ranges = [];
                            if (Array.isArray(slots)) ranges = slots.slice();
                            else if (typeof slots === 'string' && slots.trim() !== '') ranges = [slots];
                            out[idx].unavailable = !(ranges && ranges.length);
                            out[idx].ranges = ranges || [];
                            if (out[idx].ranges && out[idx].ranges.length) {
                                const first = out[idx].ranges[0];
                                if (first && first.includes('-')) {
                                    const [s,e] = first.split('-');
                                    out[idx].start = s.trim();
                                    out[idx].end = e.trim();
                                }
                            }
                        });
                    } else {
                        payload.forEach(item => {
                            let dayIndex = null;
                            if (typeof item.day_of_week === 'number') dayIndex = item.day_of_week;
                            else if (typeof item.day_of_week === 'string' && item.day_of_week.trim() !== '') dayIndex = parseInt(item.day_of_week, 10);
                            if (isNaN(dayIndex) || dayIndex === null) return;
                            dayIndex = ((dayIndex % 7) + 7) % 7;
                            out[dayIndex].unavailable = !!item.unavailable;
                            out[dayIndex].ranges = item.ranges || [];
                            if (item.ranges?.length > 0) {
                                const [start, end] = item.ranges[0].split('-');
                                out[dayIndex].start = start;
                                out[dayIndex].end = end;
                            }
                        });
                    }
                } else if (payload && typeof payload === 'object') {
                Object.entries(payload).forEach(([dayName, slots]) => {
                    try {
                        const dn = String(dayName).trim();
                        const idx = weekdayNames.indexOf(dn);
                        if (idx === -1) return;
                        if (!Array.isArray(slots) || slots.length === 0) {
                            out[idx].unavailable = true;
                            out[idx].ranges = [];
                        } else {
                            out[idx].unavailable = false;
                            out[idx].ranges = slots;
                            const first = slots[0];
                            if (first && first.includes('-')) {
                                const [s,e] = first.split('-');
                                out[idx].start = s.trim();
                                out[idx].end = e.trim();
                            }
                        }
                    } catch (e) { }
                });
            }
            return out;
        }

        // Helper: produce a server-format availability array marking all days unavailable
        function makeAllUnavailablePayload() {
            const names = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
            return names.map(n => ({ day: n, ranges: [], unavailable: true }));
        }

        // Build the canonical org-wide availability once
        const orgDefaultAvailability = buildAvailabilityFromPayload(serverAvail);

        // Build per-member availability map (membership_id -> availability)
        const memberDefaultAvailability = {};
        try {
            // First convert any server-provided member maps
            for (const k of Object.keys(memberAvailMap || {})) {
                try { memberDefaultAvailability[String(k)] = buildAvailabilityFromPayload(memberAvailMap[k]); } catch(e){ /* fallthrough */ }
            }
        } catch(e){ /* ignore */ }

        // Ensure every membership present in the selector has an entry (new members default to all-unavailable)
        try {
            const sel = document.getElementById('memberSelect');
            if (sel) {
                Array.from(sel.options).forEach(opt => {
                    try{
                        const val = opt.value;
                        if (!val) return;
                        // skip service pseudo-options
                        if (String(val).startsWith('svc:')) return;
                        if (!memberDefaultAvailability[String(val)]){
                            memberDefaultAvailability[String(val)] = buildAvailabilityFromPayload(makeAllUnavailablePayload());
                        }
                    }catch(e){}
                });
            } else {
                // fallback: ensure known MEMBERS have entries
                if (Array.isArray(MEMBERS)){
                    for (const m of MEMBERS){
                        const mid = String(m.id);
                        if (!memberDefaultAvailability[mid]) memberDefaultAvailability[mid] = buildAvailabilityFromPayload(makeAllUnavailablePayload());
                    }
                }
            }
        } catch(e){ /* ignore */ }

        // The live defaultAvailability object used by the UI. Initialized to org defaults.
        const defaultAvailability = JSON.parse(JSON.stringify(orgDefaultAvailability));

    // -----------------------------
    // 2️⃣ Helper: is date in the past
    // -----------------------------
    function isPastDate(dateStr) {
        const today = new Date();
        const date = parseYMD(dateStr);
        const todayMidnight = new Date(today.getFullYear(), today.getMonth(), today.getDate());
        return date < todayMidnight;
    }

    
    function updateUnavailableDays() {
        // Service-scope parity: when a specific service is selected (svc:<id>),
        // use the same backend availability computation as the public booking page.
        // This ensures month visuals reflect *bookable* starts after applying bookings,
        // buffers, min notice, max booking days, overrides, resources, and freezes.
        try {
            if (typeof refreshServiceScopeMonthParity === 'function' && SELECTED_MEMBER && String(SELECTED_MEMBER).startsWith('svc:')) {
                refreshServiceScopeMonthParity();
                // Still keep the overrides table updated (it lists per-date overrides regardless
                // of whether a day has remaining slots).
                try { renderOverridesTable(); } catch (e) { /* ignore */ }
                return;
            }
        } catch (e) { /* fall through to legacy */ }

        // Compute per-date full-day blocks from background events (so per-date overrides take precedence)
        const blockedDates = new Set();
        const availableOverrideDates = new Set();
        try {
            calendar.getEvents().forEach(ev => {
                try {
                    const props = ev.extendedProps || {};
                    if (props.override_type === 'blocked') {
                        blockedDates.add(ev.startStr.split('T')[0]);
                    } else if (props.override_type === 'available') {
                        availableOverrideDates.add(ev.startStr.split('T')[0]);
                    }
                } catch (e) { /* ignore per-event parse errors */ }
            });
        } catch (e) { /* ignore if calendar.getEvents fails */ }

        document.querySelectorAll('.fc-daygrid-day').forEach(dayCell => {
            const dateStr = dayCell.dataset.date; // e.g., "2025-11-19"
            if (!dateStr) return;
            const dayIndex = parseYMD(dateStr).getDay(); // 0=Sunday..6=Saturday (local parse)
            const isPast = isPastDate(dateStr);

            // Past dates should be visually distinct (greyed circle) but NOT treated as
            // "unavailable" in the sense of future availability settings. Unavailable
            // is a future-facing user setting and should not be applied retroactively.
            if (isPast) {
                dayCell.classList.remove('fc-day-unavailable');
                dayCell.classList.remove('fc-day-available');
                dayCell.classList.add('fc-day-past');
                const num = dayCell.querySelector('.fc-daygrid-day-number');
                if (num) {
                    num.classList.add('past-day');
                    num.classList.remove('unavailable-number');
                    num.style.cursor = 'default';
                }
                return; // skip further unavailable/available processing for past dates
            }

            // Use classes to indicate available/unavailable so styles remain consistent
            // Precedence: per-date full-day blocks (unavailable) > per-date available overrides > weekly defaults
            if (blockedDates.has(dateStr)) {
                dayCell.classList.add('fc-day-unavailable');
                dayCell.classList.remove('fc-day-available');
                const num = dayCell.querySelector('.fc-daygrid-day-number');
                if (num) {
                    num.classList.add('unavailable-number');
                    num.style.cursor = 'pointer';
                }
            } else if (availableOverrideDates.has(dateStr)) {
                dayCell.classList.add('fc-day-available');
                dayCell.classList.remove('fc-day-unavailable');
                const num = dayCell.querySelector('.fc-daygrid-day-number');
                if (num) {
                    num.classList.remove('unavailable-number');
                    num.style.cursor = 'pointer';
                }
            } else if (defaultAvailability[dayIndex]?.unavailable) {
                dayCell.classList.add('fc-day-unavailable');
                dayCell.classList.remove('fc-day-available');
                const num = dayCell.querySelector('.fc-daygrid-day-number');
                if (num) {
                    num.classList.add('unavailable-number');
                    num.style.cursor = 'pointer';
                }
            } else {
                dayCell.classList.add('fc-day-available');
                dayCell.classList.remove('fc-day-unavailable');
                const num = dayCell.querySelector('.fc-daygrid-day-number');
                if (num) {
                    num.classList.remove('unavailable-number');
                    num.style.cursor = 'pointer';
                }
            }
        });
        // After updating day classes, refresh the overrides table so it reflects per-date overrides
        try { renderOverridesTable(); } catch (e) { console.warn('renderOverridesTable failed', e); }
    }

    // -----------------------------
    // Service-scope parity (month)
    // -----------------------------
    let __svcParityToken = 0;
    let __svcParityLastKey = null;
    let __svcParityLastMap = null;

    function _invalidateServiceScopeParityCache() {
        // Any per-date override creation/deletion can change real bookable availability.
        // When service scope is selected we must force a re-computation so day circles
        // flip immediately (and don't get stuck on a cached month map).
        try { __svcParityLastKey = null; } catch (e) {}
        try { __svcParityLastMap = null; } catch (e) {}
        // Bump token to cancel any in-flight background verification
        try { __svcParityToken = (__svcParityToken || 0) + 1; } catch (e) {}
    }

    function _svcForSelectedScope() {
        try {
            if (!SELECTED_MEMBER) return null;
            const raw = String(SELECTED_MEMBER);
            if (!raw.startsWith('svc:')) return null;
            const svcId = Number(raw.slice(4)) || null;
            if (!svcId) return null;
            const svc = (typeof svcById === 'function') ? svcById(svcId) : null;
            if (!svc || !svc.slug) return null;
            return svc;
        } catch (e) {
            return null;
        }
    }

    function _visibleDayDates() {
        const out = [];
        try {
            // Only include in-month cells; FullCalendar still renders out-of-month cells
            // even if we hide them via CSS.
            document.querySelectorAll('.fc-daygrid-day[data-date]:not(.fc-day-other)').forEach(el => {
                const d = el.getAttribute('data-date');
                if (d) out.push(d);
            });
        } catch (e) {}
        // De-dupe while preserving order
        try { return Array.from(new Set(out)); } catch (e) { return out; }
    }

    function _toIsoLocal(dateStr, hh, mm, ss) {
        // dateStr: YYYY-MM-DD
        try {
            const parts = String(dateStr).split('-');
            const y = Number(parts[0]);
            const m = Number(parts[1]);
            const d = Number(parts[2]);
            const pad = n => String(n).padStart(2, '0');
            return `${y}-${pad(m)}-${pad(d)}T${pad(hh)}:${pad(mm)}:${pad(ss || 0)}`;
        } catch (e) {
            return `${dateStr}T${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:00`;
        }
    }

    function _applyServiceScopeDayClasses(dayHasSlots) {
        try {
            document.querySelectorAll('.fc-daygrid-day').forEach(dayCell => {
                const dateStr = dayCell.dataset.date;
                if (!dateStr) return;
                const isPast = isPastDate(dateStr);
                if (isPast) {
                    dayCell.classList.remove('fc-day-unavailable');
                    dayCell.classList.remove('fc-day-available');
                    dayCell.classList.add('fc-day-past');
                    const num = dayCell.querySelector('.fc-daygrid-day-number');
                    if (num) {
                        num.classList.add('past-day');
                        num.classList.remove('unavailable-number');
                        num.style.cursor = 'default';
                    }
                    return;
                }

                const enabled = !!(dayHasSlots && dayHasSlots[dateStr]);
                if (enabled) {
                    dayCell.classList.add('fc-day-available');
                    dayCell.classList.remove('fc-day-unavailable');
                } else {
                    dayCell.classList.add('fc-day-unavailable');
                    dayCell.classList.remove('fc-day-available');
                }

                dayCell.style.background = 'transparent';
                const num = dayCell.querySelector('.fc-daygrid-day-number');
                if (num) {
                    // Keep clickable for override editing even when unavailable
                    num.style.cursor = 'pointer';
                    if (enabled) num.classList.remove('unavailable-number');
                    else num.classList.add('unavailable-number');
                }
            });
        } catch (e) { console.warn('applyServiceScopeDayClasses failed', e); }
    }

    // -----------------------------
    // Service-scope calendar loading UX
    // -----------------------------
    function _ensureCalendarLoadingOverlay() {
        try {
            const calEl = document.getElementById('calendar');
            if (!calEl) return null;
            let overlay = calEl.querySelector('.cc-calendar-loading-overlay');
            if (overlay) return overlay;
            overlay = document.createElement('div');
            overlay.className = 'cc-calendar-loading-overlay';
            overlay.innerHTML = `
                <div class="cc-calendar-spinner" aria-hidden="true"></div>
                <div class="cc-calendar-loading-text">Loading availability…</div>
            `;
            calEl.appendChild(overlay);
            return overlay;
        } catch (e) {
            return null;
        }
    }

    function _setCalendarLoading(isLoading, message) {
        try {
            const calEl = document.getElementById('calendar');
            if (!calEl) return;
            const overlay = _ensureCalendarLoadingOverlay();
            if (overlay) {
                const textEl = overlay.querySelector('.cc-calendar-loading-text');
                if (textEl && typeof message === 'string' && message.trim()) {
                    textEl.textContent = message;
                } else if (textEl) {
                    textEl.textContent = 'Loading availability…';
                }
            }
            if (isLoading) calEl.classList.add('cc-calendar-loading');
            else calEl.classList.remove('cc-calendar-loading');
        } catch (e) { /* ignore */ }
    }

    async function refreshServiceScopeMonthParity() {
        const svc = _svcForSelectedScope();
        if (!svc) return;
        const dates = _visibleDayDates();
        if (!dates || dates.length === 0) return;

        const token = ++__svcParityToken;
        const sorted = dates.slice().sort();
        const minDate = sorted[0];
        const maxDate = sorted[sorted.length - 1];
        const key = `${svc.slug}|${minDate}|${maxDate}`;

        // Fast path: re-apply cached results for the same visible month/service
        if (__svcParityLastKey === key && __svcParityLastMap) {
            _applyServiceScopeDayClasses(__svcParityLastMap);
            try { _setCalendarLoading(false); } catch (e) {}
            return;
        }

        // Grey out calendar until parity finishes (prevents confusing partial render)
        try { _setCalendarLoading(true, 'Loading availability…'); } catch (e) {}

        const today = new Date();
        const todayMidnight = new Date(today.getFullYear(), today.getMonth(), today.getDate());

        // Fetch server-effective settings (once) + batch summary in parallel.
        const cacheBuster = `&_t=${Date.now()}`;
        let eff = null;
        let summary = {};
        const startIsoRange = _toIsoLocal(minDate, 0, 0, 0);
        const endIsoRange = _toIsoLocal(maxDate, 23, 59, 59);
        try {
            const effUrl = `/bus/${orgSlug}/services/${svc.slug}/effective/?date=${encodeURIComponent(minDate)}`;
            const batchUrl = `/bus/${orgSlug}/services/${svc.slug}/availability/batch/?start=${encodeURIComponent(startIsoRange)}&end=${encodeURIComponent(endIsoRange)}${cacheBuster}`;
            const [effResp, batchResp] = await Promise.all([
                fetch(effUrl, { credentials: 'same-origin' }).catch(() => null),
                fetch(batchUrl, { credentials: 'same-origin' }).catch(() => null),
            ]);
            try { if (effResp && effResp.ok) eff = await effResp.json(); } catch (e) { eff = null; }
            try { if (batchResp && batchResp.ok) summary = await batchResp.json(); } catch (e) { summary = {}; }
        } catch (e) {
            eff = null;
            summary = {};
        }

        const useFixed = (eff && typeof eff.use_fixed_increment === 'boolean') ? !!eff.use_fixed_increment : !!svc.use_fixed_increment;
        const incVal = Math.max(5, Number((eff && eff.time_increment_minutes) || svc.time_increment_minutes || 30));
        let allowEndsForAvail = false;
        try {
            allowEndsForAvail = (eff && typeof eff.allow_ends_after_availability === 'boolean') ? !!eff.allow_ends_after_availability : !!svc.allow_ends_after_availability;
        } catch (e) { allowEndsForAvail = false; }

        const edgeVal = (function(){
            try {
                const raw = localStorage.getItem('edge_buffers_' + svc.slug);
                if (raw === '1' || raw === 'true') return 1;
                if (raw === '0' || raw === 'false') return 0;
            } catch (e) {}
            return 0;
        })();

        // Fast paint (matches public month behavior): apply batch summary immediately.
        // This makes circles appear quickly instead of waiting for per-day verification.
        const dayHasSlots = {};
        for (const dateStr of dates) {
            dayHasSlots[dateStr] = false;
            try {
                const d = parseYMD(dateStr);
                if (d < todayMidnight) continue;
            } catch (e) {}
            dayHasSlots[dateStr] = !!(summary && summary[dateStr]);
        }

        if (token !== __svcParityToken) return;
        _applyServiceScopeDayClasses(dayHasSlots);
        try { renderOverridesTable(); } catch (e) { /* ignore */ }
        // Remove the overlay once we've painted the month; refine in background.
        try { _setCalendarLoading(false); } catch (e) {}

        // Background verification: for days batch marked true, confirm slots exist.
        // This mirrors the public page's "verify detailed availability" idea, but
        // does NOT block rendering.
        const candidates = [];
        for (const dateStr of dates) {
            try {
                const d = parseYMD(dateStr);
                if (d < todayMidnight) continue;
            } catch (e) {}
            if (dayHasSlots[dateStr]) candidates.push(dateStr);
        }

        if (candidates.length === 0) {
            __svcParityLastKey = key;
            __svcParityLastMap = dayHasSlots;
            return;
        }

        (async () => {
            const incQueryBase = useFixed ? '' : `&inc=${incVal}`;
            const concurrency = 4;
            let idx = 0;
            let pendingApply = null;
            const scheduleApply = () => {
                if (pendingApply) return;
                pendingApply = setTimeout(() => {
                    pendingApply = null;
                    if (token !== __svcParityToken) return;
                    _applyServiceScopeDayClasses(dayHasSlots);
                }, 75);
            };

            async function worker() {
                while (true) {
                    const my = idx++;
                    if (my >= candidates.length) return;
                    const dateStr = candidates[my];
                    try {
                        const startIso = _toIsoLocal(dateStr, 0, 0, 0);
                        const endIso = _toIsoLocal(dateStr, 23, 59, 59);
                        const availUrl = `/bus/${orgSlug}/services/${svc.slug}/availability/?start=${encodeURIComponent(startIso)}&end=${encodeURIComponent(endIso)}${incQueryBase}&edge_buffers=${edgeVal}&allow_ends_after_availability=${allowEndsForAvail?1:0}${cacheBuster}`;
                        const r = await fetch(availUrl, { credentials: 'same-origin' });
                        const slots = r.ok ? await r.json() : [];
                        dayHasSlots[dateStr] = Array.isArray(slots) && slots.length > 0;
                    } catch (e) {
                        dayHasSlots[dateStr] = false;
                    }
                    scheduleApply();
                }
            }

            try {
                await Promise.all(Array.from({ length: Math.min(concurrency, candidates.length) }, () => worker()));
            } catch (e) { /* ignore */ }
            if (token !== __svcParityToken) return;

            if (pendingApply) {
                try { clearTimeout(pendingApply); } catch (e) {}
                pendingApply = null;
            }

            __svcParityLastKey = key;
            __svcParityLastMap = dayHasSlots;
            _applyServiceScopeDayClasses(dayHasSlots);
            try { renderOverridesTable(); } catch (e) { /* ignore */ }
        })();
    }

    // -----------------------------
    // 3️⃣ Render default availability table
    // -----------------------------
    // Global Custom Time Picker accessible across contexts
    function createCustomTimePickerGlobal(inputElement) {
        const picker = document.createElement('div');
        picker.className = 'custom-time-picker';

        const [initialHour, initialMinute] = (inputElement.value || '09:00').split(':');
        let selectedHour = initialHour;
        let selectedMinute = initialMinute;

        const isStart = inputElement.classList.contains('modal-range-start') || inputElement.classList.contains('range-start');
        const headerText = isStart ? 'Start Time' : 'End Time';

        picker.innerHTML = `
            <div class="time-picker-header">${headerText}</div>
            <div class="time-picker-display">${formatDisplayTime(selectedHour, selectedMinute)}</div>
            <div class="time-picker-selectors">
                <div class="time-selector">
                    <div class="time-selector-label">Hour</div>
                    <div class="time-scroll-container" data-type="hour"></div>
                </div>
                <div class="time-selector">
                    <div class="time-selector-label">Minute</div>
                    <div class="time-scroll-container" data-type="minute"></div>
                </div>
            </div>
            <div class="time-picker-actions">
                <button class="time-picker-btn cancel">Cancel</button>
                <button class="time-picker-btn confirm">Confirm</button>
            </div>
        `;

        const hourContainer = picker.querySelector('[data-type="hour"]');
        for (let h = 0; h < 24; h++) {
            const hourStr = String(h).padStart(2, '0');
            const opt = document.createElement('div');
            opt.className = 'time-option';
            if (hourStr === selectedHour) opt.classList.add('selected');
            opt.textContent = formatHour(h);
            opt.addEventListener('click', () => {
                hourContainer.querySelectorAll('.time-option').forEach(o => o.classList.remove('selected'));
                opt.classList.add('selected');
                selectedHour = hourStr;
                updateDisplay();
                opt.scrollIntoView({ behavior: 'smooth', block: 'center' });
            });
            hourContainer.appendChild(opt);
        }

        const minuteContainer = picker.querySelector('[data-type="minute"]');
        for (let m = 0; m < 60; m++) {
            const minStr = String(m).padStart(2, '0');
            const opt = document.createElement('div');
            opt.className = 'time-option';
            if (minStr === selectedMinute) opt.classList.add('selected');
            opt.textContent = minStr;
            opt.addEventListener('click', () => {
                minuteContainer.querySelectorAll('.time-option').forEach(o => o.classList.remove('selected'));
                opt.classList.add('selected');
                selectedMinute = minStr;
                updateDisplay();
                opt.scrollIntoView({ behavior: 'smooth', block: 'center' });
            });
            minuteContainer.appendChild(opt);
        }

        function updateDisplay() {
            picker.querySelector('.time-picker-display').textContent = formatDisplayTime(selectedHour, selectedMinute);
        }
        function formatHour(h) {
            if (h === 0) return '12 AM';
            if (h < 12) return `${h} AM`;
            if (h === 12) return '12 PM';
            return `${h - 12} PM`;
        }
        function formatDisplayTime(h, m) {
            const hour = parseInt(h);
            const ampm = hour >= 12 ? 'PM' : 'AM';
            const h12 = hour === 0 ? 12 : (hour > 12 ? hour - 12 : hour);
            return `${h12}:${m} ${ampm}`;
        }

        setTimeout(() => {
            hourContainer.querySelector('.selected')?.scrollIntoView({ block: 'center' });
            minuteContainer.querySelector('.selected')?.scrollIntoView({ block: 'center' });
        }, 50);

        picker.querySelector('.confirm').addEventListener('click', (e) => {
            e.stopPropagation();
            inputElement.value = `${selectedHour}:${selectedMinute}`;
            picker.remove();
        });
        picker.querySelector('.cancel').addEventListener('click', (e) => {
            e.stopPropagation();
            picker.remove();
        });
        setTimeout(() => {
            document.addEventListener('click', function closeOnOutside(e) {
                if (!picker.contains(e.target) && e.target !== inputElement) {
                    picker.remove();
                    document.removeEventListener('click', closeOnOutside);
                }
            });
        }, 100);

        return picker;
    }

    function displayDefaultAvailability() {
        const container = document.getElementById("defaultAvailabilityTable");
        container.innerHTML = "";
        const days = ["Sunday", "Monday","Tuesday","Wednesday","Thursday","Friday", "Saturday"];

        // Custom Time Picker Creator
        function createCustomTimePicker(inputElement) {
            const picker = document.createElement('div');
            picker.className = 'custom-time-picker';
            
            const [initialHour, initialMinute] = (inputElement.value || '09:00').split(':');
            let selectedHour = initialHour;
            let selectedMinute = initialMinute;
            
            picker.innerHTML = `
                <div class="time-picker-header">Select Time</div>
                <div class="time-picker-display">${formatDisplayTime(selectedHour, selectedMinute)}</div>
                <div class="time-picker-selectors">
                    <div class="time-selector">
                        <div class="time-selector-label">Hour</div>
                        <div class="time-scroll-container" data-type="hour"></div>
                    </div>
                    <div class="time-selector">
                        <div class="time-selector-label">Minute</div>
                        <div class="time-scroll-container" data-type="minute"></div>
                    </div>
                </div>
                <div class="time-picker-actions">
                    <button class="time-picker-btn cancel">Cancel</button>
                    <button class="time-picker-btn confirm">Confirm</button>
                </div>
            `;
            
            // Populate hours (0-23)
            const hourContainer = picker.querySelector('[data-type="hour"]');
            for (let h = 0; h < 24; h++) {
                const hourStr = String(h).padStart(2, '0');
                const opt = document.createElement('div');
                opt.className = 'time-option';
                if (hourStr === selectedHour) opt.classList.add('selected');
                opt.textContent = formatHour(h);
                opt.addEventListener('click', () => {
                    hourContainer.querySelectorAll('.time-option').forEach(o => o.classList.remove('selected'));
                    opt.classList.add('selected');
                    selectedHour = hourStr;
                    updateDisplay();
                    opt.scrollIntoView({ behavior: 'smooth', block: 'center' });
                });
                hourContainer.appendChild(opt);
            }
            
            // Populate minutes (00-59)
            const minuteContainer = picker.querySelector('[data-type="minute"]');
            for (let m = 0; m < 60; m++) {
                const minStr = String(m).padStart(2, '0');
                const opt = document.createElement('div');
                opt.className = 'time-option';
                if (minStr === selectedMinute) opt.classList.add('selected');
                opt.textContent = minStr;
                opt.addEventListener('click', () => {
                    minuteContainer.querySelectorAll('.time-option').forEach(o => o.classList.remove('selected'));
                    opt.classList.add('selected');
                    selectedMinute = minStr;
                    updateDisplay();
                    opt.scrollIntoView({ behavior: 'smooth', block: 'center' });
                });
                minuteContainer.appendChild(opt);
            }
            
            function updateDisplay() {
                picker.querySelector('.time-picker-display').textContent = formatDisplayTime(selectedHour, selectedMinute);
            }
            
            function formatHour(h) {
                if (h === 0) return '12 AM';
                if (h < 12) return `${h} AM`;
                if (h === 12) return '12 PM';
                return `${h - 12} PM`;
            }
            
            function formatDisplayTime(h, m) {
                const hour = parseInt(h);
                const ampm = hour >= 12 ? 'PM' : 'AM';
                const h12 = hour === 0 ? 12 : (hour > 12 ? hour - 12 : hour);
                return `${h12}:${m} ${ampm}`;
            }
            
            // Scroll selected items into view
            setTimeout(() => {
                hourContainer.querySelector('.selected')?.scrollIntoView({ block: 'center' });
                minuteContainer.querySelector('.selected')?.scrollIntoView({ block: 'center' });
            }, 50);
            
            // Confirm button
            picker.querySelector('.confirm').addEventListener('click', (e) => {
                e.stopPropagation();
                inputElement.value = `${selectedHour}:${selectedMinute}`;
                picker.remove();
            });
            
            // Cancel button
            picker.querySelector('.cancel').addEventListener('click', (e) => {
                e.stopPropagation();
                picker.remove();
            });
            
            // Close on outside click
            setTimeout(() => {
                document.addEventListener('click', function closeOnOutside(e) {
                    if (!picker.contains(e.target) && e.target !== inputElement) {
                        picker.remove();
                        document.removeEventListener('click', closeOnOutside);
                    }
                });
            }, 100);
            
            return picker;
        }

        // Helper to create a single range row (start/end + remove)
        function createRangeRow(dayIndex, startVal = '', endVal = '') {
            const row = document.createElement('div');
            row.className = 'range-row';

            // Wrap start input in positioned container
            const startContainer = document.createElement('div');
            startContainer.className = 'time-input-container';
            
            const start = document.createElement('input');
            start.type = 'time';
            start.className = 'range-start';
            start.value = startVal || '09:00';
            start.readOnly = true;
            start.style.cursor = 'pointer';
            
            start.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                // Remove any existing pickers
                document.querySelectorAll('.custom-time-picker').forEach(p => p.remove());
                
                const picker = (typeof createCustomTimePickerGlobal === 'function' ? createCustomTimePickerGlobal : createCustomTimePicker)(start);
                picker.classList.add('active');
                startContainer.appendChild(picker);
            });
            
            startContainer.appendChild(start);

            // Wrap end input in positioned container
            const endContainer = document.createElement('div');
            endContainer.className = 'time-input-container';
            
            const end = document.createElement('input');
            end.type = 'time';
            end.className = 'range-end';
            end.value = endVal || '17:00';
            end.readOnly = true;
            end.style.cursor = 'pointer';
            
            end.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                // Remove any existing pickers
                document.querySelectorAll('.custom-time-picker').forEach(p => p.remove());
                
                const picker = (typeof createCustomTimePickerGlobal === 'function' ? createCustomTimePickerGlobal : createCustomTimePicker)(end);
                picker.classList.add('active');
                endContainer.appendChild(picker);
            });
            
            endContainer.appendChild(end);

            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'remove-range-btn';
            removeBtn.setAttribute('aria-label', 'Remove range');
            removeBtn.innerHTML = '<span class="remove-icon" aria-hidden="true">✖</span>';
            removeBtn.addEventListener('click', () => {
                try { row.remove(); } catch (e) {}
                // If the user removed the last range for a day, treat that day as unavailable.
                // This matches backend semantics (no rows => unavailable) and prevents the UI
                // from auto-adding a default range on re-render after save.
                try {
                    const containerEl = document.getElementById(`ranges-container-${dayIndex}`);
                    const hasAny = containerEl ? containerEl.querySelectorAll('.range-row').length > 0 : false;
                    if (!hasAny) {
                        const cb = document.querySelector(`.unavailable-checkbox[data-day='${dayIndex}']`);
                        if (cb && !cb.checked) {
                            cb.checked = true;
                            cb.dispatchEvent(new Event('change'));
                        } else {
                            // Ensure in-memory state still reflects the removal
                            defaultAvailability[dayIndex].unavailable = true;
                            defaultAvailability[dayIndex].ranges = [];
                        }
                    }
                } catch (e) {}
            });

            row.appendChild(startContainer);
            row.appendChild(endContainer);
            row.appendChild(removeBtn);

            return row;
        }

        days.forEach((dayName, i) => {
            const dayIndex = i;
            const row = document.createElement('tr');

            row.innerHTML = `
                <td style="vertical-align:top; padding-top:10px; white-space:nowrap;">${dayName}</td>
                <td colspan="2" style="vertical-align:top; padding-left:24px;">
                    <div id="ranges-container-${dayIndex}" style="display:flex; flex-direction:column; gap:4px;"></div>
                    <div style="margin-top:6px;"><button type="button" class="add-range-btn" data-day="${dayIndex}" style="padding:6px 10px; background:#007bff; color:white; border:none; border-radius:6px; cursor:pointer;">Add range</button></div>
                </td>
                <td style="text-align:right; vertical-align:top; padding-top:18px; padding-right:8px;"><input type="checkbox" class="unavailable-checkbox" data-day="${dayIndex}" ${defaultAvailability[dayIndex].unavailable ? "checked" : ""}></td>
            `;

            container.appendChild(row);

            const rangesContainer = document.getElementById(`ranges-container-${dayIndex}`);
            const existing = defaultAvailability[dayIndex].ranges || [];
            if (existing.length) {
                existing.forEach(r => {
                    const parts = r.split('-');
                    const s = parts[0] ? parts[0].trim() : '09:00';
                    const e = parts[1] ? parts[1].trim() : '17:00';
                    rangesContainer.appendChild(createRangeRow(dayIndex, s, e));
                });
            } else {
                // if not unavailable, add a single blank row
                if (!defaultAvailability[dayIndex].unavailable) {
                    rangesContainer.appendChild(createRangeRow(dayIndex, defaultAvailability[dayIndex].start || '09:00', defaultAvailability[dayIndex].end || '17:00'));
                }
            }

            // Add button handler
            const addBtn = row.querySelector('.add-range-btn');
            addBtn.addEventListener('click', () => {
                rangesContainer.appendChild(createRangeRow(dayIndex, '09:00', '17:00'));
            });
        });

        // Handle unavailable checkbox toggles (disable ranges UI when unavailable)
        // NOTE: do NOT apply changes to the calendar immediately here. Changes should
        // be saved by clicking the Save Defaults button. This prevents premature
        // application of availability while the user is still editing the defaults.
        document.querySelectorAll('.unavailable-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', function() {
                const day = this.dataset.day;
                // Update the in-memory defaultAvailability but do not mutate calendar yet
                defaultAvailability[day].unavailable = this.checked;
                const containerEl = document.getElementById(`ranges-container-${day}`);
                const addBtn = document.querySelector(`.add-range-btn[data-day='${day}']`);
                if (this.checked) {
                    // hide/disable ranges
                    containerEl.style.opacity = '0.5';
                    containerEl.querySelectorAll('input').forEach(i => i.disabled = true);
                    addBtn.disabled = true;
                } else {
                    containerEl.style.opacity = '1';
                    // If there are no existing range rows (user just toggled available), add a default range row
                    if (!containerEl.querySelectorAll('.range-row').length) {
                        const start = defaultAvailability[day].start || '09:00';
                        const end = defaultAvailability[day].end || '17:00';
                        containerEl.appendChild(createRangeRow(day, start, end));
                    }
                    containerEl.querySelectorAll('input').forEach(i => i.disabled = false);
                    addBtn.disabled = false;
                }
                // Do not call updateUnavailableDays() here; wait for Save Defaults to apply
            });
            // Trigger initial state (this will only set UI inputs; calendar not updated until save)
            checkbox.dispatchEvent(new Event('change'));
        });

        // Save handler (use onclick to avoid duplicate listeners)
        const saveBtn = document.getElementById('saveDefaultAvailabilityBtn');

        function _ensureAvailabilitySaveBanner(){
            let el = document.getElementById('cc-availability-save-banner');
            if (el) return el;
            el = document.createElement('div');
            el.id = 'cc-availability-save-banner';
            el.setAttribute('role', 'status');
            el.setAttribute('aria-live', 'polite');
            el.style.display = 'none';
            el.style.margin = '0 0 10px 0';
            el.style.padding = '10px 12px';
            el.style.borderRadius = '10px';
            el.style.border = '1px solid #e5e7eb';
            el.style.background = '#f9fafb';
            el.style.color = '#111827';
            el.style.fontSize = '14px';
            el.style.lineHeight = '1.35';
            // Place banner right above the Save button if possible.
            try {
                const parent = saveBtn && saveBtn.parentElement ? saveBtn.parentElement : null;
                if (parent) parent.insertBefore(el, saveBtn);
                else document.body.appendChild(el);
            } catch (e) {
                document.body.appendChild(el);
            }
            return el;
        }

        function _availabilitySaveHint(msg){
            const m = String(msg || '').toLowerCase();
            if (m.includes('overlaps another solo service')) {
                return "Tip: Either make the services' scheduling settings identical, or move one service to a non-overlapping day/time.";
            }
            if (m.includes("within the assigned member's weekly availability")) {
                return "Tip: Expand the member's overall availability first (or shrink the service window).";
            }
            if (m.includes('overall availability cannot exclude existing service availability')) {
                return 'Tip: Expand overall availability first, then save.';
            }
            return '';
        }

        function _showAvailabilitySaveBanner(kind, message){
            const el = _ensureAvailabilitySaveBanner();
            const hint = _availabilitySaveHint(message);
            const safeMsg = String(message || '').trim();

            el.style.display = 'block';
            if (kind === 'success') {
                el.style.border = '1px solid #86efac';
                el.style.background = '#ecfdf5';
                el.style.color = '#065f46';
                el.innerHTML = `<div style="font-weight:700">Saved</div><div style="margin-top:2px">${safeMsg || 'Weekly availability saved.'}</div>`;
            } else {
                el.style.border = '1px solid #fecaca';
                el.style.background = '#fef2f2';
                el.style.color = '#7f1d1d';
                el.innerHTML = `<div style="font-weight:700">Couldn't save</div><div style="margin-top:2px">${safeMsg || 'The server rejected these changes.'}</div>${hint ? `<div style="margin-top:6px;color:#991b1b"><strong>\u2022</strong> ${hint}</div>` : ''}`;
            }
            try { el.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); } catch (e) {}
        }

        function _clearAvailabilitySaveBanner(){
            const el = document.getElementById('cc-availability-save-banner');
            if (!el) return;
            el.style.display = 'none';
            el.textContent = '';
        }

        saveBtn.onclick = async function() {
            // Build payload from dynamic inputs
            const payload = [];
            for (let day = 0; day < 7; day++) {
                const containerEl = document.getElementById(`ranges-container-${day}`);
                const rows = containerEl ? Array.from(containerEl.querySelectorAll('.range-row')) : [];
                const ranges = [];
                let invalid = false;
                for (const r of rows) {
                    const s = r.querySelector('.range-start').value;
                    const e = r.querySelector('.range-end').value;
                    if (!s || !e) continue;
                    if (s >= e) {
                        alert(`Invalid range for ${days[day]}: start must be before end (${s} >= ${e})`);
                        invalid = true;
                        break;
                    }
                    ranges.push(`${s}-${e}`);
                }
                if (invalid) return;
                const cb = document.querySelector(`.unavailable-checkbox[data-day='${day}']`);
                const unavailableChecked = !!(cb && cb.checked);
                // If no ranges remain, treat the day as unavailable even if the checkbox
                // wasn't toggled. This matches persisted semantics and avoids re-render
                // creating a default range row.
                const unavailable = unavailableChecked || ranges.length === 0;
                // Backend accepts day names or numeric; send full day name for clarity
                payload.push({ day: days[day], ranges: ranges, unavailable: unavailable });
            }

            // Debug: show payload about to be sent to server (days sent as names)
            console.log('Saving weekly availability payload (day names):', JSON.parse(JSON.stringify(payload)));

            try {
                // Save ONLY the current selection (member or service). Sending bulk maps here
                // causes stale data to overwrite the current edits.
                const target = (SELECTED_MEMBER || null);

                const res = await fetch(`/bus/${orgSlug}/availability/save/`, {
                    method: 'POST',
                    credentials: 'same-origin',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrftoken
                    },
                    body: JSON.stringify({ availability: payload, target: target })
                });

                const data = await res.json().catch(() => null);
                if (res.ok && data && data.success) {
                    _showAvailabilitySaveBanner('success', 'Weekly availability saved.');

                    // Update selection-specific caches so switching scopes doesn't revert until reload.
                    try {
                        if (target && !String(target).startsWith('svc:')) {
                            // membership id
                            memberDefaultAvailability[String(target)] = buildAvailabilityFromPayload(payload);
                            try { memberAvailMap[String(target)] = payload; } catch (e) {}
                        } else if (target && String(target).startsWith('svc:')) {
                            const svcId = String(target).slice(4);
                            const svc = (SERVICES||[]).find(s => String(s.id) === String(svcId));
                            if (svc) {
                                // Store as list-of-lists (UI expects this shape for unions).
                                const byDay = [[],[],[],[],[],[],[]];
                                for (let i=0;i<7;i++){
                                    const row = payload[i];
                                    if (row && !row.unavailable && Array.isArray(row.ranges)) byDay[i] = row.ranges.slice();
                                    else byDay[i] = [];
                                }
                                svc.weekly_map = byDay;
                                svc.has_service_weekly_windows = true;
                            }
                        }
                    } catch (e) { console.warn('Failed to update selection caches after save', e); }

                    // Update local defaultAvailability from payload so the UI reflects saved values immediately
                    try {
                        payload.forEach(item => {
                            let dayIdx = null;
                            if (typeof item.day === 'number') dayIdx = item.day;
                            else if (typeof item.day === 'string') {
                                const name = item.day.trim();
                                // try to match full weekday name first
                                const idx = weekdayNames.indexOf(name);
                                if (idx !== -1) dayIdx = idx;
                                else {
                                    // try numeric string
                                    const asNum = parseInt(name, 10);
                                    if (!isNaN(asNum)) dayIdx = ((asNum % 7) + 7) % 7;
                                }
                            }
                            if (dayIdx === null || typeof dayIdx !== 'number' || isNaN(dayIdx)) return;
                            // apply values
                            defaultAvailability[dayIdx].unavailable = !!item.unavailable;
                            defaultAvailability[dayIdx].ranges = Array.isArray(item.ranges) ? item.ranges.slice() : [];
                            if (defaultAvailability[dayIdx].ranges && defaultAvailability[dayIdx].ranges.length) {
                                const first = defaultAvailability[dayIdx].ranges[0];
                                if (first && first.includes('-')) {
                                    const [s,e] = first.split('-');
                                    defaultAvailability[dayIdx].start = s.trim();
                                    defaultAvailability[dayIdx].end = e.trim();
                                }
                            }
                        });
                    } catch (e) { console.warn('Failed to update local defaults after save', e); }

                    // Re-render inputs and calendar backgrounds immediately
                    try { displayDefaultAvailability(); } catch (e) { console.warn('displayDefaultAvailability failed', e); }
                    try { syncAvailabilityToCalendar(); } catch (e) { console.warn('syncAvailabilityToCalendar failed', e); }
                    try { updateUnavailableDays(); } catch (e) { console.warn('updateUnavailableDays failed', e); }
                    // Also refetch server events to pick up any server-side overrides
                    try { calendar.refetchEvents(); } catch (e) { /* ignore */ }
                } else {
                    const msg = (data && (data.error || data.message)) || `Server returned ${res.status}`;
                    _showAvailabilitySaveBanner('error', msg);
                }
            } catch (err) {
                console.error('Save failed', err);
                const msg = (err && err.message) ? err.message : String(err);
                _showAvailabilitySaveBanner('error', msg);
            }
        };
    }

    const calendarEl = document.getElementById('calendar');
    const clearBtn = document.getElementById('clearSelectionBtn');
    const selectBtn = document.getElementById('selectDaysBtn');
     const retryInitBtn = document.getElementById('retryInitCalendarBtn');
    if (retryInitBtn) retryInitBtn.addEventListener('click', () => { try { location.reload(); } catch(e){} });
    
    const orgSlug = "{{ organization.slug }}";
    const orgTimezone = "{{ org_timezone }}";  // e.g., 'America/Los_Angeles'
    const EDIT_SERVICE_URL_TEMPLATE = "{% url 'calendar_app:edit_service' organization.slug 0 %}";
        // Services metadata from server (includes per-service weekly_map)
        const SERVICES = {{ services_json|default:"[]"|safe }} || [];
        const MEMBERS = {{ members_list|default:'[]'|safe }} || [];
        const IS_TEAM = {{ is_team_plan|yesno:'true,false' }};
        const CAN_USE_OVERRIDES = {{ can_use_overrides|yesno:'true,false' }};
        const PRICING_URL = "{% url 'calendar_app:pricing_page' organization.slug %}";
        // Selected member id (string). Defaults to saved selection or provided default_member_id or first member id.
        const DEFAULT_MEMBER = {{ default_member_id|default:'null' }};
        const _stored_selected = localStorage.getItem('cc_selected_member');
        let SELECTED_MEMBER = (_stored_selected && _stored_selected !== 'null') ? _stored_selected : (DEFAULT_MEMBER ? String(DEFAULT_MEMBER) : (MEMBERS.length? String(MEMBERS[0].id) : null));
        // If not a Team plan, disable member selection and clear stored preference
        if (!IS_TEAM){
            SELECTED_MEMBER = null;
            try{ localStorage.removeItem('cc_selected_member'); }catch(e){}
        }
        // Visible services after filtering by selected member
        let VISIBLE_SERVICES = [];

        function ccPromptOverridesUpgrade() {
            try {
                const modal = document.getElementById('ccOverridesUpgradeModal');
                const cancelBtn = document.getElementById('ccOverridesUpgradeCancelBtn');
                const goBtn = document.getElementById('ccOverridesUpgradeGoBtn');

                // Fallback if the modal HTML isn't present for some reason
                if (!modal || !cancelBtn || !goBtn) {
                    const msg = 'A higher subscription plan is required to override days.';
                    const go = confirm(msg + "\n\nPress OK to view pricing, or Cancel to stay on the calendar.");
                    if (go) {
                        try { window.location.href = PRICING_URL; } catch (e) {}
                    }
                    return false;
                }

                // Show
                modal.style.display = 'flex';

                let cleaned = false;
                function cleanup() {
                    if (cleaned) return;
                    cleaned = true;
                    try { cancelBtn.onclick = null; } catch (e) {}
                    try { goBtn.onclick = null; } catch (e) {}
                    try { modal.onclick = null; } catch (e) {}
                    try { document.removeEventListener('keydown', onKey); } catch (e) {}
                }
                function close() {
                    try { modal.style.display = 'none'; } catch (e) {}
                    cleanup();
                }
                function onKey(e) {
                    try {
                        if (e && e.key === 'Escape') close();
                    } catch (err) {}
                }

                cancelBtn.onclick = (e) => {
                    try { e.preventDefault(); } catch (err) {}
                    close();
                };
                goBtn.onclick = (e) => {
                    try { e.preventDefault(); } catch (err) {}
                    try { window.location.href = PRICING_URL; } catch (err) {}
                };
                // Click outside the dialog -> cancel
                modal.onclick = (e) => {
                    try {
                        if (e && e.target === modal) close();
                    } catch (err) {}
                };
                try { document.addEventListener('keydown', onKey); } catch (e) {}
            } catch (e) {
                const msg = 'A higher subscription plan is required to override days.';
                const go = confirm(msg + "\n\nPress OK to view pricing, or Cancel to stay on the calendar.");
                if (go) {
                    try { window.location.href = PRICING_URL; } catch (err) {}
                }
            }
            return false;
        }

        // Hard-stop any background/legacy flows that try to hit the per-date override endpoints
        // when the plan doesn't allow it, and show the upgrade prompt instead.
        (function ccGuardOverrideEndpoints(){
            if (CAN_USE_OVERRIDES) return;
            try {
                const _fetch = window.fetch;
                if (typeof _fetch !== 'function') return;
                window.fetch = function(input, init){
                    try {
                        const url = (typeof input === 'string') ? input : (input && input.url ? input.url : '');
                        if (url && (url.includes(`/bus/${orgSlug}/bookings/batch_create/`) || url.includes(`/bus/${orgSlug}/bookings/batch_delete/`))) {
                            ccPromptOverridesUpgrade();
                            return Promise.reject(new Error('Per-date overrides are locked by plan'));
                        }
                    } catch (e) {}
                    return _fetch.apply(this, arguments);
                };
            } catch (e) {}
        })();

        function ccEnforceOverridesLock() {
            if (CAN_USE_OVERRIDES) return;
            // Keep the section visible but greyed out.
            const oc = document.getElementById('overridesContainer');
            if (oc) {
                try { oc.classList.add('cc-overrides-disabled'); } catch (e) {}
                // Intercept attempts from within the overrides section (any click).
                // The overlay + pointer-events CSS blocks interaction; this click handler provides the prompt.
                try {
                    oc.addEventListener('click', (evt) => {
                        evt.preventDefault();
                        evt.stopPropagation();
                        ccPromptOverridesUpgrade();
                    }, true);
                } catch (e) {}
            }
        }
        try { ccEnforceOverridesLock(); } catch(e) {}

        // Keep service-scope month visuals in sync immediately after per-date override changes.
        // This fixes cases where overrides apply server-side (public page correct) but the
        // internal calendar stays visually stale due to parity caching.
        (function ccHookOverrideMutations(){
            try {
                const _fetch = window.fetch;
                if (typeof _fetch !== 'function') return;
                // Avoid double-wrapping
                if (window.__ccOverrideMutationHookInstalled) return;
                window.__ccOverrideMutationHookInstalled = true;

                window.fetch = function(input, init){
                    let url = '';
                    try {
                        url = (typeof input === 'string') ? input : (input && input.url ? input.url : '');
                    } catch (e) { url = ''; }

                    const isOverrideMutation = !!(url && (url.includes(`/bus/${orgSlug}/bookings/batch_create/`) || url.includes(`/bus/${orgSlug}/bookings/batch_delete/`)));
                    const p = _fetch.apply(this, arguments);
                    if (!isOverrideMutation || !p || typeof p.then !== 'function') return p;

                    return p.then((res) => {
                        try {
                            if (res && res.ok) {
                                try { if (typeof _invalidateServiceScopeParityCache === 'function') _invalidateServiceScopeParityCache(); } catch (e) {}
                                // Refresh day styles + table on the next tick (after any refetchEvents).
                                try {
                                    setTimeout(() => {
                                        try { updateUnavailableDays(); } catch (e) {}
                                        try { renderOverridesTable(); } catch (e) {}
                                    }, 0);
                                } catch (e) {}
                            }
                        } catch (e) {}
                        return res;
                    });
                };
            } catch (e) { /* ignore */ }
        })();

        // Ensure each service has a weekly_map array (server should provide this, but keep a defensive fallback).
        try{
            if (Array.isArray(SERVICES)){
                for (const s of SERVICES){
                    try{
                        if (!s.weekly_map || !Array.isArray(s.weekly_map) || s.weekly_map.length !== 7){
                            s.weekly_map = makeAllUnavailablePayload().map(row => row.ranges || []);
                        }
                    }catch(e){}
                }
            }
        }catch(e){}

        function getAssignedMembersForService(serviceObj) {
            try {
                const assigned = (serviceObj && Array.isArray(serviceObj.assigned_members)) ? serviceObj.assigned_members : [];
                return assigned.map(String);
            } catch (e) {
                return [];
            }
        }

        function isSingleAssigneeService(serviceObj) {
            try {
                return getAssignedMembersForService(serviceObj).length === 1;
            } catch (e) {
                return false;
            }
        }

        function _soloServicesForMember(membershipId) {
            try {
                const idStr = String(membershipId);
                if (!idStr) return [];
                if (!Array.isArray(SERVICES)) return [];
                return SERVICES.filter(s => {
                    try {
                        const assigned = getAssignedMembersForService(s);
                        return assigned.length === 1 && String(assigned[0]) === idStr;
                    } catch (e) {
                        return false;
                    }
                });
            } catch (e) {
                return [];
            }
        }

        function _mergedSoloServiceIdForMemberScope(membershipId) {
            try {
                if (!membershipId) return null;
                const solo = _soloServicesForMember(membershipId);
                if (solo.length !== 1) return null;
                const svc = solo[0];
                const id = (svc && (svc.id != null)) ? svc.id : null;
                return id != null ? String(id) : null;
            } catch (e) {
                return null;
            }
        }

        function getSelectedUserIdForMembership(membershipId) {
            try {
                const m = MEMBERS.find(mm => String(mm.id) === String(membershipId));
                if (!m) return null;
                const uid = (m.user__id || m.user_id || (m.user && (m.user.id || m.user.pk)) || null);
                return uid ? Number(uid) : null;
            } catch (e) {
                return null;
            }
        }

        function getScopePropsForSelection(selection) {
            try {
                if (!selection) return {};
                if (String(selection).startsWith('svc:')) {
                    return { assigned_scope_service_id: Number(String(selection).slice(4)) };
                }
                // membership selection: use assigned_user_id (user id) to match server event feed,
                // but keep membership id as well for debugging/traceability.
                const userId = getSelectedUserIdForMembership(selection);
                const props = { assigned_membership_id: Number(selection) };
                if (userId) props.assigned_user_id = Number(userId);
                return props;
            } catch (e) {
                return {};
            }
        }

        function purgeOptimisticPerDateEvents() {
            try {
                if (!calendar || typeof calendar.getEvents !== 'function') return;
                calendar.getEvents().forEach(ev => {
                    try {
                        const xp = ev.extendedProps || {};
                        if (ev.display === 'background' && xp.is_per_date && xp.optimistic) {
                            ev.remove();
                        }
                    } catch (e) { /* ignore */ }
                });
            } catch (e) { /* ignore */ }
        }

        function _minutesFromTimeStr(t) {
            try {
                const s = String(t || '').trim();
                const parts = s.split(':');
                const hh = parseInt(parts[0] || '0', 10) || 0;
                const mm = parseInt(parts[1] || '0', 10) || 0;
                return (hh * 60) + mm;
            } catch (e) {
                return 0;
            }
        }

        function _timeStrFromMinutes(mins) {
            try {
                const m = Math.max(0, Math.min(24 * 60, Number(mins) || 0));
                const hh = Math.floor(m / 60);
                const mm = m % 60;
                const ampm = hh >= 12 ? 'PM' : 'AM';
                let h12 = hh % 12;
                if (h12 === 0) h12 = 12;
                return `${h12}:${String(mm).padStart(2, '0')} ${ampm}`;
            } catch (e) {
                return '';
            }
        }

        function _getDayBoundsLocal(dateStr) {
            const d = parseYMD(dateStr);
            const start = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0, 0, 0, 0);
            const end = new Date(d.getFullYear(), d.getMonth(), d.getDate() + 1, 0, 0, 0, 0);
            return [start, end];
        }

        function _isRealBookingEvent(ev) {
            try {
                const xp = ev.extendedProps || {};
                if (xp.is_blocking || xp.is_per_date || ev.display === 'background') return false;
                return true;
            } catch (e) {
                return false;
            }
        }

        function _isBookingInSelectedScope(ev) {
            try {
                if (!SELECTED_MEMBER) return true;
                const xp = ev.extendedProps || {};

                // Service-scoped selection: only consider bookings for that service
                if (String(SELECTED_MEMBER).startsWith('svc:')) {
                    const svcId = String(SELECTED_MEMBER).slice(4);
                    const bookingSvc = (xp.service_id || xp.service || ev.service_id || null);
                    if (!bookingSvc) return true; // conservative if id is missing
                    return String(bookingSvc) === String(svcId);
                }

                // Member-scoped selection:
                // Only merge bookings into the member view when that member has EXACTLY ONE
                // solo-hosted service assigned. Otherwise, member availability remains flexible
                // and should not be blocked by service bookings.
                const mergedSvcId = _mergedSoloServiceIdForMemberScope(SELECTED_MEMBER);
                if (!mergedSvcId) return false;

                const bookingSvc = (xp.service_id || xp.service || ev.service_id || null);
                if (!bookingSvc) return false;
                return String(bookingSvc) === String(mergedSvcId);
            } catch (e) {
                return true;
            }
        }

        function _getBookingsForDateInScope(dateStr) {
            const out = [];
            if (!calendar || typeof calendar.getEvents !== 'function') return out;
            const [dayStart, dayEnd] = _getDayBoundsLocal(dateStr);

            let events = [];
            try { events = calendar.getEvents() || []; } catch (e) { events = []; }

            for (const ev of events) {
                try {
                    if (!_isRealBookingEvent(ev)) continue;
                    if (!_isBookingInSelectedScope(ev)) continue;
                    const s = ev.start || null;
                    const e = ev.end || null;
                    if (!s) continue;
                    const end = e || s;
                    const overlaps = (s < dayEnd) && (end > dayStart);
                    if (!overlaps) continue;
                    out.push(ev);
                } catch (e) { /* ignore */ }
            }

            try { out.sort((a,b) => (a.start?.getTime()||0) - (b.start?.getTime()||0)); } catch (e) {}
            return out;
        }

        function _weeklyDefaultRangesForDate(dateStr) {
            try {
                const d = parseYMD(dateStr);
                const dow = d.getDay();
                const info = defaultAvailability[dow] || {};
                const ranges = info.ranges && info.ranges.length ? info.ranges : (info.start && info.end ? [`${info.start}-${info.end}`] : []);
                if (!ranges || !ranges.length) return [];
                return ranges.map(r => {
                    const parts = String(r || '').split('-');
                    return { start: (parts[0] || '00:00').trim(), end: (parts[1] || '00:00').trim() };
                }).filter(r => r.start && r.end && r.start < r.end);
            } catch (e) {
                return [];
            }
        }

        function _validateOverrideAgainstBookings(dateStr, rangesOrNull) {
            const bookings = _getBookingsForDateInScope(dateStr);
            if (!bookings.length) return { ok: true };

            // Full-day unavailable (blocking): any booking blocks this action
            if (!rangesOrNull || !Array.isArray(rangesOrNull) || rangesOrNull.length === 0) {
                const first = bookings[0];
                const s = first.start;
                const e = first.end || first.start;
                const msg = `Can’t block ${dateStr} because there’s already a booking (${s ? s.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}) : '—'}${e ? ' - ' + e.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}) : ''}).`;
                return { ok: false, message: msg };
            }

            const parsedRanges = [];
            for (const r of rangesOrNull) {
                try {
                    const start = _minutesFromTimeStr(r.start);
                    const end = _minutesFromTimeStr(r.end);
                    if (start < end) parsedRanges.push({ start, end });
                } catch (e) {}
            }
            if (!parsedRanges.length) {
                return _validateOverrideAgainstBookings(dateStr, null);
            }

            const [dayStart] = _getDayBoundsLocal(dateStr);
            for (const b of bookings) {
                try {
                    const bs = b.start;
                    const be = b.end || b.start;
                    if (!bs) continue;
                    const startMin = Math.max(0, Math.floor((bs.getTime() - dayStart.getTime()) / 60000));
                    const endMin = Math.min(24 * 60, Math.ceil((be.getTime() - dayStart.getTime()) / 60000));

                    const covered = parsedRanges.some(r => r.start <= startMin && endMin <= r.end);
                    if (!covered) {
                        const msg = `Can’t save availability for ${dateStr}. A booking (${_timeStrFromMinutes(startMin)} - ${_timeStrFromMinutes(endMin)}) would fall outside the new override ranges.`;
                        return { ok: false, message: msg };
                    }
                } catch (e) { /* ignore */ }
            }

            return { ok: true };
        }

        // Helper: return a human-friendly label for the current selection (member or service)
        function getSelectionLabel() {
            try {
                if (!SELECTED_MEMBER) return 'organization defaults';
                if (String(SELECTED_MEMBER).startsWith('svc:')) {
                    const svcId = String(SELECTED_MEMBER).slice(4);
                    const svc = SERVICES.find(s => String(s.id) === String(svcId));
                    const svcLabel = svc ? (svc.name || svc.title || `Service ${svcId}`) : `Service ${svcId}`;
                    try {
                        if (svc) {
                            const assigned = getAssignedMembersForService(svc) || [];
                            if (assigned.length === 1) {
                                const m = MEMBERS.find(mm => String(mm.id) === String(assigned[0]));
                                const mLabel = m ? memberDisplayName(m) : 'Member';
                                return `${mLabel} - ${svcLabel}`;
                            }
                        }
                    } catch (e) { /* ignore */ }
                    return svcLabel;
                }
                const m = MEMBERS.find(mm => String(mm.id) === String(SELECTED_MEMBER));
                if (!m) return 'selected member';
                const fname = (m.user__first_name || m.first_name || (m.user && (m.user.first_name || m.user.firstName)) || '');
                const lname = (m.user__last_name || m.last_name || (m.user && (m.user.last_name || m.user.lastName)) || '');
                const email = (m.user__email || m.email || (m.user && m.user.email) || '');
                const display = (m.display_name || m.profile_display_name || m.name || '').trim();
                const full = ((fname || lname) ? `${(fname||'').trim()} ${(lname||'').trim()}`.trim() : (email || display || 'member'));
                if (display && display.length && display.toLowerCase() !== full.toLowerCase()) return `${full} (${display})`;
                return full;
            } catch (e) { return 'selected member'; }
        }

        function updateVisibleServices(){
            if (!SELECTED_MEMBER){
                VISIBLE_SERVICES = SERVICES.slice();
                return;
            }
            // If a service option is selected (prefixed with 'svc:'), show only that service
            try{
                if (String(SELECTED_MEMBER).startsWith('svc:')){
                    const svcId = String(SELECTED_MEMBER).slice(4);
                    VISIBLE_SERVICES = SERVICES.filter(s => String(s.id) === svcId);
                    return;
                }
            }catch(e){ /* fall back to member filtering */ }

            VISIBLE_SERVICES = SERVICES.filter(s => {
                try{
                    const assigned = getAssignedMembersForService(s);
                    if (assigned.length === 0) return false; // hide unassigned services when a member is selected
                    return assigned.indexOf(String(SELECTED_MEMBER)) !== -1;
                }catch(e){ return false; }
            });
        }

        function svcById(svcId){
            const idStr = String(svcId);
            let found = VISIBLE_SERVICES.find(s => String(s.id) === idStr);
            if (!found) found = SERVICES.find(s => String(s.id) === idStr);
            return found || null;
        }

        // Initialize visible services
        updateVisibleServices();

        // Wire member selector when present
        try{
            const sel = document.getElementById('memberSelect');
            if (sel) {
                function selectDefaultAvailabilityFor(selection){
                    try{
                        if (selection && String(selection).startsWith('svc:')){
                            const svcId = String(selection).slice(4);
                            const svc = SERVICES.find(s=>String(s.id)===svcId) || null;
                            if (svc && svc.weekly_map) {
                                const src = svc.weekly_map;
                                const built = buildAvailabilityFromPayload(src);
                                for (const k of Object.keys(built)) defaultAvailability[k] = built[k];
                                return;
                            }
                        }
                        // Default membership-specific availability
                        if (selection && memberDefaultAvailability[String(selection)]){
                            const src = memberDefaultAvailability[String(selection)];
                            for (const k of Object.keys(src)) defaultAvailability[k] = JSON.parse(JSON.stringify(src[k]));
                        } else {
                            // fallback to org defaults
                            for (const k of Object.keys(orgDefaultAvailability)) defaultAvailability[k] = JSON.parse(JSON.stringify(orgDefaultAvailability[k]));
                        }
                    }catch(e){ console.warn('selectDefaultAvailabilityFor error', e); }
                }

                    function updateSelectionBadge(selection){
                        try{
                            const badge = document.getElementById('memberScopeBadge');
                            if (!badge) return;
                            if (selection && String(selection).startsWith('svc:')){
                                const svcId = String(selection).slice(4);
                                const svc = SERVICES.find(s=>String(s.id)===svcId) || null;
                                const hasAnyRanges = !!(svc && Array.isArray(svc.weekly_map) && svc.weekly_map.some(day => Array.isArray(day) && day.length > 0));
                                if (hasAnyRanges && svc && (svc.has_service_weekly_windows || false)){
                                    badge.textContent = 'Service-specific availability';
                                    badge.style.borderColor = 'rgba(16,185,129,0.15)';
                                    badge.style.background = 'rgba(16,185,129,0.06)';
                                    badge.style.color = 'var(--success-600)';
                                    return;
                                }
                            }
                            if (selection && memberAvailMap && memberAvailMap[String(selection)]){
                                badge.textContent = 'Member-specific availability';
                                badge.style.borderColor = 'rgba(59,130,246,0.15)';
                                badge.style.background = 'rgba(59,130,246,0.06)';
                                badge.style.color = 'var(--primary-600)';
                                return;
                            }
                            // default
                            badge.textContent = 'Showing org defaults';
                            badge.style.borderColor = 'var(--gray-200)';
                            badge.style.background = 'transparent';
                            badge.style.color = 'var(--gray-600)';
                        }catch(e){ /* ignore */ }
                    }

                    function updateInterchangeLink(selection){
                        try{
                            const btn = document.getElementById('cc-open-edit-service-from-calendar');
                            const note = document.getElementById('cc-weekly-interchange-note');
                            if (!btn || !note) return;

                            if (selection && String(selection).startsWith('svc:')){
                                const svcId = String(selection).slice(4);
                                const url = String(EDIT_SERVICE_URL_TEMPLATE).replace('/0/edit/', '/' + svcId + '/edit/');
                                btn.setAttribute('href', url);
                                btn.style.display = 'inline-flex';
                                note.textContent = 'These weekly service availability settings are interchangeable with the Edit Service page. You can update them in either place.';
                                return;
                            }

                            btn.style.display = 'none';
                            btn.setAttribute('href', '#');
                            note.textContent = 'Tip: When you select a service scope, this weekly schedule is interchangeable with that service’s availability on the Edit Service page.';
                        }catch(e){ /* ignore */ }
                    }

                // Explicit apply flow: changing the select only stages a pending selection.
                let pendingSelection = SELECTED_MEMBER;

                // Initialize the Calendar <-> Edit Service cross-link based on the current scope.
                try { updateInterchangeLink(SELECTED_MEMBER); } catch(e){}

                function applySelection(selection){
                    try{
                        SELECTED_MEMBER = selection || null;
                        if (SELECTED_MEMBER) localStorage.setItem('cc_selected_member', SELECTED_MEMBER);
                        else localStorage.removeItem('cc_selected_member');

                        // Prevent optimistic per-date overrides from "carrying over" when switching
                        // member/service: clear any locally added background events.
                        try { purgeOptimisticPerDateEvents(); } catch (e) {}

                        updateVisibleServices();
                        try { selectDefaultAvailabilityFor(SELECTED_MEMBER); } catch(e){}
                        try { updateSelectionBadge(SELECTED_MEMBER); } catch(e){}
                        try { updateInterchangeLink(SELECTED_MEMBER); } catch(e){}
                        try { calendar && calendar.refetchEvents(); } catch(e){}
                        try { displayDefaultAvailability(); } catch(e){}
                        try { syncAvailabilityToCalendar(); } catch(e){}
                        try { if (typeof updateBookingsViewAllLink === 'function') updateBookingsViewAllLink(); } catch(e){}
                        try { if (typeof filterInlineAuditBySelection === 'function') filterInlineAuditBySelection(); } catch(e){}

                        // Update scope menu button label (new UI)
                        try {
                            const lbl = document.getElementById('ccScopeMenuButtonLabel');
                            if (lbl) lbl.textContent = getSelectionLabel();
                        } catch (e) {}
                    }catch(e){ console.warn('applySelection failed', e); }
                }

                // ---- New nested menu wiring ----
                function memberDisplayName(m){
                    try {
                        const fname = (m.user__first_name || '').trim();
                        const lname = (m.user__last_name || '').trim();
                        const email = (m.user__email || '').trim();
                        const base = ((fname || lname) ? `${fname} ${lname}`.trim() : (email || 'Member'));
                        return base;
                    } catch (e) { return 'Member'; }
                }

                function personalServicesForMember(mid){
                    try {
                        const idStr = String(mid);
                        return SERVICES.filter(s => {
                            const assigned = getAssignedMembersForService(s);
                            return assigned.length === 1 && String(assigned[0]) === idStr;
                        });
                    } catch (e) { return []; }
                }

                function closeScopeMenus(){
                    try{ const m = document.getElementById('ccScopeMenu'); if (m) m.style.display = 'none'; }catch(e){}
                    try{ const sm = document.getElementById('ccScopeSubmenu'); if (sm) sm.style.display = 'none'; }catch(e){}
                }

                function openScopeMenu(){
                    try{ const m = document.getElementById('ccScopeMenu'); if (m) m.style.display = 'block'; }catch(e){}
                }

                function openSubmenuForMember(mid){
                    const sm = document.getElementById('ccScopeSubmenu');
                    const inner = document.getElementById('ccScopeSubmenuInner');
                    if (!sm || !inner) return;
                    inner.innerHTML = '';

                    const header = document.createElement('div');
                    header.style.padding = '10px 12px';
                    header.style.borderBottom = '1px solid var(--gray-100)';
                    header.style.fontWeight = '700';
                    header.style.fontSize = '12px';
                    header.style.color = 'var(--gray-700)';
                    header.style.textTransform = 'uppercase';
                    header.style.letterSpacing = '0.5px';
                    const m = MEMBERS.find(mm => String(mm.id) === String(mid));
                    header.textContent = m ? memberDisplayName(m) : 'Member';
                    inner.appendChild(header);

                    const memberItem = document.createElement('button');
                    memberItem.type = 'button';
                    memberItem.textContent = 'View member availability';
                    memberItem.style.display = 'block';
                    memberItem.style.width = '100%';
                    memberItem.style.textAlign = 'left';
                    memberItem.style.padding = '10px 12px';
                    memberItem.style.border = 'none';
                    memberItem.style.background = 'transparent';
                    memberItem.style.cursor = 'pointer';
                    memberItem.addEventListener('click', function(){
                        closeScopeMenus();
                        pendingSelection = String(mid);
                        applySelection(pendingSelection);
                    });
                    inner.appendChild(memberItem);

                    const divider = document.createElement('div');
                    divider.style.height = '1px';
                    divider.style.background = 'var(--gray-100)';
                    inner.appendChild(divider);

                    const svcHeader = document.createElement('div');
                    svcHeader.style.padding = '10px 12px 6px 12px';
                    svcHeader.style.fontWeight = '700';
                    svcHeader.style.fontSize = '12px';
                    svcHeader.style.color = 'var(--gray-700)';
                    svcHeader.style.textTransform = 'uppercase';
                    svcHeader.style.letterSpacing = '0.5px';
                    svcHeader.textContent = 'Personal services';
                    inner.appendChild(svcHeader);

                    const services = personalServicesForMember(mid);
                    if (!services.length){
                        const empty = document.createElement('div');
                        empty.style.padding = '8px 12px 12px 12px';
                        empty.style.color = 'var(--gray-600)';
                        empty.style.fontSize = '13px';
                        empty.textContent = 'No personal services.';
                        inner.appendChild(empty);
                    } else {
                        for (const s of services){
                            const btn = document.createElement('button');
                            btn.type = 'button';
                            btn.textContent = s.name || ('Service ' + String(s.id));
                            btn.style.display = 'block';
                            btn.style.width = '100%';
                            btn.style.textAlign = 'left';
                            btn.style.padding = '10px 12px';
                            btn.style.border = 'none';
                            btn.style.background = 'transparent';
                            btn.style.cursor = 'pointer';
                            btn.addEventListener('click', function(){
                                closeScopeMenus();
                                pendingSelection = 'svc:' + String(s.id);
                                applySelection(pendingSelection);
                            });
                            inner.appendChild(btn);
                        }
                    }

                    sm.style.display = 'block';
                }

                function buildScopeMenu(){
                    const root = document.getElementById('ccScopeMenuRoot');
                    const btn = document.getElementById('ccScopeMenuButton');
                    const menu = document.getElementById('ccScopeMenu');
                    const list = document.getElementById('ccScopeMenuMembers');
                    if (!root || !btn || !menu || !list) return;

                    list.innerHTML = '';
                    for (const m of MEMBERS){
                        const row = document.createElement('div');
                        row.style.display = 'flex';
                        row.style.alignItems = 'center';
                        row.style.justifyContent = 'space-between';
                        row.style.gap = '10px';
                        row.style.padding = '10px 12px';
                        row.style.cursor = 'pointer';

                        const left = document.createElement('div');
                        left.style.flex = '1 1 auto';
                        left.style.whiteSpace = 'nowrap';
                        left.style.overflow = 'hidden';
                        left.style.textOverflow = 'ellipsis';
                        left.textContent = memberDisplayName(m);

                        const right = document.createElement('div');
                        right.style.flex = '0 0 auto';
                        right.style.color = 'var(--gray-600)';
                        right.style.fontSize = '16px';
                        right.textContent = '›';

                        row.appendChild(left);
                        row.appendChild(right);

                        row.addEventListener('mouseenter', function(){
                            try{ openSubmenuForMember(m.id); }catch(e){}
                        });
                        row.addEventListener('click', function(){
                            try{ openSubmenuForMember(m.id); }catch(e){}
                        });

                        list.appendChild(row);
                    }

                    // ---- Service scopes (below members) ----
                    function hideSubmenu(){
                        try{
                            const sm = document.getElementById('ccScopeSubmenu');
                            if (sm) sm.style.display = 'none';
                        }catch(e){}
                    }

                    function addDivider(){
                        const divider = document.createElement('div');
                        divider.style.height = '1px';
                        divider.style.background = 'var(--gray-100)';
                        list.appendChild(divider);
                    }

                    function addSectionHeader(text){
                        const h = document.createElement('div');
                        h.style.padding = '10px 12px 6px 12px';
                        h.style.fontWeight = '700';
                        h.style.fontSize = '12px';
                        h.style.color = 'var(--gray-700)';
                        h.style.textTransform = 'uppercase';
                        h.style.letterSpacing = '0.5px';
                        h.textContent = text;
                        list.appendChild(h);
                    }

                    function addEmptyRow(text){
                        const empty = document.createElement('div');
                        empty.style.padding = '8px 12px 12px 12px';
                        empty.style.color = 'var(--gray-600)';
                        empty.style.fontSize = '13px';
                        empty.textContent = text;
                        list.appendChild(empty);
                    }

                    function addServiceRow(service, badgeText){
                        const row = document.createElement('div');
                        row.style.display = 'flex';
                        row.style.alignItems = 'center';
                        row.style.justifyContent = 'space-between';
                        row.style.gap = '10px';
                        row.style.padding = '10px 12px';
                        row.style.cursor = 'pointer';

                        const left = document.createElement('div');
                        left.style.flex = '1 1 auto';
                        left.style.whiteSpace = 'nowrap';
                        left.style.overflow = 'hidden';
                        left.style.textOverflow = 'ellipsis';
                        left.textContent = service.name || ('Service ' + String(service.id));

                        const right = document.createElement('div');
                        right.style.flex = '0 0 auto';
                        right.style.color = 'var(--gray-600)';
                        right.style.fontSize = '12px';
                        right.textContent = badgeText || '';

                        row.appendChild(left);
                        row.appendChild(right);

                        row.addEventListener('mouseenter', function(){
                            hideSubmenu();
                        });
                        row.addEventListener('click', function(){
                            hideSubmenu();
                            closeScopeMenus();
                            pendingSelection = 'svc:' + String(service.id);
                            applySelection(pendingSelection);
                        });

                        list.appendChild(row);
                    }

                    // Below the members list, show ONLY:
                    // - Unassigned services (0 assignees)
                    // - Group services (2+ assignees)
                    // Solo (1-assignee) services stay in each member's submenu only.
                    let unassigned = [];
                    let shared = [];
                    try{
                        for (const s of SERVICES){
                            const assigned = getAssignedMembersForService(s) || [];
                            if (assigned.length === 0) unassigned.push(s);
                            else if (assigned.length >= 2) shared.push(s);
                        }
                    }catch(e){ unassigned = []; shared = []; }

                    addDivider();
                    addSectionHeader('Unassigned services');
                    if (!unassigned.length) addEmptyRow('No unassigned services.');
                    else {
                        unassigned.sort((a,b)=>String(a.name||'').localeCompare(String(b.name||'')));
                        for (const s of unassigned) addServiceRow(s, 'Unassigned');
                    }

                    addDivider();
                    addSectionHeader('Group services');
                    if (!shared.length) addEmptyRow('No group services.');
                    else {
                        shared.sort((a,b)=>String(a.name||'').localeCompare(String(b.name||'')));
                        for (const s of shared){
                            let badge = '';
                            try { badge = String((getAssignedMembersForService(s)||[]).length) + ' members'; } catch(e) { badge = 'Group'; }
                            addServiceRow(s, badge);
                        }
                    }

                    btn.addEventListener('click', function(e){
                        e.preventDefault();
                        e.stopPropagation();
                        const isOpen = menu.style.display === 'block';
                        if (isOpen){ closeScopeMenus(); }
                        else { openScopeMenu(); }
                    });

                    document.addEventListener('click', function(ev){
                        try{
                            if (!root.contains(ev.target)) closeScopeMenus();
                        }catch(e){}
                    });
                }

                // Initialize defaultAvailability for the current selection by applying it once
                try { applySelection(SELECTED_MEMBER); } catch(e){}
                try { buildScopeMenu(); } catch(e){}
                try {
                    const lbl = document.getElementById('ccScopeMenuButtonLabel');
                    if (lbl) lbl.textContent = getSelectionLabel();
                } catch (e) {}
            }
        }catch(e){ console.warn('member selector wiring failed', e); }
    const AUTO_OPEN_SERVICE = "{{ auto_open_service|default:'' }}";
    const AUTO_OPEN_DATE = "{{ auto_open_date|default:'' }}";
     
                if (!calendarEl) return;

    let selectedDates = new Set();
    let isDragging = false;
    let dragStartDate = null;
    let dragMode = null;
    let dragStartIsUnavailable = false;

    let calendar = null;
        try {
        calendar = new FullCalendar.Calendar(calendarEl, {
        initialView: 'dayGridMonth',
        height: 'auto',
        selectable: false, // disable default selection highlight
        editable: false,
        events: function(fetchInfo, successCallback, failureCallback) {
            // Fetch events from server then filter by VISIBLE_SERVICES
            const params = new URLSearchParams();
            if (fetchInfo && fetchInfo.startStr) params.set('start', fetchInfo.startStr);
            if (fetchInfo && fetchInfo.endStr) params.set('end', fetchInfo.endStr);
            const url = `/bus/${orgSlug}/events/?` + params.toString();
            fetch(url, { credentials: 'same-origin' }).then(r => r.json()).then(data => {
                try{
                    const items = Array.isArray(data) ? data : (data.events || []);
                    // build allowed service id set from VISIBLE_SERVICES
                    const allowed = new Set((VISIBLE_SERVICES||[]).map(s=>String(s.id)));
                    // Map membership id -> user id (if provided in MEMBERS payload)
                    const MEMBER_TO_USER = {};
                    try{ MEMBERS.forEach(m => { MEMBER_TO_USER[String(m.id)] = (m.user__id || m.user_id || (m.user && (m.user.id || m.user.pk)) || null); }); }catch(e){}

                    const filtered = items.filter(ev => {
                        try{
                            const ext = (ev.extendedProps || {});
                            // If this is a per-date override, allow it when it matches the selected scope
                            if (ext.is_per_date) {
                                // No selection -> show all per-date overrides
                                if (!SELECTED_MEMBER) return true;
                                // Service-scoped selection (values like 'svc:123') -> match assigned_scope_service_id
                                if (String(SELECTED_MEMBER).startsWith('svc:')){
                                    const svcId = String(SELECTED_MEMBER).slice(4);
                                    const assignedSvc = (ext.assigned_scope_service_id || ext.assigned_scope_service || (ev.client_name && ev.client_name.replace && ev.client_name.replace('scope:svc:','')) || null);
                                    if (assignedSvc && String(assignedSvc) === svcId) return true;
                                    return false;
                                }
                                // Membership selection -> compare assigned_user_id (map membership->user id when needed)
                                const mUser = MEMBER_TO_USER[String(SELECTED_MEMBER)] || null;
                                const assignedUserId = ext.assigned_user_id || ev.assigned_user_id || null;
                                if (assignedUserId && String(assignedUserId) === String(mUser)) return true;
                                return false;
                            }

                            // Non per-date events: match by visible service ids or slug/name fallback
                            const svcId = (ev.service_id || ext.service_id || ext.service || null);
                            if (svcId && allowed.has(String(svcId))) return true;
                            const slug = (ev.service_slug || ext.service_slug || ev.title || ev.service || null);
                            if (slug) {
                                for (const s of VISIBLE_SERVICES) {
                                    if (String(s.slug) === String(slug) || String(s.name) === String(slug)) return true;
                                }
                            }
                        }catch(e){/* ignore */}
                        return false;
                    });
                    successCallback(filtered);
                }catch(e){ successCallback([]); }
            }).catch(err => { failureCallback(err); });
        },
        headerToolbar: { left: 'prev', center: 'title', right: 'next' },
        showNonCurrentDates: false,
        dayMaxEvents: true,
        eventsSet: function(events) {
            // After events load/refetch, recompute override/past/unavailable visuals & table
            try { updateUnavailableDays(); } catch(e) { console.warn('eventsSet updateUnavailableDays failed', e); }
            try { if (typeof renderOverridesTable === 'function') renderOverridesTable(); } catch(e) { console.warn('eventsSet renderOverridesTable failed', e); }
            try { styleOverridesTable(); } catch(e) { /* ignore */ }
            try { if (typeof renderInlineBookings === 'function') renderInlineBookings(); } catch(e) { console.warn('eventsSet renderInlineBookings failed', e); }
            try {
                const selSpan = document.getElementById('overridesHeaderSelection');
                const monthSpan = document.getElementById('overridesHeaderMonth');
                if (monthSpan && calendar) {
                    const currentDate = calendar.getDate ? calendar.getDate() : new Date();
                    const monthName = currentDate.toLocaleString('default', { month: 'long' });
                    monthSpan.textContent = monthName;
                    if (selSpan) selSpan.textContent = getSelectionLabel();
                }
            } catch (e) { /* ignore */ }
        },

         // Handle selection in timeGridDay view
        select: function(info) {
            if (calendar.view.type === 'timeGridDay') {
                handleTimeSlotSelection(info);
            }
        },

        // View changed (month navigated). Recompute day visuals and trim trailing weeks.
        datesSet: function() {
            try { updateUnavailableDays(); } catch(e) { console.warn('datesSet updateUnavailableDays failed', e); }
            try { hideTrailingOtherRows(); } catch (e) { /* ignore */ }
        }
        });
    } catch (err) {
        console.error('FullCalendar initialization failed', err);
        calendarEl.innerHTML = '<div style="color:#721c24;background:#f8d7da;border:1px solid #f5c6cb;padding:12px;border-radius:6px;">Calendar failed to initialize. Check browser console for errors (see server console too).</div>';
        return; // abort further calendar-related setup to avoid runtime errors
    }

    // Render the calendar so DOM/date cells exist for later manipulation
    try { calendar.render(); } catch (e) { console.warn('calendar.render failed', e); }

        // If the admin requested opening the Day Schedule for a service, compute the
        // soonest date with default weekly availability for that service and open the modal.
        (function(){
            try {
                if (!AUTO_OPEN_SERVICE) return;
                // AUTO_OPEN_SERVICE may be an id (numeric). Find service by id.
                const svcId = Number(AUTO_OPEN_SERVICE) || null;
                const svc = svcById(svcId);
                if (!svc) return;

                // Starting date: prefer AUTO_OPEN_DATE, fall back to today
                let start = null;
                if (AUTO_OPEN_DATE && AUTO_OPEN_DATE.match(/^\d{4}-\d{2}-\d{2}$/)) {
                    start = new Date(AUTO_OPEN_DATE + 'T00:00:00');
                } else {
                    const t = new Date();
                    start = new Date(t.getFullYear(), t.getMonth(), t.getDate());
                }

                // Search forward up to 365 days for the first weekday that has any default ranges
                let foundDate = null;
                for (let i = 0; i < 365; i++) {
                    const candidate = new Date(start);
                    candidate.setDate(start.getDate() + i);
                    const dow = candidate.getDay(); // 0=Sunday..6=Saturday
                    const weekly = (svc.weekly_map && Array.isArray(svc.weekly_map)) ? svc.weekly_map : [];
                    const ranges = weekly[dow] || [];
                    if (ranges && ranges.length > 0) {
                        // Ensure not a past date
                        const iso = candidate.toISOString().slice(0,10);
                        if (!isPastDate(iso)) {
                            foundDate = iso;
                            // Convert ranges like '09:00-12:00' to objects expected by modal
                            const rangesObjs = ranges.map(r => {
                                const parts = (r||'').split('-');
                                return { start: (parts[0]||'09:00').trim(), end: (parts[1]||'17:00').trim() };
                            });
                            // Use service-level increment; if fixed increments are enabled, use duration+buffer_after
                            let inc = Number(svc.time_increment_minutes || 30);
                            try {
                                if (svc.use_fixed_increment) {
                                    const dur = Number(svc.duration || 0);
                                    const buf = Number(svc.buffer_after || 0);
                                    if (!isNaN(dur) && !isNaN(buf) && (dur + buf) > 0) {
                                        inc = dur + buf;
                                    }
                                }
                            } catch (e) { /* ignore */ }
                            // Open the Day Schedule modal for this date
                            try { openTimeCirclesModal(foundDate, inc, 1, rangesObjs); } catch (e) { console.warn('auto-open modal failed', e); }
                            break;
                        }
                    }
                }
            } catch (e) { console.warn('auto-open Day Schedule failed', e); }
        })();

    // Relocate calendar controls below the month title on mobile, revert on desktop
    function relocateCalendarControls() {
        const controls = document.getElementById('calendar-controls');
        const cal = document.getElementById('calendar');
        if (!controls || !cal) return;
        const isMobile = window.matchMedia('(max-width: 768px)').matches;
        const toolbar = cal.querySelector('.fc-header-toolbar');
        if (isMobile && toolbar) {
            if (controls.dataset.inHeader !== '1') {
                controls.dataset.inHeader = '1';
                // Ensure inline layout
                controls.style.position = 'static';
                controls.style.left = '';
                controls.style.top = '';
                controls.style.transform = 'none';
                toolbar.insertAdjacentElement('afterend', controls);
            }
        } else {
            if (controls.dataset.inHeader === '1') {
                controls.dataset.inHeader = '';
                const parent = cal.parentElement; // calendar column container
                if (parent) parent.appendChild(controls);
                // Restore desktop overlay positioning
                controls.style.position = 'absolute';
                controls.style.left = '50%';
                controls.style.top = '80px';
                controls.style.transform = 'translateX(-50%)';
            }
        }
    }
    try { relocateCalendarControls(); } catch (e) {}
    try { window.addEventListener('resize', relocateCalendarControls); } catch (e) {}

    // Remove trailing extra rows made of only other-month days
    try { hideTrailingOtherRows(); } catch (e) { /* ignore */ }

    // Initial styling for overrides table (badges + animated buttons)
    try { styleOverridesTable(); } catch (e) { /* ignore */ }

    // Inline bookings: render bookings for the current visible calendar range
    function renderInlineBookings() {
        const tbody = document.getElementById('bookingsInlineTBody');
        if (!tbody || !calendar) return;

        const view = calendar.view;
        const rangeStart = view && view.activeStart ? view.activeStart : null;
        const rangeEnd = view && view.activeEnd ? view.activeEnd : null;

        // Gather events already loaded in calendar and filter to real bookings only
        let events = [];
        try { events = calendar.getEvents() || []; } catch (e) { events = []; }
        const bookings = events.filter(ev => {
            try {
                const xp = ev.extendedProps || {};
                if (xp.is_blocking || xp.is_per_date || ev.display === 'background') return false;
                // Keep this in sync with Day Schedule booking scope behavior
                try {
                    if (typeof _isBookingInSelectedScope === 'function' && !_isBookingInSelectedScope(ev)) return false;
                } catch (e) { /* ignore */ }
                if (rangeStart && ev.start < rangeStart) return false;
                if (rangeEnd && ev.start >= rangeEnd) return false;
                return true;
            } catch (_) { return false; }
        }).sort((a,b) => (a.start?.getTime()||0) - (b.start?.getTime()||0));

        const search = (document.getElementById('bookingsSearchInline')?.value || '').toLowerCase();
        const filtered = bookings.filter(ev => {
            const xp = ev.extendedProps || {};
            const name = (xp.client_name || xp.customer_name || '').toLowerCase();
            const email = (xp.client_email || xp.customer_email || '').toLowerCase();
            return !search || name.includes(search) || email.includes(search);
        });

        tbody.innerHTML = '';
        if (filtered.length === 0) {
            const msg = (typeof IS_TEAM !== 'undefined' && IS_TEAM) ? 'No bookings from this member/service' : 'No bookings for this period';
            tbody.innerHTML = `<tr><td colspan="5" style="text-align:center; color:var(--gray-600); padding:16px;">${msg}</td></tr>`;
            return;
        }

        const todayStr = new Date().toDateString();
        filtered.forEach(ev => {
            const tr = document.createElement('tr');
            tr.style.borderBottom = '1px solid var(--gray-200)';

            const xp = ev.extendedProps || {};
            const client = xp.client_name || xp.customer_name || '—';
            const email = xp.client_email || xp.customer_email || '';
            let service = xp.service_name || xp.service_slug || '';
            if (!service) {
                try {
                    const svcId = (xp.service_id || ev.service_id || null);
                    const svc = svcId ? svcById(svcId) : null;
                    service = (svc && svc.name) ? svc.name : '';
                } catch (e) { /* ignore */ }
            }
            if (!service) service = ev.title || '—';
            const start = ev.start;
            const end = ev.end || null;

            let status = 'Upcoming';
            if (start) {
                const startDay = start.toDateString();
                if (startDay === todayStr) status = 'Today';
                else if (start < new Date()) status = 'Past';
            }

            const tdDT = document.createElement('td');
            tdDT.style.padding = '10px';
            tdDT.innerHTML = start ? `<div style="font-weight:600;">${start.toLocaleDateString()}</div><div style="font-size:13px; color:var(--gray-600);">${start.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}${end ? ' - ' + end.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}) : ''}</div>` : '—';

            const tdClient = document.createElement('td');
            tdClient.style.padding = '10px';
            tdClient.innerHTML = `<div style="font-weight:600;">${client}</div><div style="font-size:13px; color:var(--gray-600);">${email}</div>`;

            const tdService = document.createElement('td');
            tdService.style.padding = '10px';
            tdService.textContent = service;

            const tdStatus = document.createElement('td');
            tdStatus.style.padding = '10px';
            const badgeMap = { Today: ['#d4edda','#155724'], Past:['#d6d8db','#383d41'], Upcoming:['#d1ecf1','#0c5460'] };
            const [bg, fg] = badgeMap[status] || ['#eee','#444'];
            tdStatus.innerHTML = `<span style="padding:4px 8px; border-radius:4px; font-size:12px; font-weight:600; background:${bg}; color:${fg};">${status}</span>`;

            const tdActions = document.createElement('td');
            tdActions.style.padding = '10px';
            const viewBtn = document.createElement('button');
            viewBtn.type = 'button';
            viewBtn.textContent = 'View';
            viewBtn.style.cssText = 'padding:6px 10px; background:var(--primary-500); color:white; border:none; border-radius:6px; cursor:pointer;';
            viewBtn.onclick = () => {
                try { openBookingModal(ev); } catch (e) { console.error('openBookingModal failed', e); }
            };
            tdActions.appendChild(viewBtn);

            tr.appendChild(tdDT);
            tr.appendChild(tdClient);
            tr.appendChild(tdService);
            tr.appendChild(tdStatus);
            tr.appendChild(tdActions);
            tbody.appendChild(tr);
        });
    }

    function updateBookingsViewAllLink(){
        try{
            const a = document.getElementById('bookingsViewAllBtn');
            if (!a) return;
            const base = `/bus/${orgSlug}/bookings/`;
            if (SELECTED_MEMBER) a.setAttribute('href', `${base}?scope=${encodeURIComponent(String(SELECTED_MEMBER))}`);
            else a.setAttribute('href', base);
        }catch(e){ /* ignore */ }
    }

    function filterInlineAuditBySelection(){
        try{
            const rows = Array.from(document.querySelectorAll('.cc-inline-audit-row'));
            const empty = document.getElementById('inlineAuditEmptyScoped');
            if (!rows.length) {
                if (empty) empty.style.display = 'none';
                return;
            }

            // allowed service ids for current scope
            let allowed = null;
            if (SELECTED_MEMBER) {
                if (String(SELECTED_MEMBER).startsWith('svc:')) {
                    allowed = new Set([String(SELECTED_MEMBER).slice(4)]);
                } else {
                    // Member selection -> show audit entries for visible services
                    try { allowed = new Set((VISIBLE_SERVICES || []).map(s => String(s.id))); }
                    catch (e) { allowed = new Set(); }
                }
            }

            let shown = 0;
            rows.forEach(li => {
                try{
                    const sid = String(li.getAttribute('data-service-id') || '');
                    const show = (!allowed) ? true : (sid && allowed.has(sid));
                    li.style.display = show ? 'flex' : 'none';
                    if (!show) {
                        const cb = li.querySelector('input.auditRowCbInline');
                        if (cb) cb.checked = false;
                    } else {
                        shown += 1;
                    }
                }catch(e){ /* ignore */ }
            });

            if (empty) empty.style.display = (allowed && shown === 0) ? 'block' : 'none';
            try { const selAll = document.getElementById('auditInlineSelectAll'); if (selAll) selAll.checked = false; } catch(e) {}
        }catch(e){ /* ignore */ }
    }

    // Search and manual refresh handlers
    try {
        document.getElementById('bookingsSearchInline')?.addEventListener('input', () => renderInlineBookings());
        document.getElementById('bookingsRefreshBtn')?.addEventListener('click', () => renderInlineBookings());
    } catch (_) {}

    // Initial render
    try { renderInlineBookings(); } catch (_) {}
    try { updateBookingsViewAllLink(); } catch (_) {}
    try { filterInlineAuditBySelection(); } catch (_) {}

    // Render the default availability UI and sync backgrounds to the calendar
    try { displayDefaultAvailability(); } catch (e) { console.warn('displayDefaultAvailability failed', e); }
    try { syncAvailabilityToCalendar(); } catch (e) { console.warn('syncAvailabilityToCalendar failed', e); }
    try { updateUnavailableDays(); } catch (e) { console.warn('updateUnavailableDays failed', e); }
    try { reapplySelections(); } catch (e) { /* optional */ }
    try { updateClearButton(); } catch (e) { /* optional */ }

    // Minimal runtime fix: on small viewports, make sure the availability
    // container's min-height is at least as tall as its content so nothing
    // visually leaks out. This only runs on page load and on resize for
    // viewports <= 768px.
    (function ensureAvailabilityContainerFits() {
        function apply() {
            try {
                if (window.innerWidth > 768) return;
                const el = document.getElementById('defaultAvailabilityContainer');
                if (!el) return;
                // Use scrollHeight to measure content; add small padding safety.
                const wanted = Math.max(el.scrollHeight + 24, 520);
                el.style.minHeight = wanted + 'px';
                // Keep overflow hidden so the top-gradient (::before) is clipped
                // to the container's border-radius and doesn't produce a 'hat' effect.
                el.style.overflow = 'hidden';
            } catch (err) { /* ignore */ }
        }
        // Run after next paint to allow layout to settle
        requestAnimationFrame(() => setTimeout(apply, 0));
        // Also adjust on viewport resizes (debounced)
        let t = null;
        window.addEventListener('resize', () => {
            clearTimeout(t);
            t = setTimeout(apply, 120);
        });
    })();

    // Audit modal for inline feed
    function tryParseSnapshot(raw){
        if(!raw) return null;
        try{
            // unescape unicode sequences like \u0027 -> '
            raw = String(raw).replace(/\\u([0-9a-fA-F]{4})/g, function(_, g){ return String.fromCharCode(parseInt(g,16)); });
        }catch(e){}
        try { return JSON.parse(raw); } catch(e){}
        try {
            let alt = String(raw).replace(/\\'/g, "'");
            alt = alt.replace(/'/g, '"');
            alt = alt.replace(/\bNone\b/g, 'null').replace(/\bTrue\b/g,'true').replace(/\bFalse\b/g,'false');
            return JSON.parse(alt);
        } catch(e){}
        try { return (new Function('return ' + raw))(); } catch(e){}
        return null;
    }
    window.openAuditInline = function(btn) {
        try {
            const raw = btn.getAttribute('data-snapshot');
            let parsed = tryParseSnapshot(raw);
            const out = document.getElementById('inlineAuditContent');
            if (parsed && typeof parsed === 'object'){
                // Build friendly HTML
                const parts = [];
                if (parsed.title) parts.push(`<div><strong>Title:</strong> ${parsed.title}</div>`);
                if (parsed.start) parts.push(`<div><strong>Start:</strong> ${new Date(parsed.start).toLocaleString()}</div>`);
                if (parsed.end) parts.push(`<div><strong>End:</strong> ${new Date(parsed.end).toLocaleString()}</div>`);
                if (parsed.client_name) parts.push(`<div><strong>Client:</strong> ${parsed.client_name} <span style="color:#666">&lt;${parsed.client_email || parsed.clientEmail || '-'}&gt;</span></div>`);
                const svc = parsed.service_slug || parsed.service || parsed.service_name || (parsed.snapshot && parsed.snapshot.service_slug);
                if (svc) parts.push(`<div><strong>Service:</strong> ${svc}</div>`);
                if (parsed.created_at) parts.push(`<div><strong>Booked At:</strong> ${new Date(parsed.created_at).toLocaleString()}</div>`);
                out.innerHTML = parts.join('\n') || (raw || 'No detail');
            } else {
                out.textContent = raw || 'No detail';
            }
            document.getElementById('inlineAuditModal').style.display = 'flex';
        } catch (e) { console.error(e); }
    }
    window.closeInlineAudit = function() { document.getElementById('inlineAuditModal').style.display = 'none'; }

    // Inline audit select-all + export
    const auditInlineSelectAll = document.getElementById('auditInlineSelectAll');
    if (auditInlineSelectAll) {
        auditInlineSelectAll.addEventListener('change', (e) => {
            document.querySelectorAll('.auditRowCbInline').forEach(cb => cb.checked = e.target.checked);
        });
    }

    const exportAuditInlineBtn = document.getElementById('exportAuditInlineBtn');
    if (exportAuditInlineBtn) {
        exportAuditInlineBtn.addEventListener('click', async () => {
            const ids = Array.from(document.querySelectorAll('.auditRowCbInline:checked')).map(cb => Number(cb.value));
            if (!ids.length) { alert('No audit rows selected'); return; }
            try {
                const resp = await fetch(`/bus/{{ organization.slug }}/bookings/audit/export/`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'X-CSRFToken': getCookie('csrftoken') || '' },
                    body: JSON.stringify({ ids })
                });
                if (!resp.ok) { alert('Export failed'); return; }
                const blob = await resp.blob();
                const contentType = resp.headers.get('Content-Type') || '';
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url;
                if (contentType === 'application/pdf') a.download = 'audit_export.pdf'; else a.download = 'audit_export.json';
                document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
            } catch (e) { console.error(e); alert('Export error'); }
        });
        const deleteAuditInlineBtn = document.getElementById('deleteAuditInlineBtn');
        if (deleteAuditInlineBtn){
            deleteAuditInlineBtn.addEventListener('click', async () => {
                const ids = Array.from(document.querySelectorAll('.auditRowCbInline:checked')).map(cb => Number(cb.value));
                if (!ids.length) { alert('No audit rows selected'); return; }
                if (!confirm('Permanently delete selected audit records? This cannot be undone.')) return;
                try {
                    const resp = await fetch(`/bus/{{ organization.slug }}/bookings/audit/delete/`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': getCookie('csrftoken') || '' },
                        body: JSON.stringify({ ids })
                    });
                    if (!resp.ok) { alert('Delete failed'); return; }
                    const data = await resp.json();
                    showToast('success', `Deleted ${data.deleted || 0} audit rows.`);
                    document.querySelectorAll('.auditRowCbInline:checked').forEach(cb => { const li = cb.closest('li'); if (li) li.remove(); });
                } catch (e) { console.error(e); alert('Delete error'); }
            });
        }
    }

    // Save client-facing view settings to localStorage so public profile can read them.
    // Also allow a custom increment value and sync it immediately so the edit
    // service page (which listens to storage events) stays in sync.
    try {
        const saveClientBtn = document.getElementById('saveClientSettingsBtn');
        const clientIncrementSelect = document.getElementById('clientIncrementSelect');
        const clientBlockSelect = document.getElementById('clientBlockSelect');
        // Reuse the existing custom increment UI used by the coach section
        const sharedCustomIncrementContainer = document.getElementById('customIncrementContainer');
        const sharedCustomIncrementInput = document.getElementById('customIncrementInput');
        const sharedApplyCustomIncrementBtn = document.getElementById('applyCustomIncrementBtn');

        const CLIENT_KEY = 'client_view_settings';
        const STANDARD_INCREMENTS = ['15','30','45','60'];

        function readClientSettingsFromStorage(){
            try {
                const raw = localStorage.getItem(CLIENT_KEY) || '{}';
                const parsed = JSON.parse(raw);
                return parsed && typeof parsed === 'object' ? parsed : {};
            } catch (e) { return {}; }
        }

        function writeClientSettingsToStorage(obj){
            try {
                localStorage.setItem(CLIENT_KEY, JSON.stringify(obj || {}));
                // Dispatch a storage event for same-window listeners (some browsers won't).
                try { window.dispatchEvent(new Event('storage')); } catch(e){}
            } catch (e) { console.error('write client view storage failed', e); }
        }

        // Initialize client increment select from storage (or leave default)
        try {
            const stored = readClientSettingsFromStorage();
            if (stored && typeof stored.increment !== 'undefined') {
                const inc = String(stored.increment);
                // If it's a standard option, select it. Otherwise switch the select
                // to the 'custom' choice and prefill the custom inputs (do not add
                // custom options to the dropdown to avoid clutter).
                if (STANDARD_INCREMENTS.includes(inc)) {
                    if (clientIncrementSelect) clientIncrementSelect.value = inc;
                } else if (clientIncrementSelect) {
                    // Put the select into the 'custom' position and show custom inputs
                    try {
                        clientIncrementSelect.value = 'custom';
                    } catch (e) { /* ignore */ }
                    if (sharedCustomIncrementContainer && sharedCustomIncrementInput) {
                        sharedCustomIncrementContainer.style.display = 'flex';
                        sharedCustomIncrementInput.value = String(inc);
                    }
                    const clientCustomContainer = document.getElementById('clientCustomIncrementContainer');
                    const clientCustomInput = document.getElementById('clientCustomIncrementInput');
                    if (clientCustomContainer && clientCustomInput) {
                        clientCustomContainer.style.display = 'inline-flex';
                        clientCustomInput.value = String(inc);
                    }
                }
            }
        } catch (e) { /* ignore init errors */ }

        // When the client increment select changes, if it's one of the standard
        // increments, write to storage immediately. If it's an unfamiliar value
        // (like 'custom' or something not numeric) show the custom input.
        if (clientIncrementSelect) {
            clientIncrementSelect.addEventListener('change', function(){
                try {
                    const val = clientIncrementSelect.value;
                    if (STANDARD_INCREMENTS.includes(val)) {
                        // hide any custom UI if visible
                        if (sharedCustomIncrementContainer) sharedCustomIncrementContainer.style.display = 'none';
                        const clientCustomContainer = document.getElementById('clientCustomIncrementContainer');
                        if (clientCustomContainer) clientCustomContainer.style.display = 'none';
                        const payload = Object.assign({}, readClientSettingsFromStorage(), { block: Number(clientBlockSelect?.value || 1), increment: Number(val) });
                        writeClientSettingsToStorage(payload);
                    } else if (val === 'custom') {
                        // Show the client-specific custom input
                        const clientCustomContainer = document.getElementById('clientCustomIncrementContainer');
                        if (clientCustomContainer) clientCustomContainer.style.display = 'inline-flex';
                        // Also show shared custom UI so user can use either
                        if (sharedCustomIncrementContainer) sharedCustomIncrementContainer.style.display = 'flex';
                        if (sharedCustomIncrementInput) sharedCustomIncrementInput.value = '';
                    } else {
                        // Not standard — show shared custom input
                        if (sharedCustomIncrementContainer) sharedCustomIncrementContainer.style.display = 'flex';
                        if (sharedCustomIncrementInput) sharedCustomIncrementInput.value = '';
                    }
                } catch (e) { console.warn('client increment change handler failed', e); }
            });
        }

        // Client custom input is persisted when the user clicks the
        // 'Save for Client View' button below. We removed the separate
        // Apply button to simplify UX.

        // Also keep coach preview controls in sync: initialize coach select/value
        // from storage when the modal loads (if present). We'll set these up in
        // the openTimeCirclesModal initializer below as well, but add a small
        // defensive update here for any code paths that reuse this block.
        try {
            const coachIncrementSelect = document.getElementById('incrementSelect');
            const coachCustomIncrementInput = document.getElementById('customIncrementInput');
            if (coachIncrementSelect) {
                const stored = readClientSettingsFromStorage();
                if (stored && typeof stored.increment !== 'undefined') {
                    const s = String(stored.increment);
                    // If standard, select; otherwise set to 'custom' and prefill coach custom input
                    if (STANDARD_INCREMENTS.includes(s)) {
                        coachIncrementSelect.value = s;
                        if (coachCustomIncrementInput) {
                            const coachCustomContainer = document.getElementById('customIncrementContainer');
                            if (coachCustomContainer) coachCustomContainer.style.display = 'none';
                            coachCustomIncrementInput.value = '';
                        }
                    } else {
                        try { coachIncrementSelect.value = 'custom'; } catch(e){}
                        if (coachCustomIncrementInput) {
                            coachCustomIncrementInput.value = s;
                            const coachCustomContainer = document.getElementById('customIncrementContainer');
                            if (coachCustomContainer) coachCustomContainer.style.display = 'flex';
                        }
                    }
                }
            }
        } catch (e) { /* ignore */ }

        // Wire the shared custom increment apply button so it updates the select,
        // hides the custom UI, and writes to storage.
        if (sharedApplyCustomIncrementBtn && sharedCustomIncrementInput && clientIncrementSelect) {
            sharedApplyCustomIncrementBtn.onclick = () => {
                try {
                    const v = parseInt(sharedCustomIncrementInput.value, 10);
                    if (isNaN(v) || v < 5) return alert('Enter a valid increment (5+ minutes).');
                    // Do not add persistent options to the dropdown. Use the 'custom'
                    // select value and prefill both client and shared custom inputs.
                    try { clientIncrementSelect.value = 'custom'; } catch(e){}
                    const clientCustomContainer = document.getElementById('clientCustomIncrementContainer');
                    const clientCustomInput = document.getElementById('clientCustomIncrementInput');
                    if (clientCustomContainer && clientCustomInput) {
                        clientCustomContainer.style.display = 'inline-flex';
                        clientCustomInput.value = String(v);
                    }
                    const payload = Object.assign({}, readClientSettingsFromStorage(), { block: Number(clientBlockSelect?.value || 1), increment: Number(v) });
                    writeClientSettingsToStorage(payload);
                    alert('Custom client increment applied.');
                } catch (e) { console.error('apply custom increment failed', e); alert('Unable to apply custom increment.'); }
            };
        }

        // Save button: persist current selections (including custom increment)
        if (saveClientBtn) {
            saveClientBtn.onclick = () => {
                try {
                    const block = Number(clientBlockSelect?.value || 1);
                    let incrementVal = clientIncrementSelect?.value;
                    if (!incrementVal || isNaN(Number(incrementVal))) {
                        // If select is non-numeric (e.g., 'custom'), read the shared custom input
                        incrementVal = Number(sharedCustomIncrementInput?.value || 30);
                    } else {
                        incrementVal = Number(incrementVal);
                    }
                    const payload = { block: Number(block), increment: Number(incrementVal) };
                    writeClientSettingsToStorage(payload);
                    // Also attempt to persist to the service settings when the modal
                    // was opened for a specific service (e.g., via Edit Service -> Open Day Schedule).
                    try {
                        const svcId = Number(AUTO_OPEN_SERVICE) || null;
                        if (svcId) {
                            // Preview -> apply flow so server can create per-date freezes for
                            // any dates with bookings. This prevents changes from affecting
                            // already-booked days.
                            (async function(){
                                try {
                                    const previewResp = await fetch(`/bus/${orgSlug}/services/${svcId}/preview_update/`, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                                        body: JSON.stringify({ time_increment_minutes: Number(incrementVal) })
                                    });
                                    const previewJson = previewResp && previewResp.ok ? await previewResp.json().catch(()=>null) : null;
                                    if (!previewJson || previewJson.status !== 'ok' || !previewJson.conflicts || Object.keys(previewJson.conflicts).length === 0) {
                                        // No conflicts detected: apply immediately
                                        await fetch(`/bus/${orgSlug}/services/${svcId}/apply_update/`, {
                                            method: 'POST',
                                            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                                            body: JSON.stringify({ time_increment_minutes: Number(incrementVal), confirm: true })
                                        }).then(r => r.json().catch(()=>null)).then(d => { /* no-op */ }).catch(()=>{});
                                    } else {
                                        // Conflicts exist (dates with bookings). Ask user to confirm applying
                                        const days = Object.keys(previewJson.conflicts || {});
                                        const msg = `This change would affect ${days.length} day(s) that already have bookings. Those days will be preserved (old settings will be frozen) if you continue. Apply changes?`;
                                        if (confirm(msg)) {
                                            await fetch(`/bus/${orgSlug}/services/${svcId}/apply_update/`, {
                                                method: 'POST',
                                                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                                                body: JSON.stringify({ time_increment_minutes: Number(incrementVal), confirm: true })
                                            }).then(r => r.json().catch(()=>null)).then(d => { /* no-op */ }).catch(()=>{});
                                        } else {
                                            // User cancelled: do not apply to server; client view persisted only
                                        }
                                    }
                                } catch (err) {
                                    console.error('preview/apply update failed', err);
                                }
                            })();
                        }
                    } catch (e) { /* ignore server persist errors */ }
                    alert('Client view settings saved — public page will use these when viewing a day.');
                } catch (err) {
                    console.error('save client settings failed', err);
                    alert('Unable to save client view settings locally.');
                }
            };
        }

        // Keep storage in sync if other tabs change it
        window.addEventListener('storage', function(e){
            if (e.key !== CLIENT_KEY) return;
            try {
                const parsed = readClientSettingsFromStorage();
                if (!parsed) return;
                const inc = parsed.increment;
                if (typeof inc !== 'undefined') {
                    const s = String(inc);
                    // update client select
                    if (clientIncrementSelect) {
                        if (STANDARD_INCREMENTS.includes(s)) {
                            clientIncrementSelect.value = s;
                            if (sharedCustomIncrementContainer) sharedCustomIncrementContainer.style.display = 'none';
                        } else {
                            // ensure option exists
                            // If it's a known standard increment, set the select to it.
                            // Otherwise set select to 'custom' and show the client custom input.
                            if (STANDARD_INCREMENTS.includes(s)) {
                                clientIncrementSelect.value = s;
                                if (sharedCustomIncrementContainer) sharedCustomIncrementContainer.style.display = 'none';
                            } else {
                                try { clientIncrementSelect.value = 'custom'; } catch(e){}
                                if (sharedCustomIncrementContainer && sharedCustomIncrementInput) {
                                    sharedCustomIncrementContainer.style.display = 'flex';
                                    sharedCustomIncrementInput.value = String(s);
                                }
                                const clientCustomContainer = document.getElementById('clientCustomIncrementContainer');
                                const clientCustomInput = document.getElementById('clientCustomIncrementInput');
                                if (clientCustomContainer && clientCustomInput) {
                                    clientCustomContainer.style.display = 'inline-flex';
                                    clientCustomInput.value = String(s);
                                }
                            }
                            if (sharedCustomIncrementContainer && sharedCustomIncrementInput) {
                                sharedCustomIncrementContainer.style.display = 'flex';
                                sharedCustomIncrementInput.value = String(s);
                            }
                        }
                    }

                    // update coach select and custom input if present
                    try {
                        const coachIncrementSelect = document.getElementById('incrementSelect');
                        const coachCustomIncrementInput = document.getElementById('customIncrementInput');
                        const coachCustomIncrementContainer = document.getElementById('customIncrementContainer');
                        if (coachIncrementSelect) {
                            if (STANDARD_INCREMENTS.includes(s)) {
                                coachIncrementSelect.value = s;
                                if (coachCustomIncrementContainer) coachCustomIncrementContainer.style.display = 'none';
                            } else {
                                // Do not append a persistent option for non-standard increments.
                                // Select the 'custom' bucket and prefill the coach custom input.
                                try { coachIncrementSelect.value = 'custom'; } catch (e) {}
                                if (coachCustomIncrementContainer && coachCustomIncrementInput) {
                                    coachCustomIncrementContainer.style.display = 'flex';
                                    coachCustomIncrementInput.value = String(s);
                                }
                            }
                        }
                    } catch (ee) { /* ignore coach update errors */ }
                    // update client custom input if present
                    try {
                        const clientCustomInput = document.getElementById('clientCustomIncrementInput');
                        const clientCustomContainer = document.getElementById('clientCustomIncrementContainer');
                        if (clientCustomInput) clientCustomInput.value = String(s);
                        if (clientCustomContainer) clientCustomContainer.style.display = STANDARD_INCREMENTS.includes(s) ? 'none' : 'inline-flex';
                    } catch (ee) { /* ignore */ }
                }
            } catch (err) { /* ignore */ }
        });
    } catch (e) { console.warn('client settings save wiring failed', e); }

    // Ensure every day-number has a click handler that opens the proper modal
    function attachDayNumberClickHandlers() {
        document.querySelectorAll('.fc-daygrid-day').forEach(dayCell => {
            const dateStr = dayCell.dataset.date;
            if (!dateStr) return;
            const numberEl = dayCell.querySelector('.fc-daygrid-day-number');
            if (!numberEl) return;

            // Keep cursor interactive; actual click handling is done by delegated pointerup
            numberEl.style.cursor = 'pointer';
        });
    }

    try { attachDayNumberClickHandlers(); } catch (e) { console.warn('attachDayNumberClickHandlers failed', e); }

    // Use a single delegated pointerup handler to toggle selection or open past-day modal.
    calendarEl.addEventListener('pointerup', function(ev) {
        try {
            // If a drag is in progress, skip (drag logic will handle selection on mouseup)
            if (isDragging) return;

            const num = ev.target.closest('.fc-daygrid-day-number');
            if (!num) return;
            const dayCell = num.closest('.fc-daygrid-day');
            if (!dayCell) return;
            const dateStr = dayCell.dataset.date;
            if (!dateStr) return;

            // Past-day click -> open past-day modal
            if (isPastDate(dateStr)) {
                return openPastDayModal(dateStr);
            }

            // Toggle selection for any non-past day (available or unavailable)
            toggleDateSelection(dateStr);
        } catch (err) { console.error('delegated pointerup handler failed', err); }
    });

    // Parse a YYYY-MM-DD string into a local Date at midnight (avoids Date("YYYY-MM-DD") UTC parsing)
    function parseYMD(dateStr) {
            const parts = String(dateStr).split('-');
            if (parts.length !== 3) return new Date(dateStr);
            const y = parseInt(parts[0], 10);
            const m = parseInt(parts[1], 10) - 1;
            const d = parseInt(parts[2], 10);
            return new Date(y, m, d);
        }

        // Apply visual badges for type column and animated styles for action buttons
        function styleOverridesTable() {
            const tbody = document.getElementById('overridesTableBody');
            if (!tbody) return;
            // Wrap type text in badges
            Array.from(tbody.querySelectorAll('tr')).forEach(row => {
                const cells = row.children;
                if (!cells || cells.length < 2) return;
                const typeCell = cells[1]; // Date(0), Type(1), Time Ranges(2)...
                if (!typeCell) return;
                const raw = (typeCell.textContent || '').trim();
                if (!raw) return;
                const lower = raw.toLowerCase();
                let cls = 'type-badge';
                if (lower.includes('blocked') || lower.includes('unavailable')) cls += ' blocked';
                else if (lower.includes('available')) cls += ' available';
                // Avoid double-wrapping
                if (!typeCell.querySelector('.type-badge')) {
                    typeCell.innerHTML = `<span class="${cls}">${raw}</span>`;
                }
            });
            // Upgrade buttons with animation styles
            Array.from(tbody.querySelectorAll('button')).forEach(btn => {
                if (!btn.classList.contains('overrides-btn')) {
                    btn.classList.add('overrides-btn');
                }
            });
        }

        // Re-style badges/buttons whenever overrides table changes
        try {
            const overridesBody = document.getElementById('overridesTableBody');
            if (overridesBody) {
                const obs = new MutationObserver(() => { try { styleOverridesTable(); } catch(e){} });
                obs.observe(overridesBody, { childList: true, subtree: true });
            }
        } catch (e) { /* ignore */ }

        // Hide any week rows that contain only out-of-month cells (prevents grey frames below last week)
        function hideTrailingOtherRows() {
            try {
                document.querySelectorAll('.fc-daygrid-week').forEach(week => {
                    const cells = week.querySelectorAll('.fc-daygrid-day');
                    if (!cells.length) return;
                    const allOther = Array.from(cells).every(c => c.classList.contains('fc-day-other'));
                    week.style.display = allOther ? 'none' : '';
                });
            } catch (e) { /* ignore */ }
        }

        // Format a Date object into YYYY-MM-DD using local date components
        function formatYMD(d) {
            if (!(d instanceof Date)) d = new Date(d);
            const y = d.getFullYear();
            const m = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${y}-${m}-${day}`;
        }

        // Toggle the modal ranges container visibility based on whether the given date
        // is fully unavailable (weekly default or per-date full-day block).
        function setModalTimeRowVisibility(dateStr) {
            try {
                const rangesContainer = document.getElementById('modalRangesContainer');
                const noticeId = 'makeAvailableNotice';
                const prev = document.getElementById(noticeId);
                if (prev) prev.remove();

                if (!rangesContainer) return;

                const d = parseYMD(dateStr);
                const dow = d.getDay();
                const info = defaultAvailability[dow] || {};
                const firstRange = (info.ranges && info.ranges.length) ? info.ranges[0] : (info.start && info.end ? `${info.start}-${info.end}` : null);

                let hasPerDateBlocked = false;
                let hasPerDateAvailable = false;
                try {
                    const events = (typeof calendar.getEvents === 'function') ? calendar.getEvents() : [];
                    for (const ev of events) {
                        if (!ev || ev.display !== 'background') continue;
                        const props = ev.extendedProps || {};
                        if (!props.is_per_date) continue;
                        if (!ev.start) continue;
                        const evDate = formatYMD(ev.start);
                        if (evDate !== dateStr) continue;
                        const isFullDay = ev.startStr && ev.endStr && ev.startStr.endsWith('T00:00') && ev.endStr.endsWith('T23:59');
                        if (props.override_type === 'blocked' && isFullDay) {
                            hasPerDateBlocked = true;
                        } else if (props.override_type === 'available') {
                            hasPerDateAvailable = true;
                        }
                    }
                } catch (e) { /* ignore */ }

                // Precedence: per-date blocked > per-date available > weekly defaults
                let fullyUnavailable = hasPerDateBlocked || ((!!info.unavailable || (!firstRange && (!info.ranges || info.ranges.length === 0))) && !hasPerDateAvailable);
                try {
                    const cell = document.querySelector(`.fc-daygrid-day[data-date="${dateStr}"]`);
                    const num = cell ? cell.querySelector('.fc-daygrid-day-number') : null;
                    const cellUnavailable = cell && (cell.classList.contains('fc-day-unavailable') || (num && num.classList.contains('unavailable-number')));
                    if (cellUnavailable) fullyUnavailable = true;
                } catch (e) { /* ignore */ }

                if (fullyUnavailable) {
                    rangesContainer.style.display = 'none';
                    // Hide the Add Range button when the date is fully unavailable
                    try {
                        const addBtnEl = document.getElementById('addModalRangeBtn');
                        if (addBtnEl) addBtnEl.style.display = 'none';
                    } catch (e) { /* ignore */ }
                    const msg = document.createElement('div');
                    msg.id = noticeId;
                    msg.style.padding = '12px 0';
                    msg.style.fontWeight = '600';
                    msg.textContent = 'This date is currently fully unavailable; make it available to set times.';
                    const modalContent = document.getElementById('timeModal')?.querySelector('div[style*="padding"]') || document.getElementById('timeModal')?.firstElementChild;
                    if (modalContent) modalContent.insertBefore(msg, modalContent.querySelector('div') || modalContent.firstChild);
                } else {
                    rangesContainer.style.display = '';
                    // Ensure Add Range button is visible when date is available
                    try {
                        const addBtnEl = document.getElementById('addModalRangeBtn');
                        if (addBtnEl) addBtnEl.style.display = 'inline-block';
                    } catch (e) { /* ignore */ }
                }
            } catch (e) { console.warn('setModalTimeRowVisibility failed', e); }
        }

        function getCoachOccupiedDates() {
            const occupied = new Set();
            calendar.getEvents().forEach(event => {
                const start = event.startStr.split('T')[0];
                const end = event.endStr ? event.endStr.split('T')[0] : start;
                let curr = parseYMD(start);
                const last = parseYMD(end);
                while (curr <= last) {
                    occupied.add(formatYMD(curr));
                    curr.setDate(curr.getDate() + 1);
                }
            });
            return occupied;
        }

        // Apply a per-date unavailable UI immediately (client-side) by adding
        // a full-day background event and switching classes on the calendar cell.
        function applyPerDateUnavailable(dateStr) {
            try {
                // Add a background block for immediate visual feedback
                calendar.addEvent({
                    start: dateStr + 'T00:00',
                    end: dateStr + 'T23:59',
                    display: 'background',
                    color: '#e0e0e0',
                    extendedProps: Object.assign({ is_per_date: true, override_type: 'blocked', optimistic: true }, getScopePropsForSelection(SELECTED_MEMBER))
                });
            } catch (e) { console.warn('applyPerDateUnavailable addEvent failed', e); }

            const cell = document.querySelector(`.fc-daygrid-day[data-date="${dateStr}"]`);
            if (!cell) return;
            cell.classList.add('fc-day-unavailable');
            cell.classList.remove('fc-day-available');
            const num = cell.querySelector('.fc-daygrid-day-number');
            if (num) {
                num.classList.add('unavailable-number');
                num.classList.remove('past-day');
                num.style.cursor = 'pointer';
            }
        }

        

        // -----------------------------
        // 6️⃣ Sync default weekly availability to calendar
        // -----------------------------
        function syncAvailabilityToCalendar() {
            // 1️⃣ Clear existing background events that we previously added as defaults
            calendar.getEvents().forEach(e => {
                try {
                    if (e.display === 'background' && e.extendedProps && e.extendedProps.is_default) e.remove();
                } catch (e) { /* ignore */ }
            });

            const occupied = getCoachOccupiedDates();

            // Prefer to sync over the currently visible calendar range so
            // the visuals always match what the user sees (important when
            // the month view spans different weeks).
            const viewStart = (calendar.view && calendar.view.activeStart) ? new Date(calendar.view.activeStart) : new Date();
            const viewEnd = (calendar.view && calendar.view.activeEnd) ? new Date(calendar.view.activeEnd) : (() => { const d=new Date(); d.setMonth(d.getMonth()+1); return d; })();

            // Iterate each day in the visible range
            for (let d = new Date(viewStart); d < viewEnd; d.setDate(d.getDate() + 1)) {
                const dateStr = formatYMD(d);
                if (isPastDate(dateStr)) continue;
                if (occupied.has(dateStr)) continue; // keep booked days alone

                const dow = d.getDay(); // 0=Sunday
                const info = defaultAvailability[dow] || {};

                // If day is unavailable, block whole day (mark as default)
                if (info.unavailable) {
                    calendar.addEvent({ start: dateStr + 'T00:00', end: dateStr + 'T23:59', display: 'background', color: '#e0e0e0', extendedProps: { is_default: true } });
                } else {
                    const ranges = info.ranges || (info.start && info.end ? [`${info.start}-${info.end}`] : []);
                    ranges.forEach(range => {
                        const [s, e] = range.split('-');
                        if (!s || !e) return;
                        calendar.addEvent({ start: dateStr + 'T' + s.trim(), end: dateStr + 'T' + e.trim(), display: 'background', color: '#d0f0d0', extendedProps: { is_default: true } });
                    });
                }
            }
        }

        // Debounce sync to avoid expensive repeated recalculations on rapid events
        function debounce(fn, wait) {
            let t = null;
            return function(...args) {
                if (t) clearTimeout(t);
                t = setTimeout(() => { try { fn.apply(this, args); } catch(e){}; t = null; }, wait);
            };
        }
        // Replace syncAvailabilityToCalendar with a debounced version to reduce CPU spikes
        syncAvailabilityToCalendar = debounce(syncAvailabilityToCalendar, 150);


    // 1️⃣ Function to mark past days grey
    function markPastDaysImmediately() {
        const calendarContainer = document.getElementById('calendar');
        if (!calendarContainer) return;

        // Avoid observing full calendar DOM changes (expensive).
        // Instead perform a single initial pass and rely on FullCalendar lifecycle
        // hooks (`eventsSet`, `datesSet`) which already call `updateUnavailableDays()`
        // when the calendar changes. Observing the entire subtree caused repeated
        // full DOM traversals and frequent calls to `updateUnavailableDays`, which
        // can be very CPU intensive when FullCalendar updates the view.
        (function applyPastClassesOnce() {
            document.querySelectorAll('.fc-daygrid-day').forEach(cell => {
                const dateStr = cell.dataset.date;
                const numberEl = cell.querySelector('.fc-daygrid-day-number');
                if (!numberEl) return;
                numberEl.classList.remove('past-day');
                if (isPastDate(dateStr)) numberEl.classList.add('past-day');
            });
            try { updateUnavailableDays(); } catch (e) { /* ignore errors during reapply */ }
        })();
    }

    // Return the first per-date timed override for a given date, or null.
    function findPerDateTimedOverride(dateStr) {
        try {
            const events = (typeof calendar.getEvents === 'function') ? calendar.getEvents() : [];
            for (const ev of events) {
                try {
                    if (!ev || ev.display !== 'background') continue;
                    if (!ev.extendedProps || !ev.extendedProps.is_per_date) continue;
                    // Only consider per-date overrides in the currently selected scope
                    try {
                        if (SELECTED_MEMBER) {
                            const xp = ev.extendedProps || {};
                            if (String(SELECTED_MEMBER).startsWith('svc:')) {
                                const svcId = String(SELECTED_MEMBER).slice(4);
                                const assignedSvc = (xp.assigned_scope_service_id || xp.assigned_scope_service || null);
                                if (!assignedSvc || String(assignedSvc) !== String(svcId)) continue;
                            } else {
                                const userId = getSelectedUserIdForMembership(SELECTED_MEMBER);
                                const assignedUserId = xp.assigned_user_id || null;
                                const assignedMembershipId = xp.assigned_membership_id || null;
                                if (userId && assignedUserId && String(assignedUserId) !== String(userId)) continue;
                                if (!userId && assignedMembershipId && String(assignedMembershipId) !== String(SELECTED_MEMBER)) continue;
                            }
                        }
                    } catch (e) { /* ignore scope check errors */ }
                    if (!ev.start || !ev.end) continue;
                    const evDate = formatYMD(ev.start);
                    if (evDate !== dateStr) continue;
                    // Skip full-day blocks
                    const isFullDay = ev.startStr && ev.endStr && ev.startStr.endsWith('T00:00') && ev.endStr.endsWith('T23:59');
                    if (isFullDay) continue;
                    const sH = String(ev.start.getHours()).padStart(2, '0');
                    const sM = String(ev.start.getMinutes()).padStart(2, '0');
                    const eH = String(ev.end.getHours()).padStart(2, '0');
                    const eM = String(ev.end.getMinutes()).padStart(2, '0');
                    return { start: `${sH}:${sM}`, end: `${eH}:${eM}` };
                } catch (ie) { /* ignore */ }
            }
        } catch (e) { /* ignore */ }
        return null;
    }

    // Return all per-date timed overrides for a given date (array)
    function findPerDateTimedOverrides(dateStr) {
        const out = [];
        try {
            const events = (typeof calendar.getEvents === 'function') ? calendar.getEvents() : [];
            for (const ev of events) {
                try {
                    if (!ev || ev.display !== 'background') continue;
                    if (!ev.extendedProps || !ev.extendedProps.is_per_date) continue;
                    // Only include per-date overrides in the currently selected scope
                    try {
                        if (SELECTED_MEMBER) {
                            const xp = ev.extendedProps || {};
                            if (String(SELECTED_MEMBER).startsWith('svc:')) {
                                const svcId = String(SELECTED_MEMBER).slice(4);
                                const assignedSvc = (xp.assigned_scope_service_id || xp.assigned_scope_service || null);
                                if (!assignedSvc || String(assignedSvc) !== String(svcId)) continue;
                            } else {
                                const userId = getSelectedUserIdForMembership(SELECTED_MEMBER);
                                const assignedUserId = xp.assigned_user_id || null;
                                const assignedMembershipId = xp.assigned_membership_id || null;
                                if (userId && assignedUserId && String(assignedUserId) !== String(userId)) continue;
                                if (!userId && assignedMembershipId && String(assignedMembershipId) !== String(SELECTED_MEMBER)) continue;
                            }
                        }
                    } catch (e) { /* ignore scope check errors */ }
                    if (!ev.start || !ev.end) continue;
                    const evDate = formatYMD(ev.start);
                    if (evDate !== dateStr) continue;
                    const isFullDay = ev.startStr && ev.endStr && ev.startStr.endsWith('T00:00') && ev.endStr.endsWith('T23:59');
                    if (isFullDay) continue;
                    const sH = String(ev.start.getHours()).padStart(2, '0');
                    const sM = String(ev.start.getMinutes()).padStart(2, '0');
                    const eH = String(ev.end.getHours()).padStart(2, '0');
                    const eM = String(ev.end.getMinutes()).padStart(2, '0');
                    out.push({ start: `${sH}:${sM}`, end: `${eH}:${eM}` });
                } catch (ie) { /* ignore */ }
            }
        } catch (e) { /* ignore */ }
        return out;
    }

    // Create a UI row for a modal range (start/end + remove)
    function createModalRangeRow(startVal = '09:00', endVal = '17:00') {
        const row = document.createElement('div');
        row.className = 'modal-range-row';
        row.style.display = 'flex';
        row.style.alignItems = 'center';
        row.style.justifyContent = 'center';
        row.style.gap = '8px';

        const startLabel = document.createElement('label');
        startLabel.textContent = 'Start:';
        startLabel.style.minWidth = '45px';
        startLabel.style.textAlign = 'right';

        // Wrap the start input to position the custom picker relative to it
        const startContainer = document.createElement('div');
        startContainer.className = 'time-input-container';
        const start = document.createElement('input');
        start.type = 'time';
        start.className = 'modal-range-start';
        start.value = startVal;
        start.readOnly = true; // use custom time picker for consistency
        startContainer.appendChild(start);
        // Open custom picker on click
        start.style.cursor = 'pointer';
        start.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            try {
                document.querySelectorAll('.custom-time-picker').forEach(p => p.remove());
                const picker = (typeof createCustomTimePickerGlobal === 'function' ? createCustomTimePickerGlobal : createCustomTimePicker)(start);
                picker.classList.add('active');
                startContainer.appendChild(picker);
            } catch (err) { /* ignore */ }
        });

        const endLabel = document.createElement('label');
        endLabel.textContent = 'End:';
        endLabel.style.minWidth = '40px';
        endLabel.style.textAlign = 'right';

        // Wrap the end input to position the custom picker relative to it
        const endContainer = document.createElement('div');
        endContainer.className = 'time-input-container';
        const end = document.createElement('input');
        end.type = 'time';
        end.className = 'modal-range-end';
        end.value = endVal;
        end.readOnly = true; // use custom time picker for consistency
        endContainer.appendChild(end);
        // Open custom picker on click
        end.style.cursor = 'pointer';
        end.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            try {
                document.querySelectorAll('.custom-time-picker').forEach(p => p.remove());
                const picker = (typeof createCustomTimePickerGlobal === 'function' ? createCustomTimePickerGlobal : createCustomTimePicker)(end);
                picker.classList.add('active');
                endContainer.appendChild(picker);
            } catch (err) { /* ignore */ }
        });

        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.textContent = 'Remove';
        removeBtn.style.padding = '6px 8px';
        removeBtn.style.border = 'none';
        removeBtn.style.background = '#dc3545';
        removeBtn.style.color = 'white';
        removeBtn.style.borderRadius = '6px';
        removeBtn.style.cursor = 'pointer';
        removeBtn.onclick = () => row.remove();

        row.appendChild(startLabel);
        row.appendChild(startContainer);
        row.appendChild(endLabel);
        row.appendChild(endContainer);
        row.appendChild(removeBtn);
        return row;
    }

    // Call after calendar.render()
    // If the edit_service page requested opening the Day Schedule modal for a service,
    // compute the next available date (based on the service's weekly_map) and open it.
    (function autoOpenDaySchedule(){
        try{
            // Prefer localStorage keys for a clean redirect; fall back to query params
            let autoService = null, autoDate = null;
            try {
                const lsSvc = localStorage.getItem('cc_auto_open_service');
                const lsDate = localStorage.getItem('cc_auto_open_date');
                if (lsSvc) {
                    autoService = lsSvc;
                    autoDate = lsDate || "";
                    // clear keys so this only runs once
                    try { localStorage.removeItem('cc_auto_open_service'); } catch(e){}
                    try { localStorage.removeItem('cc_auto_open_date'); } catch(e){}
                }
            } catch (e) {
                // localStorage may be unavailable; ignore
            }
            if (!autoService) {
                if (AUTO_OPEN_SERVICE && AUTO_OPEN_DATE) {
                    autoService = AUTO_OPEN_SERVICE;
                    autoDate = AUTO_OPEN_DATE;
                }
            }
            if (!autoService || !autoDate) return;

            // Find the service by id (autoService may be string)
            const svcId = String(autoService);
            const svc = svcById(svcId);
            if (!svc) return;

            // helper: format Date to YYYY-MM-DD
            function formatYMD(d){
                const y = d.getFullYear();
                const m = String(d.getMonth()+1).padStart(2,'0');
                const dd = String(d.getDate()).padStart(2,'0');
                return `${y}-${m}-${dd}`;
            }

            // parse autoDate as local date
            const parts = (autoDate || '').split('-');
            let startDate = null;
            if (parts.length === 3){
                startDate = new Date(Number(parts[0]), Number(parts[1]) - 1, Number(parts[2]));
            } else {
                startDate = new Date();
            }

            // weekly_map expected: array length 7, each item is array of ranges like ['09:00-12:00']
            const weekly = Array.isArray(svc.weekly_map) ? svc.weekly_map : [[],[],[],[],[],[],[]];

            // scan up to 365 days forward for a weekday that has availability
            let foundDate = null;
            for (let i=0;i<365;i++){
                const d = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate() + i);
                const dow = d.getDay(); // 0=Sunday..6=Saturday
                const ranges = weekly[dow] || [];
                if (Array.isArray(ranges) && ranges.length > 0){
                    foundDate = d;
                    break;
                }
            }

            if (!foundDate) {
                // no weekly availability; fallback to the provided date
                try { foundDate = new Date(startDate); } catch(e){ foundDate = new Date(); }
            }

            // Build ranges object for the modal: convert 'HH:MM-HH:MM' -> {start, end}
            const dow = foundDate.getDay();
            const rawRanges = (weekly[dow] && Array.isArray(weekly[dow])) ? weekly[dow] : [];
            const modalRanges = rawRanges.map(r => {
                const p = (r || '').split('-');
                return { start: (p[0]||'09:00').trim(), end: (p[1]||'17:00').trim() };
            });

            // Determine client increment (fixed increments use duration+buffer_after)
            let increment = Number(svc.time_increment_minutes || 30);
            try {
                if (svc.use_fixed_increment) {
                    const dur = Number(svc.duration || 0);
                    const buf = Number(svc.buffer_after || 0);
                    if (!isNaN(dur) && !isNaN(buf) && (dur + buf) > 0) {
                        increment = dur + buf;
                    }
                }
            } catch (e) { /* ignore */ }

            // Delay opening slightly to ensure calendar cells & modal DOM exist
            setTimeout(() => {
                try{
                    const dateStr = formatYMD(foundDate);
                    // openTimeCirclesModal used for Day Schedule
                    if (typeof openTimeCirclesModal === 'function'){
                        openTimeCirclesModal(dateStr, increment, 1, modalRanges);
                    } else {
                        // fallback: highlight the day cell
                        const cell = document.querySelector(`.fc-daygrid-day[data-date="${dateStr}"] .fc-daygrid-day-number`);
                        if (cell) cell.classList.add('selected');
                    }
                } catch (e){ console.warn('autoOpenDaySchedule failed', e); }
            }, 300);

        } catch (e) { /* ignore */ }
    })();
    markPastDaysImmediately();

    // Render a table of per-date overrides (available/unavailable) based on calendar background events
    function renderOverridesTable() {
        const tbody = document.getElementById('overridesTableBody');
        if (!tbody) return;
        tbody.innerHTML = '';

        // Update month label in header
        try {
            const selSpan = document.getElementById('overridesHeaderSelection');
            const monthSpan = document.getElementById('overridesHeaderMonth');
            if (monthSpan && calendar) {
                const currentDate = calendar.getDate ? calendar.getDate() : new Date();
                const monthName = currentDate.toLocaleString('default', { month: 'long' });
                monthSpan.textContent = monthName;
                if (selSpan) selSpan.textContent = getSelectionLabel();
            }
        } catch (e) { /* ignore month label errors */ }

        // Header controls: normalize to 4 columns (Date, Type, Time Ranges, Actions); re-add Reset All button; no group actions
        try {
            const table = document.getElementById('overridesTable');
            const thead = table ? table.querySelector('thead') : null;
            const headerRow = thead ? thead.querySelector('tr') : null;
            if (headerRow) {
                // Trim extra columns if any
                while (headerRow.children.length > 4) {
                    headerRow.removeChild(headerRow.lastElementChild);
                }
                // Ensure headings
                if (headerRow.children[0]) headerRow.children[0].textContent = 'Date';
                if (headerRow.children[1]) headerRow.children[1].textContent = 'Type';
                if (headerRow.children[2]) headerRow.children[2].textContent = 'Time Ranges';
                // Intentionally omit label text for 4th column (Actions) per request
                if (headerRow.children[3]) headerRow.children[3].textContent = '';

                // Ensure Reset All Overrides button exists in 4th header cell
                const resetTh = headerRow.children[3];
                if (resetTh) {
                    // Center the button in the header cell
                    resetTh.style.textAlign = 'center';
                    // Avoid duplicates
                    const existing = resetTh.querySelector('#resetAllOverridesBtn');
                    if (!existing) {
                        const resetBtn = document.createElement('button');
                        resetBtn.id = 'resetAllOverridesBtn';
                        resetBtn.type = 'button';
                        resetBtn.textContent = 'Reset All Overrides';
                        resetBtn.style.padding = '6px 10px';
                        resetBtn.style.border = '1px solid #ccc';
                        resetBtn.style.borderRadius = '4px';
                        resetBtn.style.background = '#fff';
                        resetBtn.style.cursor = 'pointer';
                        resetTh.appendChild(resetBtn);

                        resetBtn.onclick = async () => {
                            if (!confirm('Reset ALL per-date overrides to weekly defaults?')) return;
                            const evs = (typeof calendar.getEvents === 'function') ? calendar.getEvents() : [];
                            const dates = [];
                            evs.forEach(ev => {
                                try {
                                    if (ev.display !== 'background') return;
                                    const isPer = ev.extendedProps && ev.extendedProps.is_per_date;
                                    if (!isPer) return;
                                    const s = ev.startStr || (ev.start ? ev.start.toISOString() : null);
                                    if (!s) return;
                                    const d = s.split('T')[0];
                                    if (dates.indexOf(d) === -1) dates.push(d);
                                } catch (e) {}
                            });

                            if (dates.length === 0) {
                                alert('No per-date overrides to reset.');
                                return;
                            }

                            // Prevent reset-all if weekly defaults would exclude existing bookings.
                            try {
                                const bad = [];
                                for (const d of dates) {
                                    const weekly = _weeklyDefaultRangesForDate(d);
                                    const verdict = _validateOverrideAgainstBookings(d, weekly);
                                    if (!verdict.ok) {
                                        bad.push(verdict.message || (`Reset blocked for ${d} due to existing booking(s).`));
                                        if (bad.length >= 5) break;
                                    }
                                }
                                if (bad.length) {
                                    alert(bad.join('\n\n'));
                                    return;
                                }
                            } catch (e) { /* ignore */ }

                            try {
                                const res = await fetch(`/bus/${orgSlug}/bookings/batch_delete/`, {
                                    method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken }, body: JSON.stringify({ dates, target: (SELECTED_MEMBER || null) })
                                });
                                const data = await res.json().catch(() => null);
                                if (res.ok) {
                                    // Immediately remove per-date background events from the current scope so
                                    // the overrides table can't stay stale even if refetch is slow.
                                    try {
                                        const svcScope = (typeof _svcForSelectedScope === 'function') ? _svcForSelectedScope() : null;
                                        const isSvc = !!(SELECTED_MEMBER && String(SELECTED_MEMBER).startsWith('svc:'));
                                        const svcId = isSvc ? String(SELECTED_MEMBER).slice(4) : null;
                                        const userId = (!isSvc && SELECTED_MEMBER) ? getSelectedUserIdForMembership(SELECTED_MEMBER) : null;
                                        const membershipId = (!isSvc && SELECTED_MEMBER) ? String(SELECTED_MEMBER) : null;

                                        (calendar.getEvents() || []).forEach(ev => {
                                            try {
                                                if (!ev || ev.display !== 'background') return;
                                                const xp = ev.extendedProps || {};
                                                if (!xp.is_per_date) return;

                                                // Scope match
                                                if (SELECTED_MEMBER) {
                                                    if (isSvc) {
                                                        const assignedSvc = (xp.assigned_scope_service_id || xp.assigned_scope_service || null);
                                                        if (!assignedSvc || String(assignedSvc) !== String(svcId)) return;
                                                    } else {
                                                        const assignedUserId = xp.assigned_user_id || null;
                                                        const assignedMembershipId = xp.assigned_membership_id || null;
                                                        if (userId && assignedUserId && String(assignedUserId) !== String(userId)) return;
                                                        if (!userId && assignedMembershipId && String(assignedMembershipId) !== String(membershipId)) return;
                                                    }
                                                }
                                                ev.remove();
                                            } catch (e) {}
                                        });
                                    } catch (e) {}

                                    try { if (typeof _invalidateServiceScopeParityCache === 'function') _invalidateServiceScopeParityCache(); } catch (e) {}
                                    try { renderOverridesTable(); } catch (e) {}
                                    try { updateUnavailableDays(); } catch (e) {}
                                    // Still refetch to ensure canonical state
                                    try { await calendar.refetchEvents(); } catch (e) {}
                                    try { renderOverridesTable(); } catch (e) {}
                                    try { updateUnavailableDays(); } catch (e) {}
                                    alert('All per-date overrides reset.');
                                } else {
                                    const msg = (data && (data.error || data.message)) || `Server returned ${res.status}`;
                                    alert('Error resetting: ' + msg);
                                }
                            } catch (err) {
                                console.error('Reset all failed', err);
                                alert('Error resetting: ' + (err && err.message ? err.message : String(err)));
                            }
                        };
                    }
                }
            }
        } catch (e) { /* ignore header setup errors */ }

        const events = (typeof calendar.getEvents === 'function') ? calendar.getEvents() : [];
        const perDate = {}; // date -> { rangesSet: Set, items: [] }

        function fmtTime(h, m) {
            const hh = parseInt(h,10);
            const mm = parseInt(m,10);
            const ampm = hh >= 12 ? 'PM' : 'AM';
            let hour = hh % 12;
            if (hour === 0) hour = 12;
            return `${hour}:${String(mm).padStart(2,'0')} ${ampm}`;
        }

        events.forEach(ev => {
            try {
                if (ev.display !== 'background') return;
                const props = ev.extendedProps || {};
                if (!props.is_per_date) return;
                const startStr = ev.startStr || (ev.start ? ev.start.toISOString() : null);
                if (!startStr) return;
                const date = startStr.split('T')[0];

                let sH = 0, sM = 0, eH = 23, eM = 59;
                if (ev.start && ev.start.getHours) { sH = ev.start.getHours(); sM = ev.start.getMinutes(); }
                else if (startStr.split('T')[1]) { const parts = startStr.split('T')[1].split(':'); sH = parseInt(parts[0]||'0',10); sM = parseInt(parts[1]||'0',10); }
                if (ev.end && ev.end.getHours) { eH = ev.end.getHours(); eM = ev.end.getMinutes(); }
                else if (ev.endStr && ev.endStr.split('T')[1]) { const parts = ev.endStr.split('T')[1].split(':'); eH = parseInt(parts[0]||'23',10); eM = parseInt(parts[1]||'59',10); }
                if (!perDate[date]) perDate[date] = { rangesSet: new Set(), items: [], blocked: false };
                const fullDay = (sH === 0 && sM === 0 && eH === 23 && eM === 59);
                if (props.override_type === 'blocked' && fullDay) {
                    perDate[date].blocked = true;
                } else {
                    const key = `${sH}:${sM}-${eH}:${eM}`;
                    if (!perDate[date].rangesSet.has(key)) {
                        perDate[date].rangesSet.add(key);
                        perDate[date].items.push({ startH: sH, startM: sM, endH: eH, endM: eM });
                    }
                }
            } catch (e) { /* ignore */ }
        });

        // Ensure earlier ranges render to the left: sort by ascending start time
        Object.keys(perDate).forEach(d => {
            const entry = perDate[d];
            if (entry && Array.isArray(entry.items)) {
                entry.items.sort((a,b) => (a.startH*60 + a.startM) - (b.startH*60 + b.startM));
            }
        });

        // cache for group ops
        window._perDateOverridesCache = perDate;

        const dates = Object.keys(perDate).sort();
        if (dates.length === 0) {
            const r = document.createElement('tr');
            r.innerHTML = '<td colspan="4" style="text-align:center; color:#666; padding:12px;">No per-date overrides</td>';
            tbody.appendChild(r);
            return;
        }

        dates.forEach(d => {
            const entry = perDate[d];
            const items = entry.items;
            const type = entry.blocked ? 'Blocked' : 'Available';
            let times = '';
            if (entry.blocked) {
                times = 'Blocked (Full Day)';
            } else if (items.length === 0) {
                times = 'No ranges';
            } else {
                const rngs = items.map(it => fmtTime(it.startH, it.startM) + ' - ' + fmtTime(it.endH, it.endM));
                times = rngs.join('; ');
            }

            const row = document.createElement('tr');
            row.style.borderBottom = '1px solid #eee';
            row.setAttribute('data-date', d);

            const tdDate = document.createElement('td');
            tdDate.style.padding = '8px';
            // Format YYYY-MM-DD as Mon D, YYYY (e.g., Nov 9, 2025)
            try {
                const parts = d.split('-');
                if (parts.length === 3) {
                    const y = parseInt(parts[0],10), m = parseInt(parts[1],10)-1, day = parseInt(parts[2],10);
                    const dt = new Date(y, m, day);
                    const monthShort = dt.toLocaleString('default', { month: 'short' });
                    tdDate.textContent = `${monthShort} ${day}, ${y}`;
                } else {
                    tdDate.textContent = d;
                }
            } catch (e) { tdDate.textContent = d; }
            const tdType = document.createElement('td'); tdType.style.padding = '8px'; tdType.textContent = type;
            const tdTimes = document.createElement('td'); tdTimes.style.padding = '8px'; tdTimes.textContent = times;
            const tdAction = document.createElement('td'); tdAction.style.padding = '8px';
            const tdSelect = document.createElement('td'); tdSelect.style.padding = '8px';

            const resetBtn = document.createElement('button');
            resetBtn.type = 'button';
            resetBtn.textContent = 'Reset';
            resetBtn.setAttribute('data-label', 'Reset');
            resetBtn.classList.add('overrides-btn');
            // Use class-based styling; avoid inline white background which can hide white text
            resetBtn.style.padding = '';
            resetBtn.style.border = '';
            resetBtn.style.borderRadius = '';
            resetBtn.style.background = '';
            resetBtn.style.cursor = '';
            try { if (isPastDate(d)) { resetBtn.disabled = true; resetBtn.title = 'Cannot reset past dates'; resetBtn.style.opacity = '0.6'; resetBtn.style.cursor = 'not-allowed'; } } catch(e) {}

            resetBtn.onclick = async () => {
                if (!confirm(`Reset ${d} to weekly defaults? This will remove per-date overrides for this date.`)) return;

                // Prevent reset if weekly defaults would exclude existing bookings.
                try {
                    const weekly = _weeklyDefaultRangesForDate(d);
                    const verdict = _validateOverrideAgainstBookings(d, weekly);
                    if (!verdict.ok) { alert(verdict.message || 'This day already has a booking.'); return; }
                } catch (e) { /* ignore */ }
                resetBtn.disabled = true;
                try {
                    const res = await fetch(`/bus/${orgSlug}/bookings/batch_delete/`, {
                        method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken }, body: JSON.stringify({ dates: [d], target: (SELECTED_MEMBER || null) })
                    });
                    const data = await res.json().catch(() => null);
                    if (res.ok) {
                        try { calendar.getEvents().forEach(ev => { try { if (ev.display === 'background' && ev.startStr && ev.startStr.startsWith(d)) ev.remove(); } catch(e){} }); } catch(e){}
                        try { await calendar.refetchEvents(); } catch(e){}
                        try { updateUnavailableDays(); } catch(e){}
                        try { renderOverridesTable(); } catch(e){}
                        alert('Reset to weekly defaults completed.');
                    } else {
                        const msg = (data && (data.error || data.message)) || `Server returned ${res.status}`;
                        alert('Error resetting: ' + msg);
                        try { await calendar.refetchEvents(); } catch(e){}
                        try { updateUnavailableDays(); } catch(e){}
                    }
                } catch (err) {
                    console.error('Reset request failed', err);
                    alert('Error: ' + (err && err.message ? err.message : String(err)));
                    try { await calendar.refetchEvents(); } catch(e){}
                    try { updateUnavailableDays(); } catch(e){}
                } finally { try { resetBtn.disabled = isPastDate(d); } catch(e) { resetBtn.disabled = false; } }
            };

            const selectBtn = document.createElement('button');
            selectBtn.type = 'button';
            selectBtn.className = 'override-select-btn';
            selectBtn.textContent = 'Select';
            selectBtn.setAttribute('data-label', 'Select');
            selectBtn.classList.add('overrides-btn');
            // Use class-based styling; avoid inline white background which can hide white text
            selectBtn.style.padding = '';
            selectBtn.style.border = '';
            selectBtn.style.borderRadius = '';
            selectBtn.style.background = '';
            selectBtn.style.cursor = '';
            selectBtn.onclick = () => {
                try { openMakeAvailableModal(d); } catch (e) { console.error('Failed to open edit modal for', d, e); }
            };

            tdSelect.appendChild(selectBtn);
            tdAction.appendChild(resetBtn);
            row.appendChild(tdDate); row.appendChild(tdType); row.appendChild(tdTimes); row.appendChild(tdAction); row.appendChild(tdSelect);
            tbody.appendChild(row);
        });
    }

    // Bulk edit modal using the existing timeModal
    async function openBulkEditModal(dates, initRanges) {
        if (!CAN_USE_OVERRIDES) {
            ccPromptOverridesUpgrade();
            return;
        }
        const modal = document.getElementById('timeModal');
        const rangesContainer = document.getElementById('modalRangesContainer');
        const addBtn = document.getElementById('addModalRangeBtn');
        const saveBtnEl = document.getElementById('saveTimeBtn');
        const closeBtnEl = document.getElementById('closeTimeBtn');
        const makeUnavailableBtn = document.getElementById('makeUnavailableBtn');

        try { rangesContainer.innerHTML = ''; } catch(e) {}
        if (Array.isArray(initRanges) && initRanges.length) {
            const seen = new Set();
            initRanges.forEach(r => {
                try {
                    const [s,e] = r.split('-');
                    const key = `${s}-${e}`;
                    if (!seen.has(key)) { seen.add(key); rangesContainer.appendChild(createModalRangeRow(s,e)); }
                } catch (er) {}
            });
        } else {
            rangesContainer.appendChild(createModalRangeRow('09:00','17:00'));
        }
        if (addBtn) addBtn.onclick = () => rangesContainer.appendChild(createModalRangeRow('09:00','17:00'));

        // Adjust visibility for bulk: always show ranges; hide makeUnavailable (use Delete Selected instead)
        try { rangesContainer.style.display = ''; } catch(e){}
        try { if (makeUnavailableBtn) makeUnavailableBtn.style.display = 'none'; } catch(e){}

        modal.style.display = 'flex';

        // Temporarily override handlers
        const prevSave = saveBtnEl.onclick;
        const prevClose = closeBtnEl.onclick;
        let restored = false;
        function restoreHandlers() { if (restored) return; restored = true; saveBtnEl.onclick = prevSave; closeBtnEl.onclick = prevClose; }

        saveBtnEl.onclick = async () => {
            // Gather ranges
            const rows = Array.from(rangesContainer.querySelectorAll('.modal-range-row'));
            const ranges = [];
            for (const r of rows) {
                try {
                    const s = r.querySelector('.modal-range-start').value;
                    const e = r.querySelector('.modal-range-end').value;
                    if (s && e && s < e) ranges.push({ start: s, end: e });
                } catch (ie) {}
            }
            // Deduplicate
            const unique = [];
            const seen = new Set();
            for (const rr of ranges) { const k = `${rr.start}-${rr.end}`; if (!seen.has(k)) { seen.add(k); unique.push(rr); } }

            // Prevent overrides that would conflict with existing bookings.
            try {
                const bad = [];
                for (const d of (dates || [])) {
                    const rangesToCheck = unique.length ? unique : _weeklyDefaultRangesForDate(d);
                    const verdict = _validateOverrideAgainstBookings(d, rangesToCheck);
                    if (!verdict.ok) {
                        bad.push(verdict.message || (`Override blocked for ${d} due to existing booking(s).`));
                        if (bad.length >= 5) break;
                    }
                }
                if (bad.length) {
                    alert(bad.join('\n\n'));
                    return;
                }
            } catch (e) { /* ignore */ }

            try {
                // Remove existing overrides for these dates
                await fetch(`/bus/${orgSlug}/bookings/batch_delete/`, { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken }, body: JSON.stringify({ dates, target: (SELECTED_MEMBER || null) }) });

                if (unique.length === 0) {
                    // No ranges -> simply deleted (reverts to weekly defaults)
                } else {
                    // Create new ranges; batch by each distinct range across all selected dates
                    for (const rr of unique) {
                        await fetch(`/bus/${orgSlug}/bookings/batch_create/`, {
                            method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                            body: JSON.stringify({ dates, start_time: rr.start, end_time: rr.end, target: (SELECTED_MEMBER || null) })
                        });
                    }
                }
                try { await calendar.refetchEvents(); } catch(e){}
                try { updateUnavailableDays(); } catch(e){}
                try { renderOverridesTable(); } catch(e){}
                alert('Bulk update applied.');
            } catch (err) {
                console.error('Bulk update failed', err);
                alert('Error applying bulk update.');
            }

            modal.style.display = 'none';
            restoreHandlers();
        };
        closeBtnEl.onclick = () => { modal.style.display = 'none'; restoreHandlers(); };
    }

    function updateClearButton() {
        clearBtn.style.display = selectedDates.size > 0 ? 'inline-block' : 'none';
        // Reset select button text if no dates selected
        if (selectedDates.size === 0) {
            selectBtn.textContent = "Select Day";
        }
    }

    // Open a small modal to make a single (previously-unavailable) date available
    function openMakeAvailableModal(dateStr) {
        if (!CAN_USE_OVERRIDES) {
            ccPromptOverridesUpgrade();
            return;
        }
        const modal = document.getElementById('timeModal');
        const rangesContainer = document.getElementById('modalRangesContainer');
        const addBtn = document.getElementById('addModalRangeBtn');
        const saveBtnEl = document.getElementById('saveTimeBtn');
        const closeBtnEl = document.getElementById('closeTimeBtn');

        // Clear existing rows
        try { rangesContainer.innerHTML = ''; } catch (e) { /* ignore */ }

        // Populate ranges: prefer per-date overrides, otherwise weekly defaults, otherwise sensible fallback
            try {
                const overrides = findPerDateTimedOverrides(dateStr);
                if (overrides && overrides.length) {
                    // dedupe overrides by start-end
                    const seen = new Set();
                    // sort by ascending start time
                    const sorted = overrides.slice().sort((a,b) => {
                        const [ah, am] = (a.start||'00:00').split(':').map(x=>parseInt(x,10)||0);
                        const [bh, bm] = (b.start||'00:00').split(':').map(x=>parseInt(x,10)||0);
                        return (ah*60+am) - (bh*60+bm);
                    });
                    sorted.forEach(o => {
                        try {
                            const k = `${o.start}-${o.end}`;
                            if (!seen.has(k)) { seen.add(k); rangesContainer.appendChild(createModalRangeRow(o.start, o.end)); }
                        } catch (er) { /* ignore */ }
                    });
                } else {
                const d = parseYMD(dateStr);
                const dow = d.getDay();
                const info = defaultAvailability[dow] || {};
                const ranges = info.ranges && info.ranges.length ? info.ranges : (info.start && info.end ? [`${info.start}-${info.end}`] : []);
                if (ranges && ranges.length) {
                    // sort by ascending start time
                    const sortedRanges = ranges.slice().sort((ra, rb) => {
                        try {
                            const [sa] = ra.split('-'); const [sb] = rb.split('-');
                            const [ah, am] = (sa||'00:00').split(':').map(x=>parseInt(x,10)||0);
                            const [bh, bm] = (sb||'00:00').split(':').map(x=>parseInt(x,10)||0);
                            return (ah*60+am) - (bh*60+bm);
                        } catch (er) { return 0; }
                    });
                    sortedRanges.forEach(r => {
                        try {
                            const parts = r.split('-');
                            const s = (parts[0]||'09:00').trim();
                            const e = (parts[1]||'17:00').trim();
                            rangesContainer.appendChild(createModalRangeRow(s, e));
                        } catch (er) { /* ignore row parse errors */ }
                    });
                } else {
                    rangesContainer.appendChild(createModalRangeRow('09:00','17:00'));
                }
            }
        } catch (e) { rangesContainer.appendChild(createModalRangeRow('09:00','17:00')); }

        // Wire Add Range
        if (addBtn) addBtn.onclick = () => rangesContainer.appendChild(createModalRangeRow('09:00','17:00'));

        // Decide visibility based on fully-unavailable status
        try { setModalTimeRowVisibility(dateStr); } catch (e) { /* ignore */ }

        // Ensure Save/Add buttons reflect current ranges visibility (important after optimistic updates)
        try {
            const rangesVisible = (document.getElementById('modalRangesContainer')?.style.display !== 'none');
            const saveBtn = document.getElementById('saveTimeBtn');
            const addBtnEl = document.getElementById('addModalRangeBtn');
            if (saveBtn) saveBtn.style.display = rangesVisible ? 'inline-block' : 'none';
            if (addBtnEl) addBtnEl.style.display = rangesVisible ? 'inline-block' : 'none';
        } catch (e) { /* ignore */ }

        modal.style.display = 'flex';

        // Temporarily override handlers
        const prevSave = saveBtnEl.onclick;
        const prevClose = closeBtnEl.onclick;
        let restored = false;
        function restoreHandlers() {
            if (restored) return; restored = true;
            saveBtnEl.onclick = prevSave;
            closeBtnEl.onclick = prevClose;
        }

        // Show Make Unavailable button for single-date modal
        const makeUnavailableBtn = document.getElementById('makeUnavailableBtn');
        if (makeUnavailableBtn) {
            makeUnavailableBtn.style.display = 'inline-block';
            const prevMakeUnavailable = makeUnavailableBtn.onclick;
            let restoredMake = false;
            function restoreMake() { if (restoredMake) return; restoredMake = true; makeUnavailableBtn.onclick = prevMakeUnavailable; }

            makeUnavailableBtn.onclick = async () => {
                if (!CAN_USE_OVERRIDES) {
                    ccPromptOverridesUpgrade();
                    try { modal.style.display = 'none'; } catch (e) {}
                    restoreHandlers();
                    restoreMake();
                    return;
                }

                // Prevent blocking a day that already has bookings in this scope.
                try {
                    const verdict = _validateOverrideAgainstBookings(dateStr, null);
                    if (!verdict.ok) { alert(verdict.message || 'This day already has a booking.'); return; }
                } catch (e) { /* ignore */ }
                if (!confirm(`Mark ${dateStr} as unavailable? This will block the whole day.`)) return;
                try {
                    const res = await fetch(`/bus/${orgSlug}/bookings/batch_create/`, { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken }, body: JSON.stringify({ dates: [dateStr], start_time: '00:00', end_time: '23:59', is_blocking: true, target: (SELECTED_MEMBER || null) }) });
                    const data = await res.json().catch(() => null);
                    if (res.ok) {
                        applyPerDateUnavailable(dateStr);
                        try { calendar.refetchEvents(); } catch(e){}
                        try { updateUnavailableDays(); } catch(e){}
                        alert('Date marked unavailable.');
                    } else {
                        const msg = (data && (data.error || data.message)) || `Server returned ${res.status}`;
                        alert('Error marking unavailable: ' + msg);
                    }
                } catch (err) { console.error('Make unavailable failed', err); alert('Error: ' + (err && err.message ? err.message : String(err))); }
                modal.style.display = 'none';
                restoreHandlers();
                restoreMake();
            };
        }

        // Save: collect ranges and create per-date overrides for this single date
        saveBtnEl.onclick = async () => {
            if (!CAN_USE_OVERRIDES) {
                ccPromptOverridesUpgrade();
                try { modal.style.display = 'none'; } catch (e) {}
                restoreHandlers();
                return;
            }
            const rows = Array.from(rangesContainer.querySelectorAll('.modal-range-row'));
            const ranges = [];
            for (const r of rows) {
                try {
                    const s = r.querySelector('.modal-range-start').value;
                    const e = r.querySelector('.modal-range-end').value;
                    if (s && e && s < e) ranges.push({ start: s, end: e });
                } catch (ie) { /* ignore */ }
            }

            // If coach removed all ranges for this single date, treat it as "make unavailable"
            if (ranges.length === 0) {
                // Prevent blocking a day that already has bookings in this scope.
                try {
                    const verdict = _validateOverrideAgainstBookings(dateStr, null);
                    if (!verdict.ok) { alert(verdict.message || 'This day already has a booking.'); return; }
                } catch (e) { /* ignore */ }
                if (!confirm(`No time ranges provided. Mark ${dateStr} as unavailable for the whole day?`)) return;
                try {
                    const res = await fetch(`/bus/${orgSlug}/bookings/batch_create/`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                        body: JSON.stringify({ dates: [dateStr], start_time: '00:00', end_time: '23:59', is_blocking: true, target: (SELECTED_MEMBER || null) })
                    });
                    const data = await res.json().catch(() => null);
                    if (res.ok) {
                        // Apply UI changes immediately
                        applyPerDateUnavailable(dateStr);
                        try { await calendar.refetchEvents(); } catch (e) {}
                        try { updateUnavailableDays(); } catch (e) {}
                        alert('Date marked unavailable.');
                    } else {
                        const msg = (data && (data.error || data.message)) || `Server returned ${res.status}`;
                        alert('Error marking unavailable: ' + msg);
                    }
                } catch (err) {
                    console.error('Make unavailable failed', err);
                    alert('Error: ' + (err && err.message ? err.message : String(err)));
                }

                modal.style.display = 'none';
                restoreHandlers();
                return;
            }

            // Deduplicate ranges by start-end to avoid creating duplicate per-date events
            const uniqueRanges = [];
            const seen = new Set();
            for (const rr of ranges) {
                try {
                    const k = `${rr.start}-${rr.end}`;
                    if (!seen.has(k)) { seen.add(k); uniqueRanges.push(rr); }
                } catch (e) { /* ignore malformed */ }
            }
            // replace ranges with unique set
            const rangesToCreate = uniqueRanges;

            // Prevent saving ranges that would exclude existing bookings.
            try {
                const verdict = _validateOverrideAgainstBookings(dateStr, rangesToCreate);
                if (!verdict.ok) { alert(verdict.message || 'This day already has a booking.'); return; }
            } catch (e) { /* ignore */ }

            try {
                // remove existing per-date overrides for the date
                try { await fetch(`/bus/${orgSlug}/bookings/batch_delete/`, { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken }, body: JSON.stringify({ dates: [dateStr], target: (SELECTED_MEMBER || null) }) }); } catch(e){}

                // Remove existing optimistic background events for this date before adding new ones
                try {
                    calendar.getEvents().forEach(ev => {
                        if (ev.display === 'background' && ev.startStr.startsWith(dateStr + 'T')) {
                            const props = ev.extendedProps || {};
                            if (props.override_type === 'available' || props.is_per_date) {
                                ev.remove();
                            }
                        }
                    });
                } catch (e) { /* ignore removal errors */ }

                for (const r of rangesToCreate) {
                    try {
                        // optimistic UI
                        const res = await fetch(`/bus/${orgSlug}/bookings/batch_create/`, { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken }, body: JSON.stringify({ dates: [dateStr], start_time: r.start, end_time: r.end, target: (SELECTED_MEMBER || null) }) });
                        const data = await res.json().catch(() => null);
                        if (!res.ok) console.warn('Error creating per-date range', r, data);
                        else {
                            // On success add event (avoid transient duplicate before server cleanup)
                            try { calendar.addEvent({ start: dateStr + 'T' + r.start, end: dateStr + 'T' + r.end, display: 'background', color: '#d0f0d0', extendedProps: Object.assign({ is_per_date: true, override_type: 'available', optimistic: true }, getScopePropsForSelection(SELECTED_MEMBER)) }); } catch(e){}
                        }
                    } catch (err) { console.error('range create failed', err); }
                }

                try { await calendar.refetchEvents(); } catch(e){}
                try { updateUnavailableDays(); } catch(e){}
                alert('Per-date availability saved.');
            } catch (err) { console.error('Save per-date failed', err); alert('Error saving: ' + (err && err.message ? err.message : String(err))); }

            modal.style.display = 'none';
            restoreHandlers();
        };

        closeBtnEl.onclick = () => { modal.style.display = 'none'; restoreHandlers(); try { window._highlightAll = false; } catch(e) {} };
    }

    function toggleDateSelection(dateStr) {
        const numberEl = document.querySelector(`.fc-daygrid-day[data-date="${dateStr}"] .fc-daygrid-day-number`);
        if (!numberEl) return;

        const isPast = isPastDate(dateStr);

        // --- Handle past-day logic ---
        if (isPast) {
            // If coach is already selecting future/present days, block it
            if ([...selectedDates].some(d => !isPastDate(d))) {
                alert("You can only select past days or available days — not both at the same time.");
                return;
            }

            // Instead of selecting, open details
            openPastDayModal(dateStr); // your custom function
            return;
        }

        // --- Handle available/future days ---
        // If currently has any past days selected, block this
        if ([...selectedDates].some(d => isPastDate(d))) {
            alert("You can only select past days or available days — not both at the same time.");
            return;
        }

        // Toggle highlight
        if (selectedDates.has(dateStr)) {
            selectedDates.delete(dateStr);
            numberEl.classList.remove('selected');
        } else {
            selectedDates.add(dateStr);
            numberEl.classList.add('selected');
        }

        updateClearButton();
        updateSelectButtonText();
    }

    // --- Add this function here ---
    function updateSelectButtonText() {
        const count = selectedDates.size;

        if (count === 0) {
            selectBtn.textContent = "Select Day";
        } else if (count === 1) {
            selectBtn.textContent = "Select Day";
        } else {
            selectBtn.textContent = `Select ${count} Days`;
        }
    }

    // Format YYYY-MM-DD -> "January 14th, 2026"
    function formatDateLong(ymd) {
        try {
            const d = parseYMD(ymd);
            const month = d.toLocaleString(undefined, { month: 'long' });
            const day = d.getDate();
            const year = d.getFullYear();
            // ordinal suffix with 11/12/13 special-case
            const v = day % 100;
            let suf = 'th';
            if (v < 11 || v > 13) {
                switch (day % 10) {
                    case 1: suf = 'st'; break;
                    case 2: suf = 'nd'; break;
                    case 3: suf = 'rd'; break;
                }
            }
            return `${month} ${day}${suf}, ${year}`;
        } catch (e) { return String(ymd); }
    }

        function resetClientViewStyles() {
            const clientSettings = document.getElementById("clientTimeSettings");
            clientSettings.style.display = "flex"; // show for present/future days
            clientSettings.style.flexDirection = "column"; // stack vertically
            clientSettings.style.gap = "10px";
            clientSettings.style.alignItems = "flex-start";
        }

        // This part runs once when the page loads
        function openPastDayModal(dateStr) {
            const modal = document.getElementById("timeCirclesModal");
            const container = document.getElementById("timeCirclesContainer");
            const title = document.getElementById("circleModalTitle");

            // Coach preference elements
            const coachHourBlockSelect = document.getElementById("hourBlockSelect");
            const coachIncrementSelect = document.getElementById("incrementSelect");
            const coachCustomBlockContainer = document.getElementById("customBlockInputContainer");
            const coachCustomBlockInput = document.getElementById("customBlockInput");
            const coachApplyCustomBlockBtn = document.getElementById("applyCustomBlockBtn");
            const coachCustomIncrementContainer = document.getElementById("customIncrementContainer");
            const coachCustomIncrementInput = document.getElementById("customIncrementInput");
            const coachApplyCustomIncrementBtn = document.getElementById("applyCustomIncrementBtn");

            // Hide client settings for past days
            document.getElementById("clientTimeSettings").style.display = "none";

            // Show modal
            modal.style.display = "flex";
            title.textContent = `Schedule for ${formatDateLong(dateStr)}`;
            container.innerHTML = "";

            // Initialize block size & increment
            let currentBlockSize = parseInt(coachHourBlockSelect.value);
            let currentIncrement = parseInt(coachIncrementSelect.value);

            // Render grid function
            function renderGrid(blockSize) {
                container.innerHTML = "";
                const startHour = 6;
                const endHour = 22;
                const blockMinutes = blockSize * 60;

                for (let blockStartHour = startHour; blockStartHour < endHour; blockStartHour += blockSize) {
                    const row = document.createElement("div");
                    row.style.display = "flex";
                    row.style.alignItems = "center";
                    row.style.justifyContent = "space-between";
                    row.style.gap = "8px";
            

                    // Hour label
                    const blockLabel = document.createElement("div");
                    const labelDate = parseYMD(dateStr);
                    labelDate.setHours(blockStartHour, 0, 0, 0);
                    blockLabel.textContent = labelDate.toLocaleString(undefined, { hour: 'numeric', hour12: true });
                    blockLabel.style.width = "70px";
                    blockLabel.style.fontWeight = "bold";
                    row.appendChild(blockLabel);

                    // Circles container
                    const circlesContainer = document.createElement("div");
                    circlesContainer.style.display = "flex";
                    circlesContainer.style.flexWrap = "wrap";
                    circlesContainer.style.gap = "8px";
                    circlesContainer.style.marginLeft = "auto"; // push only circles to right

                    for (let minutes = 0; minutes < blockMinutes; minutes += currentIncrement) {
                        const totalMinutes = blockStartHour*60 + minutes;
                        let hour = Math.floor(totalMinutes / 60);
                        const min = totalMinutes % 60;
                        const ampm = hour >= 12 ? "PM" : "AM";
                        hour = hour % 12;
                        if (hour === 0) hour = 12;
                        const timeLabel = `${hour}:${min.toString().padStart(2,'0')} ${ampm}`;

                        const circle = document.createElement("div");
                        circle.className = "time-circle open";
                        circle.textContent = timeLabel;
                        circle.dataset.time = timeLabel;

                        // Grey out past times (read-only)
                        const now = new Date();
                        const slotDate = parseYMD(dateStr);
                        slotDate.setHours(blockStartHour, min, 0, 0);
                        if (slotDate < now) circle.style.background = "#6c757d";

                        // Read-only click
                        circle.addEventListener("click", () => {
                            alert(`This slot (${timeLabel}) is read-only.`);
                        });

                        circlesContainer.appendChild(circle);
                    }

                    row.appendChild(circlesContainer);
                    container.appendChild(row);
                }

                if (container.lastElementChild) container.lastElementChild.style.borderBottom = "none";
            }

            renderGrid(currentBlockSize);

            // Coach hour block / increment handlers
            coachHourBlockSelect.onchange = () => {
                if (coachHourBlockSelect.value === "custom") coachCustomBlockContainer.style.display = "flex";
                else {
                    coachCustomBlockContainer.style.display = "none";
                    currentBlockSize = parseInt(coachHourBlockSelect.value);
                    renderGrid(currentBlockSize);
                }
            };
            coachApplyCustomBlockBtn.onclick = () => {
                const val = parseInt(coachCustomBlockInput.value);
                if (isNaN(val) || val < 15) return alert("Enter valid minutes 15+");
                coachCustomBlockContainer.style.display = "none";
                currentBlockSize = val / 60;
                renderGrid(currentBlockSize);
            };

            coachIncrementSelect.onchange = () => {
                if (coachIncrementSelect.value === "custom") {
                    coachCustomIncrementContainer.style.display = "flex";
                } else {
                    coachCustomIncrementContainer.style.display = "none";
                    currentIncrement = parseInt(coachIncrementSelect.value);
                    // Persist coach-chosen increment into client_view_settings so other pages sync
                    try {
                        const key = 'client_view_settings';
                        const raw = localStorage.getItem(key) || '{}';
                        let parsed = {};
                        try { parsed = JSON.parse(raw); } catch(_) { parsed = {}; }
                        parsed.increment = Number(coachIncrementSelect.value);
                        parsed.block = parsed.block || 1;
                        localStorage.setItem(key, JSON.stringify(parsed));
                        try { window.dispatchEvent(new Event('storage')); } catch(e){}
                    } catch (e) { /* ignore storage errors */ }
                    renderGrid(currentBlockSize);
                }
            };
            coachApplyCustomIncrementBtn.onclick = () => {
                const val = parseInt(coachCustomIncrementInput.value);
                if (isNaN(val) || val < 5) return alert("Enter valid increment 5+");
                coachCustomIncrementContainer.style.display = "none";
                currentIncrement = val;
                // Persist custom value to client_view_settings so other pages sync
                try {
                    const key = 'client_view_settings';
                    const raw = localStorage.getItem(key) || '{}';
                    let parsed = {};
                    try { parsed = JSON.parse(raw); } catch(_) { parsed = {}; }
                    parsed.increment = Number(val);
                    parsed.block = parsed.block || 1;
                    localStorage.setItem(key, JSON.stringify(parsed));
                    try { window.dispatchEvent(new Event('storage')); } catch(e){}
                } catch (e) { /* ignore */ }
                renderGrid(currentBlockSize);
            };

            // Close button works
            document.getElementById("closeCirclesBtn").onclick = () => {
                modal.style.display = "none";
                document.getElementById("clientTimeSettings").style.display = "flex"; // restore client settings
            };

            // Add circle CSS if not already
            if (!document.getElementById("timeCirclesStyle")) {
                const style = document.createElement("style");
                style.id = "timeCirclesStyle";
                style.innerHTML = `
                    .time-circle {
                        width: 80px; height: 80px; border-radius: 50%;
                        display: flex; justify-content: center; align-items: center;
                        cursor: pointer; font-size: 13px; color: white; transition: transform 0.1s ease;
                    }
                    .time-circle.open { background: #28a745; }
                    .time-circle.booked { background: #dc3545; }
                    .time-circle.blocked { background: #6c757d; }
                    .time-circle:hover { transform: scale(1.1); }
                `;
                document.head.appendChild(style);
            }
        }


    function reapplySelections() {
        // Reapply selection highlights for any non-past day that is in selectedDates.
        // This includes both available and unavailable future days so selections
        // persist across FullCalendar re-renders.
        document.querySelectorAll('.fc-daygrid-day').forEach(cell => {
            const dateStr = cell.dataset.date;
            if (!dateStr) return;
            if (isPastDate(dateStr)) return; // skip past days
            if (selectedDates.has(dateStr)) {
                const numberEl = cell.querySelector('.fc-daygrid-day-number');
                if (numberEl) numberEl.classList.add('selected');
            } else {
                const numberEl = cell.querySelector('.fc-daygrid-day-number');
                if (numberEl) numberEl.classList.remove('selected');
            }
        });
    }

    function handleTimeSlotSelection(info) {
        const start = info.startStr;
        const end = info.endStr;

        // Example modal: ask whether to mark as available or block off
        const choice = confirm(`Mark time ${start} - ${end} as available? Click Cancel to block off.`);

        const color = choice ? '#4CAF50' : '#E74C3C'; // green for available, red for blocked

        calendar.addEvent({
            start: start,
            end: end,
            display: 'background',
            backgroundColor: color
        });

        // You can also send this to the backend via AJAX later
    }

        function openBookingModal(event) {
            const modal = document.getElementById('bookingModal');
            document.getElementById('clientName').textContent = event.extendedProps.client_name || 'Unknown';
            document.getElementById('lessonType').textContent = event.extendedProps.lesson_type || 'N/A';
            document.getElementById('lessonTime').textContent = `${event.start.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})} - ${event.end.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})}`;
            document.getElementById('paymentMethod').textContent = event.extendedProps.payment_method || 'N/A';

            modal.style.display = 'flex';

            document.getElementById('closeBookingBtn').onclick = () => {
                modal.style.display = 'none';
            };

            document.getElementById('viewClientBookingsBtn').onclick = () => {
                modal.style.display = 'none';
                // Later this could redirect to the client’s profile page:
                // window.location.href = `/coach/clients/${event.extendedProps.client_id}/bookings/`;
                alert('Show all bookings for this client');
            };
        }

    function openTimeCirclesModal(date, increment = 30, hourBlockSize = 1, rangesOrStart = null, endTime = null) {
        const modal = document.getElementById("timeCirclesModal");
        const container = document.getElementById("timeCirclesContainer");
        const title = document.getElementById("circleModalTitle");

        const coachHourBlockSelect = document.getElementById("hourBlockSelect");
        const coachIncrementSelect = document.getElementById("incrementSelect");
        const coachCustomBlockContainer = document.getElementById("customBlockInputContainer");
        const coachCustomBlockInput = document.getElementById("customBlockInput");
        const coachApplyCustomBlockBtn = document.getElementById("applyCustomBlockBtn");
        const coachCustomIncrementContainer = document.getElementById("customIncrementContainer");
        const coachCustomIncrementInput = document.getElementById("customIncrementInput");
        const coachApplyCustomIncrementBtn = document.getElementById("applyCustomIncrementBtn");

        resetClientViewStyles();

        modal.style.display = "flex";
        title.textContent = `Schedule for ${formatDateLong(date)}`;
        

        let currentBlockSize = hourBlockSize;
        let currentIncrement = increment;

        const svcScope = (typeof _svcForSelectedScope === 'function') ? _svcForSelectedScope() : null;
        const isServiceScope = !!(svcScope && svcScope.slug);
        let __svcEff = null;
        let __svcSlots = null;

        function _svcToIsoLocal(dateStr, hh, mm, ss) {
            try {
                const parts = String(dateStr).split('-');
                const y = Number(parts[0]);
                const m = Number(parts[1]);
                const d = Number(parts[2]);
                const pad = n => String(n).padStart(2, '0');
                return `${y}-${pad(m)}-${pad(d)}T${pad(hh)}:${pad(mm)}:${pad(ss || 0)}`;
            } catch (e) {
                return `${dateStr}T${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:00`;
            }
        }

        function _svcIsoToLocalMinutes(isoStr) {
            try {
                const m = String(isoStr || '').match(/T(\d{2}):(\d{2})/);
                if (!m) return null;
                const h = parseInt(m[1], 10);
                const mm = parseInt(m[2], 10);
                if (isNaN(h) || isNaN(mm)) return null;
                return h * 60 + mm;
            } catch (e) {
                return null;
            }
        }

        function _svcLabelFromMin(totalMin) {
            const h24 = Math.floor(totalMin / 60);
            const m = totalMin % 60;
            const ampm = h24 >= 12 ? 'PM' : 'AM';
            let h = h24 % 12; if (h === 0) h = 12;
            return `${h}:${String(m).padStart(2,'0')} ${ampm}`;
        }

        async function _fetchServiceScopeSlots() {
            if (!isServiceScope) return [];
            try {
                // Server-effective settings (parity with public)
                try {
                    const effUrl = `/bus/${orgSlug}/services/${svcScope.slug}/effective/?date=${encodeURIComponent(date)}`;
                    const effResp = await fetch(effUrl, { credentials: 'same-origin' });
                    if (effResp.ok) __svcEff = await effResp.json();
                } catch (e) { __svcEff = null; }

                const useFixed = (__svcEff && typeof __svcEff.use_fixed_increment === 'boolean') ? !!__svcEff.use_fixed_increment : !!svcScope.use_fixed_increment;
                const previewIncrement = Math.max(5, Number((__svcEff && __svcEff.time_increment_minutes) || svcScope.time_increment_minutes || currentIncrement || 30));
                currentIncrement = previewIncrement;

                let allowEndsForAvail = false;
                try {
                    allowEndsForAvail = (__svcEff && typeof __svcEff.allow_ends_after_availability === 'boolean') ? !!__svcEff.allow_ends_after_availability : !!svcScope.allow_ends_after_availability;
                } catch (e) { allowEndsForAvail = false; }

                const edgeVal = (function(){
                    try {
                        const raw = localStorage.getItem('edge_buffers_' + svcScope.slug);
                        if (raw === '1' || raw === 'true') return 1;
                        if (raw === '0' || raw === 'false') return 0;
                    } catch (e) {}
                    return 0;
                })();

                const startIso = _svcToIsoLocal(date, 0, 0, 0);
                const endIso = _svcToIsoLocal(date, 23, 59, 59);
                const incQuery = useFixed ? '' : `&inc=${previewIncrement}`;
                const cacheBuster = `&_t=${Date.now()}`;
                const availUrl = `/bus/${orgSlug}/services/${svcScope.slug}/availability/?start=${encodeURIComponent(startIso)}&end=${encodeURIComponent(endIso)}${incQuery}&edge_buffers=${edgeVal}&allow_ends_after_availability=${allowEndsForAvail?1:0}${cacheBuster}`;
                const resp = await fetch(availUrl, { credentials: 'same-origin' });
                if (!resp.ok) { __svcSlots = []; return []; }
                const slots = await resp.json();
                __svcSlots = Array.isArray(slots) ? slots : [];
                return __svcSlots;
            } catch (e) {
                console.error('service-scope availability fetch failed', e);
                __svcSlots = [];
                return [];
            }
        }

        // When coach changes preview increment or applies a custom increment,
        // update the visible time circles immediately so the modal reflects
        // the current preview settings.
        try {
            if (coachIncrementSelect) {
                coachIncrementSelect.addEventListener('change', function(){
                    try {
                        const val = coachIncrementSelect.value;
                        if (STANDARD_INCREMENTS.includes(val)) {
                            currentIncrement = Number(val);
                            if (coachCustomIncrementContainer) coachCustomIncrementContainer.style.display = 'none';
                        } else if (val === 'custom') {
                            if (coachCustomIncrementContainer) coachCustomIncrementContainer.style.display = 'flex';
                            const v = parseInt(coachCustomIncrementInput?.value || 0, 10);
                            if (!isNaN(v) && v > 0) currentIncrement = v;
                        }
                        try { renderGrid(currentBlockSize); } catch (e) { /* ignore render errors */ }
                    } catch (e) { /* ignore */ }
                });
            }

            if (coachApplyCustomIncrementBtn) {
                coachApplyCustomIncrementBtn.onclick = () => {
                    try {
                        const v = parseInt(coachCustomIncrementInput?.value || '', 10);
                        if (isNaN(v) || v < 5) return alert('Enter a valid increment (5+ minutes).');
                        currentIncrement = v;
                        // Persist coach preview to client view storage so other UI can reflect it
                        try {
                            const payload = Object.assign({}, readClientSettingsFromStorage(), { block: Number(coachHourBlockSelect?.value || currentBlockSize), increment: Number(v) });
                            writeClientSettingsToStorage(payload);
                        } catch (e) { /* ignore storage write failures */ }
                        try { renderGrid(currentBlockSize); } catch (e) { /* ignore */ }
                    } catch (e) { console.error('coach apply custom increment failed', e); alert('Unable to apply custom increment.'); }
                };
            }
        } catch (e) { /* defensive */ }

        // Initialize client/coach increment selects from shared storage so the
        // modal reflects any change made elsewhere (edit_service or another tab).
        try {
            const storedRaw = localStorage.getItem('client_view_settings');
            if (storedRaw) {
                const parsedStored = JSON.parse(storedRaw);
                if (parsedStored && typeof parsedStored.increment === 'number') {
                    currentIncrement = parsedStored.increment;
                    // Update client select if present. Do not add persistent options;
                    // instead switch to 'custom' and prefill custom inputs when needed.
                    const clientSelect = document.getElementById('clientIncrementSelect');
                    if (clientSelect) {
                        const s = String(parsedStored.increment);
                        if (STANDARD_INCREMENTS.includes(s)) {
                            clientSelect.value = s;
                        } else {
                            try { clientSelect.value = 'custom'; } catch (e) {}
                            const clientCustomContainer = document.getElementById('clientCustomIncrementContainer');
                            const clientCustomInput = document.getElementById('clientCustomIncrementInput');
                            if (clientCustomContainer && clientCustomInput) {
                                clientCustomContainer.style.display = 'inline-flex';
                                clientCustomInput.value = String(s);
                            }
                            if (sharedCustomIncrementContainer && sharedCustomIncrementInput) {
                                sharedCustomIncrementContainer.style.display = 'flex';
                                sharedCustomIncrementInput.value = String(s);
                            }
                        }
                    }
                    // Update coach select if present
                    const coachSelect = document.getElementById('incrementSelect');
                    const coachCustomInput = document.getElementById('customIncrementInput');
                    const coachCustomContainer = document.getElementById('customIncrementContainer');
                    if (coachSelect) {
                        const s = String(parsedStored.increment);
                        if (STANDARD_INCREMENTS.includes(s)) {
                            coachSelect.value = s;
                            if (coachCustomContainer) coachCustomContainer.style.display = 'none';
                        } else {
                            try { coachSelect.value = 'custom'; } catch (e) {}
                            if (coachCustomInput) coachCustomInput.value = String(parsedStored.increment);
                            if (coachCustomContainer) coachCustomContainer.style.display = 'flex';
                        }
                    }
                }
            }
        } catch (e) { /* ignore parse errors */ }

        // Fetch bookings for this date
        let bookingsForDate = [];
        
        // Helper: parse ISO with offset directly to browser-local time
        // Booking "start"/"end" are ISO strings with timezone info
        const convertOrgTimeToBrowser = (isoStr) => {
            try { return new Date(isoStr); } catch { return null; }
        };
        
        const fetchBookings = async () => {
            try {
                const startStr = `${date}T00:00:00`;
                const endStr = `${date}T23:59:59`;
                const response = await fetch(`/bus/${orgSlug}/events/?start=${encodeURIComponent(startStr)}&end=${encodeURIComponent(endStr)}&_t=${Date.now()}`);
                if (response.ok) {
                    const allEvents = await response.json();
                    // Keep only real bookings, scoped to the current selection.
                    // Important: for member scope, bookings should only apply when the member
                    // has exactly one solo-hosted service assigned (see _isBookingInSelectedScope).
                    bookingsForDate = allEvents.filter(e => {
                        try {
                            if (!_isRealBookingEvent(e)) return false;
                            return _isBookingInSelectedScope(e);
                        } catch (err) {
                            return false;
                        }
                    });
                }
            } catch (error) {
                console.error('Failed to fetch bookings:', error);
            }
        };

        // Normalize ranges: rangesOrStart may be an array of ranges or a single start string (backwards-compat)
        let rangesArr = [];
        try {
            if (Array.isArray(rangesOrStart)) {
                rangesArr = rangesOrStart.slice();
            } else if (rangesOrStart && typeof rangesOrStart === 'object') {
                rangesArr = [rangesOrStart];
            } else if (typeof rangesOrStart === 'string' && endTime) {
                rangesArr = [{ start: rangesOrStart, end: endTime }];
            }
        } catch (e) { rangesArr = []; }

        // If no ranges provided, derive from default weekly availability
        if (!rangesArr || rangesArr.length === 0) {
            try {
                const d = parseYMD(date);
                const dow = d.getDay();
                const info = defaultAvailability[dow] || {};
                const rs = info.ranges && info.ranges.length ? info.ranges : (info.start && info.end ? [`${info.start}-${info.end}`] : []);
                rangesArr = (rs || []).map(r => {
                    const parts = String(r).split('-');
                    return { start: (parts[0]||'09:00').trim(), end: (parts[1]||'17:00').trim() };
                });
            } catch (e) { rangesArr = [{ start: '09:00', end: '17:00' }]; }
        }

        // Deduplicate rangesArr by start-end to avoid duplicate rendering
        try {
            const seen = new Set();
            const uniq = [];
            for (const r of rangesArr) {
                try {
                    const s = (r && r.start) ? String(r.start).trim() : '';
                    const e = (r && r.end) ? String(r.end).trim() : '';
                    const key = `${s}-${e}`;
                    if (!seen.has(key)) { seen.add(key); uniq.push({ start: s || '09:00', end: e || '17:00' }); }
                } catch (ie) { /* ignore malformed */ }
            }
            rangesArr = uniq;
        } catch (e) { /* ignore dedupe errors */ }

        // Function to show booking details in a modal
        function showBookingInfo(booking) {
            const bookingModal = document.getElementById('bookingModal');
            if (!bookingModal) return;

            // Convert booking times from org timezone to user's browser timezone
            const startTime = convertOrgTimeToBrowser(booking.start);
            const endTime = convertOrgTimeToBrowser(booking.end);
            
            document.getElementById('clientName').textContent = booking.extendedProps.client_name || 'Unknown';
            document.getElementById('lessonType').textContent = booking.title || 'Booking';
            
            if (startTime && endTime) {
                document.getElementById('lessonTime').textContent = `${startTime.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})} - ${endTime.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})}`;
            } else {
                document.getElementById('lessonTime').textContent = 'Invalid time';
            }
            
            document.getElementById('paymentMethod').textContent = booking.extendedProps.payment_method || 'N/A';

            bookingModal.style.display = 'flex';

            document.getElementById('closeBookingBtn').onclick = () => {
                bookingModal.style.display = 'none';
            };

            document.getElementById('viewClientBookingsBtn').onclick = () => {
                bookingModal.style.display = 'none';
                // Could navigate to bookings list filtered by this client
                window.location.href = `/bus/${orgSlug}/bookings/`;
            };
        }

        function renderGrid(blockSize) {
            container.innerHTML = "";
            const blockMinutes = Math.max(1, blockSize) * 60;

            // Service-scope parity: render ONLY server-provided starts (matches public)
            if (isServiceScope) {
                const slots = Array.isArray(__svcSlots) ? __svcSlots : [];
                if (!slots || slots.length === 0) {
                    const empty = document.createElement('div');
                    empty.style.color = '#6b7280';
                    empty.textContent = 'No available times on this day.';
                    container.appendChild(empty);
                    return;
                }

                const startToEnd = new Map();
                for (const s of slots) {
                    const sm = _svcIsoToLocalMinutes(s.start);
                    const em = _svcIsoToLocalMinutes(s.end);
                    if (sm != null && em != null && em > sm) startToEnd.set(sm, em);
                }
                const validStarts = Array.from(startToEnd.keys()).sort((a,b)=>a-b);
                if (validStarts.length === 0) {
                    const empty = document.createElement('div');
                    empty.style.color = '#6b7280';
                    empty.textContent = 'No available times on this day.';
                    container.appendChild(empty);
                    return;
                }

                const hours = [];
                const hourMap = new Map();
                for (const sm of validStarts) {
                    const hourStart = Math.floor(sm/60) * 60;
                    if (!hourMap.has(hourStart)) {
                        hourMap.set(hourStart, []);
                        hours.push(hourStart);
                    }
                    hourMap.get(hourStart).push(sm);
                }

                for (const hourStart of hours) {
                    const row = document.createElement('div');
                    row.style.display = 'flex';
                    row.style.alignItems = 'center';
                    row.style.justifyContent = 'space-between';
                    row.style.gap = '8px';
                    row.style.borderBottom = '1px solid #ccc';

                    const hourLabel = document.createElement('div');
                    hourLabel.style.width = '70px';
                    hourLabel.style.fontWeight = 'bold';
                    const labelDate = parseYMD(date);
                    labelDate.setHours(Math.floor(hourStart/60), hourStart%60, 0, 0);
                    const labelOpts = { hour: 'numeric', minute: (hourStart%60!==0?'2-digit':undefined), hour12: true };
                    hourLabel.textContent = labelDate.toLocaleString(undefined, labelOpts);
                    row.appendChild(hourLabel);

                    const circlesContainer = document.createElement('div');
                    circlesContainer.className = 'circles-for-hour';
                    circlesContainer.style.display = 'flex';
                    circlesContainer.style.flexWrap = 'wrap';
                    circlesContainer.style.gap = '8px';
                    circlesContainer.style.marginLeft = 'auto';

                    for (const sm of (hourMap.get(hourStart) || [])) {
                        const endMin = startToEnd.get(sm);
                        const timeLabel = _svcLabelFromMin(sm);
                        const circle = document.createElement('div');

                        const slotDate = parseYMD(date);
                        const h = Math.floor(sm / 60);
                        const m = sm % 60;
                        slotDate.setHours(h, m, 0, 0);
                        const slotEndDate = new Date(slotDate.getTime() + Math.max(1, (endMin - sm)) * 60000);
                        const now = new Date();

                        const booking = bookingsForDate.find(b => {
                            try {
                                const bookingStart = convertOrgTimeToBrowser(b.start);
                                const bookingEnd = convertOrgTimeToBrowser(b.end);
                                if (!bookingStart || !bookingEnd) return false;
                                return slotDate.getTime() < bookingEnd.getTime() && slotEndDate.getTime() > bookingStart.getTime();
                            } catch (e) { return false; }
                        });

                        if (booking) {
                            circle.className = 'time-circle booked';
                            circle.textContent = 'Booked';
                            circle.dataset.time = timeLabel;
                            circle.dataset.bookingId = booking.id;
                            circle.addEventListener('click', () => { showBookingInfo(booking); });
                        } else if (slotDate < now) {
                            circle.className = 'time-circle blocked';
                            circle.textContent = timeLabel;
                            circle.dataset.time = timeLabel;
                            circle.style.background = '#6c757d';
                            circle.style.cursor = 'not-allowed';
                            circle.addEventListener('click', () => { alert(`This slot (${timeLabel}) is in the past.`); });
                        } else {
                            circle.className = 'time-circle open';
                            circle.textContent = timeLabel;
                            circle.dataset.time = timeLabel;
                            circle.addEventListener('click', () => { alert(`Slot: ${timeLabel} is available`); });
                        }

                        circlesContainer.appendChild(circle);
                    }

                    row.appendChild(circlesContainer);
                    container.appendChild(row);
                }

                if (container.lastElementChild) container.lastElementChild.style.borderBottom = 'none';
                return;
            }

            // Render per supplied range so multiple discontiguous ranges are supported
            for (const range of rangesArr) {
                // compute start/end minutes for this range
                let startTotalMinutes = 6 * 60;
                let endTotalMinutes = 22 * 60;
                try {
                    if (range.start) {
                        const parts = String(range.start).split(':');
                        const sh = parseInt(parts[0], 10);
                        const sm = parts.length > 1 ? parseInt(parts[1], 10) : 0;
                        if (!isNaN(sh)) startTotalMinutes = sh * 60 + (isNaN(sm) ? 0 : sm);
                    }
                    if (range.end) {
                        const parts = String(range.end).split(':');
                        const eh = parseInt(parts[0], 10);
                        const em = parts.length > 1 ? parseInt(parts[1], 10) : 0;
                        if (!isNaN(eh)) endTotalMinutes = eh * 60 + (isNaN(em) ? 0 : em);
                    }
                } catch (e) { /* ignore parse errors */ }

                for (let blockStart = startTotalMinutes; blockStart < endTotalMinutes; blockStart += blockMinutes) {
                    const row = document.createElement('div');
                    row.style.display = 'flex';
                    row.style.alignItems = 'center';
                    row.style.justifyContent = 'space-between';
                    row.style.gap = '8px';
                    row.style.borderBottom = '1px solid #ccc';

                    const blockLabel = document.createElement('div');
                    blockLabel.style.width = '70px';
                    blockLabel.style.fontWeight = 'bold';
                    const labelDate = parseYMD(date);
                    const startHourForLabel = Math.floor(blockStart / 60);
                    labelDate.setHours(startHourForLabel, 0, 0, 0);
                    if (blockMinutes > 60) {
                        const endLabelDate = parseYMD(date);
                        const endHourForLabel = Math.min(23, Math.floor((blockStart + blockMinutes) / 60));
                        endLabelDate.setHours(endHourForLabel, 0, 0, 0);
                        blockLabel.textContent = `${labelDate.toLocaleString(undefined, { hour: 'numeric', hour12: true })} - ${endLabelDate.toLocaleString(undefined, { hour: 'numeric', hour12: true })}`;
                    } else {
                        blockLabel.textContent = labelDate.toLocaleString(undefined, { hour: 'numeric', hour12: true });
                    }
                    row.appendChild(blockLabel);

                    const circlesContainer = document.createElement('div');
                    circlesContainer.className = 'circles-for-hour';
                    circlesContainer.style.display = 'flex';
                    circlesContainer.style.flexWrap = 'wrap';
                    circlesContainer.style.gap = '8px';
                    circlesContainer.style.marginLeft = 'auto';

                    for (let offset = 0; offset < blockMinutes; offset += currentIncrement) {
                        const totalMinutes = blockStart + offset;
                        if (totalMinutes >= endTotalMinutes) break;
                        const hour = Math.floor(totalMinutes / 60);
                        const min = totalMinutes % 60;

                        const ampm = hour >= 12 ? 'PM' : 'AM';
                        let displayHour = hour % 12;
                        if (displayHour === 0) displayHour = 12;
                        const timeLabel = `${displayHour}:${String(min).padStart(2, '0')} ${ampm}`;

                        const circle = document.createElement('div');
                        const slotDate = parseYMD(date);
                        slotDate.setHours(hour, min, 0, 0);
                        const slotEndDate = new Date(slotDate.getTime() + (currentIncrement * 60000));
                        const now = new Date();

                        // Check if this slot overlaps with any booking
                        // A slot overlaps if: slot_start < booking_end AND slot_end > booking_start
                        const booking = bookingsForDate.find(b => {
                            try {
                                // Convert booking times from org timezone to browser timezone
                                const bookingStart = convertOrgTimeToBrowser(b.start);
                                const bookingEnd = convertOrgTimeToBrowser(b.end);
                                
                                if (!bookingStart || !bookingEnd) return false;
                                
                                // Compare timestamps
                                const overlaps = slotDate.getTime() < bookingEnd.getTime() && slotEndDate.getTime() > bookingStart.getTime();
                                
                                return overlaps;
                            } catch (e) { 
                                console.error('Error checking booking overlap:', e);
                                return false; 
                            }
                        });

                        if (booking) {
                            // Slot is booked
                            circle.className = 'time-circle booked';
                            circle.textContent = 'Booked';
                            circle.dataset.time = timeLabel;
                            circle.dataset.bookingId = booking.id;

                            circle.addEventListener('click', () => {
                                showBookingInfo(booking);
                            });
                        } else if (slotDate < now) {
                            // Past time slot
                            circle.className = 'time-circle blocked';
                            circle.textContent = timeLabel;
                            circle.dataset.time = timeLabel;
                            circle.style.background = '#6c757d';
                            circle.style.cursor = 'not-allowed';

                            circle.addEventListener('click', () => {
                                alert(`This slot (${timeLabel}) is in the past.`);
                            });
                        } else {
                            // Available slot
                            circle.className = 'time-circle open';
                            circle.textContent = timeLabel;
                            circle.dataset.time = timeLabel;

                            circle.addEventListener('click', () => {
                                alert(`Slot: ${timeLabel} is available`);
                            });
                        }

                        circlesContainer.appendChild(circle);
                    }

                    row.appendChild(circlesContainer);
                    container.appendChild(row);
                }
            }

            if (container.lastElementChild) container.lastElementChild.style.borderBottom = 'none';
        }

        // Fetch bookings first, then render grid
        fetchBookings().then(async () => {
            try {
                if (isServiceScope) {
                    await _fetchServiceScopeSlots();
                }
            } catch (e) { /* ignore */ }
            renderGrid(currentBlockSize);
        });

        // Handle coach settings - refetch bookings when re-rendering
        coachHourBlockSelect.onchange = () => {
            if (coachHourBlockSelect.value === "custom") coachCustomBlockContainer.style.display = "flex";
            else {
                coachCustomBlockContainer.style.display = "none";
                currentBlockSize = parseInt(coachHourBlockSelect.value);
                fetchBookings().then(() => renderGrid(currentBlockSize));
            }
        };
        coachApplyCustomBlockBtn.onclick = () => {
            const val = parseInt(coachCustomBlockInput.value);
            if (isNaN(val) || val<15) return alert("Enter valid minutes 15+");
            coachCustomBlockContainer.style.display="none";
            currentBlockSize = val/60;
            fetchBookings().then(() => renderGrid(currentBlockSize));
        };
        coachIncrementSelect.onchange = () => {
            if (coachIncrementSelect.value==="custom") coachCustomIncrementContainer.style.display="flex";
            else {
                coachCustomIncrementContainer.style.display="none";
                currentIncrement = parseInt(coachIncrementSelect.value);
                fetchBookings().then(() => renderGrid(currentBlockSize));
            }
        };
        coachApplyCustomIncrementBtn.onclick = () => {
            const val = parseInt(coachCustomIncrementInput.value);
            if (isNaN(val) || val<5) return alert("Enter valid increment 5+");
            coachCustomIncrementContainer.style.display="none";
            currentIncrement = val;
            fetchBookings().then(() => renderGrid(currentBlockSize));
        };

        // Close modal
        document.getElementById("closeCirclesBtn").onclick = () => {
            modal.style.display = "none";
        };

        // Add circle styles if not present
        if (!document.getElementById("timeCirclesStyle")) {
            const style = document.createElement("style");
            style.id = "timeCirclesStyle";
            style.innerHTML = `
                .time-circle {
                    width: 80px; height: 80px; border-radius: 50%;
                    display: flex; justify-content: center; align-items: center;
                    cursor: pointer; font-size: 13px; color: white; transition: transform 0.1s ease;
                }
                .time-circle.open { background: #28a745; }
                .time-circle.booked { background: #dc3545; }
                .time-circle.blocked { background: #6c757d; }
                .time-circle:hover { transform: scale(1.1); }
            `;
            document.head.appendChild(style);
        }
    }

    calendarEl.addEventListener('mousedown', e => {
        if (e.button !== 0) return;
        // Allow starting a drag from any rendered day cell (available OR unavailable),
        // but we will ignore past days below.
        const cell = e.target.closest('.fc-daygrid-day');
        if (!cell) return;

        const date = cell.dataset.date;
        const isPast = isPastDate(date);

        // Check for mixed selection immediately
        if (isPast && [...selectedDates].some(d => !isPastDate(d)) ||
            !isPast && [...selectedDates].some(d => isPastDate(d))) 
        {
            alert("You can only select past days or available days — not both at the same time.");
            // 🔹 reset drag state immediately
            isDragging = false;
            dragStartDate = null;
            dragMode = null;
            dragStartIsUnavailable = false;
            document.querySelectorAll('.fc-daygrid-day-number.temp-highlight').forEach(el => el.classList.remove('temp-highlight'));
            return;
        }

        // Handle past day click
        if (isPast) {
            openPastDayModal(date); // open modal
            return; // do not start dragging
        }

        // Start drag for future/available days
        isDragging = true;
        dragStartDate = date;
        dragMode = selectedDates.has(date) ? "deselect" : "select";

        // Record whether the drag started on an unavailable cell so we only
        // highlight cells of the same availability type during the drag.
        try {
            const numEl = cell.querySelector('.fc-daygrid-day-number');
            dragStartIsUnavailable = cell.classList.contains('fc-day-unavailable') || (numEl && numEl.classList.contains('unavailable-number'));
        } catch (e) { dragStartIsUnavailable = false; }

        // Immediate toggle for the first cell
        toggleDateSelection(date, dragMode === "select");
    });

    calendarEl.addEventListener('mousemove', e => {
        if (!isDragging || !dragStartDate) return;

        // During dragging, include any day cells (we'll only highlight those
        // matching the start cell's availability type).
        const cell = e.target.closest('.fc-daygrid-day');
        if (!cell) return;
        const currentDate = cell.dataset.date;

        // Skip if mixed past/future detected
        const isPast = isPastDate(currentDate);
        if (isPast && [...selectedDates].some(d => !isPastDate(d)) ||
            !isPast && [...selectedDates].some(d => isPastDate(d))) 
        {
            isDragging = false;
            dragStartDate = null;
            dragMode = null;
            dragStartIsUnavailable = false;
            document.querySelectorAll('.fc-daygrid-day-number.temp-highlight').forEach(el => el.classList.remove('temp-highlight'));
            return;
        }

        const start = parseYMD(dragStartDate);
        const end = parseYMD(currentDate);
        const minDate = start < end ? start : end;
        const maxDate = start > end ? start : end;

        const selector = dragStartIsUnavailable ? '.fc-daygrid-day.fc-day-unavailable' : '.fc-daygrid-day.fc-day-available';
        document.querySelectorAll(selector).forEach(c => {
            const dateStr = c.dataset.date;
            const numberEl = c.querySelector('.fc-daygrid-day-number');
            if (!numberEl || !dateStr) return;

            const date = parseYMD(dateStr);
            if (date >= minDate && date <= maxDate) {
                numberEl.classList.add('temp-highlight');
                if (dragMode === 'select') numberEl.classList.add('selected');
                else numberEl.classList.remove('selected');
            } else {
                numberEl.classList.remove('temp-highlight');
                if (dragMode === 'select' && !selectedDates.has(dateStr)) numberEl.classList.remove('selected');
                if (dragMode === 'deselect' && selectedDates.has(dateStr)) numberEl.classList.add('selected');
            }
        });
    });

    document.addEventListener('mouseup', () => {
        if (!isDragging) return;

        document.querySelectorAll('.fc-daygrid-day-number.temp-highlight').forEach(el => {
            el.classList.remove('temp-highlight');
            const date = el.closest('.fc-daygrid-day').dataset.date;
            if (dragMode === 'select') selectedDates.add(date);
            else if (dragMode === 'deselect') selectedDates.delete(date);
        });

        isDragging = false;
        dragStartDate = null;
        dragMode = null;
        dragStartIsUnavailable = false;

        updateClearButton();
        updateSelectButtonText();
    });

    function saveNewlySelectedDates() {
        const selectedStartTime = document.getElementById('startTime')?.value || "09:00";
        const selectedEndTime = document.getElementById('endTime')?.value || "17:00";
        const datesArray = Array.from(selectedDates);

        // Prevent applying overrides that would exclude existing bookings.
        try {
            const rangesToCheck = [{ start: selectedStartTime, end: selectedEndTime }];
            const bad = [];
            for (const d of datesArray) {
                const verdict = _validateOverrideAgainstBookings(d, rangesToCheck);
                if (!verdict.ok) {
                    bad.push(verdict.message || (`Override blocked for ${d} due to existing booking(s).`));
                    if (bad.length >= 5) break;
                }
            }
            if (bad.length) {
                alert(bad.join('\n\n'));
                return;
            }
        } catch (e) { /* ignore */ }

        // Pre-clean: remove existing overrides for these dates to avoid duplicates
        fetch(`/bus/${orgSlug}/bookings/batch_delete/`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
            body: JSON.stringify({ dates: datesArray, target: (SELECTED_MEMBER || null) })
        }).then(r => {
            return r.json().catch(() => null);
        }).then(data => {
        }).catch(err => console.warn('batch_delete pre-clean failed', err)).finally(() => {
            // Optimistically add per-date background events so they override defaults immediately
            try {
                datesArray.forEach(d => {
                    try {
                        calendar.addEvent({ start: d + 'T' + selectedStartTime, end: d + 'T' + selectedEndTime, display: 'background', color: '#d0f0d0', extendedProps: Object.assign({ is_per_date: true, override_type: 'available', optimistic: true }, getScopePropsForSelection(SELECTED_MEMBER)) });
                    } catch (e) { /* ignore */ }
                });
            } catch (e) { console.warn('optimistic add failed', e); }

            const _payload = {
                dates: datesArray,  // e.g. ['2025-11-10', '2025-11-11']
                start_time: selectedStartTime,
                end_time: selectedEndTime,
                target: (SELECTED_MEMBER || null)
            };
            fetch(`/bus/${orgSlug}/bookings/batch_create/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken
            },
            body: JSON.stringify(_payload)
        })
        .then(r => r.json())
        .then(data => {
            // Refresh events to reconcile with server truth (server may attach ids/changes)
            try { calendar.refetchEvents(); } catch(e) { console.warn('refetchEvents failed', e); }
        })
        .catch(err => { console.error(err); });
        });
    }

    function toUTCDate(dateStr) {
        const d = parseYMD(dateStr);
        return new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
    }


    selectBtn.addEventListener('click', () => {
        const dates = Array.from(selectedDates).sort(); // ['2025-11-01', '2025-11-02', ...]
        
        // ✅ Check if no days are selected
        if (dates.length === 0) {
            alert("Drag to highlight multiple days on the calendar. Select only one to view the schedule for that day. Select a past date to view previous bookings for records.");
            return; // stop further execution
        }

        // Trial/Basic: per-date overrides are not available. Keep this modal view-only.
        if (typeof ccEnforceOverridesLock === 'function') {
            try { ccEnforceOverridesLock(); } catch(e) {}
        }
        

        const modal = document.getElementById('timeModal');
        const viewDayBtn = document.getElementById('viewDayBtn');
        const summary = document.getElementById('selectedDaysSummary');

        // Helper to format "YYYY-MM-DD" into "Month DDth"
        function formatDateStr(dateStr) {
            const [year, month, day] = dateStr.split('-');
            const date = parseYMD(`${year}-${month}-${day}`);
            const monthName = date.toLocaleString(undefined, { month: 'long' });
            const dayNum = parseInt(day);
            let suffix = "th";
            if (dayNum === 1 || dayNum === 21 || dayNum === 31) suffix = "st";
            else if (dayNum === 2 || dayNum === 22) suffix = "nd";
            else if (dayNum === 3 || dayNum === 23) suffix = "rd";
            return `${monthName} ${dayNum}${suffix}`;
        }

        // Helper to check if two dates are consecutive
        function areConsecutive(prevStr, currStr) {
            const prevDate = parseYMD(prevStr);
            const currDate = parseYMD(currStr);
            const diffDays = (currDate - prevDate) / (1000 * 60 * 60 * 24);
            return diffDays === 1;
        }

        const ranges = [];
        let rangeStart = dates[0];
        let prev = dates[0];

        for (let i = 1; i < dates.length; i++) {
            const curr = dates[i];

            const prevDate = parseYMD(prev);
            const currDate = parseYMD(curr);

            const sameMonth = prevDate.getMonth() === currDate.getMonth();
            const consecutive = (currDate - prevDate) / (1000 * 60 * 60 * 24) === 1;

            if (consecutive && sameMonth) {
                prev = curr; // continue range
            } else {
                // Push the previous range
                if (rangeStart === prev) {
                    ranges.push(formatDateStr(rangeStart));
                } else {
                    ranges.push(`${formatDateStr(rangeStart)}-${formatDateStr(prev).split(' ')[1]}`);
                }
                rangeStart = curr;
                prev = curr;
            }
        }

        // Push the final range
        if (rangeStart === prev) {
            ranges.push(formatDateStr(rangeStart));
        } else {
            ranges.push(`${formatDateStr(rangeStart)}-${formatDateStr(prev).split(' ')[1]}`);
        }

        // Display summary
        if (dates.length === 1) {
            summary.textContent = `Selected day: ${formatDateStr(dates[0])}`;
            // Only show the View Day Schedule button if the selected day is not marked unavailable and not past
            try {
                const cell = document.querySelector(`.fc-daygrid-day[data-date="${dates[0]}"]`);
                const num = cell ? cell.querySelector('.fc-daygrid-day-number') : null;
                const isUnavailable = cell && (cell.classList.contains('fc-day-unavailable') || (num && num.classList.contains('unavailable-number')));
                const saveBtnEl = document.getElementById('saveTimeBtn');
                if (!isUnavailable && !isPastDate(dates[0])) {
                    viewDayBtn.style.display = 'inline-block';
                    if (saveBtnEl) saveBtnEl.style.display = 'inline-block';
                } else {
                    viewDayBtn.style.display = 'none';
                    if (saveBtnEl) saveBtnEl.style.display = 'none';
                }
            } catch (e) { try { viewDayBtn.style.display = 'none'; const saveBtnEl = document.getElementById('saveTimeBtn'); if (saveBtnEl) saveBtnEl.style.display = 'none'; } catch(ex) {} }
            selectBtn.textContent = "Select Day";

            // Populate ranges UI (below) — do not use single modalStart/modalEnd inputs.

            // Ensure the time inputs are hidden when the date is fully unavailable
            try { setModalTimeRowVisibility(dates[0]); } catch (e) { /* ignore */ }

                // If per-date timed overrides exist, populate the modalRangesContainer and prefer those times
                try {
                    const rangesContainer = document.getElementById('modalRangesContainer');
                    rangesContainer.innerHTML = '';
                    const overrides = findPerDateTimedOverrides(dates[0]);
                    if (overrides && overrides.length > 0) {
                        // populate rows from overrides (dedupe identical start-end pairs)
                        const seen = new Set();
                        overrides.forEach(o => {
                            try {
                                const key = `${o.start}-${o.end}`;
                                if (!seen.has(key)) {
                                    seen.add(key);
                                    rangesContainer.appendChild(createModalRangeRow(o.start, o.end));
                                }
                            } catch (e) { /* ignore row errors */ }
                        });
                    } else {
                        // populate rows from weekly defaults if multiple ranges exist, otherwise single default
                        const d = parseYMD(dates[0]);
                        const dow = d.getDay();
                        const info = defaultAvailability[dow] || {};
                        const ranges = info.ranges && info.ranges.length ? info.ranges : (info.start && info.end ? [`${info.start}-${info.end}`] : []);
                        if (ranges && ranges.length) {
                            ranges.forEach(r => {
                                try {
                                    const parts = r.split('-');
                                    const s = parts[0] ? parts[0].trim() : '09:00';
                                    const e = parts[1] ? parts[1].trim() : '17:00';
                                    rangesContainer.appendChild(createModalRangeRow(s, e));
                                } catch (e) {}
                            });
                        } else {
                            // fallback single row: use weekly defaults or sensible times
                            try {
                                const parts = (info.start && info.end) ? [info.start, info.end] : ['09:00','17:00'];
                                const s = (parts[0]||'09:00').trim();
                                const e = (parts[1]||'17:00').trim();
                                rangesContainer.appendChild(createModalRangeRow(s, e));
                            } catch (e) {
                                rangesContainer.appendChild(createModalRangeRow('09:00','17:00'));
                            }
                        }
                    }

                    // wire Add Range button to append a blank row
                    const addBtn = document.getElementById('addModalRangeBtn');
                    if (addBtn) {
                        addBtn.onclick = () => rangesContainer.appendChild(createModalRangeRow('09:00','17:00'));
                    }
                } catch (e) { console.warn('populate modal ranges failed', e); }

            // Show Make Available button if this single selected day is currently unavailable
            try {
                const makeAvailableBtn = document.getElementById('makeAvailableBtn');
                if (makeAvailableBtn) {
                    const cell = document.querySelector(`.fc-daygrid-day[data-date="${dates[0]}"]`);
                    const num = cell ? cell.querySelector('.fc-daygrid-day-number') : null;
                    const isUnavailable = cell && (cell.classList.contains('fc-day-unavailable') || (num && num.classList.contains('unavailable-number')));
                    // Only show Make Available for future unavailable days
                    if (isUnavailable && !isPastDate(dates[0])) {
                        makeAvailableBtn.style.display = 'inline-block';
                        makeAvailableBtn.onclick = async () => {
                            if (!CAN_USE_OVERRIDES) {
                                ccPromptOverridesUpgrade();
                                return;
                            }
                            if (!confirm(`Make ${dates[0]} available?`)) return;
                            try {
                                const res = await fetch(`/bus/${orgSlug}/bookings/batch_delete/`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                                    body: JSON.stringify({ dates: [dates[0]], target: (SELECTED_MEMBER || null) })
                                });
                                const data = await res.json().catch(() => null);
                                if (res.ok) {
                                    // Persist a default available range immediately so "Make Available" actually
                                    // creates a per-date override (otherwise users expect availability to save
                                    // but nothing is created until they click Save inside the editor).
                                    let _createdStart = '09:00';
                                    let _createdEnd = '17:00';
                                    try {
                                        const d = parseYMD(dates[0]);
                                        const dow = d.getDay();
                                        const info = defaultAvailability[dow] || {};
                                        let start = '09:00', end = '17:00';
                                        if (info.ranges && info.ranges.length) {
                                            const first = info.ranges[0];
                                            if (first && first.includes('-')) {
                                                const parts = first.split('-');
                                                start = (parts[0] || start).trim();
                                                end = (parts[1] || end).trim();
                                            }
                                        } else if (info.start && info.end) {
                                            start = info.start;
                                            end = info.end;
                                        }

                                        _createdStart = start;
                                        _createdEnd = end;

                                        const createRes = await fetch(`/bus/${orgSlug}/bookings/batch_create/`, {
                                            method: 'POST',
                                            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                                            body: JSON.stringify({ dates: [dates[0]], start_time: start, end_time: end, target: (SELECTED_MEMBER || null) })
                                        });
                                        const createData = await createRes.json().catch(() => null);
                                        if (!createRes.ok) {
                                            const msg = (createData && (createData.error || createData.message)) || `Server returned ${createRes.status}`;
                                            alert('Error making available: ' + msg);
                                            return;
                                        }
                                    } catch (e) {
                                        console.warn('makeAvailable batch_create failed', e);
                                        alert('Error making available (create step failed).');
                                        return;
                                    }

                                    // Remove any full-day block for this date
                                    try {
                                        calendar.getEvents().forEach(ev => {
                                            try {
                                                if (ev.display === 'background' && ev.startStr && ev.startStr.startsWith(dates[0])) ev.remove();
                                            } catch (e) { /* ignore per-event errors */ }
                                        });
                                    } catch (e) { /* ignore */ }

                                    // Add a green background event for this date to mark it as available (optimistic UI)
                                    try {
                                        // Mark this optimistic available background as a per-date override
                                        calendar.addEvent({
                                            start: dates[0] + 'T' + _createdStart,
                                            end: dates[0] + 'T' + _createdEnd,
                                            display: 'background',
                                            color: '#d0f0d0',
                                            extendedProps: Object.assign({ is_per_date: true, override_type: 'available', optimistic: true }, getScopePropsForSelection(SELECTED_MEMBER))
                                        });
                                    } catch (e) { /* ignore */ }

                                    // Update classes immediately
                                    try { updateUnavailableDays(); } catch (e) {}
                                    try { calendar.refetchEvents(); } catch (e) {}

                                    // Exit out of the modal (match Make Unavailable behavior)
                                    try { modal.style.display = 'none'; } catch (e) {}
                                    try {
                                        selectedDates.clear();
                                        document.querySelectorAll('.fc-daygrid-day-number.selected').forEach(el => el.classList.remove('selected'));
                                        updateClearButton();
                                        updateSelectButtonText();
                                    } catch (e) {}
                                    alert('Date made available.');
                                } else {
                                    const msg = (data && (data.error || data.message)) || `Server returned ${res.status}`;
                                    alert('Error making available: ' + msg);
                                }
                            } catch (err) {
                                console.error('Make available failed', err);
                                alert('Error: ' + (err && err.message ? err.message : String(err)));
                            }
                        };
                    } else {
                        makeAvailableBtn.style.display = 'none';
                    }
                }
            } catch (e) { /* ignore */ }
                } else {
            // Ensure any leftover single-day "make available" notice is removed
            try {
                const notice = document.getElementById('makeAvailableNotice'); if (notice) notice.remove();
            } catch (e) {}

            // Hide per-day ranges UI and add/save/view/make-available buttons for multi-day selection
            try {
                const rangesContainer = document.getElementById('modalRangesContainer'); if (rangesContainer) rangesContainer.style.display = 'none';
                const addBtn = document.getElementById('addModalRangeBtn'); if (addBtn) addBtn.style.display = 'none';
                const saveBtn = document.getElementById('saveTimeBtn'); if (saveBtn) saveBtn.style.display = 'none';
                const viewBtn = document.getElementById('viewDayBtn'); if (viewBtn) viewBtn.style.display = 'none';
                const makeAvailableBtn = document.getElementById('makeAvailableBtn'); if (makeAvailableBtn) makeAvailableBtn.style.display = 'none';
            } catch (e) { /* ignore */ }

            summary.textContent = `${dates.length} days selected: ${ranges.join(', ')}`;
            viewDayBtn.style.display = 'none';
            selectBtn.textContent = "Select Days";

            // If multiple days selected, offer "Make Available" when ALL selected
            // days are currently unavailable (and none are in the past).
            try {
                const makeAvailableBtn = document.getElementById('makeAvailableBtn');
                if (makeAvailableBtn) {
                    const allUnavailable = dates.every(d => {
                        try {
                            if (isPastDate(d)) return false;
                            const c = document.querySelector(`.fc-daygrid-day[data-date="${d}"]`);
                            const n = c ? c.querySelector('.fc-daygrid-day-number') : null;
                            return c && (c.classList.contains('fc-day-unavailable') || (n && n.classList.contains('unavailable-number')));
                        } catch (e) { return false; }
                    });

                    if (allUnavailable) {
                        makeAvailableBtn.style.display = 'inline-block';
                        makeAvailableBtn.onclick = async () => {
                            if (!confirm(`Make ${dates.length} selected day(s) available?`)) return;
                            try {
                                // Compute groups (start/end per date) up-front so we can optimistically update UI
                                const groups = {}; // key -> { start, end, dates: [] }
                                for (const d of dates) {
                                    try {
                                        const dow = parseYMD(d).getDay();
                                        const info = defaultAvailability[dow] || {};
                                        let start = '09:00', end = '17:00';
                                        if (info.ranges && info.ranges.length) {
                                            const first = info.ranges[0];
                                            if (first && first.includes('-')) {
                                                const parts = first.split('-');
                                                start = parts[0].trim(); end = parts[1].trim();
                                            }
                                        } else if (info.start && info.end) {
                                            start = info.start; end = info.end;
                                        }
                                        const key = `${start}|${end}`;
                                        if (!groups[key]) groups[key] = { start, end, dates: [] };
                                        groups[key].dates.push(d);
                                    } catch (e) { console.warn('grouping date failed', d, e); }
                                }

                                // Optimistic UI: remove grey blocks and mark days available immediately
                                try {
                                    for (const d of dates) {
                                        // remove any full-day grey background events for this date
                                        calendar.getEvents().forEach(ev => {
                                            try {
                                                if (ev.display === 'background' && ev.startStr && ev.startStr.startsWith(d) && (ev.backgroundColor === '#e0e0e0' || ev.color === '#e0e0e0')) {
                                                    ev.remove();
                                                }
                                            } catch (e) { /* ignore per-event */ }
                                        });

                                        // add a per-date available background using the date's default time
                                        const dow = parseYMD(d).getDay();
                                        const info = defaultAvailability[dow] || {};
                                        let s = '09:00', e = '17:00';
                                        if (info.ranges && info.ranges.length) {
                                            const first = info.ranges[0];
                                            if (first && first.includes('-')) {
                                                const parts = first.split('-'); s = parts[0].trim(); e = parts[1].trim();
                                            }
                                        } else if (info.start && info.end) { s = info.start; e = info.end; }

                                        try {
                                            calendar.addEvent({ start: d + 'T' + s, end: d + 'T' + e, display: 'background', color: '#d0f0d0', extendedProps: Object.assign({ is_per_date: true, override_type: 'available', optimistic: true }, getScopePropsForSelection(SELECTED_MEMBER)) });
                                        } catch (ee) { /* ignore addEvent errors */ }

                                        // Update day cell classes immediately
                                        try {
                                            const cell = document.querySelector(`.fc-daygrid-day[data-date="${d}"]`);
                                            if (cell) {
                                                cell.classList.remove('fc-day-unavailable');
                                                cell.classList.add('fc-day-available');
                                                const num = cell.querySelector('.fc-daygrid-day-number');
                                                if (num) {
                                                    num.classList.remove('unavailable-number');
                                                    num.style.cursor = 'pointer';
                                                }
                                            }
                                        } catch (e) { /* ignore per-cell errors */ }
                                    }
                                } catch (e) { console.warn('optimistic UI update failed', e); }

                                // First, remove any per-day blocks or avails that explicitly block these dates
                                const delRes = await fetch(`/bus/${orgSlug}/bookings/batch_delete/`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                                    body: JSON.stringify({ dates: dates, target: (SELECTED_MEMBER || null) })
                                });
                                const delData = await delRes.json().catch(() => null);
                                if (!delRes.ok) {
                                    const msg = (delData && (delData.error || delData.message)) || `Server returned ${delRes.status}`;
                                    alert('Error making available (cleanup step): ' + msg);
                                    // Re-fetch server state to revert optimistic edits
                                    try { await calendar.refetchEvents(); } catch(e){}
                                    try { updateUnavailableDays(); } catch(e){}
                                    return;
                                }

                                // For each group, call batch_create to add per-date available overrides
                                const creationPromises = Object.values(groups).map(g => {
                                    return fetch(`/bus/${orgSlug}/bookings/batch_create/`, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                                        body: JSON.stringify({ dates: g.dates, start_time: g.start, end_time: g.end, target: (SELECTED_MEMBER || null) })
                                    }).then(r => r.json().catch(() => null).then(data => ({ ok: r.ok, data })));
                                });

                                const creationResults = await Promise.all(creationPromises);
                                // If any creation failed, surface a message but continue to refresh UI
                                const failed = creationResults.filter(r => !r.ok);
                                if (failed.length) {
                                    console.warn('Some per-date creation requests failed', failed);
                                    alert('Some dates could not be made available. Check console for details.');
                                }

                                // Refresh UI from server to reconcile authoritative state
                                try { await calendar.refetchEvents(); } catch(e){}
                                try { updateUnavailableDays(); } catch(e){}
                                alert('Selected days made available.');
                            } catch (err) {
                                console.error('Make available failed', err);
                                alert('Error: ' + (err && err.message ? err.message : String(err)));
                                try { await calendar.refetchEvents(); } catch(e){}
                                try { updateUnavailableDays(); } catch(e){}
                            }
                            // close modal
                            modal.style.display = 'none';
                        };
                    } else {
                        makeAvailableBtn.style.display = 'none';
                    }
                }
            } catch (e) { /* ignore */ }
        }

        modal.style.display = 'flex';

        // Final UI lock after any conditional button toggles above.
        if (typeof ccEnforceOverridesLock === 'function') {
            try { ccEnforceOverridesLock(); } catch(e) {}
        }

        // Handle "View Day Schedule"
        viewDayBtn.onclick = () => {
            modal.style.display = 'none';
            // Build ranges to pass to the day schedule modal: prefer per-date overrides, fall back to weekly defaults
            let ranges = findPerDateTimedOverrides(dates[0]);
            if (!ranges || ranges.length === 0) {
                const d = parseYMD(dates[0]);
                const dow = d.getDay();
                const info = defaultAvailability[dow] || {};
                const rs = info.ranges && info.ranges.length ? info.ranges : (info.start && info.end ? [`${info.start}-${info.end}`] : []);
                ranges = rs.map(r => {
                    const parts = r.split('-');
                    return { start: (parts[0]||'09:00').trim(), end: (parts[1]||'17:00').trim() };
                });
            }
            openTimeCirclesModal(dates[0], 30, 1, ranges);
        };

        // Show Make Unavailable button for the selected dates (only when none are already unavailable and none are past)
        const makeUnavailableBtn = document.getElementById('makeUnavailableBtn');
        if (makeUnavailableBtn) {
            const anyPast = dates.some(d => isPastDate(d));
            const anyAlreadyUnavailable = dates.some(d => {
                try {
                    const c = document.querySelector(`.fc-daygrid-day[data-date="${d}"]`);
                    const n = c ? c.querySelector('.fc-daygrid-day-number') : null;
                    return c && (c.classList.contains('fc-day-unavailable') || (n && n.classList.contains('unavailable-number')));
                } catch (e) { return false; }
            });

            makeUnavailableBtn.style.display = (anyPast || anyAlreadyUnavailable) ? 'none' : 'inline-block';

            makeUnavailableBtn.onclick = async () => {
                // Prevent blocking any day that already has bookings in this scope.
                try {
                    const bad = [];
                    for (const d of dates) {
                        const verdict = _validateOverrideAgainstBookings(d, null);
                        if (!verdict.ok) {
                            bad.push(verdict.message || (`Can’t block ${d} because there’s already a booking.`));
                            if (bad.length >= 5) break;
                        }
                    }
                    if (bad.length) {
                        alert(bad.join('\n\n'));
                        return;
                    }
                } catch (e) { /* ignore */ }
                if (!confirm(`Mark ${dates.length} selected day(s) as unavailable? This will block each selected day.`)) return;
                try {
                    const res = await fetch(`/bus/${orgSlug}/bookings/batch_create/`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                        body: JSON.stringify({ dates: dates, start_time: '00:00', end_time: '23:59', is_blocking: true, target: (SELECTED_MEMBER || null) })
                    });
                    const data = await res.json().catch(() => null);
                    if (res.ok) {
                        // Apply UI changes immediately for responsiveness
                        dates.forEach(d => applyPerDateUnavailable(d));
                        try { calendar.refetchEvents(); } catch(e){}
                        try { updateUnavailableDays(); } catch(e){}
                        alert('Selected days marked unavailable.');
                        // Clear selection after making unavailable
                        selectedDates.clear();
                        document.querySelectorAll('.fc-daygrid-day-number.selected').forEach(el => el.classList.remove('selected'));
                        updateClearButton();
                        updateSelectButtonText();
                    } else {
                        const msg = (data && (data.error || data.message)) || `Server returned ${res.status}`;
                        alert('Error marking unavailable: ' + msg);
                    }
                } catch (err) {
                    console.error('Make unavailable failed', err);
                    alert('Error: ' + (err && err.message ? err.message : String(err)));
                }
                modal.style.display = 'none';
            };
        }

        // Handle "Save" button: create calendar-level overrides (do NOT change defaults)
        document.getElementById('saveTimeBtn').onclick = async () => {
            // Gather ranges from modalRangesContainer if present, otherwise fall back to single inputs
            const ranges = [];
            try {
                const rangesContainer = document.getElementById('modalRangesContainer');
                if (rangesContainer) {
                    const rows = Array.from(rangesContainer.querySelectorAll('.modal-range-row'));
                    for (const r of rows) {
                        try {
                            const s = r.querySelector('.modal-range-start').value;
                            const e = r.querySelector('.modal-range-end').value;
                            if (s && e && s < e) ranges.push({ start: s, end: e });
                        } catch (ie) { /* ignore invalid rows */ }
                    }
                }
            } catch (e) { /* ignore */ }

            if (ranges.length === 0) {
                // If the coach explicitly removed all ranges for a single selected date,
                // treat this action as "mark the date unavailable" instead of silently
                // falling back to weekly defaults.
                if (dates.length === 1) {
                    const theDate = dates[0];
                    // Prevent blocking a day that already has bookings in this scope.
                    try {
                        const verdict = _validateOverrideAgainstBookings(theDate, null);
                        if (!verdict.ok) { alert(verdict.message || 'This day already has a booking.'); return; }
                    } catch (e) { /* ignore */ }
                    if (!confirm(`No time ranges provided. Mark ${theDate} as unavailable for the whole day?`)) return;
                    try {
                        const res = await fetch(`/bus/${orgSlug}/bookings/batch_create/`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                            body: JSON.stringify({ dates: [theDate], start_time: '00:00', end_time: '23:59', is_blocking: true, target: (SELECTED_MEMBER || null) })
                        });
                        const data = await res.json().catch(() => null);
                        if (res.ok) {
                            // Apply UI changes immediately for responsiveness
                            applyPerDateUnavailable(theDate);
                            try { await calendar.refetchEvents(); } catch (e) {}
                            try { updateUnavailableDays(); } catch (e) {}
                            alert('Date marked unavailable.');
                        } else {
                            const msg = (data && (data.error || data.message)) || `Server returned ${res.status}`;
                            alert('Error marking unavailable: ' + msg);
                        }
                    } catch (err) {
                        console.error('Make unavailable failed', err);
                        alert('Error: ' + (err && err.message ? err.message : String(err)));
                    }
                    modal.style.display = 'none';
                    // Clear selection for single-date
                    try { selectedDates.delete(dates[0]); document.querySelectorAll('.fc-daygrid-day-number.selected').forEach(el => el.classList.remove('selected')); updateClearButton(); updateSelectButtonText(); } catch(e){}
                    return;
                }

                // Otherwise fallback to weekly defaults for the first selected date, otherwise sensible times
                try {
                    const d = parseYMD(dates[0]);
                    const dow = d.getDay();
                    const info = defaultAvailability[dow] || {};
                    const rs = info.ranges && info.ranges.length ? info.ranges : (info.start && info.end ? [`${info.start}-${info.end}`] : []);
                    if (rs && rs.length) {
                        const parts = rs[0].split('-');
                        const s = (parts[0]||'09:00').trim();
                        const e = (parts[1]||'17:00').trim();
                        if (s && e && s < e) ranges.push({ start: s, end: e });
                    } else {
                        const s = document.getElementById('startTime')?.value || '09:00';
                        const e = document.getElementById('endTime')?.value || '17:00';
                        if (s && e && s < e) ranges.push({ start: s, end: e });
                    }
                } catch (e) {
                    // final fallback
                    ranges.push({ start: '09:00', end: '17:00' });
                }
            }

            if (ranges.length === 0) return alert('No valid ranges to save.');

            // Prevent saving ranges that would exclude existing bookings.
            try {
                const bad = [];
                for (const d of dates) {
                    const verdict = _validateOverrideAgainstBookings(d, ranges);
                    if (!verdict.ok) {
                        bad.push(verdict.message || (`Can’t save overrides for ${d} due to existing booking(s).`));
                        if (bad.length >= 5) break;
                    }
                }
                if (bad.length) {
                    alert(bad.join('\n\n'));
                    return;
                }
            } catch (e) { /* ignore */ }

            try {
                // First remove existing per-date overrides for these dates
                try {
                    const delRes = await fetch(`/bus/${orgSlug}/bookings/batch_delete/`, {
                        method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken }, body: JSON.stringify({ dates: dates, target: (SELECTED_MEMBER || null) })
                    });
                    // ignore result details — we'll refetch after creating
                } catch (e) { /* ignore delete errors */ }

                    // Deduplicate ranges by start-end to avoid creating duplicates
                    const uniqueRanges = [];
                    const seenRanges = new Set();
                    for (const rr of ranges) {
                        try {
                            const key = `${rr.start}-${rr.end}`;
                            if (!seenRanges.has(key)) { seenRanges.add(key); uniqueRanges.push(rr); }
                        } catch (e) { /* ignore malformed range */ }
                    }

                    // Now create each unique range for each selected date
                    for (const r of uniqueRanges) {
                    try {
                        // optimistic UI addition
                        dates.forEach(d => {
                                            try { calendar.addEvent({ start: d + 'T' + r.start, end: d + 'T' + r.end, display: 'background', color: '#d0f0d0', extendedProps: Object.assign({ is_per_date: true, override_type: 'available', optimistic: true }, getScopePropsForSelection(SELECTED_MEMBER)) }); } catch(e) {}
                        });

                        const res = await fetch(`/bus/${orgSlug}/bookings/batch_create/`, {
                            method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                            body: JSON.stringify({ dates: dates, start_time: r.start, end_time: r.end, target: (SELECTED_MEMBER || null) })
                        });
                        const data = await res.json().catch(() => null);
                        if (!res.ok) {
                            const msg = (data && (data.error || data.message)) || `Server returned ${res.status}`;
                            console.warn('Error creating range', r, msg);
                        }
                    } catch (err) { console.error('range create failed', err); }
                }

                try { await calendar.refetchEvents(); } catch(e){}
                alert('Saved overrides for selected day(s).');
            } catch (err) {
                console.error('Save failed', err);
                alert('Error saving overrides: ' + (err && err.message ? err.message : String(err)));
            }

            // close modal but do not mutate defaultAvailability
            modal.style.display = 'none';
        };

        // Wire Reset-to-default button for the currently selected dates
        const resetBtn = document.getElementById('resetToDefaultBtn');
        resetBtn.onclick = async () => {
            if (!confirm('Reset selected day(s) to weekly defaults? This will remove per-day overrides (client-side).')) return;
            try {
                // Work on a copy of dates
                const targets = dates.slice();

                // Prevent reset if weekly defaults would exclude existing bookings.
                try {
                    const bad = [];
                    for (const d of targets) {
                        const weekly = _weeklyDefaultRangesForDate(d);
                        const verdict = _validateOverrideAgainstBookings(d, weekly);
                        if (!verdict.ok) {
                            bad.push(verdict.message || (`Reset blocked for ${d} due to existing booking(s).`));
                            if (bad.length >= 5) break;
                        }
                    }
                    if (bad.length) {
                        alert(bad.join('\n\n'));
                        return;
                    }
                } catch (e) { /* ignore */ }

                // Remove client-side background events for these dates so UI immediately reflects defaults
                calendar.getEvents().forEach(ev => {
                    try {
                        if (ev.display === 'background' && ev.startStr) {
                            const evDate = (ev.startStr || '').split('T')[0];
                            for (const d of targets) {
                                if (evDate === d) {
                                    ev.remove();
                                    break;
                                }
                            }
                        }
                    } catch(e) { /* ignore per-event errors */ }
                });

                // Clear per-day classes for the targets so updateUnavailableDays can recompute
                targets.forEach(d => {
                    try {
                        const cell = document.querySelector(`.fc-daygrid-day[data-date="${d}"]`);
                        if (!cell) return;
                        cell.classList.remove('fc-day-unavailable');
                        cell.classList.remove('fc-day-available');
                        const num = cell.querySelector('.fc-daygrid-day-number');
                        if (num) {
                            num.classList.remove('unavailable-number');
                            num.classList.remove('selected');
                        }
                    } catch(e) { /* ignore per-cell errors */ }
                });

                // Re-sync defaults to calendar for visual fallback (over the current view)
                try { syncAvailabilityToCalendar(); } catch(e) { console.warn('sync failed', e); }

                // Ensure classes reflect the newly-synced defaults
                try { updateUnavailableDays(); } catch(e) { console.warn('updateUnavailableDays failed', e); }

                // Best-effort: ask server to remove per-day overrides if endpoint exists
                try {
                    const res = await fetch(`/bus/${orgSlug}/bookings/batch_delete/`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                        body: JSON.stringify({ dates: targets, target: (SELECTED_MEMBER || null) })
                    });
                    if (res.ok) {
                        try { await res.json(); } catch(e) {}
                        // If server acknowledged deletion, refetch to ensure server-side state matches UI
                        try { await calendar.refetchEvents(); } catch(e) { console.warn('refetch after delete failed', e); }
                        alert('Reset completed. Calendar now shows weekly defaults.');
                    } else {
                        // Endpoint may not exist; fall back to client-only reset
                        console.warn('Server reset failed or endpoint missing', res.status);
                        alert('Reset applied locally. Server may require an endpoint to persist this change.');
                        try { await calendar.refetchEvents(); } catch(e) {}
                    }
                } catch (err) {
                    console.warn('batch_delete request failed', err);
                    alert('Reset applied locally. Server request failed.');
                    try { await calendar.refetchEvents(); } catch(e) {}
                }

                // Ensure the selection UI is cleared after reset
                try {
                    selectedDates.clear();
                    document.querySelectorAll('.fc-daygrid-day-number.selected').forEach(el => el.classList.remove('selected'));
                    updateClearButton();
                    updateSelectButtonText();
                } catch (e) { console.warn('clearing selection UI failed', e); }
            } catch (err) {
                console.error('Reset failed', err);
                alert('Reset failed: ' + (err && err.message ? err.message : String(err)));
            }

            modal.style.display = 'none';
        };

        // Handle "Cancel" button
        document.getElementById('closeTimeBtn').onclick = () => {
            modal.style.display = 'none';
        };
    });

    document.getElementById('selectAllBtn').addEventListener('click', () => {
        // Select all future (non-past) days in the currently rendered month view.
        const cells = document.querySelectorAll('.fc-daygrid-day');

        // Block if any past day is selected (keep selection homogenous)
        if ([...selectedDates].some(d => isPastDate(d))) {
            alert("You can only select past days or available days — not both at the same time.");
            return;
        }

        // Mark that the user used Highlight All so modal logic can hide Make Available
        window._highlightAll = true;

        cells.forEach(cell => {
            const dateStr = cell.dataset.date;
            if (!dateStr) return;
            if (isPastDate(dateStr)) return; // skip past

            const numberEl = cell.querySelector('.fc-daygrid-day-number');
            if (!numberEl) return;
            numberEl.classList.add('selected');
            selectedDates.add(dateStr);
        });

        updateClearButton();
        updateSelectButtonText();
    });

    clearBtn.addEventListener('click', () => {
        document.querySelectorAll('.fc-daygrid-day-number.selected').forEach(el => {
            el.classList.remove('selected');
        });
        selectedDates.clear();
        updateClearButton();

        selectBtn.textContent = "Select Day";
    });

    // --- MODAL HANDLING LOGIC ---
    const timeModal = document.getElementById('timeModal');
    const saveTimeBtn = document.getElementById('saveTimeBtn');
    const closeTimeBtn = document.getElementById('closeTimeBtn');
    const selectedDaysSummary = document.getElementById('selectedDaysSummary');

});
    // Sync the cc-wave animations across sections by setting a shared negative
    // animation-delay equal to the elapsed phase of the animation duration.
    // This keeps all gradients visually in-step even if elements mount at
    // slightly different times.
    (function syncCcWave() {
        try {
            // Read duration from CSS var if present, fallback to 14s
            const root = document.documentElement;
            const cssRaw = getComputedStyle(root).getPropertyValue('--cc-wave-duration') || '14s';
            const cssDur = parseFloat(cssRaw);
            const dur = Number(cssDur) || 14; // seconds

            // Set a single initial offset so elements mounted at different times
            // appear visually in-step. Avoid updating this every animation frame
            // (which forces repaints each frame) — recompute only when the page
            // becomes visible again to keep CPU usage low.
            function setOffsetOnce() {
                const nowSec = performance.now() / 1000; // high-res
                const elapsed = nowSec % dur; // seconds into animation
                const offset = `-${elapsed.toFixed(3)}s`;
                root.style.setProperty('--cc-wave-offset', offset);
            }

            setOffsetOnce();
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) setOffsetOnce();
            });
        } catch (e) { /* fail silently */ }
    })();

</script>
{% endblock %}


