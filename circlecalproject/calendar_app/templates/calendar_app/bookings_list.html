{% extends "calendar_app/base.html" %}
{% load tz %}
{% block title %}Bookings - {{ organization.name }}{% endblock %}

{% block content %}
<style>
  :root { --row-height: 64px; }
  .bookings-container { max-width: 1200px; margin: 0 auto; padding: 20px; }
  .bookings-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px; }
  .filter-controls { display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap; }
  .filter-btn { padding: 6px 10px; border: 1px solid #ddd; background: white; border-radius: 6px; cursor: pointer; transition: all .15s; font-size: 12px; }
  .filter-btn.active { background: #007bff; color: white; border-color: #007bff; }
  .filter-btn:hover { border-color: #007bff; }
  .bookings-table { width: 100%; border-collapse: collapse; background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
  .bookings-table th { background: #f8f9fa; padding: 12px; text-align: left; font-weight: 600; border-bottom: 2px solid #dee2e6; }
  .bookings-table td { padding: 12px; border-bottom: 1px solid #dee2e6; }
  .bookings-table tr:hover { background: #f8f9fa; }
  .status-badge { padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: 600; }
  .status-upcoming { background: #d1ecf1; color: #0c5460; }
  .status-past { background: #d6d8db; color: #383d41; }
  .status-today { background: #d4edda; color: #155724; }
  .status-ongoing { background: #d4edda; color: #155724; }
  .booking-actions { display: flex; gap: 8px; }
  .btn-sm { padding: 4px 12px; font-size: 13px; border: none; border-radius: 4px; cursor: pointer; transition: all .2s; }
  .btn-view { background: #007bff; color: white; }
  .btn-view:hover { background: #0056b3; }
  .btn-delete { background: #dc3545; color: white; }
  .btn-delete:hover { background: #c82333; }
  .no-bookings { text-align: center; padding: 60px 20px; color: #6c757d; }
  .search-box { padding: 6px 10px; border: 1px solid #ddd; border-radius: 6px; width: 200px; font-size: 13px; }
  /* Wrapper to constrain visible rows to ~10 and enable scrolling for overflow */
  .table-wrapper { max-height: calc(var(--row-height) * 10); overflow: auto; }
  /* Small visual tweak so scroller area shows rounded corners consistently */
  .table-wrapper .bookings-table { margin: 0; }
</style>

<div class="bookings-container">
    <div class="bookings-header">
    <h1 style="font-size: 2rem; font-weight: bold; margin: 0;">Bookings</h1>
    <div style="display:flex; gap:8px; align-items:center;">
      {% if user_org_role != 'staff' %}
        <a href="{% url 'calendar_app:calendar' organization.slug %}" class="btn-sm btn-view">View Calendar</a>
      {% endif %}
      <a href="{% url 'calendar_app:dashboard' organization.slug %}" class="btn-sm btn-view">Back to Dashboard</a>
    </div>
  </div>

  <!-- Filters -->
  <div class="filter-controls">
    <input type="text" id="searchBox" class="search-box" placeholder="Search by name or email...">
    <button class="filter-btn active" data-filter="all">All</button>
    <button class="filter-btn" data-filter="upcoming">Upcoming</button>
    <button class="filter-btn" data-filter="ongoing">Ongoing</button>
    <button class="filter-btn" data-filter="today">Today</button>
    <button class="filter-btn" data-filter="past">Past</button>
    <select id="serviceFilter" class="filter-btn" style="padding: 8px 12px;">
      <option value="">All Services</option>
      {% for service in services %}
        <option value="{{ service.id }}">{{ service.name }}</option>
      {% endfor %}
    </select>
    <button id="deleteSelectedBtn" class="btn-sm btn-delete" onclick="deleteSelected()" style="display:none; margin-left:8px;">Delete selected</button>
    </div>
  </div>

  <!-- Bookings Table -->
  <div class="table-wrapper">
    <table class="bookings-table">
    <thead>
      <tr>
        <th style="padding:8px; text-align:left; font-weight:600;"><input type="checkbox" id="selectAllBookings"/></th>
        <th>Date & Time</th>
        <th>Booking ID</th>
        <th>Client</th>
        <th>Service</th>
        <th>Duration</th>
        <th>Status</th>
        <th>Booked At</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody id="bookingsTableBody">
      {% if bookings %}
        {% for booking in bookings %}
        <tr data-booking-id="{{ booking.id }}" data-public-ref="{{ booking.public_ref|default:'' }}" 
          data-status="{% if booking.start <= now and booking.end >= now %}ongoing{% elif booking.start.date == today %}today{% elif booking.start < now %}past{% else %}upcoming{% endif %}"
          data-service-id="{{ booking.service.id|default:'' }}"
          data-service-price="{{ booking.service.price|default:'' }}"
          data-search="{{ booking.client_name|lower }} {{ booking.client_email|lower }} {{ booking.public_ref|default:''|lower }} {{ booking.id }}">
          <td style="padding:8px;"><input type="checkbox" class="bookingRowCb" value="{{ booking.id }}" style="margin-right:8px;"/></td>
          <td>
            {% timezone organization.timezone %}
              <div style="font-weight: 600;">{{ booking.start|date:"M d, Y" }}</div>
              <div style="font-size: 13px; color: #6c757d;">{{ booking.start|time:"g:i A" }} - {{ booking.end|time:"g:i A" }}</div>
            {% endtimezone %}
          </td>
          <td>
            <div>{{ booking.public_ref|default:booking.id }}</div>
          </td>
          <td>
            <div style="font-weight: 600;">{{ booking.client_name|default:"No name" }}</div>
            <div style="font-size: 13px; color: #6c757d;">{{ booking.client_email|default:"No email" }}</div>
          </td>
          <td>{{ booking.service.name|default:"N/A" }}</td>
          <td>{{ booking.service.duration|default:"-" }} min</td>
          <td>
            {% timezone organization.timezone %}
                {% if booking.start and booking.end and booking.start <= now and booking.end >= now %}
                  <span class="status-badge status-ongoing">Ongoing</span>
                {% elif booking.start|date == today %}
                  <span class="status-badge status-today">Today</span>
                {% elif booking.start < now %}
                  <span class="status-badge status-past">Past</span>
                {% else %}
                  <span class="status-badge status-upcoming">Upcoming</span>
                {% endif %}
            {% endtimezone %}
          </td>
          <td>
            {% timezone organization.timezone %}
              <div style="font-weight: 600;">{{ booking.created_at|date:"M d, Y" }}</div>
              <div style="font-size: 13px; color: #6c757d;">{{ booking.created_at|time:"g:i A" }}</div>
            {% endtimezone %}
          </td>
          <td>
              <div class="booking-actions">
              <button class="btn-sm btn-view" onclick="viewBooking({{ booking.id }})">View</button>
            </div>
          </td>
        </tr>
        {% endfor %}
      {% else %}
        <tr>
          <td colspan="9" class="no-bookings">
            <div style="font-size: 18px; margin-bottom: 10px;">ðŸ“…</div>
            No bookings found
          </td>
        </tr>
      {% endif %}
    </tbody>
    </table>
  </div>
  
  <!-- Audit: Cancelled / Deleted Bookings -->
  <div style="margin-top:28px;">
    <h2 style="font-size:1.25rem; margin-bottom:8px;">Recently Cancelled / Deleted</h2>
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; gap:8px;">
      <div style="display:flex; gap:8px; align-items:center;">
          <input type="text" id="auditSearch" class="search-box" placeholder="Search audit (client, ref, email...)" style="width:260px;">
        <select id="auditEventFilter" class="filter-btn" style="padding:6px 10px;">
          <option value="all">All events</option>
          <option value="deleted">Deleted</option>
          <option value="successful">Successful</option>
          <option value="cancelled">Cancelled</option>
        </select>
        <select id="auditServiceFilter" class="filter-btn" style="padding:6px 10px;">
          <option value="">All Services</option>
          {% for service in services %}
            <option value="{{ service.name|escapejs }}">{{ service.name }}</option>
          {% endfor %}
        </select>
      </div>
      <div style="display:flex;gap:8px; align-items:center;">
        <button class="btn-sm btn-view" id="exportAuditBtn">Export (PDF)</button>
        <button class="btn-sm btn-delete" id="deleteAuditBtn">Delete selected</button>
      </div>
    </div>
    <div class="table-wrapper">
      <table class="bookings-table" style="width:100%;">
      <thead>
            <tr style="background:#f8f9fa;">
              <th style="padding:8px; text-align:left; font-weight:600;"><input type="checkbox" id="auditSelectAll" /></th>
              <th style="padding:8px; text-align:left; font-weight:600;">Event</th>
              <th style="padding:8px; text-align:left; font-weight:600;">Date &amp; Time</th>
              <th style="padding:8px; text-align:left; font-weight:600;">Booking ID</th>
              <th style="padding:8px; text-align:left; font-weight:600;">Client</th>
              <th style="padding:8px; text-align:left; font-weight:600;">Service</th>
              <th style="padding:8px; text-align:left; font-weight:600;">Booked At</th>
              <th style="padding:8px; text-align:left; font-weight:600;">Details</th>
            </tr>
      </thead>
      <tbody id="auditTableBody">
        {% if audit_entries %}
          {% for a in audit_entries %}
              {% comment %}Compute a compact label for dataset (mirror displayed label){% endcomment %}
              <tr data-audit-id="{{ a.id }}" data-event-type="{{ a.event_type|default:''|escapejs }}" data-label="{% if a.event_type == 'deleted' and a.start and a.start < now %}successful{% else %}{{ a.event_type|default:''|escapejs }}{% endif %}" data-service-name="{{ a.service.name|default:''|escapejs }}" data-client="{{ a.client_name|default:''|lower|escapejs }}" data-public-ref="{% with ref=a.booking_snapshot.public_ref %}{{ ref|default:a.booking_id }}{% endwith %}">
                <td style="padding:8px;"><input type="checkbox" class="auditRowCb" value="{{ a.id }}" style="margin-right:8px;" /></td>
                <td style="padding:8px;">
                  {% if a.event_type == 'deleted' and a.start and a.start < now %}
                    Successful
                  {% else %}
                    {{ a.get_event_type_display|capfirst }}
                  {% endif %}
                </td>
                <td style="padding:8px;">{% with snap=a.booking_snapshot %}{% if a.start or snap.start %}{% timezone organization.timezone %}
                    <div style="font-weight:600;">{{ a.start|default:snap.start|date:'M d, Y' }}</div>
                    <div style="font-size:13px; color:#6c757d;">{% if a.end or snap.end %}{{ a.start|default:snap.start|time:'g:i A' }} - {{ a.end|default:snap.end|time:'g:i A' }}{% else %}{{ a.start|default:snap.start|time:'g:i A' }}{% endif %}</div>
                  {% endtimezone %}{% else %}-{% endif %}{% endwith %}</td>
                <td style="padding:8px;">{% with ref=a.booking_snapshot.public_ref %}{{ ref|default:a.booking_id }}{% endwith %}</td>
                <td style="padding:8px;">{{ a.client_name|default:'-' }}<div style="font-size:12px; color:#666">{{ a.client_email }}</div></td>
                <td style="padding:8px;">{{ a.service.name|default:'-' }}</td>
                <td style="padding:8px;">{% timezone organization.timezone %}
                    <div style="font-weight:600;">{{ a.created_at|date:'M d, Y' }}</div>
                    <div style="font-size:13px; color:#6c757d;">{{ a.created_at|time:'g:i A' }}</div>
                  {% endtimezone %}</td>
                <td style="padding:8px;">
                  <button class="btn-sm btn-view" onclick="viewAudit(this)" data-snapshot='{{ a.booking_snapshot|escapejs }}'>View</button>
                </td>
              </tr>
            {% endfor %}
            {% else %}
          <tr id="noAuditRow"><td colspan="8" style="padding:16px; text-align:center; color:#6c757d;">No recent audited deletions or cancellations.</td></tr>
        {% endif %}
      </tbody>
      </table>
    </div>
  </div>
</div>

<!-- Booking Detail Modal -->
<div id="bookingModal" style="display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); justify-content: center; align-items: center; z-index: 10000; padding: 20px;">
  <div style="background: white; padding: 30px; border-radius: 12px; max-width: 500px; width: 100%; position: relative;">
    <button onclick="closeModal()" style="position: absolute; top: 10px; right: 15px; background: none; border: none; font-size: 24px; cursor: pointer; color: #666;">Ã—</button>
    
    <h2 style="margin-bottom: 20px; font-size: 24px;">Booking Details</h2>
    
    <div style="display: grid; gap: 15px;">
      <div>
        <strong>Date:</strong>
        <div id="modalDate" style="color: #666; margin-top: 4px;"></div>
      </div>
      <div>
        <strong>Time:</strong>
        <div id="modalTime" style="color: #666; margin-top: 4px;"></div>
      </div>
      <div>
        <strong>Booked At:</strong>
        <div id="modalBookedAt" style="color: #666; margin-top: 4px;"></div>
      </div>
      <div>
        <strong>Client Name:</strong>
        <div id="modalClientName" style="color: #666; margin-top: 4px;"></div>
      </div>
      <div>
        <strong>Client Email:</strong>
        <div id="modalClientEmail" style="color: #666; margin-top: 4px;"></div>
      </div>
      <div>
        <strong>Service:</strong>
        <div id="modalService" style="color: #666; margin-top: 4px;"></div>
      </div>
      <div>
        <strong>Duration:</strong>
        <div id="modalDuration" style="color: #666; margin-top: 4px;"></div>
      </div>
      <div>
        <strong>Charge:</strong>
        <div id="modalCharge" style="color: #666; margin-top: 4px;"></div>
      </div>
    </div>

    <div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 30px;">
      <button onclick="closeModal()" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 6px; cursor: pointer;">Close</button>
    </div>
  </div>
</div>

<!-- Audit Modal -->
<div id="auditModal" style="display:none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); justify-content: center; align-items: center; z-index: 10000; padding: 20px;">
  <div style="background: white; padding: 24px; border-radius: 12px; max-width: 700px; width: 100%; position: relative;">
    <button onclick="closeAuditModal()" style="position: absolute; top: 10px; right: 15px; background: none; border: none; font-size: 24px; cursor: pointer; color: #666;">Ã—</button>
    <h2 style="margin-bottom:12px;">Audit Details</h2>
    <div id="auditContent" style="white-space:pre-wrap; background:#f8f9fa; padding:12px; border-radius:8px; max-height:60vh; overflow:auto;"></div>
    <div style="display:flex; justify-content:flex-end; margin-top:12px;"><button onclick="closeAuditModal()" style="padding:8px 14px; background:#6c757d; color:white; border:none; border-radius:6px;">Close</button></div>
  </div>
</div>

<script>
const orgSlug = "{{ organization.slug }}";
const csrftoken = '{{ csrf_token }}';
const ORG_NAME = "{{ organization.name|escapejs }}";
// Polling: track last-seen server time to fetch new bookings
let lastSeen = "{{ now|date:'c' }}";
const POLL_INTERVAL_MS = 15000; // 15 seconds
// Audit polling: track last seen audit created_at
let lastAuditSeen = "{% if audit_entries and audit_entries.0 %}{{ audit_entries.0.created_at|date:'c' }}{% else %}{{ now|date:'c' }}{% endif %}";

// Performance caches
const _bookingsTbody = document.getElementById('bookingsTableBody');
const _auditTbody = document.getElementById('auditTableBody');
const _selectAllBookings = document.getElementById('selectAllBookings');
const _auditSelectAll = document.getElementById('auditSelectAll');
// Track inserted authoritative audit ids to avoid expensive DOM queries
const _seenAuditIds = new Set();
// Timestamped suppression maps for optimistic deletions. Keys map to
// milliseconds-since-epoch when the optimistic delete occurred. We only
// suppress re-insertion of an audit if the incoming audit's created_at is
// older-or-equal to the suppression timestamp (i.e. it's the same record).
const _recentlyDeletedAuditTimestamps = Object.create(null);
const _recentlyDeletedBookingTimestamps = Object.create(null);
const _recentlyDeletedPublicRefTimestamps = Object.create(null);
try { document.querySelectorAll('#auditTableBody tr[data-audit-id]').forEach(r => { if (r.dataset && r.dataset.auditId) _seenAuditIds.add(String(r.dataset.auditId)); }); } catch(e) {}

// Normalize time strings to remove leading zero on hour (e.g. '09:00 AM' -> '9:00 AM')
function stripLeadingZeroFromTime(s){
  try{ return String(s).replace(/\b0(?=\d{1,2}:\d{2})/g,''); }catch(e){ return s; }
}

function tryParseSnapshot(raw){
  if (!raw) return null;
  // unescape common JS unicode escapes (e.g. \u0027 -> ')
  try{
    raw = String(raw).replace(/\\u([0-9a-fA-F]{4})/g, function(_, g){ return String.fromCharCode(parseInt(g,16)); });
  }catch(e){}
  try { return JSON.parse(raw); } catch(e){}
  try {
    // Try convert Python-like repr to JSON-ish: single -> double quotes, True/False/None
    let alt = String(raw).replace(/\\'/g, "'");
    alt = alt.replace(/'/g, '"');
    alt = alt.replace(/\bNone\b/g, 'null').replace(/\bTrue\b/g,'true').replace(/\bFalse\b/g,'false');
    return JSON.parse(alt);
  } catch(e){}
  try {
    // Last resort: evaluate (controlled environment assumed)
    // eslint-disable-next-line no-new-func
    return (new Function('return ' + raw))();
  } catch(e){}
  return null;
}

function viewAudit(btn) {
  if (!btn) return;
  const raw = btn.getAttribute('data-snapshot');
  try {
    const parsed = tryParseSnapshot(raw);
    const parts = [];
      // Determine event label from the surrounding row if available
      try{
        const row = btn.closest && btn.closest('tr');
        if (row){
          const rowLabel = (row.dataset && (row.dataset.label || row.dataset.eventType)) || null;
          const nonRefundFlag = (row.dataset && (row.dataset.nonRefunded || row.dataset.non_refunded || '')) || '';
          const refundWithin = (row.dataset && (row.dataset.refundWithinCutoff || row.dataset.refund_within_cutoff || '')) || '';
          if (rowLabel){
            let displayEvent = rowLabel.charAt(0).toUpperCase() + rowLabel.slice(1);
            if (rowLabel.toLowerCase() === 'cancelled' && (nonRefundFlag === '1' || nonRefundFlag === 'true')){
              if (refundWithin === '1' || refundWithin === 'true'){
                displayEvent = 'Cancelled (within refund rule for service) - non refunded for client';
              } else {
                displayEvent = 'Cancelled - non-refunded for client';
              }
            }
            parts.push(`<div><strong>Event:</strong> ${displayEvent}</div>`);
          }
        }
      }catch(e){}

      if (parsed && typeof parsed === 'object'){
      if (parsed.title) parts.push(`<div><strong>Title:</strong> ${parsed.title}</div>`);
      // Business name (prefers parsed business, falls back to page org)
      parts.push(`<div><strong>Business:</strong> ${parsed.business || ORG_NAME}</div>`);
      if (parsed.service_slug) parts.push(`<div><strong>Service:</strong> ${parsed.service_slug}</div>`);
      // Charge
      if (parsed.service_price !== undefined && parsed.service_price !== null) parts.push(`<div><strong>Charge:</strong> $${Number(parsed.service_price).toFixed(2)}</div>`);
      if (parsed.start) parts.push(`<div><strong>Start:</strong> ${new Date(parsed.start).toLocaleString()}</div>`);
      if (parsed.end) parts.push(`<div><strong>End:</strong> ${new Date(parsed.end).toLocaleString()}</div>`);
      if (parsed.client_name) parts.push(`<div><strong>Client:</strong> ${parsed.client_name} <span style="color:#666">&lt;${parsed.client_email || '-'}&gt;</span></div>`);
      if (parsed.created_at) parts.push(`<div><strong>Booked At:</strong> ${new Date(parsed.created_at).toLocaleString()}</div>`);
      document.getElementById('auditContent').innerHTML = parts.join('\n') || JSON.stringify(parsed, null, 2);
    } else {
      document.getElementById('auditContent').textContent = raw || 'No detail available';
    }
  } catch (e) {
    document.getElementById('auditContent').textContent = raw || 'No detail available';
  }
  document.getElementById('auditModal').style.display = 'flex';
}
function closeAuditModal(){ document.getElementById('auditModal').style.display = 'none'; }

// Filter functionality
document.querySelectorAll('.filter-btn').forEach(btn => {
  btn.addEventListener('click', function() {
    if (this.dataset.filter) {
      document.querySelectorAll('.filter-btn[data-filter]').forEach(b => b.classList.remove('active'));
      this.classList.add('active');
      filterBookings();
    }
  });
});

document.getElementById('searchBox').addEventListener('input', filterBookings);
document.getElementById('serviceFilter').addEventListener('change', filterBookings);

function filterBookings() {
  const activeFilter = document.querySelector('.filter-btn.active').dataset.filter;
  const searchTerm = document.getElementById('searchBox').value.toLowerCase();
  const serviceId = document.getElementById('serviceFilter').value;

  document.querySelectorAll('#bookingsTableBody tr').forEach(row => {
    const status = row.dataset.status;
    const search = row.dataset.search;
    const rowServiceId = row.dataset.serviceId;

    let show = true;

    // Status filter
    if (activeFilter !== 'all' && status !== activeFilter) show = false;

    // Search filter
    if (searchTerm && !search.includes(searchTerm)) show = false;

    // Service filter
    if (serviceId && rowServiceId !== serviceId) show = false;

    row.style.display = show ? '' : 'none';
  });
}

function viewBooking(id) {
  const row = document.querySelector(`tr[data-booking-id="${id}"]`);
  if (!row) return;

  const cells = row.querySelectorAll('td');
  // Adjusted indexes because a leading checkbox column was added:
  // 0: checkbox, 1: date/time, 2: client, 3: service, 4: duration, 5: status, 6: bookedAt, 7: actions
  const dateCell = cells[1] || null;
  if (dateCell) {
    const d0 = dateCell.querySelector('div');
    const d1 = dateCell.querySelectorAll('div')[1];
    document.getElementById('modalDate').textContent = d0 ? d0.textContent : '';
    document.getElementById('modalTime').textContent = d1 ? d1.textContent : '';
  } else {
    document.getElementById('modalDate').textContent = '';
    document.getElementById('modalTime').textContent = '';
  }

  const bookedAtCell = cells[7] || null;
  const bookedAtDivs = bookedAtCell ? bookedAtCell.querySelectorAll('div') : [];
  if (bookedAtDivs.length >= 2) {
    document.getElementById('modalBookedAt').textContent = `${bookedAtDivs[0].textContent} ${bookedAtDivs[1].textContent}`;
  } else {
    document.getElementById('modalBookedAt').textContent = '';
  }

  const clientCell = cells[3] || null;
  if (clientCell) {
    const c0 = clientCell.querySelector('div');
    const c1 = clientCell.querySelectorAll('div')[1];
    document.getElementById('modalClientName').textContent = c0 ? c0.textContent : '';
    document.getElementById('modalClientEmail').textContent = c1 ? c1.textContent : '';
  } else {
    document.getElementById('modalClientName').textContent = '';
    document.getElementById('modalClientEmail').textContent = '';
  }

  document.getElementById('modalService').textContent = (cells[4] ? cells[4].textContent : '') || '';
  document.getElementById('modalDuration').textContent = (cells[5] ? cells[5].textContent : '') || '';
  // Show service price if available (data attribute on row)
  const priceVal = row.dataset.servicePrice;
  let priceText = '-';
  if (priceVal !== undefined && priceVal !== null && priceVal !== '') {
    const n = Number(priceVal);
    if (isFinite(n)) priceText = `$${n.toFixed(2)}`;
  }
  document.getElementById('modalCharge').textContent = priceText;

  document.getElementById('bookingModal').style.display = 'flex';
}

function closeModal() {
  document.getElementById('bookingModal').style.display = 'none';
}

  // Insert a booking row (used by poll and undo)
function insertBookingRow(b, toTop=true) {
  if (!b) return;
  // Normalize booking identifiers - accept `booking_id` or `id`
  const bidPrimary = (b.booking_id !== undefined && b.booking_id !== null) ? String(b.booking_id) : '';
  const bidAlt = (b.id !== undefined && b.id !== null) ? String(b.id) : '';
  const bid = bidPrimary || bidAlt;
  if (!bid) return;
  // Remove any existing row for this booking id (primary or alt) to avoid duplicates
  // But preserve existing duration text if the incoming payload lacks it.
  let preservedDurationText = null;
  try{
    const existing = document.querySelectorAll(`#bookingsTableBody tr[data-booking-id]`);
    for (const ex of existing){
      const exId = String(ex.getAttribute('data-booking-id'));
      const exPub = String(ex.getAttribute('data-public-ref') || '');
      if (exId === bid || (bidPrimary && exId === bidPrimary) || (bidAlt && exId === bidAlt) || (b.public_ref && exPub === String(b.public_ref))) {
        try{
          const td = ex.querySelectorAll('td')[4]; // duration cell
          if (td && (!preservedDurationText || preservedDurationText === null)){
            const txt = (td.textContent || '').trim();
            if (txt && txt !== '- min') preservedDurationText = txt;
          }
        }catch(e){}
        ex.remove();
      }
    }
  }catch(e){ /* defensive */ }
  const tbody = document.getElementById('bookingsTableBody');
  const newTr = document.createElement('tr');
  // determine status
  let status = 'upcoming';
  try {
    if (b.start) {
      const s = new Date(b.start);
      const n = new Date();
      if (s.toDateString() === n.toDateString()) status = 'today';
      else if (s <= n && b.end && new Date(b.end) >= n) status = 'ongoing';
      else if (s < n) status = 'past';
      else status = 'upcoming';
    }
  } catch(e){}
  newTr.setAttribute('data-booking-id', bid);
  newTr.setAttribute('data-public-ref', b.public_ref || '');
  newTr.setAttribute('data-status', status);
  newTr.setAttribute('data-service-id', b.service_id || '');
  // Expose service price on the row so the "View" modal can show the charge
  try{
    const svcPrice = (b.service_price !== undefined && b.service_price !== null) ? String(b.service_price) : (b.price !== undefined && b.price !== null ? String(b.price) : '');
    newTr.setAttribute('data-service-price', svcPrice);
  }catch(e){ newTr.setAttribute('data-service-price',''); }
  try{
    if (b.duration !== undefined && b.duration !== null) newTr.setAttribute('data-duration', String(b.duration));
  }catch(e){}
  newTr.setAttribute('data-search', (b.client_name || '').toLowerCase() + ' ' + (b.client_email || '').toLowerCase());
  newTr.innerHTML = `
    <td style="padding:8px;"><input type="checkbox" class="bookingRowCb" value="${bid}" style="margin-right:8px;"/></td>
    <td>
      <div style="font-weight:600;">${b.start_date || ''}</div>
      <div style="font-size:13px; color:#6c757d;">${stripLeadingZeroFromTime(b.time_range || '')}</div>
    </td>
    <td>
      <div style="font-weight:600;">${b.public_ref || b.booking_id || ''}</div>
    </td>
    <td>
      <div style="font-weight:600;">${b.client_name || ''}</div>
      <div style="font-size:13px; color:#6c757d;">${b.client_email || ''}</div>
    </td>
    <td>${b.service_name || 'N/A'}</td>
    <td>${(b.duration !== undefined && b.duration !== null ? (b.duration + ' min') : (preservedDurationText || '- min'))}</td>
    <td><span class="status-badge ${status==='past'?'status-past':(status==='today'?'status-today':'status-upcoming')}">${status.charAt(0).toUpperCase()+status.slice(1)}</span></td>
    <td>${(function(){
        try{
          // Prefer ISO timestamp `created_at` if present
          if (b.created_at){
            const cd = new Date(b.created_at);
            if (!isNaN(cd)){
              let createdTime = cd.toLocaleTimeString(undefined,{hour:'numeric',minute:'2-digit'});
              createdTime = stripLeadingZeroFromTime(createdTime);
              return `<div style="font-weight:600;">${cd.toLocaleDateString(undefined,{month:'short',day:'numeric',year:'numeric'})}</div><div style="font-size:13px;color:#6c757d;">${createdTime}</div>`;
            }
          }
          if (b.created_display){
            const pd = new Date(b.created_display);
            if (!isNaN(pd)){
              let createdTime = pd.toLocaleTimeString(undefined,{hour:'numeric',minute:'2-digit'});
              createdTime = stripLeadingZeroFromTime(createdTime);
              return `<div style="font-weight:600;">${pd.toLocaleDateString(undefined,{month:'short',day:'numeric',year:'numeric'})}</div><div style="font-size:13px;color:#6c757d;">${createdTime}</div>`;
            }
            // Fallback: try to extract a time like "9:00 AM" at end of string
            const m = String(b.created_display).match(/^(.*?\b\d{1,2}[:\d]{0,5}\s*(?:AM|PM|am|pm))$/);
            if (m){
              // split last token as time
              const parts = m[1].trim().split(/\s+(?=\d{1,2}:)/);
              if (parts.length >= 2){
                const datePart = parts[0];
                const timePart = stripLeadingZeroFromTime(parts.slice(1).join(' '));
                return `<div style="font-weight:600;">${datePart}</div><div style="font-size:13px;color:#6c757d;">${timePart}</div>`;
              }
            }
          }
        }catch(e){}
        // last resort: show raw string on first line
        return `<div style="font-weight:600;">${b.created_display || ''}</div><div style="font-size:13px;color:#6c757d;">${''}</div>`;
      })()}</td>
    <td>
      <div class="booking-actions">
          <button class="btn-sm btn-view" onclick="viewBooking(${b.booking_id})">View</button>
      </div>
    </td>
  `;
  if (toTop && tbody.firstChild) tbody.insertBefore(newTr, tbody.firstChild); else tbody.appendChild(newTr);
}

async function pollNewBookings(){
  try{
    const url = `/bus/${orgSlug}/bookings/recent/?since=${encodeURIComponent(lastSeen)}`;
    const resp = await fetch(url, { method: 'GET' });
    if (!resp.ok) return;
    const j = await resp.json();
    if (!j || !Array.isArray(j.items)) return;
    for (const it of j.items){
      insertBookingRow(it, true);
      // update lastSeen to the latest created_at
      if (it.created_at) lastSeen = it.created_at;
    }
  }catch(e){ console.error('Poll error', e); }
}

// start polling
setInterval(pollNewBookings, POLL_INTERVAL_MS);
// Also trigger an initial poll shortly after load
setTimeout(pollNewBookings, 2000);

// Poll audit entries for recent cancellations/deletions
async function pollNewAudits(){
  try{
    const url = `/bus/${orgSlug}/bookings/audit/?since=${encodeURIComponent(lastAuditSeen)}`;
    const resp = await fetch(url, { method: 'GET' });
    if (!resp.ok) return;
    const j = await resp.json();
    if (!j || !Array.isArray(j.items)) return;
    for (const item of j.items){
      insertAuditRow(item);
      if (item.created_at) lastAuditSeen = item.created_at;
    }
  }catch(e){ console.error('Audit poll error', e); }
}
setInterval(pollNewAudits, POLL_INTERVAL_MS);
setTimeout(pollNewAudits, 2500);

// Selection / bulk-delete UI
function updateSelectionState(){
  const selected = Array.from(document.querySelectorAll('.bookingRowCb')).filter(cb => cb.checked).map(cb => cb.value);
  const btn = document.getElementById('deleteSelectedBtn');
  if (btn) {
    if (selected.length > 0) { btn.style.display = 'inline-block'; btn.textContent = `Delete selected (${selected.length})`; }
    else { btn.style.display = 'none'; }
  }
}

// Wire up select-all and per-row checkboxes
try{
  const selectAll = document.getElementById('selectAllBookings');
  if (selectAll){
    selectAll.addEventListener('change', function(){
      const all = Array.from(document.querySelectorAll('.bookingRowCb'));
      all.forEach(cb => { try{ cb.checked = selectAll.checked; }catch(e){} });
      updateSelectionState();
    });
  }
  document.addEventListener('change', function(e){
    if (e.target && e.target.classList && e.target.classList.contains('bookingRowCb')) updateSelectionState();
  });
}catch(e){ }

function deleteSelected(){
  const selected = Array.from(document.querySelectorAll('.bookingRowCb')).filter(cb => cb.checked).map(cb => cb.value);
  if (!selected || selected.length === 0) return;
  if (!confirm(`Delete ${selected.length} selected booking(s)?`)) return;
  for (const id of selected){
    // attempt to extract date/client for nicer confirm UI in deleteBooking
    const row = document.querySelector(`tr[data-booking-id="${id}"]`);
    let dateTxt = '';
    let clientTxt = '';
    try{ const cells = row.querySelectorAll('td'); dateTxt = cells[1] ? cells[1].textContent.trim() : ''; clientTxt = cells[3] ? (cells[3].querySelector('div') ? cells[3].querySelector('div').textContent.trim() : cells[3].textContent.trim()) : ''; }catch(e){}
    // call existing deleteBooking with skipConfirm true
    try{ deleteBooking(id, dateTxt, clientTxt, true); }catch(e){ console.error('deleteSelected error', e); }
  }
  // clear selection UI
  try{ document.getElementById('selectAllBookings').checked = false; }catch(e){}
  updateSelectionState();
}


function insertAuditRow(item){
  try{
    // Avoid inserting duplicates: check fast in-memory set before DOM queries
    try { if (item.id && _seenAuditIds.has(String(item.id))) return; } catch(e) {}
    // Also avoid duplicates by checking existing DOM rows for the same
    // authoritative identifiers (audit id, booking id, public_ref).
    try{
      const auditIdStr = (item.id !== undefined && item.id !== null) ? String(item.id) : null;
      const bookingIdStr = (item.booking_id !== undefined && item.booking_id !== null) ? String(item.booking_id) : null;
      const itemRef = (item.public_ref || (item.snapshot && item.snapshot.public_ref) || '') || '';
      // Determine created_at for the incoming audit (if available)
      let itemCreatedMs = null;
      try {
        const src = item.created_at || (item.snapshot && (item.snapshot.created_at || item.snapshot.created_display)) || null;
        if (src) {
          const parsed = Date.parse(src);
          if (!Number.isNaN(parsed)) itemCreatedMs = parsed;
        }
      } catch(e) { itemCreatedMs = null; }
      // If this audit/booking/public_ref was optimistically deleted recently,
      // only suppress re-insertion when the incoming record is not newer than
      // the optimistic deletion (i.e. it's the same record being re-polled).
      try {
        if (auditIdStr && _recentlyDeletedAuditTimestamps[auditIdStr]){
          const ts = Number(_recentlyDeletedAuditTimestamps[auditIdStr]);
          if (itemCreatedMs === null || itemCreatedMs <= ts) return;
        }
        if (bookingIdStr && _recentlyDeletedBookingTimestamps[bookingIdStr]){
          const ts = Number(_recentlyDeletedBookingTimestamps[bookingIdStr]);
          if (itemCreatedMs === null || itemCreatedMs <= ts) return;
        }
        if (itemRef){
          const key = String(itemRef).toLowerCase();
          if (_recentlyDeletedPublicRefTimestamps[key]){
            const ts = Number(_recentlyDeletedPublicRefTimestamps[key]);
            if (itemCreatedMs === null || itemCreatedMs <= ts) return;
          }
        }
      } catch(e) {}
      if (auditIdStr) {
        const existingByAudit = document.querySelector(`#auditTableBody tr[data-audit-id="${auditIdStr}"]`);
        if (existingByAudit) return;
      }
      if (bookingIdStr) {
        const existingByBooking = document.querySelector(`#auditTableBody tr[data-booking-id="${bookingIdStr}"]`);
        if (existingByBooking) return;
      }
      if (itemRef) {
        const existingByRef = Array.from(document.querySelectorAll('#auditTableBody tr')).find(r => (r.dataset && String(r.dataset.publicRef || '').toLowerCase()) === String(itemRef).toLowerCase());
        if (existingByRef) return;
      }
    }catch(e){}
    // Remove any optimistic temp rows for the same booking_id (prevent dupes)
    try{
      const tempCbs = Array.from(document.querySelectorAll('.auditRowCb')).filter(cb => cb && String(cb.value).startsWith('tmp-'));
      for (const cb of tempCbs){
        try{
          const tr = cb.closest('tr'); if (!tr) continue;
          // Prefer dataset attributes (set on optimistic rows) for reconciliation
          const tempBookingId = tr.dataset.bookingId;
          const tempPublicRef = tr.dataset.publicRef;
          const itemRef = (item.public_ref || (item.snapshot && item.snapshot.public_ref) || (item.booking_id !== undefined ? String(item.booking_id) : ''));
          if ((tempBookingId && String(tempBookingId) === String(item.booking_id)) || (tempPublicRef && String(tempPublicRef) === String(itemRef))) {
            tr.remove();
          }
        }catch(e){}
      }
    }catch(e){}
    // Also remove any existing booking row in the main bookings table that matches this audit
    try{
      const bookingIdStr = (item.booking_id !== undefined && item.booking_id !== null) ? String(item.booking_id) : '';
      const bookingRef = (item.public_ref || (item.snapshot && item.snapshot.public_ref) || '') || '';
      if (bookingIdStr) {
        const bRow = document.querySelector(`#bookingsTableBody tr[data-booking-id="${bookingIdStr}"]`);
        if (bRow) try{ bRow.remove(); }catch(e){}
      }
      if (bookingRef) {
        const bRow2 = Array.from(document.querySelectorAll('#bookingsTableBody tr')).find(r => (r.dataset && String(r.dataset.publicRef) === String(bookingRef)));
        if (bRow2) try{ bRow2.remove(); }catch(e){}
      }
    }catch(e){}
    const tbody = document.getElementById('auditTableBody');
    const noRow = document.getElementById('noAuditRow'); if (noRow) noRow.remove();
    const tr = document.createElement('tr');
    // Prefer item.start/end but fall back to snapshot.start/end so the UI
    // shows both start and end immediately after client-initiated cancellations
    // where the server may only include those values inside snapshot.
    let startHtml = '-';
    const srcStart = item.start || (item.snapshot && item.snapshot.start);
    const srcEnd = item.end || (item.snapshot && item.snapshot.end);
    if (srcStart) {
      try {
        const sd = new Date(srcStart);
        const startDateStr = sd.toLocaleDateString(undefined,{month:'short',day:'numeric',year:'numeric'});
        let startTimeStr = sd.toLocaleTimeString(undefined,{hour:'numeric',minute:'2-digit'});
        startTimeStr = stripLeadingZeroFromTime(startTimeStr);
        let timeLine = startTimeStr;
        if (srcEnd) {
          try {
            const ed = new Date(srcEnd);
            let endTimeStr = ed.toLocaleTimeString(undefined,{hour:'numeric',minute:'2-digit'});
            endTimeStr = stripLeadingZeroFromTime(endTimeStr);
            timeLine = `${startTimeStr} - ${endTimeStr}`;
          } catch (e) { /* ignore end formatting */ }
        }
        startHtml = `<div style="font-weight:600;">${startDateStr}</div><div style="font-size:13px;color:#6c757d;">${timeLine}</div>`;
      } catch (e) { startHtml = '-'; }
    }
    // The "Booked At" should reflect the original booking time. Prefer
    // snapshot.created_at / created_display when present so cancelling/deleting
    // does not change the displayed booked-at value.
    let createdHtml = '';
    const srcCreated = (item.snapshot && (item.snapshot.created_at || item.snapshot.created_display)) || item.created_at || item.created_display;
    if (srcCreated) {
      try{
        const cd = new Date(srcCreated);
        if (!isNaN(cd)){
          let createdTime = cd.toLocaleTimeString(undefined,{hour:'numeric',minute:'2-digit'});
          createdTime = stripLeadingZeroFromTime(createdTime);
          createdHtml = `<div style="font-weight:600;">${cd.toLocaleDateString(undefined,{month:'short',day:'numeric',year:'numeric'})}</div><div style="font-size:13px;color:#6c757d;">${createdTime}</div>`;
        } else {
          // fallback: display raw string
          createdHtml = `<div style="font-weight:600;">${srcCreated}</div><div style="font-size:13px;color:#6c757d;">${''}</div>`;
        }
      }catch(e){ createdHtml = ''; }
    }
    let label = '';
    try{ if (item.event_type === 'deleted' && item.start && (new Date(item.start) < new Date())) label = 'Successful'; }catch(e){}
    if (!label) label = item.event_type ? (item.event_type.charAt(0).toUpperCase() + item.event_type.slice(1)) : '';
    let bookingDisplay = (item.snapshot && item.snapshot.public_ref) ? item.snapshot.public_ref : (item.public_ref || item.booking_id || '-');
    tr.innerHTML = `
      <td style="padding:8px;"><input type="checkbox" class="auditRowCb" value="${item.id}" style="margin-right:8px;" /></td>
      <td style="padding:8px;">${label}</td>
      <td style="padding:8px;">${startHtml}</td>
      <td style="padding:8px;">${bookingDisplay}</td>
      <td style="padding:8px;">${item.client_name || '-'}<div style="font-size:12px; color:#666">${item.client_email || ''}</div></td>
      <td style="padding:8px;">${item.service || '-'}</td>
      <td style="padding:8px;">${createdHtml}</td>
      <td style="padding:8px;"><button class="btn-sm btn-view" onclick="viewAudit(this)" data-snapshot='${JSON.stringify(item.snapshot).replace(/'/g, "\\'") }'>View</button></td>`;
    // Set dataset attributes for filtering/search
    try{
      tr.dataset.auditId = item.id;
      tr.dataset.eventType = (item.event_type || '').toLowerCase();
      // store displayed label too (e.g. 'Successful') for fine-grained filtering
      const dispLabel = (function(){ try{ if (item.event_type === 'deleted' && item.start && (new Date(item.start) < new Date())) return 'successful'; }catch(e){} return (item.event_type || '').toLowerCase(); })();
      tr.dataset.label = dispLabel;
      // Mark whether this cancelled audit retained a non-refunded charge
      try{ tr.dataset.nonRefunded = item.non_refunded ? '1' : ''; tr.dataset.refundWithinCutoff = item.refund_within_cutoff ? '1' : ''; }catch(e){ tr.dataset.nonRefunded = ''; tr.dataset.refundWithinCutoff = ''; }
      tr.dataset.serviceName = (item.service || '').toLowerCase();
      tr.dataset.client = (item.client_name || '').toLowerCase();
      tr.dataset.publicRef = (((item.snapshot && item.snapshot.public_ref) ? item.snapshot.public_ref : (item.public_ref || (item.booking_id !== undefined ? String(item.booking_id) : ''))) || '').toLowerCase();
    }catch(e){}

    if (tbody.firstChild) tbody.insertBefore(tr, tbody.firstChild); else tbody.appendChild(tr);
    try { if (item.id !== undefined && item.id !== null) { tr.dataset.auditId = String(item.id); _seenAuditIds.add(String(item.id)); } } catch(e) {}
  }catch(e){ console.error('insertAuditRow error', e); }
}

// Audit filters: event type, service, and search
function filterAudits(){
  try{
    const evt = (document.getElementById('auditEventFilter') && document.getElementById('auditEventFilter').value) ? String(document.getElementById('auditEventFilter').value).toLowerCase() : 'all';
    const svc = (document.getElementById('auditServiceFilter') && document.getElementById('auditServiceFilter').value) ? String(document.getElementById('auditServiceFilter').value).toLowerCase() : '';
    const searchTerm = (document.getElementById('auditSearch') && document.getElementById('auditSearch').value) ? document.getElementById('auditSearch').value.toLowerCase().trim() : '';

    document.querySelectorAll('#auditTableBody tr').forEach(row => {
      // skip placeholder rows without an audit id (e.g. 'no recent' placeholder)
      const auditIdAttr = row.dataset && row.dataset.auditId;
      if (!auditIdAttr) return;
      let show = true;
      const rowEvt = (row.dataset.eventType || '').toLowerCase();
      const rowLabel = (row.dataset.label || '').toLowerCase();
      const rowSvc = (row.dataset.servicename || row.dataset.serviceName || '').toLowerCase();
      const rowClient = (row.dataset.client || '').toLowerCase();
      const rowRef = (row.dataset.publicref || row.dataset.publicRef || '').toLowerCase();

      // Event filter: 'deleted' should include all deletions (including 'successful'),
      // 'successful' matches only the successful label, 'cancelled' matches cancelled.
      if (evt && evt !== 'all'){
        if (evt === 'successful'){
          if (rowLabel !== 'successful') show = false;
        } else if (evt === 'deleted'){
          if (rowEvt !== 'deleted') show = false;
        } else {
          if (rowEvt !== evt) show = false;
        }
      }

      // Service filter (normalize both sides)
      if (svc && svc !== ''){
        if (!rowSvc || rowSvc !== svc) show = false;
      }

      if (searchTerm){
        if (!(rowClient.includes(searchTerm) || rowRef.includes(searchTerm) || (row.querySelector('td:nth-child(5)') && row.querySelector('td:nth-child(5)').textContent.toLowerCase().includes(searchTerm)))){
          show = false;
        }
      }

      row.style.display = show ? '' : 'none';
    });
  }catch(e){ console.error('filterAudits error', e); }
}

// Wire audit filter controls
try{
  const aSearch = document.getElementById('auditSearch');
  const aEvt = document.getElementById('auditEventFilter');
  const aSvc = document.getElementById('auditServiceFilter');
  // debounce input to avoid re-filtering on every keystroke
  function _debounce(fn, wait){ let t = null; return function(){ const args = arguments; clearTimeout(t); t = setTimeout(() => fn.apply(this, args), wait); }; }
  if (aSearch) aSearch.addEventListener('input', _debounce(filterAudits, 200));
  if (aEvt) aEvt.addEventListener('change', filterAudits);
  if (aSvc) aSvc.addEventListener('change', filterAudits);
}catch(e){}

async function deleteBooking(id, date, clientName, skipConfirm = false) {
  if (!skipConfirm) {
    if (!confirm(`Delete booking for ${clientName} on ${date}?`)) return;
  }
  // Capture row details to show immediately in the audit list
  const row = document.querySelector(`tr[data-booking-id="${id}"]`);
  let svcText = '';
  let startDateText = '';
  let startTimeText = '';
  let clientEmail = '';
  if (row) {
    const cells = row.querySelectorAll('td');
    // columns: 0=checkbox, 1=date/time, 2=booking id, 3=client, 4=service, ...
    svcText = cells[4] ? cells[4].textContent.trim() : '';
    // extract both date and time lines from the booking date cell so optimistic audit shows both
    try{
      const dateCellDivs = cells[1] ? cells[1].querySelectorAll('div') : [];
      startDateText = dateCellDivs[0] ? dateCellDivs[0].textContent.trim() : '';
      startTimeText = dateCellDivs[1] ? dateCellDivs[1].textContent.trim() : '';
    }catch(e){ }
    const clientDivs = cells[3] ? cells[3].querySelectorAll('div') : [];
    clientEmail = clientDivs[1] ? clientDivs[1].textContent.trim() : '';
  }

  // Remove booking row immediately
  try { if (row) row.remove(); } catch (e) {}

  // Insert an optimistic (temporary) audit row immediately so the UI updates instantly.
  // The optimistic row includes dataset.bookingId and dataset.publicRef so the
  // authoritative insertion (from poll or server response) can detect and remove it.
  try {
    const tempId = 'tmp-' + Date.now();
    const tbody = document.getElementById('auditTableBody');
    const noRow = document.getElementById('noAuditRow'); if (noRow) noRow.remove();
    const tempTr = document.createElement('tr');
    tempTr.id = 'audit-temp-' + tempId;
    tempTr.dataset.tempId = tempId;
    try { tempTr.dataset.bookingId = String(id); } catch(e) { tempTr.dataset.bookingId = ''; }
    try { tempTr.dataset.publicRef = (row && row.dataset && row.dataset.publicRef) ? row.dataset.publicRef : ''; } catch(e) { tempTr.dataset.publicRef = ''; }
    const createdNowDate = new Date();
    const createdNowDateStr = createdNowDate.toLocaleDateString(undefined,{month:'short',day:'numeric',year:'numeric'});
    const createdNowTimeStr = createdNowDate.toLocaleTimeString(undefined,{hour:'numeric',minute:'2-digit'});
    const createdHtml = `<div style="font-weight:600;">${createdNowDateStr}</div><div style="font-size:13px;color:#6c757d;">${createdNowTimeStr}</div>`;
    const snapshot = { title: clientName || '', start: null, end: null, client_name: clientName || '', client_email: clientEmail || '', service_slug: svcText || '', service_price: null, business: ORG_NAME };
    let optimisticLabel = 'Deleted';
    try { if (row && row.dataset && row.dataset.status === 'past') optimisticLabel = 'Successful'; } catch(e){}
    const normalizedDate = startDateText || '';
    const normalizedTime = startTimeText ? stripLeadingZeroFromTime(startTimeText) : '';
    const startHtmlOpt = (normalizedDate || normalizedTime) ? (`<div style="font-weight:600;">${normalizedDate}</div><div style="font-size:13px;color:#6c757d;">${normalizedTime || '&nbsp;'}</div>`) : '-';
    tempTr.innerHTML = `
      <td style="padding:8px;"><input type="checkbox" class="auditRowCb" value="${tempId}" style="margin-right:8px;" /></td>
      <td style="padding:8px;">${optimisticLabel}</td>
      <td style="padding:8px;">${startHtmlOpt}</td>
      <td style="padding:8px;">${(row && row.dataset && row.dataset.publicRef) ? row.dataset.publicRef : '-'}</td>
      <td style="padding:8px;">${clientName || '-'}<div style="font-size:12px; color:#666">${clientEmail || ''}</div></td>
      <td style="padding:8px;">${svcText || '-'}</td>
      <td style="padding:8px;">${createdHtml}</td>
      <td style="padding:8px;"><button class="btn-sm btn-view" onclick="viewAudit(this)" data-snapshot='${JSON.stringify(snapshot).replace(/'/g, "\\'") }'>View</button></td>
    `;
    if (tbody.firstChild) tbody.insertBefore(tempTr, tbody.firstChild); else tbody.appendChild(tempTr);
  } catch(e) { console.error('Error inserting optimistic audit row', e); }

  // Now call delete endpoint; on success insert authoritative audit row
  try {
    const response = await fetch(`/bus/${orgSlug}/bookings/${id}/delete/`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': csrftoken
      }
    });

    if (response.ok) {
      try {
        const j = await response.json();
        if (j && j.audit) {
          try { insertAuditRow(j.audit); } catch(e) { console.error('Error inserting audit row after delete', e); }
        } else {
          showToast('error', 'Delete succeeded but no audit record was created');
        }
      } catch (e) { console.error('Error reading delete response', e); showToast('error','Error reading server response'); }
    } else {
      showToast('error', 'Failed to delete booking');
    }
  } catch (error) {
    console.error('Error:', error);
    showToast('error', 'Error deleting booking');
  }
}

async function undoAudit(btn) {
  if (!btn) return;
  const auditId = btn.dataset.auditId;
  if (!auditId) return;
  if (!confirm('Restore this booking back to the bookings list?')) return;

  try {
    const resp = await fetch(`/bus/${orgSlug}/bookings/audit/undo/`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
      body: JSON.stringify({ audit_id: Number(auditId) })
    });
    if (!resp.ok) { const txt = await resp.text(); alert('Restore failed: ' + txt); return; }
    const j = await resp.json();
    if (j && j.booking) {
      const b = j.booking;
      // remove audit row
      const tr = btn.closest('tr'); if (tr) { try { if (tr.dataset && tr.dataset.auditId) _seenAuditIds.delete(String(tr.dataset.auditId)); } catch(e){} tr.remove(); }
      // also remove any other audit rows for the same booking_id or public_ref (defensive)
      try{
        document.querySelectorAll('.auditRowCb').forEach(cb => {
          try{
            const ct = cb.closest('tr'); if (!ct) return;
            const tempBookingId = ct.dataset.bookingId;
            const tempPublicRef = ct.dataset.publicRef;
            const bookRef = (b && (b.public_ref || (b.booking_id !== undefined ? String(b.booking_id) : '')));
            if ((tempBookingId && String(tempBookingId) === String(b.booking_id)) || (tempPublicRef && String(tempPublicRef) === String(bookRef))) {
              try { if (ct.dataset && ct.dataset.auditId) _seenAuditIds.delete(String(ct.dataset.auditId)); } catch(e){}
              ct.remove();
            }
          }catch(e){}
        });
      }catch(e){}
      // Insert booking row using helper
      insertBookingRow(b, true);
      showToast('success', 'Booking restored');
    }
  } catch (e) { console.error(e); alert('Error restoring booking'); }
}

// Audit select-all and export
const auditSelectAll = document.getElementById('auditSelectAll');
if (auditSelectAll) {
  auditSelectAll.addEventListener('change', (e) => {
    document.querySelectorAll('.auditRowCb').forEach(cb => cb.checked = e.target.checked);
  });
}

// Bookings select-all and select-by-status handlers
const bookingsSelectAll = document.getElementById('bookingsSelectAll');
if (bookingsSelectAll) {
  bookingsSelectAll.addEventListener('change', (e) => {
    // only affect visible rows
    document.querySelectorAll('#bookingsTableBody tr').forEach(row => {
      if (row.style.display === 'none') return;
      const cb = row.querySelector('.bookingRowCb'); if (cb) cb.checked = e.target.checked;
    });
    updateBulkDeleteVisibility();
  });
}

function deselectAllBookings(){ document.querySelectorAll('.bookingRowCb').forEach(cb => cb.checked = false); if (bookingsSelectAll) bookingsSelectAll.checked = false; updateBulkDeleteVisibility(); }
function selectByStatus(status){ document.querySelectorAll('#bookingsTableBody tr').forEach(row => { const cb = row.querySelector('.bookingRowCb'); if (!cb) return; if (row.style.display === 'none') return; if (status === 'all') cb.checked = true; else if (row.dataset.status === status) cb.checked = true; else cb.checked = false; }); if (bookingsSelectAll) bookingsSelectAll.checked = false; updateBulkDeleteVisibility(); }

const selectAllBookingsBtn = document.getElementById('selectAllBookingsBtn'); if (selectAllBookingsBtn) selectAllBookingsBtn.addEventListener('click', () => selectByStatus('all'));
const selectStatusMenu = document.getElementById('selectStatusMenu');
if (selectStatusMenu) {
  selectStatusMenu.addEventListener('change', (e) => {
    const v = e.target.value;
    if (v === 'deselect') {
      deselectAllBookings();
    } else if (v) {
      selectByStatus(v);
    }
    // reset menu back to placeholder
    setTimeout(() => { selectStatusMenu.value = ''; }, 150);
  });
}

// Bulk delete UI wiring
const bulkDeleteBtn = document.getElementById('bulkDeleteBtn');
function updateBulkDeleteVisibility(){
  if (bulkDeleteBtn) bulkDeleteBtn.style.display = 'none';
}

// Update visibility when individual checkboxes change (delegated)
const bookingsTbody = document.getElementById('bookingsTableBody');
if (bookingsTbody){
  bookingsTbody.addEventListener('change', (e) => {
    if (e.target && e.target.classList && e.target.classList.contains('bookingRowCb')){
      updateBulkDeleteVisibility();
    }
  });
}

// Audit tbody delegated change handler: keep select-all in sync when individual boxes change
const auditTbody = document.getElementById('auditTableBody');
if (auditTbody){
  auditTbody.addEventListener('change', (e) => {
    if (e.target && e.target.classList && e.target.classList.contains('auditRowCb')){
      try{
        const all = Array.from(document.querySelectorAll('#auditTableBody .auditRowCb')).filter(cb => cb.closest('tr') && cb.closest('tr').style.display !== 'none');
        const checked = all.filter(cb => cb.checked);
        if (auditSelectAll) auditSelectAll.checked = (all.length > 0 && checked.length === all.length);
      }catch(e){ }
    }
  });
}

if (bulkDeleteBtn){
  bulkDeleteBtn.addEventListener('click', async () => {
    const checked = Array.from(document.querySelectorAll('.bookingRowCb:checked')).filter(cb => cb.closest('tr') && cb.closest('tr').style.display !== 'none');
    if (!checked.length) return;
    // Prevent deleting ongoing
    const ongoing = checked.some(cb => cb.closest('tr').dataset.status === 'ongoing');
    if (ongoing){ alert('Cannot delete ongoing bookings'); return; }
    if (!confirm(`Permanently delete ${checked.length} selected bookings? This cannot be undone.`)) return;
    // Call deleteBooking for each selected row without per-call confirmation
    for (const cb of checked){
      try{
        const tr = cb.closest('tr');
        const id = Number(cb.value);
        // gather date and client for UI friendly messages
        const dateCell = tr.querySelectorAll('td')[1];
        const dateText = dateCell ? (dateCell.querySelector('div') ? dateCell.querySelector('div').textContent : '') : '';
        const clientCell = tr.querySelectorAll('td')[2];
        const clientName = clientCell ? (clientCell.querySelector('div') ? clientCell.querySelector('div').textContent : '') : '';
        // call deleteBooking with skipConfirm = true
        deleteBooking(id, dateText, clientName, true);
      }catch(e){ console.error('Bulk delete item error', e); }
    }
    // After initiating deletes, hide bulk button until state updates
    updateBulkDeleteVisibility();
  });
}

const exportAuditBtn = document.getElementById('exportAuditBtn');
if (exportAuditBtn) {
  exportAuditBtn.addEventListener('click', async () => {
    // Export selected audit rows
    const ids = Array.from(document.querySelectorAll('#auditTableBody .auditRowCb:checked')).filter(cb => cb.closest('tr') && cb.closest('tr').style.display !== 'none').map(cb => Number(cb.value));
    if (!ids.length) { alert('No audit rows selected to export'); return; }
    try {
      const resp = await fetch(`/bus/${orgSlug}/bookings/audit/export/`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
        body: JSON.stringify({ ids })
      });
      if (!resp.ok) { alert('Export failed'); return; }
      const blob = await resp.blob();
      const contentType = resp.headers.get('Content-Type') || '';
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      if (contentType === 'application/pdf') a.download = 'audit_export.pdf';
      else a.download = 'audit_export.json';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    } catch (e) { console.error(e); alert('Export error'); }
  });

  const deleteAuditBtn = document.getElementById('deleteAuditBtn');
  if (deleteAuditBtn){
    deleteAuditBtn.addEventListener('click', async () => {
      // Delete selected audit rows (optimistic removal for instant UX)
      const checked = Array.from(document.querySelectorAll('#auditTableBody .auditRowCb:checked')).filter(cb => cb.closest('tr') && cb.closest('tr').style.display !== 'none');
      if (!checked.length) { alert('No audit rows selected to delete'); return; }
      if (!confirm('Permanently delete the selected audit records? This cannot be undone.')) return;

      const tbody = document.getElementById('auditTableBody');
      const removed = checked.map(cb => {
        const tr = cb.closest('tr');
        const idx = tr && tbody ? Array.prototype.indexOf.call(tbody.children, tr) : -1;
        const auditId = (tr && tr.dataset && tr.dataset.auditId) ? String(tr.dataset.auditId) : null;
        const val = cb.value;
        const html = tr ? tr.outerHTML : '';
        return { tr, idx, auditId, val, html };
      });

      // Optimistically remove rows & update cache. Record deletion timestamps
      // so that subsequent poll results for the same record (same created_at)
      // can be suppressed briefly without impacting genuinely new audits.
      try {
        for (const r of removed){
          if (!r.tr) continue;
          try {
            const tr = r.tr;
            const aId = (tr.dataset && tr.dataset.auditId) ? String(tr.dataset.auditId) : null;
            const bId = (tr.dataset && tr.dataset.bookingId) ? String(tr.dataset.bookingId) : null;
            const pref = (tr.dataset && tr.dataset.publicRef) ? String(tr.dataset.publicRef) : null;
            const ts = Date.now();
            // record timestamps for suppression decisions
            if (aId) {
              try{ _seenAuditIds.delete(String(aId)); }catch(e){}
              try{ _recentlyDeletedAuditTimestamps[aId] = ts; }catch(e){}
              setTimeout(() => { try{ delete _recentlyDeletedAuditTimestamps[aId]; }catch(e){} }, 30000);
            }
            if (bId) {
              try{ _recentlyDeletedBookingTimestamps[bId] = ts; }catch(e){}
              setTimeout(() => { try{ delete _recentlyDeletedBookingTimestamps[bId]; }catch(e){} }, 30000);
            }
            if (pref) {
              try{ _recentlyDeletedPublicRefTimestamps[String(pref).toLowerCase()] = ts; }catch(e){}
              setTimeout(() => { try{ delete _recentlyDeletedPublicRefTimestamps[String(pref).toLowerCase()]; }catch(e){} }, 30000);
            }
            // Instead of removing the row from the DOM (which allows the poll
            // to re-insert it), hide it and mark as deleting. This lets
            // insertAuditRow detect the existing row and avoid re-insertion.
            try{ tr.dataset.deleting = '1'; tr.style.display = 'none'; }catch(e){}
          } catch(e){}
        }
      } catch(e){ console.error('optimistic remove error', e); }

      // Build numeric ids to send to server. Prefer the checkbox value when
      // it's numeric (covers server-rendered rows), otherwise fall back to
      // dataset.auditId (covers some cases where value may be 'tmp-...').
      let ids = removed.map(r => {
        const fromCheckbox = Number(r.val);
        if (Number.isFinite(fromCheckbox)) return fromCheckbox;
        const fromDataset = (r.auditId !== null && r.auditId !== undefined) ? Number(r.auditId) : null;
        return Number.isFinite(fromDataset) ? fromDataset : null;
      }).filter(n => n !== null);

      // If we couldn't derive any numeric ids locally (e.g. optimistic rows
      // used tmp-* values), query the server audit list and map rows by
      // booking id or public_ref to find canonical audit ids to delete.
      if (!ids || ids.length === 0) {
        try{
          const listResp = await fetch(`/bus/${orgSlug}/bookings/audit/?since=${encodeURIComponent('1970-01-01T00:00:00Z')}`);
          if (listResp && listResp.ok){
            const j = await listResp.json();
            const serverItems = Array.isArray(j.items) ? j.items : (j && j.items) || [];
            const mapped = [];
            for (const r of removed){
              try{
                const tr = r.tr;
                if (!tr) continue;
                const bid = tr.dataset && tr.dataset.bookingId ? String(tr.dataset.bookingId) : null;
                const pref = tr.dataset && tr.dataset.publicRef ? String(tr.dataset.publicRef).toLowerCase() : null;
                const found = serverItems.find(it => {
                  try{
                    if (it && it.id && (bid && String(it.booking_id) === String(bid))) return true;
                    const itPref = (it.public_ref || (it.snapshot && it.snapshot.public_ref) || '');
                    if (pref && itPref && String(itPref).toLowerCase() === pref) return true;
                  }catch(e){}
                  return false;
                });
                if (found && found.id) mapped.push(Number(found.id));
              }catch(e){}
            }
            if (mapped.length) {
              ids = Array.from(new Set(mapped));
            }
          }
        }catch(e){ console.error('Error mapping audit ids from server list', e); }
      }

      deleteAuditBtn.disabled = true;
      try {
        // debug logging removed
        const resp = await fetch(`/bus/${orgSlug}/bookings/audit/delete/`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
          body: JSON.stringify({ ids })
        });
        let rawText = '';
        try { rawText = await resp.clone().text(); } catch(e) { rawText = '<could not read response text>'; }
        if (!resp.ok) {
          // restore removed rows on failure
          try{
            for (const r of removed){
              try{
                // If we hid the original row, simply un-hide it; otherwise re-insert
                if (r.tr && tbody.contains(r.tr)){
                  try{ r.tr.style.display = ''; delete r.tr.dataset.deleting; }catch(e){}
                  if (r.auditId) try{ _seenAuditIds.add(String(r.auditId)); }catch(e){}
                } else if (tbody) {
                  const wrapper = document.createElement('tbody'); wrapper.innerHTML = r.html; const node = wrapper.firstChild;
                  if (r.idx >= 0 && r.idx < tbody.children.length) tbody.insertBefore(node, tbody.children[r.idx]); else tbody.appendChild(node);
                  if (r.auditId) try{ _seenAuditIds.add(String(r.auditId)); }catch(e){}
                }
              }catch(ignore){}
            }
          }catch(er){ console.error('restore on failed resp', er); }
          alert('Delete failed');
          return;
        }
        const data = await resp.json();
        const deletedCount = (data && Number(data.deleted)) ? Number(data.deleted) : 0;
        if (deletedCount <= 0) {
          // Server reported 0 removed â€” try one automatic retry after short delay
          try{
            await new Promise(res => setTimeout(res, 1000));
            // Fetch latest audits to reconcile canonical IDs in case temporary
            // values were sent earlier or the client-side ID disagrees with server.
            // initial ids logging removed
            const listResp = await fetch(`/bus/${orgSlug}/bookings/audit/?since=${encodeURIComponent('1970-01-01T00:00:00Z')}`);
            if (listResp && listResp.ok){
              const listJson = await listResp.json();
              const serverItems = Array.isArray(listJson.items) ? listJson.items : (listJson && listJson.items) || [];
              const serverIds = new Set(serverItems.map(it => (it && it.id) ? Number(it.id) : null).filter(n => Number.isFinite(n)));
              // Find any intersection between requested ids and server ids
              const intersect = ids.filter(i => serverIds.has(i));
              if (intersect.length > 0){
                const retryResp = await fetch(`/bus/${orgSlug}/bookings/audit/delete/`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
                  body: JSON.stringify({ ids: intersect })
                });
                if (retryResp && retryResp.ok){
                  const retryData = await retryResp.json();
                  const retryDeleted = (retryData && Number(retryData.deleted)) ? Number(retryData.deleted) : 0;
                  if (retryDeleted > 0){
                    try{ for (const r of removed){ if (r.tr && tbody && tbody.contains(r.tr)){ try{ r.tr.remove(); }catch(e){} } } }catch(e){}
                    showToast('success', `Deleted ${retryDeleted} audit rows.`);
                    deleteAuditBtn.disabled = false;
                    return;
                  }
                }
              }
            }
          }catch(retryErr){ console.error('retry delete error', retryErr); }
          // Retry didn't remove anything â€” restore hidden rows and surface error
          try{
            for (const r of removed){
              try{
                if (r.tr && tbody && tbody.contains(r.tr)){
                  try{ r.tr.style.display = ''; delete r.tr.dataset.deleting; }catch(e){}
                  if (r.auditId) try{ _seenAuditIds.add(String(r.auditId)); }catch(e){}
                } else if (tbody) {
                  const wrapper = document.createElement('tbody'); wrapper.innerHTML = r.html; const node = wrapper.firstChild;
                  if (r.idx >= 0 && r.idx < tbody.children.length) tbody.insertBefore(node, tbody.children[r.idx]); else tbody.appendChild(node);
                  if (r.auditId) try{ _seenAuditIds.add(String(r.auditId)); }catch(e){}
                }
              }catch(ignore){}
            }
          }catch(er){ console.error('restore on zero-deleted resp', er); }
          showToast('error', 'Delete failed (server reported 0 rows removed)');
        } else {
          // Server removed some rows: permanently remove the hidden rows we tracked
          try{
            for (const r of removed){
              try{
                if (r.tr && tbody && tbody.contains(r.tr)){
                  try{ r.tr.remove(); }catch(e){}
                }
              }catch(ignore){}
            }
          }catch(er){ console.error('cleanup after success', er); }
          showToast('success', `Deleted ${deletedCount} audit rows.`);
        }
      } catch (e) {
        console.error(e);
        // network/error: restore hidden rows (un-hide) or re-insert if missing
        try{
          for (const r of removed){
            try{
              if (r.tr && tbody && tbody.contains(r.tr)){
                try{ r.tr.style.display = ''; delete r.tr.dataset.deleting; }catch(e){}
                if (r.auditId) try{ _seenAuditIds.add(String(r.auditId)); }catch(e){}
              } else if (tbody) {
                const wrapper = document.createElement('tbody'); wrapper.innerHTML = r.html; const node = wrapper.firstChild;
                if (r.idx >= 0 && r.idx < tbody.children.length) tbody.insertBefore(node, tbody.children[r.idx]); else tbody.appendChild(node);
                if (r.auditId) try{ _seenAuditIds.add(String(r.auditId)); }catch(e){}
              }
            }catch(ignore){}
          }
        }catch(er){ console.error('restore after error', er); }
        alert('Delete error');
      } finally { deleteAuditBtn.disabled = false; }
    });
  }
}
</script>
{% endblock %}
