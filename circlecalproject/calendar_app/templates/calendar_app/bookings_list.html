{% extends "calendar_app/base.html" %}
{% load tz %}
{% block title %}Bookings - {{ organization.name }}{% endblock %}

{# Mobile-only: break out of base <main> constraints; keep normal base layout on sm+ #}
{% block main_class %}w-full max-w-none px-0 py-0 sm:max-w-6xl sm:mx-auto sm:px-4 sm:py-10{% endblock %}

{% block content %}
<style>
  :root { --row-height: 64px; }
  /* default visible rows if user hasn't selected one */
  :root { --visible-rows-default: 10; }
  .bookings-container { max-width: 1200px; margin: 0 auto; padding: 20px; }
  .bookings-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px; }
  .filter-controls { display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap; }
  .filter-btn { padding: 6px 10px; border: 1px solid #ddd; background: white; border-radius: 6px; cursor: pointer; transition: all .15s; font-size: 12px; }
  .filter-btn.active { background: #007bff; color: white; border-color: #007bff; }
  .filter-btn:hover { border-color: #007bff; }
  .bookings-table { width: 100%; border-collapse: collapse; background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
  .bookings-table th { background: #f8f9fa; padding: 12px; text-align: left; font-weight: 600; border-bottom: 2px solid #dee2e6; }
  .bookings-table td { padding: 12px; border-bottom: 1px solid #dee2e6; }
  .bookings-table tr:hover { background: #f8f9fa; }
  .status-badge { padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: 600; }
  .status-upcoming { background: #d1ecf1; color: #0c5460; }
  .status-past { background: #d6d8db; color: #383d41; }
  .status-today { background: #d4edda; color: #155724; }
  .status-ongoing { background: #d4edda; color: #155724; }
  .booking-actions { display: flex; gap: 8px; }
  .btn-sm { padding: 4px 12px; font-size: 13px; border: none; border-radius: 4px; cursor: pointer; transition: all .2s; }
  .btn-view { background: #007bff; color: white; }
  .btn-view:hover { background: #0056b3; }
  .btn-delete { background: #dc3545; color: white; }
  .btn-delete:hover { background: #c82333; }
  .no-bookings { text-align: center; padding: 60px 20px; color: #6c757d; }
  .search-box { padding: 6px 10px; border: 1px solid #ddd; border-radius: 6px; width: 200px; font-size: 13px; }
  /* Wrapper to constrain visible rows to ~10 and enable scrolling for overflow */
  .table-wrapper {
    /* use the selected visible rows (fallback to default) */
    --visible-rows: var(--bookings-visible-rows, var(--visible-rows-default));
    max-height: calc(var(--row-height) * var(--visible-rows));
    overflow: auto;
    background: white;
    padding: 12px;
    border-radius: 12px;
    box-shadow: 0 18px 40px rgba(2,6,23,0.10);
  }
  .table-wrapper.cc-visible-all { max-height: none !important; }
  /* Slightly lift the whole bookings area to give depth rather than flat table rows */
  /* Small visual tweak so scroller area shows rounded corners consistently */
  .table-wrapper .bookings-table { margin: 0; }

  /* Loading state for audit delete button */
  .btn-sm.is-loading { opacity: .85; cursor: wait; }
  .btn-loading-spinner {
    display: inline-block;
    width: 14px;
    height: 14px;
    border: 2px solid rgba(255,255,255,0.55);
    border-top-color: rgba(255,255,255,1);
    border-radius: 9999px;
    animation: spin .8s linear infinite;
    vertical-align: -2px;
    margin-right: 8px;
  }
  @keyframes spin { to { transform: rotate(360deg); } }

  /* Booking details modal: keep compact so it fits */
  .cc-booking-modal-card {
    background: white;
    padding: 18px;
    border-radius: 10px;
    max-width: 420px;
    width: 100%;
    position: relative;
    max-height: 80vh;
    overflow: auto;
  }
  .cc-booking-modal-title { margin: 0 0 12px 0; font-size: 20px; }
  .cc-booking-modal-grid { display: grid; gap: 10px; }
  .cc-booking-modal-label { font-size: 13px; font-weight: 700; }
  .cc-booking-modal-value { color: #666; margin-top: 3px; font-size: 13px; }
  .cc-booking-modal-subvalue { color: #666; margin-top: 3px; font-size: 12px; }
  .cc-booking-modal-actions { display: flex; justify-content: flex-end; gap: 8px; margin-top: 16px; }
  .cc-booking-modal-close {
    position: absolute;
    top: 8px;
    right: 10px;
    background: none;
    border: none;
    font-size: 20px;
    cursor: pointer;
    color: #666;
    line-height: 1;
  }

  /* Bulk delete modal */
  .cc-bulk-modal-card {
    background: white;
    padding: 18px;
    border-radius: 10px;
    max-width: 720px;
    width: 100%;
    position: relative;
    max-height: 80vh;
    overflow: auto;
  }
  .cc-bulk-list {
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 10px;
    background: #f8f9fa;
    max-height: 220px;
    overflow: auto;
  }
  .cc-bulk-row {
    padding: 8px 6px;
    border-bottom: 1px solid #e9ecef;
    font-size: 13px;
  }
  .cc-bulk-row:last-child { border-bottom: none; }
  .cc-bulk-row-title { font-weight: 700; }
  .cc-bulk-row-sub { color: #6c757d; font-size: 12px; margin-top: 2px; }
  .cc-bulk-option {
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 10px;
    margin-top: 10px;
  }
  .cc-bulk-option-title { font-weight: 700; font-size: 13px; }
  .cc-bulk-option-desc { color: #6c757d; font-size: 12px; margin-top: 4px; }
  .cc-bulk-textarea {
    width: 100%;
    min-height: 80px;
    padding: 8px 10px;
    border: 1px solid #ddd;
    border-radius: 8px;
    font-size: 13px;
    resize: vertical;
  }
  /* Elevated panel helper for audit and other sections */
  .panel-elevated { margin-top: 28px; }
  .panel-elevated h2 { font-weight: 700; }

  /* Scope filter: native select on desktop; custom dropdown on mobile */
  .cc-scope-wrap { position: relative; }
  /* Progressive enhancement: keep native <select> visible unless JS enables custom UI */
  .cc-scope-wrap .cc-scope-btn,
  .cc-scope-wrap .cc-scope-menu { display: none; }
  .cc-scope-wrap.cc-scope-enhanced #scopeFilter { display: none; }
  .cc-scope-wrap.cc-scope-enhanced .cc-scope-btn,
  .cc-scope-wrap.cc-scope-enhanced .cc-scope-menu { display: block; }

  /* When JS toggles `hidden`, it must override the enhanced display rule */
  .cc-scope-wrap.cc-scope-enhanced .cc-scope-menu[hidden] { display: none !important; }

  .cc-scope-btn {
    width: 100%;
    text-align: left;
    padding: 10px 12px;
    font-size: 14px;
    line-height: 1.25;
    white-space: normal;
  }
  .cc-scope-btn::after {
    content: "\25BE";
    float: right;
    color: #6b7280;
    margin-left: 10px;
  }
  .cc-scope-menu {
    position: absolute;
    top: calc(100% + 6px);
    left: 0;
    right: 0;
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
    background: #fff;
    border: 1px solid #ddd;
    border-radius: 12px;
    padding: 6px;
    box-shadow: 0 18px 40px rgba(2,6,23,0.18);
    z-index: 1000;
    max-height: min(55vh, 360px);
    overflow: auto;
  }
  .cc-scope-menu[hidden] { display: none; }

  /* Larger screens: allow a taller menu so it's easier to browse */
  @media (min-width: 641px) {
    .cc-scope-menu {
      /* Wider popover on desktop/tablet while staying within viewport */
      left: 50%;
      right: auto;
      width: min(560px, 92vw);
      max-width: min(560px, 92vw);
      transform: translateX(-50%);
      max-height: min(70vh, 520px);
    }
  }
  .cc-scope-group {
    padding: 8px 10px;
    font-weight: 800;
    color: #111827;
    background: #f3f4f6;
    border-radius: 10px;
    margin: 6px 4px 4px 4px;
    font-size: 13px;
  }
  .cc-scope-item {
    width: 100%;
    text-align: left;
    border: 0;
    background: transparent;
    padding: 10px;
    border-radius: 10px;
    cursor: pointer;
    font-size: 13px;
    line-height: 1.25;
    word-break: break-word;
  }
  .cc-scope-item:hover { background: #f9fafb; }
  .cc-scope-item.is-selected { background: #e8f0ff; font-weight: 700; }

  /* Mobile-only: 95% width containers + prevent horizontal overflow */
  @media (max-width: 640px) {
    :root { --row-height: 78px; }

    .bookings-container {
      width: 95vw;
      max-width: 95vw;
      margin: 24px auto;
      padding: 0;
    }

    /* Ensure padding/borders don't create overflow */
    .bookings-container, .bookings-container * { box-sizing: border-box; }

    .bookings-header {
      flex-direction: column;
      align-items: flex-start;
      gap: 12px;
    }

    .bookings-header h1 {
      width: 100%;
      text-align: center;
    }

    .cc-bookings-actions,
    .cc-bookings-rows {
      width: 100%;
      flex-wrap: wrap;
      justify-content: center;
    }

    #visibleRowsSelect,
    #visibleRowsCustomInput {
      max-width: 100%;
    }

    .filter-controls { width: 100%; gap: 10px; }
    .filter-controls .search-box { width: 100%; max-width: 100%; }
    .filter-controls select { max-width: 100%; }

    /* Ensure the "All Services" dropdown fits mobile width */
    #scopeFilter {
      width: 100% !important;
      max-width: 100% !important;
      min-width: 0 !important;
      box-sizing: border-box;
    }

    .cc-scope-wrap { flex: 1 1 100%; width: 100%; }

    /* Make filter buttons wrap in a predictable grid-like way */
    .filter-controls button.filter-btn {
      flex: 1 1 calc(33.333% - 10px);
      text-align: center;
      white-space: nowrap;
    }
    /* Service/member scope dropdown should be full-width on mobile */
    .filter-controls select.filter-btn {
      flex: 1 1 100%;
      width: 100%;
    }

    /* Audit controls: stack and keep inputs/selects inside viewport */
    .cc-audit-controls {
      flex-direction: column;
      align-items: stretch;
      gap: 10px;
    }
    .cc-audit-left,
    .cc-audit-right {
      width: 100%;
      flex-wrap: wrap;
      justify-content: center;
    }
    #auditSearch { width: 100% !important; max-width: 100% !important; }
    #auditEventFilter,
    #auditServiceFilter {
      flex: 1 1 calc(50% - 8px);
      max-width: 100%;
    }
    #exportAuditBtn,
    #deleteAuditBtn {
      flex: 1 1 calc(50% - 8px);
    }

    .table-wrapper {
      width: 100%;
      max-width: 100%;
      padding: 12px;
      border-radius: 12px;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }

    /* Mobile: keep rows looking like desktop by allowing horizontal scroll (no squished columns) */
    .table-wrapper .bookings-table {
      width: max-content !important;
      min-width: 920px;
    }
    .bookings-table th,
    .bookings-table td {
      white-space: nowrap;
    }

    /* Taller rows + slightly larger text (we have a scroller, so readability > density) */
    .bookings-table th,
    .bookings-table td {
      padding: 12px 10px;
      font-size: 13px;
      line-height: 1.35;
      vertical-align: top;
    }
    .bookings-table th { font-size: 13px; }
    .bookings-table td div { font-size: 13px !important; }
    .status-badge { font-size: 12px; padding: 4px 8px; }
    .btn-sm { padding: 6px 12px; font-size: 13px; }
    .booking-actions { flex-wrap: wrap; }

    /* Modals: keep within viewport on mobile */
    .cc-booking-modal-card,
    .cc-bulk-modal-card {
      max-width: 95vw;
    }

    /* Audit modal also needs to fit */
    #auditModal > div { max-width: 95vw; }
  }
</style>

<div class="bookings-container">
    <div class="bookings-header">
      <h1 style="font-size: 2rem; font-weight: bold; margin: 0;">Bookings</h1>
      <div class="cc-bookings-actions" style="display:flex; gap:8px; align-items:center;">
      {% if user_org_role != 'staff' %}
        <a href="{% url 'calendar_app:calendar' organization.slug %}" class="btn-sm btn-view">View Calendar</a>
      {% endif %}
      <a href="{% url 'calendar_app:dashboard' organization.slug %}" class="btn-sm btn-view">Back to Dashboard</a>
    </div>
    <div class="cc-bookings-rows" style="display:flex; gap:8px; align-items:center;">
      <label for="visibleRowsSelect" style="font-size:13px; color:#555;">Rows:</label>
      <select id="visibleRowsSelect" style="padding:6px 8px; border-radius:6px; font-size:13px;">
        <option value="5">5</option>
        <option value="10">10</option>
        <option value="15">15</option>
        <option value="20">20</option>
        <option value="all">All</option>
        <option value="custom">Custom</option>
      </select>
      <input id="visibleRowsCustomInput" type="number" min="1" placeholder="Rows" style="display:none; margin-left:6px; padding:6px 8px; width:90px; border-radius:6px;" />
    </div>
  </div>

  <!-- Filters -->
  <div class="filter-controls">
    <input type="text" id="searchBox" class="search-box" placeholder="Search by name or email...">
    <button class="filter-btn active" data-filter="all">All</button>
    <button class="filter-btn" data-filter="upcoming">Upcoming</button>
    <button class="filter-btn" data-filter="ongoing">Ongoing</button>
    <button class="filter-btn" data-filter="today">Today</button>
    <button class="filter-btn" data-filter="past">Past</button>
    <div id="ccScopeWrap" class="cc-scope-wrap">
      <select id="scopeFilter" class="filter-btn" style="padding: 8px 12px;">
        <option value="" {% if not selected_scope %}selected{% endif %}>All Services</option>
        <optgroup label="Members">
          {% for opt in scope_member_options %}
            <option value="{{ opt.value }}" {% if selected_scope == opt.value %}selected{% endif %}>{{ opt.label }}</option>
          {% endfor %}
        </optgroup>

        {% if scope_service_member_options %}
        <optgroup label="Personal services">
          {% for opt in scope_service_member_options %}
            <option value="{{ opt.value }}" {% if selected_scope == opt.value %}selected{% endif %}>{{ opt.label }}</option>
          {% endfor %}
        </optgroup>
        {% endif %}

        <optgroup label="Other / Group Services">
          {% for opt in scope_service_other_options %}
            <option value="{{ opt.value }}" {% if selected_scope == opt.value %}selected{% endif %}>{{ opt.label }}</option>
          {% endfor %}
        </optgroup>
      </select>

      {# Mobile-only custom dropdown (prevents popup leaking past viewport width) #}
      <button type="button" id="ccScopeBtn" class="filter-btn cc-scope-btn" aria-haspopup="listbox" aria-expanded="false"></button>
      <div id="ccScopeMenu" class="cc-scope-menu" role="listbox" aria-label="Service scope" hidden></div>
    </div>
    {% if user_org_role != 'staff' %}
      <button id="deleteSelectedBtn" class="btn-sm btn-delete" onclick="deleteSelected()" style="display:none; margin-left:8px;">Delete selected</button>
    {% endif %}
  </div>

  <!-- Bookings Table -->
  <div class="table-wrapper">
    <table class="bookings-table">
    <thead>
      <tr>
        <th style="padding:8px; text-align:left; font-weight:600;"><input type="checkbox" id="selectAllBookings"/></th>
        <th>Date & Time</th>
        <th>Booking ID</th>
        <th>Client</th>
        <th>Service</th>
        <th>Duration</th>
        <th>Status</th>
        <th>Booked At</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody id="bookingsTableBody">
      {% if bookings %}
        {% for booking in bookings %}
        <tr data-booking-id="{{ booking.id }}" data-public-ref="{{ booking.public_ref|default:'' }}" 
          data-status="{% if booking.start <= now and booking.end >= now %}ongoing{% elif booking.start.date == today %}today{% elif booking.start < now %}past{% else %}upcoming{% endif %}"
          data-service-id="{{ booking.service.id|default:'' }}"
          data-service-price="{{ booking.service.price|default:'' }}"
          data-payment-method="{{ booking.payment_method|default:'' }}"
          data-offline-method="{{ booking.offline_payment_method|default:'' }}"
          data-search="{{ booking.client_name|lower }} {{ booking.client_email|lower }} {{ booking.public_ref|default:''|lower }} {{ booking.id }}">
          <td style="padding:8px;"><input type="checkbox" class="bookingRowCb" value="{{ booking.id }}" style="margin-right:8px;"/></td>
          <td>
            {% timezone organization.timezone %}
              <div style="font-weight: 600;">{{ booking.start|date:"M d, Y" }}</div>
              <div style="font-size: 13px; color: #6c757d;">{{ booking.start|time:"g:i A" }} - {{ booking.end|time:"g:i A" }}</div>
            {% endtimezone %}
          </td>
          <td>
            <div>{{ booking.public_ref|default:booking.id }}</div>
          </td>
          <td>
            <div style="font-weight: 600;">{{ booking.client_name|default:"No name" }}</div>
            <div style="font-size: 13px; color: #6c757d;">{{ booking.client_email|default:"No email" }}</div>
          </td>
          <td>{{ booking.service.name|default:"N/A" }}</td>
          <td>{{ booking.service.duration|default:"-" }} min</td>
          <td>
            {% timezone organization.timezone %}
                {% if booking.start and booking.end and booking.start <= now and booking.end >= now %}
                  <span class="status-badge status-ongoing">Ongoing</span>
                {% elif booking.start|date == today %}
                  <span class="status-badge status-today">Today</span>
                {% elif booking.start < now %}
                  <span class="status-badge status-past">Past</span>
                {% else %}
                  <span class="status-badge status-upcoming">Upcoming</span>
                {% endif %}
            {% endtimezone %}
          </td>
          <td>
            {% timezone organization.timezone %}
              <div style="font-weight: 600;">{{ booking.created_at|date:"M d, Y" }}</div>
              <div style="font-size: 13px; color: #6c757d;">{{ booking.created_at|time:"g:i A" }}</div>
            {% endtimezone %}
          </td>
          <td>
              <div class="booking-actions">
              <button class="btn-sm btn-view" onclick="viewBooking({{ booking.id }})">View</button>
              <a class="btn-sm" href="{% url 'bookings:booking_ics' booking.id %}" style="background:#0069d9; color:#fff; padding:6px 10px; border-radius:4px; text-decoration:none;">ICS</a>
            </div>
          </td>
        </tr>
        {% endfor %}
      {% else %}
        <tr>
          <td colspan="9" class="no-bookings">
            <div style="font-size: 18px; margin-bottom: 10px;">ðŸ“…</div>
            No bookings found
          </td>
        </tr>
      {% endif %}
    </tbody>
    </table>
  </div>
  
  <!-- Audit: Cancelled / Deleted Bookings -->
  <div class="panel-elevated" style="margin-top:28px;">
    <h2 style="font-size:1.25rem; margin-bottom:8px;">Recently Cancelled / Deleted</h2>
    <div class="cc-audit-controls" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; gap:8px;">
      <div class="cc-audit-left" style="display:flex; gap:8px; align-items:center;">
          <input type="text" id="auditSearch" class="search-box" placeholder="Search audit (client, ref, email...)" style="width:260px;">
        <select id="auditEventFilter" class="filter-btn" style="padding:6px 10px;">
          <option value="all">All events</option>
          <option value="deleted">Deleted</option>
          <option value="successful">Successful</option>
          <option value="cancelled">Cancelled</option>
        </select>
        <select id="auditServiceFilter" class="filter-btn" style="padding:6px 10px;">
          <option value="">All Services</option>
          {% for service in audit_services %}
              <option value="{{ service.name|escapejs }}">{{ service.name }}</option>
            {% endfor %}
        </select>
      </div>
      <div class="cc-audit-right" style="display:flex;gap:8px; align-items:center;">
        <button class="btn-sm btn-view" id="exportAuditBtn">Export (PDF)</button>
        <button class="btn-sm btn-delete" id="deleteAuditBtn">Delete selected</button>
      </div>
    </div>
    <div class="table-wrapper">
      <table class="bookings-table" style="width:100%;">
      <thead>
            <tr style="background:#f8f9fa;">
              <th style="padding:8px; text-align:left; font-weight:600;"><input type="checkbox" id="auditSelectAll" /></th>
              <th style="padding:8px; text-align:left; font-weight:600;">Event</th>
              <th style="padding:8px; text-align:left; font-weight:600;">Date &amp; Time</th>
              <th style="padding:8px; text-align:left; font-weight:600;">Booking ID</th>
              <th style="padding:8px; text-align:left; font-weight:600;">Client</th>
              <th style="padding:8px; text-align:left; font-weight:600;">Service</th>
              <th style="padding:8px; text-align:left; font-weight:600;">Booked At</th>
              <th style="padding:8px; text-align:left; font-weight:600;">Details</th>
            </tr>
      </thead>
      <tbody id="auditTableBody">
        {% if audit_entries %}
          {% for a in audit_entries %}
              {% comment %}Compute a compact label for dataset (mirror displayed label){% endcomment %}
              <tr data-audit-id="{{ a.id }}" data-event-type="{{ a.event_type|default:''|escapejs }}" data-label="{% if a.event_type == 'deleted' and a.start and a.start < now %}successful{% else %}{{ a.event_type|default:''|escapejs }}{% endif %}" data-service-name="{{ a.service.name|default:''|escapejs }}" data-client="{{ a.client_name|default:''|lower|escapejs }}" data-public-ref="{% with ref=a.booking_snapshot.public_ref %}{{ ref|default:a.booking_id }}{% endwith %}">
                <td style="padding:8px;"><input type="checkbox" class="auditRowCb" value="{{ a.id }}" style="margin-right:8px;" /></td>
                <td style="padding:8px;">
                  {% if a.event_type == 'deleted' and a.start and a.start < now %}
                    Successful
                  {% else %}
                    {{ a.get_event_type_display|capfirst }}
                  {% endif %}
                </td>
                <td style="padding:8px;">{% with snap=a.booking_snapshot %}{% if a.start or snap.start %}{% timezone organization.timezone %}
                    <div style="font-weight:600;">{{ a.start|default:snap.start|date:'M d, Y' }}</div>
                    <div style="font-size:13px; color:#6c757d;">{% if a.end or snap.end %}{{ a.start|default:snap.start|time:'g:i A' }} - {{ a.end|default:snap.end|time:'g:i A' }}{% else %}{{ a.start|default:snap.start|time:'g:i A' }}{% endif %}</div>
                  {% endtimezone %}{% else %}-{% endif %}{% endwith %}</td>
                <td style="padding:8px;">{% with ref=a.booking_snapshot.public_ref %}{{ ref|default:a.booking_id }}{% endwith %}</td>
                <td style="padding:8px;">{{ a.client_name|default:'-' }}<div style="font-size:12px; color:#666">{{ a.client_email }}</div></td>
                <td style="padding:8px;">{{ a.service.name|default:'-' }}</td>
                <td style="padding:8px;">{% timezone organization.timezone %}
                    <div style="font-weight:600;">{{ a.created_at|date:'M d, Y' }}</div>
                    <div style="font-size:13px; color:#6c757d;">{{ a.created_at|time:'g:i A' }}</div>
                  {% endtimezone %}</td>
                <td style="padding:8px;">
                  <button class="btn-sm btn-view" onclick="viewAudit(this)" data-snapshot='{{ a.booking_snapshot|escapejs }}'>View</button>
                </td>
              </tr>
            {% endfor %}
            {% else %}
          <tr id="noAuditRow"><td colspan="8" style="padding:16px; text-align:center; color:#6c757d;">No recent audited deletions or cancellations.</td></tr>
        {% endif %}
      </tbody>
      </table>
    </div>
  </div>
</div>

<!-- Booking Detail Modal -->
<div id="bookingModal" style="display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); justify-content: center; align-items: center; z-index: 10000; padding: 20px;">
  <div class="cc-booking-modal-card">
    <button onclick="closeModal()" class="cc-booking-modal-close">Ã—</button>
    
    <h2 class="cc-booking-modal-title">Booking Details</h2>
    
    <div class="cc-booking-modal-grid">
      <div>
        <div class="cc-booking-modal-label">Date:</div>
        <div id="modalDate" class="cc-booking-modal-value"></div>
      </div>
      <div>
        <div class="cc-booking-modal-label">Time:</div>
        <div id="modalTime" class="cc-booking-modal-value"></div>
      </div>
      <div>
        <div class="cc-booking-modal-label">Booked At:</div>
        <div id="modalBookedAt" class="cc-booking-modal-value"></div>
      </div>
      <div>
        <div class="cc-booking-modal-label">Client Name:</div>
        <div id="modalClientName" class="cc-booking-modal-value"></div>
      </div>
      <div>
        <div class="cc-booking-modal-label">Client Email:</div>
        <div id="modalClientEmail" class="cc-booking-modal-value"></div>
      </div>
      <div>
        <div class="cc-booking-modal-label">Service:</div>
        <div id="modalService" class="cc-booking-modal-value"></div>
      </div>
      <div>
        <div class="cc-booking-modal-label">Duration:</div>
        <div id="modalDuration" class="cc-booking-modal-value"></div>
      </div>
      <div>
        <div class="cc-booking-modal-label">Charge:</div>
        <div id="modalCharge" class="cc-booking-modal-value"></div>
      </div>
      <div>
        <div class="cc-booking-modal-label">Payment:</div>
        <div id="modalPayment" class="cc-booking-modal-value"></div>
        <div id="modalPaymentSub" class="cc-booking-modal-subvalue"></div>
      </div>
    </div>

    <div class="cc-booking-modal-actions">
      <button onclick="closeModal()" style="padding: 8px 14px; background: #6c757d; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px;">Close</button>
    </div>
  </div>
</div>

<!-- Audit Modal -->
<div id="auditModal" style="display:none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); justify-content: center; align-items: center; z-index: 10000; padding: 20px;">
  <div style="background: white; padding: 24px; border-radius: 12px; max-width: 700px; width: 100%; position: relative;">
    <button onclick="closeAuditModal()" style="position: absolute; top: 10px; right: 15px; background: none; border: none; font-size: 24px; cursor: pointer; color: #666;">Ã—</button>
    <h2 style="margin-bottom:12px;">Audit Details</h2>
    <div id="auditContent" style="white-space:pre-wrap; background:#f8f9fa; padding:12px; border-radius:8px; max-height:60vh; overflow:auto;"></div>
    <div style="display:flex; justify-content:flex-end; margin-top:12px;"><button onclick="closeAuditModal()" style="padding:8px 14px; background:#6c757d; color:white; border:none; border-radius:6px;">Close</button></div>
  </div>
</div>

<!-- Bulk Delete Modal -->
<div id="bulkDeleteModal" style="display:none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); justify-content: center; align-items: center; z-index: 10000; padding: 20px;">
  <div class="cc-bulk-modal-card">
    <button onclick="closeBulkDeleteModal()" class="cc-booking-modal-close">Ã—</button>
    <h2 class="cc-booking-modal-title" style="margin-bottom: 8px;">Delete selected bookings</h2>
    <div style="color:#6c757d; font-size: 13px; margin-bottom: 12px;">You have <span id="bulkDeleteCount">0</span> booking(s) selected.</div>

    <div class="cc-bulk-list" id="bulkDeleteList"></div>

    <div style="margin-top: 14px;">
      <div style="font-weight: 700; font-size: 13px;">Choose what to do</div>

      <label class="cc-bulk-option" style="display:block; cursor:pointer;">
        <div style="display:flex; gap:10px; align-items:flex-start;">
          <input type="radio" name="bulkDeleteAction" value="cancelled" />
          <div>
            <div class="cc-bulk-option-title">Mark as cancelled (refund always)</div>
            <div class="cc-bulk-option-desc">Refunds Stripe card payments even if your refund rule would normally block it. Offline payments are not automatically refunded.</div>
          </div>
        </div>
      </label>

      <label class="cc-bulk-option" style="display:block; cursor:pointer;">
        <div style="display:flex; gap:10px; align-items:flex-start;">
          <input type="radio" name="bulkDeleteAction" value="deleted" checked />
          <div>
            <div class="cc-bulk-option-title">Mark as deleted (no refund)</div>
            <div class="cc-bulk-option-desc">Removes the booking(s) without issuing a refund.</div>
          </div>
        </div>
      </label>
    </div>

    <div style="margin-top: 14px;">
      <div class="cc-booking-modal-label" style="margin-bottom: 6px;">Explanation (optional)</div>
      <textarea id="bulkDeleteExplanation" class="cc-bulk-textarea" placeholder="Optional note for your records (shown in audit details)"></textarea>
    </div>

    <div class="cc-booking-modal-actions" style="margin-top: 16px;">
      <button onclick="closeBulkDeleteModal()" id="bulkDeleteCancelBtn" style="padding: 8px 14px; background: #6c757d; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px;">Cancel</button>
      <button onclick="submitBulkDelete()" id="bulkDeleteConfirmBtn" class="btn-sm btn-delete" style="padding: 8px 14px;">Confirm</button>
    </div>
  </div>
</div>

<script>
const orgSlug = "{{ organization.slug }}";
const csrftoken = '{{ csrf_token }}';
const ORG_NAME = "{{ organization.name|escapejs }}";
// Polling: track last-seen server time to fetch new bookings
let lastSeen = "{{ now|date:'c' }}";
const POLL_INTERVAL_MS = 15000; // 15 seconds
// Audit polling: track last seen audit created_at
let lastAuditSeen = "{% if audit_entries and audit_entries.0 %}{{ audit_entries.0.created_at|date:'c' }}{% else %}{{ now|date:'c' }}{% endif %}";

// Performance caches
const _bookingsTbody = document.getElementById('bookingsTableBody');
const _auditTbody = document.getElementById('auditTableBody');
const _selectAllBookings = document.getElementById('selectAllBookings');
const _auditSelectAll = document.getElementById('auditSelectAll');
// Track inserted authoritative audit ids to avoid expensive DOM queries
const _seenAuditIds = new Set();
// Timestamped suppression maps for optimistic deletions. Keys map to
// milliseconds-since-epoch when the optimistic delete occurred. We only
// suppress re-insertion of an audit if the incoming audit's created_at is
// older-or-equal to the suppression timestamp (i.e. it's the same record).
const _recentlyDeletedAuditTimestamps = Object.create(null);
const _recentlyDeletedBookingTimestamps = Object.create(null);
const _recentlyDeletedPublicRefTimestamps = Object.create(null);
try { document.querySelectorAll('#auditTableBody tr[data-audit-id]').forEach(r => { if (r.dataset && r.dataset.auditId) _seenAuditIds.add(String(r.dataset.auditId)); }); } catch(e) {}

// Normalize time strings to remove leading zero on hour (e.g. '09:00 AM' -> '9:00 AM')
function stripLeadingZeroFromTime(s){
  try{ return String(s).replace(/\b0(?=\d{1,2}:\d{2})/g,''); }catch(e){ return s; }
}

function tryParseSnapshot(raw){
  if (!raw) return null;
  // unescape common JS unicode escapes (e.g. \u0027 -> ')
  try{
    raw = String(raw).replace(/\\u([0-9a-fA-F]{4})/g, function(_, g){ return String.fromCharCode(parseInt(g,16)); });
  }catch(e){}
  try { return JSON.parse(raw); } catch(e){}
  try {
    // Try convert Python-like repr to JSON-ish: single -> double quotes, True/False/None
    let alt = String(raw).replace(/\\'/g, "'");
    alt = alt.replace(/'/g, '"');
    alt = alt.replace(/\bNone\b/g, 'null').replace(/\bTrue\b/g,'true').replace(/\bFalse\b/g,'false');
    return JSON.parse(alt);
  } catch(e){}
  try {
    // Last resort: evaluate (controlled environment assumed)
    // eslint-disable-next-line no-new-func
    return (new Function('return ' + raw))();
  } catch(e){}
  return null;
}

function viewAudit(btn) {
  if (!btn) return;
  const raw = btn.getAttribute('data-snapshot');
  try {
    const parsed = tryParseSnapshot(raw);
    const parts = [];
      // Determine event label from the surrounding row if available
      try{
        const row = btn.closest && btn.closest('tr');
        if (row){
          const rowLabel = (row.dataset && (row.dataset.label || row.dataset.eventType)) || null;
          const nonRefundFlag = (row.dataset && (row.dataset.nonRefunded || row.dataset.non_refunded || '')) || '';
          const refundWithin = (row.dataset && (row.dataset.refundWithinCutoff || row.dataset.refund_within_cutoff || '')) || '';
          if (rowLabel){
            let displayEvent = rowLabel.charAt(0).toUpperCase() + rowLabel.slice(1);
            if (rowLabel.toLowerCase() === 'cancelled' && (nonRefundFlag === '1' || nonRefundFlag === 'true')){
              if (refundWithin === '1' || refundWithin === 'true'){
                displayEvent = 'Cancelled (within refund rule for service) - non refunded for client';
              } else {
                displayEvent = 'Cancelled - non-refunded for client';
              }
            }
            parts.push(`<div><strong>Event:</strong> ${displayEvent}</div>`);
          }
        }
      }catch(e){}

      if (parsed && typeof parsed === 'object'){
      if (parsed.title) parts.push(`<div><strong>Title:</strong> ${parsed.title}</div>`);
      // Business name (prefers parsed business, falls back to page org)
      parts.push(`<div><strong>Business:</strong> ${parsed.business || ORG_NAME}</div>`);
      if (parsed.service_slug) parts.push(`<div><strong>Service:</strong> ${parsed.service_slug}</div>`);
      if (parsed.explanation) parts.push(`<div><strong>Explanation:</strong> ${parsed.explanation}</div>`);
      // Charge
      if (parsed.service_price !== undefined && parsed.service_price !== null) parts.push(`<div><strong>Charge:</strong> $${Number(parsed.service_price).toFixed(2)}</div>`);
      if (parsed.start) parts.push(`<div><strong>Start:</strong> ${new Date(parsed.start).toLocaleString()}</div>`);
      if (parsed.end) parts.push(`<div><strong>End:</strong> ${new Date(parsed.end).toLocaleString()}</div>`);
      if (parsed.client_name) parts.push(`<div><strong>Client:</strong> ${parsed.client_name} <span style="color:#666">&lt;${parsed.client_email || '-'}&gt;</span></div>`);
      if (parsed.created_at) parts.push(`<div><strong>Booked At:</strong> ${new Date(parsed.created_at).toLocaleString()}</div>`);
      document.getElementById('auditContent').innerHTML = parts.join('\n') || JSON.stringify(parsed, null, 2);
    } else {
      document.getElementById('auditContent').textContent = raw || 'No detail available';
    }
  } catch (e) {
    document.getElementById('auditContent').textContent = raw || 'No detail available';
  }
  document.getElementById('auditModal').style.display = 'flex';
}
function closeAuditModal(){ document.getElementById('auditModal').style.display = 'none'; }

// Filter functionality
document.querySelectorAll('.filter-btn').forEach(btn => {
  btn.addEventListener('click', function() {
    if (this.dataset.filter) {
      document.querySelectorAll('.filter-btn[data-filter]').forEach(b => b.classList.remove('active'));
      this.classList.add('active');
      filterBookings();
    }
  });
});

document.getElementById('searchBox').addEventListener('input', filterBookings);
document.getElementById('scopeFilter').addEventListener('change', function() {
  try {
    const val = this.value || '';
    const params = new URLSearchParams(window.location.search || '');
    if (val) params.set('scope', val);
    else params.delete('scope');
    const next = params.toString();
    window.location.search = next ? ('?' + next) : '';
  } catch (e) {
    // fallback: simple reload to base URL
    window.location.href = window.location.pathname;
  }
});

// Scope dropdown (custom UI to keep menu within container width)
(function initScopeDropdown(){
  const wrap = document.getElementById('ccScopeWrap');
  const select = document.getElementById('scopeFilter');
  const btn = document.getElementById('ccScopeBtn');
  const menu = document.getElementById('ccScopeMenu');
  if (!wrap || !select || !btn || !menu) return;

  try{ wrap.classList.add('cc-scope-enhanced'); }catch(e){}

  function setButtonLabel(){
    try{
      const opt = select.selectedOptions && select.selectedOptions[0];
      btn.textContent = (opt && opt.textContent) ? String(opt.textContent).trim() : 'All Services';
    }catch(e){ btn.textContent = 'All Services'; }
  }

  function closeMenu(){
    menu.hidden = true;
    btn.setAttribute('aria-expanded', 'false');
  }
  function openMenu(){
    menu.hidden = false;
    btn.setAttribute('aria-expanded', 'true');
  }

  function clearSelectedVisual(){
    try{ menu.querySelectorAll('.cc-scope-item.is-selected').forEach(el => el.classList.remove('is-selected')); }catch(e){}
  }

  function addOption(optionEl){
    const item = document.createElement('button');
    item.type = 'button';
    item.className = 'cc-scope-item';
    item.textContent = optionEl.textContent || '';
    item.dataset.value = optionEl.value;
    if (optionEl.selected) item.classList.add('is-selected');
    item.addEventListener('click', function(){
      try{
        select.value = optionEl.value;
        clearSelectedVisual();
        item.classList.add('is-selected');
        setButtonLabel();
        // trigger existing navigation behavior
        select.dispatchEvent(new Event('change', { bubbles: true }));
      }catch(e){}
      closeMenu();
    });
    menu.appendChild(item);
  }

  // Build menu contents from the <select>
  try{
    menu.innerHTML = '';
    Array.from(select.children).forEach(child => {
      const tag = String(child.tagName || '').toUpperCase();
      if (tag === 'OPTGROUP') {
        const header = document.createElement('div');
        header.className = 'cc-scope-group';
        header.textContent = child.label || '';
        menu.appendChild(header);
        Array.from(child.children).forEach(opt => {
          if (String(opt.tagName || '').toUpperCase() === 'OPTION') addOption(opt);
        });
      } else if (tag === 'OPTION') {
        addOption(child);
      }
    });
  }catch(e){}

  btn.addEventListener('click', function(e){
    e.preventDefault();
    e.stopPropagation();
    if (menu.hidden) openMenu(); else closeMenu();
  });

  document.addEventListener('click', function(e){
    try{ if (!wrap.contains(e.target)) closeMenu(); }catch(err){}
  });

  select.addEventListener('change', function(){
    setButtonLabel();
    // keep selected highlight in sync
    try{
      const val = select.value;
      clearSelectedVisual();
      const match = menu.querySelector(`.cc-scope-item[data-value="${CSS.escape(val)}"]`);
      if (match) match.classList.add('is-selected');
    }catch(e){}
  });

  setButtonLabel();
  closeMenu();
})();

function filterBookings() {
  const activeFilter = document.querySelector('.filter-btn.active').dataset.filter;
  const searchTerm = document.getElementById('searchBox').value.toLowerCase();

  document.querySelectorAll('#bookingsTableBody tr').forEach(row => {
    const status = row.dataset.status;
    const search = row.dataset.search;

    let show = true;

    // Status filter
    if (activeFilter !== 'all' && status !== activeFilter) show = false;

    // Search filter
    if (searchTerm && !search.includes(searchTerm)) show = false;

    row.style.display = show ? '' : 'none';
  });
}

function viewBooking(id) {
  const row = document.querySelector(`tr[data-booking-id="${id}"]`);
  if (!row) return;

  const cells = row.querySelectorAll('td');
  // Adjusted indexes because a leading checkbox column was added:
  // 0: checkbox, 1: date/time, 2: client, 3: service, 4: duration, 5: status, 6: bookedAt, 7: actions
  const dateCell = cells[1] || null;
  if (dateCell) {
    const d0 = dateCell.querySelector('div');
    const d1 = dateCell.querySelectorAll('div')[1];
    document.getElementById('modalDate').textContent = d0 ? d0.textContent : '';
    document.getElementById('modalTime').textContent = d1 ? d1.textContent : '';
  } else {
    document.getElementById('modalDate').textContent = '';
    document.getElementById('modalTime').textContent = '';
  }

  const bookedAtCell = cells[7] || null;
  const bookedAtDivs = bookedAtCell ? bookedAtCell.querySelectorAll('div') : [];
  if (bookedAtDivs.length >= 2) {
    document.getElementById('modalBookedAt').textContent = `${bookedAtDivs[0].textContent} ${bookedAtDivs[1].textContent}`;
  } else {
    document.getElementById('modalBookedAt').textContent = '';
  }

  const clientCell = cells[3] || null;
  if (clientCell) {
    const c0 = clientCell.querySelector('div');
    const c1 = clientCell.querySelectorAll('div')[1];
    document.getElementById('modalClientName').textContent = c0 ? c0.textContent : '';
    document.getElementById('modalClientEmail').textContent = c1 ? c1.textContent : '';
  } else {
    document.getElementById('modalClientName').textContent = '';
    document.getElementById('modalClientEmail').textContent = '';
  }

  document.getElementById('modalService').textContent = (cells[4] ? cells[4].textContent : '') || '';
  document.getElementById('modalDuration').textContent = (cells[5] ? cells[5].textContent : '') || '';
  // Show service price if available (data attribute on row)
  const priceVal = row.dataset.servicePrice;
  let priceText = '-';
  if (priceVal !== undefined && priceVal !== null && priceVal !== '') {
    const n = Number(priceVal);
    if (isFinite(n)) priceText = `$${n.toFixed(2)}`;
  }
  document.getElementById('modalCharge').textContent = priceText;

  // Payment method
  try {
    const pm = (row.dataset.paymentMethod || '').toLowerCase();
    const offlineMethod = (row.dataset.offlineMethod || '').toLowerCase();
    const paymentEl = document.getElementById('modalPayment');
    const paymentSubEl = document.getElementById('modalPaymentSub');
    if (paymentSubEl) paymentSubEl.textContent = '';
    if (paymentEl) {
      if (pm === 'stripe') {
        paymentEl.textContent = 'Paid by card';
        if (paymentSubEl) paymentSubEl.textContent = 'Loading card detailsâ€¦';
        fetch(`/bus/${orgSlug}/bookings/${encodeURIComponent(String(id))}/payment/`, { method: 'GET' })
          .then(r => r.ok ? r.json() : null)
          .then(data => {
            try {
              if (!paymentSubEl) return;
              const brand = (data && (data.stripe_card_brand || data.card_brand) || '').toString();
              const last4 = (data && (data.stripe_card_last4 || data.card_last4) || '').toString();
              if (last4) {
                paymentSubEl.textContent = `${brand ? (brand.charAt(0).toUpperCase() + brand.slice(1) + ' ') : ''}ending in ${last4}`;
              } else {
                paymentSubEl.textContent = '';
              }
            } catch (e) {
              if (paymentSubEl) paymentSubEl.textContent = '';
            }
          })
          .catch(() => { if (paymentSubEl) paymentSubEl.textContent = ''; });
      } else if (pm === 'offline') {
        paymentEl.textContent = 'Offline payment';
        if (paymentSubEl && offlineMethod) paymentSubEl.textContent = `Method: ${offlineMethod}`;
      } else {
        paymentEl.textContent = 'No payment required';
      }
    }
  } catch (e) {
    try {
      const paymentEl = document.getElementById('modalPayment');
      const paymentSubEl = document.getElementById('modalPaymentSub');
      if (paymentEl) paymentEl.textContent = '';
      if (paymentSubEl) paymentSubEl.textContent = '';
    } catch (e2) {}
  }

  document.getElementById('bookingModal').style.display = 'flex';
}

function closeModal() {
  document.getElementById('bookingModal').style.display = 'none';
}

  // Insert a booking row (used by poll and undo)
function insertBookingRow(b, toTop=true) {
  if (!b) return;
  // Normalize booking identifiers - accept `booking_id` or `id`
  const bidPrimary = (b.booking_id !== undefined && b.booking_id !== null) ? String(b.booking_id) : '';
  const bidAlt = (b.id !== undefined && b.id !== null) ? String(b.id) : '';
  const bid = bidPrimary || bidAlt;
  if (!bid) return;
  // Remove any existing row for this booking id (primary or alt) to avoid duplicates
  // But preserve existing duration text if the incoming payload lacks it.
  let preservedDurationText = null;
  try{
    const existing = document.querySelectorAll(`#bookingsTableBody tr[data-booking-id]`);
    for (const ex of existing){
      const exId = String(ex.getAttribute('data-booking-id'));
      const exPub = String(ex.getAttribute('data-public-ref') || '');
      if (exId === bid || (bidPrimary && exId === bidPrimary) || (bidAlt && exId === bidAlt) || (b.public_ref && exPub === String(b.public_ref))) {
        try{
          const td = ex.querySelectorAll('td')[4]; // duration cell
          if (td && (!preservedDurationText || preservedDurationText === null)){
            const txt = (td.textContent || '').trim();
            if (txt && txt !== '- min') preservedDurationText = txt;
          }
        }catch(e){}
        ex.remove();
      }
    }
  }catch(e){ /* defensive */ }
  const tbody = document.getElementById('bookingsTableBody');
  const newTr = document.createElement('tr');
  // determine status
  let status = 'upcoming';
  try {
    if (b.start) {
      const s = new Date(b.start);
      const n = new Date();
      if (s.toDateString() === n.toDateString()) status = 'today';
      else if (s <= n && b.end && new Date(b.end) >= n) status = 'ongoing';
      else if (s < n) status = 'past';
      else status = 'upcoming';
    }
  } catch(e){}
  newTr.setAttribute('data-booking-id', bid);
  newTr.setAttribute('data-public-ref', b.public_ref || '');
  newTr.setAttribute('data-status', status);
  newTr.setAttribute('data-service-id', b.service_id || '');
  // Expose service price on the row so the "View" modal can show the charge
  try{
    const svcPrice = (b.service_price !== undefined && b.service_price !== null) ? String(b.service_price) : (b.price !== undefined && b.price !== null ? String(b.price) : '');
    newTr.setAttribute('data-service-price', svcPrice);
  }catch(e){ newTr.setAttribute('data-service-price',''); }
  try{
    if (b.duration !== undefined && b.duration !== null) newTr.setAttribute('data-duration', String(b.duration));
  }catch(e){}
  newTr.setAttribute('data-search', (b.client_name || '').toLowerCase() + ' ' + (b.client_email || '').toLowerCase());
  try{
    newTr.setAttribute('data-payment-method', (b.payment_method || b.paymentMethod || ''));
    newTr.setAttribute('data-offline-method', (b.offline_payment_method || b.offlineMethod || ''));
  }catch(e){ newTr.setAttribute('data-payment-method',''); newTr.setAttribute('data-offline-method',''); }
  newTr.innerHTML = `
    <td style="padding:8px;"><input type="checkbox" class="bookingRowCb" value="${bid}" style="margin-right:8px;"/></td>
    <td>
      <div style="font-weight:600;">${b.start_date || ''}</div>
      <div style="font-size:13px; color:#6c757d;">${stripLeadingZeroFromTime(b.time_range || '')}</div>
    </td>
    <td>
      <div style="font-weight:600;">${b.public_ref || b.booking_id || ''}</div>
    </td>
    <td>
      <div style="font-weight:600;">${b.client_name || ''}</div>
      <div style="font-size:13px; color:#6c757d;">${b.client_email || ''}</div>
    </td>
    <td>${b.service_name || 'N/A'}</td>
    <td>${(b.duration !== undefined && b.duration !== null ? (b.duration + ' min') : (preservedDurationText || '- min'))}</td>
    <td><span class="status-badge ${status==='past'?'status-past':(status==='today'?'status-today':'status-upcoming')}">${status.charAt(0).toUpperCase()+status.slice(1)}</span></td>
    <td>${(function(){
        try{
          // Prefer ISO timestamp `created_at` if present
          if (b.created_at){
            const cd = new Date(b.created_at);
            if (!isNaN(cd)){
              let createdTime = cd.toLocaleTimeString(undefined,{hour:'numeric',minute:'2-digit'});
              createdTime = stripLeadingZeroFromTime(createdTime);
              return `<div style="font-weight:600;">${cd.toLocaleDateString(undefined,{month:'short',day:'numeric',year:'numeric'})}</div><div style="font-size:13px;color:#6c757d;">${createdTime}</div>`;
            }
          }
          if (b.created_display){
            const pd = new Date(b.created_display);
            if (!isNaN(pd)){
              let createdTime = pd.toLocaleTimeString(undefined,{hour:'numeric',minute:'2-digit'});
              createdTime = stripLeadingZeroFromTime(createdTime);
              return `<div style="font-weight:600;">${pd.toLocaleDateString(undefined,{month:'short',day:'numeric',year:'numeric'})}</div><div style="font-size:13px;color:#6c757d;">${createdTime}</div>`;
            }
            // Fallback: try to extract a time like "9:00 AM" at end of string
            const m = String(b.created_display).match(/^(.*?\b\d{1,2}[:\d]{0,5}\s*(?:AM|PM|am|pm))$/);
            if (m){
              // split last token as time
              const parts = m[1].trim().split(/\s+(?=\d{1,2}:)/);
              if (parts.length >= 2){
                const datePart = parts[0];
                const timePart = stripLeadingZeroFromTime(parts.slice(1).join(' '));
                return `<div style="font-weight:600;">${datePart}</div><div style="font-size:13px;color:#6c757d;">${timePart}</div>`;
              }
            }
          }
        }catch(e){}
        // last resort: show raw string on first line
        return `<div style="font-weight:600;">${b.created_display || ''}</div><div style="font-size:13px;color:#6c757d;">${''}</div>`;
      })()}</td>
    <td>
      <div class="booking-actions">
          <button class="btn-sm btn-view" onclick="viewBooking(${b.booking_id})">View</button>
      </div>
    </td>
  `;
  if (toTop && tbody.firstChild) tbody.insertBefore(newTr, tbody.firstChild); else tbody.appendChild(newTr);
}

async function pollNewBookings(){
  try{
    const url = `/bus/${orgSlug}/bookings/recent/?since=${encodeURIComponent(lastSeen)}`;
    const resp = await fetch(url, { method: 'GET' });
    if (!resp.ok) return;
    const j = await resp.json();
    if (!j || !Array.isArray(j.items)) return;
    for (const it of j.items){
      insertBookingRow(it, true);
      // update lastSeen to the latest created_at
      if (it.created_at) lastSeen = it.created_at;
    }
  }catch(e){ console.error('Poll error', e); }
}

// start polling
setInterval(pollNewBookings, POLL_INTERVAL_MS);
// Also trigger an initial poll shortly after load
setTimeout(pollNewBookings, 2000);

// Poll audit entries for recent cancellations/deletions
async function pollNewAudits(){
  try{
    const url = `/bus/${orgSlug}/bookings/audit/?since=${encodeURIComponent(lastAuditSeen)}`;
    const resp = await fetch(url, { method: 'GET' });
    if (!resp.ok) return;
    const j = await resp.json();
    if (!j || !Array.isArray(j.items)) return;
    for (const item of j.items){
      insertAuditRow(item);
      if (item.created_at) lastAuditSeen = item.created_at;
    }
  }catch(e){ console.error('Audit poll error', e); }
}
setInterval(pollNewAudits, POLL_INTERVAL_MS);
setTimeout(pollNewAudits, 2500);

// Selection / bulk-delete UI
function updateSelectionState(){
  const selected = Array.from(document.querySelectorAll('.bookingRowCb')).filter(cb => cb.checked).map(cb => cb.value);
  const btn = document.getElementById('deleteSelectedBtn');
  if (btn) {
    if (selected.length > 0) { btn.style.display = 'inline-block'; btn.textContent = `Delete selected (${selected.length})`; }
    else { btn.style.display = 'none'; }
  }
}

// Wire up select-all and per-row checkboxes
try{
  const selectAll = document.getElementById('selectAllBookings');
  if (selectAll){
    selectAll.addEventListener('change', function(){
      const all = Array.from(document.querySelectorAll('.bookingRowCb'));
      all.forEach(cb => { try{ cb.checked = selectAll.checked; }catch(e){} });
      updateSelectionState();
    });
  }
  document.addEventListener('change', function(e){
    if (e.target && e.target.classList && e.target.classList.contains('bookingRowCb')) updateSelectionState();
  });
}catch(e){ }

function deleteSelected(){
  try{ openBulkDeleteModal(); }catch(e){ console.error('deleteSelected error', e); }
}

function closeBulkDeleteModal(){
  try{ document.getElementById('bulkDeleteModal').style.display = 'none'; }catch(e){}
}

function _getSelectedBookingIds(){
  try{
    return Array.from(document.querySelectorAll('.bookingRowCb:checked'))
      .map(cb => cb && cb.value)
      .filter(v => v !== null && v !== undefined && String(v).trim() !== '')
      .map(v => Number(v));
  }catch(e){
    return [];
  }
}

function _summarizeBookingRow(tr){
  if (!tr) return null;
  try{
    const cells = tr.querySelectorAll('td');
    const dateDivs = cells[1] ? cells[1].querySelectorAll('div') : [];
    const dateStr = dateDivs[0] ? dateDivs[0].textContent.trim() : '';
    const timeStr = dateDivs[1] ? dateDivs[1].textContent.trim() : '';
    const refStr = (tr.dataset && tr.dataset.publicRef) ? tr.dataset.publicRef : (cells[2] ? cells[2].textContent.trim() : '');
    const clientDivs = cells[3] ? cells[3].querySelectorAll('div') : [];
    const clientName = clientDivs[0] ? clientDivs[0].textContent.trim() : (cells[3] ? cells[3].textContent.trim() : '');
    const clientEmail = clientDivs[1] ? clientDivs[1].textContent.trim() : '';
    const serviceName = cells[4] ? cells[4].textContent.trim() : '';
    return { refStr, dateStr, timeStr, clientName, clientEmail, serviceName };
  }catch(e){
    return null;
  }
}

function openBulkDeleteModal(){
  const ids = _getSelectedBookingIds();
  if (!ids || ids.length === 0) return;

  const listEl = document.getElementById('bulkDeleteList');
  const countEl = document.getElementById('bulkDeleteCount');
  if (countEl) countEl.textContent = String(ids.length);
  if (listEl) listEl.innerHTML = '';

  // Build a friendly list of selected bookings from the table
  try{
    for (const id of ids){
      const tr = document.querySelector(`tr[data-booking-id="${id}"]`);
      const info = _summarizeBookingRow(tr) || { refStr: String(id), dateStr: '', timeStr: '', clientName: '', clientEmail: '', serviceName: '' };
      const row = document.createElement('div');
      row.className = 'cc-bulk-row';
      const top = `${info.clientName || 'No name'}${info.clientEmail ? ' (' + info.clientEmail + ')' : ''}`;
      const sub = `${info.dateStr || ''}${info.timeStr ? ' â€¢ ' + stripLeadingZeroFromTime(info.timeStr) : ''}${info.serviceName ? ' â€¢ ' + info.serviceName : ''}${info.refStr ? ' â€¢ ' + info.refStr : ''}`.trim();
      row.innerHTML = `<div class="cc-bulk-row-title">${top}</div><div class="cc-bulk-row-sub">${sub || '&nbsp;'}</div>`;
      if (listEl) listEl.appendChild(row);
    }
  }catch(e){ console.error('bulk list build error', e); }

  try{ document.getElementById('bulkDeleteExplanation').value = ''; }catch(e){}
  // Default action to deleted (safer)
  try{
    document.querySelectorAll('input[name="bulkDeleteAction"]').forEach(r => {
      r.checked = (r.value === 'deleted');
    });
  }catch(e){}

  try{ document.getElementById('bulkDeleteModal').style.display = 'flex'; }catch(e){}
}

async function submitBulkDelete(){
  const ids = _getSelectedBookingIds();
  if (!ids || ids.length === 0){
    closeBulkDeleteModal();
    return;
  }
  let action = 'deleted';
  try{
    const sel = document.querySelector('input[name="bulkDeleteAction"]:checked');
    if (sel && sel.value) action = String(sel.value);
  }catch(e){}
  let explanation = '';
  try{ explanation = (document.getElementById('bulkDeleteExplanation').value || '').trim(); }catch(e){}

  const confirmBtn = document.getElementById('bulkDeleteConfirmBtn');
  const cancelBtn = document.getElementById('bulkDeleteCancelBtn');
  try{ if (confirmBtn) confirmBtn.disabled = true; if (cancelBtn) cancelBtn.disabled = true; }catch(e){}
  try{ if (confirmBtn) confirmBtn.textContent = 'Working...'; }catch(e){}

  try{
    const resp = await fetch(`/bus/${orgSlug}/bookings/bulk_delete/`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
      body: JSON.stringify({ booking_ids: ids, action: action, explanation: explanation })
    });
    if (!resp.ok){
      const txt = await resp.text();
      showToast('error', txt || 'Bulk delete failed');
      return;
    }
    const j = await resp.json();
    if (!j || j.status !== 'ok'){
      showToast('error', 'Bulk delete failed');
      return;
    }

    // Remove the booking rows
    try{
      for (const id of ids){
        const tr = document.querySelector(`tr[data-booking-id="${id}"]`);
        if (tr) tr.remove();
      }
    }catch(e){}

    // Insert audits (if returned)
    try{
      if (Array.isArray(j.audits)){
        for (const a of j.audits){
          try{ insertAuditRow(a); }catch(e){ console.error('bulk insertAuditRow', e); }
        }
      }
    }catch(e){}

    // Clear selection
    try{ deselectAllBookings(); }catch(e){
      try{ document.getElementById('selectAllBookings').checked = false; }catch(_e){}
      try{ document.querySelectorAll('.bookingRowCb').forEach(cb => cb.checked = false); }catch(_e){}
      updateSelectionState();
    }

    closeBulkDeleteModal();

    // Show summary
    try{
      const okCount = Array.isArray(j.audits) ? j.audits.length : ids.length;
      let msg = (action === 'cancelled') ? `Marked ${okCount} booking(s) as cancelled` : `Deleted ${okCount} booking(s)`;
      if (action === 'cancelled'){
        const rs = Number(j.refund_success || 0);
        const rf = Number(j.refund_failed || 0);
        if (rs || rf) msg += ` (refunds: ${rs} succeeded${rf ? ', ' + rf + ' failed' : ''})`;
      }
      if (j.errors && Array.isArray(j.errors) && j.errors.length){
        msg += ` â€¢ ${j.errors.length} failed`;
      }
      showToast('success', msg);
    }catch(e){ showToast('success', 'Done'); }
  } catch(e){
    console.error(e);
    showToast('error', 'Bulk delete failed');
  } finally {
    try{ if (confirmBtn) confirmBtn.disabled = false; if (cancelBtn) cancelBtn.disabled = false; }catch(e){}
    try{ if (confirmBtn) confirmBtn.textContent = 'Confirm'; }catch(e){}
  }
}


function insertAuditRow(item){
  try{
    // Avoid inserting duplicates: check fast in-memory set before DOM queries
    try { if (item.id && _seenAuditIds.has(String(item.id))) return; } catch(e) {}
    // Also avoid duplicates by checking existing DOM rows for the same
    // authoritative identifiers (audit id, booking id, public_ref).
    try{
      const auditIdStr = (item.id !== undefined && item.id !== null) ? String(item.id) : null;
      const bookingIdStr = (item.booking_id !== undefined && item.booking_id !== null) ? String(item.booking_id) : null;
      const itemRef = (item.public_ref || (item.snapshot && item.snapshot.public_ref) || '') || '';
      // Determine created_at for the incoming audit (if available)
      let itemCreatedMs = null;
      try {
        const src = item.created_at || (item.snapshot && (item.snapshot.created_at || item.snapshot.created_display)) || null;
        if (src) {
          const parsed = Date.parse(src);
          if (!Number.isNaN(parsed)) itemCreatedMs = parsed;
        }
      } catch(e) { itemCreatedMs = null; }
      // If this audit/booking/public_ref was optimistically deleted recently,
      // only suppress re-insertion when the incoming record is not newer than
      // the optimistic deletion (i.e. it's the same record being re-polled).
      try {
        if (auditIdStr && _recentlyDeletedAuditTimestamps[auditIdStr]){
          const ts = Number(_recentlyDeletedAuditTimestamps[auditIdStr]);
          if (itemCreatedMs === null || itemCreatedMs <= ts) return;
        }
        if (bookingIdStr && _recentlyDeletedBookingTimestamps[bookingIdStr]){
          const ts = Number(_recentlyDeletedBookingTimestamps[bookingIdStr]);
          if (itemCreatedMs === null || itemCreatedMs <= ts) return;
        }
        if (itemRef){
          const key = String(itemRef).toLowerCase();
          if (_recentlyDeletedPublicRefTimestamps[key]){
            const ts = Number(_recentlyDeletedPublicRefTimestamps[key]);
            if (itemCreatedMs === null || itemCreatedMs <= ts) return;
          }
        }
      } catch(e) {}
      if (auditIdStr) {
        const existingByAudit = document.querySelector(`#auditTableBody tr[data-audit-id="${auditIdStr}"]`);
        if (existingByAudit) return;
      }
      if (bookingIdStr) {
        const existingByBooking = document.querySelector(`#auditTableBody tr[data-booking-id="${bookingIdStr}"]`);
        if (existingByBooking) return;
      }
      if (itemRef) {
        const existingByRef = Array.from(document.querySelectorAll('#auditTableBody tr')).find(r => (r.dataset && String(r.dataset.publicRef || '').toLowerCase()) === String(itemRef).toLowerCase());
        if (existingByRef) return;
      }
    }catch(e){}
    // Remove any optimistic temp rows for the same booking_id (prevent dupes)
    try{
      const tempCbs = Array.from(document.querySelectorAll('.auditRowCb')).filter(cb => cb && String(cb.value).startsWith('tmp-'));
      for (const cb of tempCbs){
        try{
          const tr = cb.closest('tr'); if (!tr) continue;
          // Prefer dataset attributes (set on optimistic rows) for reconciliation
          const tempBookingId = tr.dataset.bookingId;
          const tempPublicRef = tr.dataset.publicRef;
          const itemRef = (item.public_ref || (item.snapshot && item.snapshot.public_ref) || (item.booking_id !== undefined ? String(item.booking_id) : ''));
          if ((tempBookingId && String(tempBookingId) === String(item.booking_id)) || (tempPublicRef && String(tempPublicRef) === String(itemRef))) {
            tr.remove();
          }
        }catch(e){}
      }
    }catch(e){}
    // Also remove any existing booking row in the main bookings table that matches this audit
    try{
      const bookingIdStr = (item.booking_id !== undefined && item.booking_id !== null) ? String(item.booking_id) : '';
      const bookingRef = (item.public_ref || (item.snapshot && item.snapshot.public_ref) || '') || '';
      if (bookingIdStr) {
        const bRow = document.querySelector(`#bookingsTableBody tr[data-booking-id="${bookingIdStr}"]`);
        if (bRow) try{ bRow.remove(); }catch(e){}
      }
      if (bookingRef) {
        const bRow2 = Array.from(document.querySelectorAll('#bookingsTableBody tr')).find(r => (r.dataset && String(r.dataset.publicRef) === String(bookingRef)));
        if (bRow2) try{ bRow2.remove(); }catch(e){}
      }
    }catch(e){}
    const tbody = document.getElementById('auditTableBody');
    const noRow = document.getElementById('noAuditRow'); if (noRow) noRow.remove();
    const tr = document.createElement('tr');
    // Prefer item.start/end but fall back to snapshot.start/end so the UI
    // shows both start and end immediately after client-initiated cancellations
    // where the server may only include those values inside snapshot.
    let startHtml = '-';
    const srcStart = item.start || (item.snapshot && item.snapshot.start);
    const srcEnd = item.end || (item.snapshot && item.snapshot.end);
    if (srcStart) {
      try {
        const sd = new Date(srcStart);
        const startDateStr = sd.toLocaleDateString(undefined,{month:'short',day:'numeric',year:'numeric'});
        let startTimeStr = sd.toLocaleTimeString(undefined,{hour:'numeric',minute:'2-digit'});
        startTimeStr = stripLeadingZeroFromTime(startTimeStr);
        let timeLine = startTimeStr;
        if (srcEnd) {
          try {
            const ed = new Date(srcEnd);
            let endTimeStr = ed.toLocaleTimeString(undefined,{hour:'numeric',minute:'2-digit'});
            endTimeStr = stripLeadingZeroFromTime(endTimeStr);
            timeLine = `${startTimeStr} - ${endTimeStr}`;
          } catch (e) { /* ignore end formatting */ }
        }
        startHtml = `<div style="font-weight:600;">${startDateStr}</div><div style="font-size:13px;color:#6c757d;">${timeLine}</div>`;
      } catch (e) { startHtml = '-'; }
    }
    // The "Booked At" should reflect the original booking time. Prefer
    // snapshot.created_at / created_display when present so cancelling/deleting
    // does not change the displayed booked-at value.
    let createdHtml = '';
    const srcCreated = (item.snapshot && (item.snapshot.created_at || item.snapshot.created_display)) || item.created_at || item.created_display;
    if (srcCreated) {
      try{
        const cd = new Date(srcCreated);
        if (!isNaN(cd)){
          let createdTime = cd.toLocaleTimeString(undefined,{hour:'numeric',minute:'2-digit'});
          createdTime = stripLeadingZeroFromTime(createdTime);
          createdHtml = `<div style="font-weight:600;">${cd.toLocaleDateString(undefined,{month:'short',day:'numeric',year:'numeric'})}</div><div style="font-size:13px;color:#6c757d;">${createdTime}</div>`;
        } else {
          // fallback: display raw string
          createdHtml = `<div style="font-weight:600;">${srcCreated}</div><div style="font-size:13px;color:#6c757d;">${''}</div>`;
        }
      }catch(e){ createdHtml = ''; }
    }
    let label = '';
    try{ if (item.event_type === 'deleted' && item.start && (new Date(item.start) < new Date())) label = 'Successful'; }catch(e){}
    if (!label) label = item.event_type ? (item.event_type.charAt(0).toUpperCase() + item.event_type.slice(1)) : '';
    let bookingDisplay = (item.snapshot && item.snapshot.public_ref) ? item.snapshot.public_ref : (item.public_ref || item.booking_id || '-');
    tr.innerHTML = `
      <td style="padding:8px;"><input type="checkbox" class="auditRowCb" value="${item.id}" style="margin-right:8px;" /></td>
      <td style="padding:8px;">${label}</td>
      <td style="padding:8px;">${startHtml}</td>
      <td style="padding:8px;">${bookingDisplay}</td>
      <td style="padding:8px;">${item.client_name || '-'}<div style="font-size:12px; color:#666">${item.client_email || ''}</div></td>
      <td style="padding:8px;">${item.service || '-'}</td>
      <td style="padding:8px;">${createdHtml}</td>
      <td style="padding:8px;"><button class="btn-sm btn-view" onclick="viewAudit(this)" data-snapshot='${JSON.stringify(item.snapshot).replace(/'/g, "\\'") }'>View</button></td>`;
    // Set dataset attributes for filtering/search
    try{
      tr.dataset.auditId = item.id;
      tr.dataset.eventType = (item.event_type || '').toLowerCase();
      // store displayed label too (e.g. 'Successful') for fine-grained filtering
      const dispLabel = (function(){ try{ if (item.event_type === 'deleted' && item.start && (new Date(item.start) < new Date())) return 'successful'; }catch(e){} return (item.event_type || '').toLowerCase(); })();
      tr.dataset.label = dispLabel;
      // Mark whether this cancelled audit retained a non-refunded charge
      try{ tr.dataset.nonRefunded = item.non_refunded ? '1' : ''; tr.dataset.refundWithinCutoff = item.refund_within_cutoff ? '1' : ''; }catch(e){ tr.dataset.nonRefunded = ''; tr.dataset.refundWithinCutoff = ''; }
      tr.dataset.serviceName = (item.service || '').toLowerCase();
      tr.dataset.client = (item.client_name || '').toLowerCase();
      tr.dataset.publicRef = (((item.snapshot && item.snapshot.public_ref) ? item.snapshot.public_ref : (item.public_ref || (item.booking_id !== undefined ? String(item.booking_id) : ''))) || '').toLowerCase();
    }catch(e){}

    if (tbody.firstChild) tbody.insertBefore(tr, tbody.firstChild); else tbody.appendChild(tr);
    try { if (item.id !== undefined && item.id !== null) { tr.dataset.auditId = String(item.id); _seenAuditIds.add(String(item.id)); } } catch(e) {}
  }catch(e){ console.error('insertAuditRow error', e); }
}

// Audit filters: event type, service, and search
function filterAudits(){
  try{
    const evt = (document.getElementById('auditEventFilter') && document.getElementById('auditEventFilter').value) ? String(document.getElementById('auditEventFilter').value).toLowerCase() : 'all';
    const svc = (document.getElementById('auditServiceFilter') && document.getElementById('auditServiceFilter').value) ? String(document.getElementById('auditServiceFilter').value).toLowerCase() : '';
    const searchTerm = (document.getElementById('auditSearch') && document.getElementById('auditSearch').value) ? document.getElementById('auditSearch').value.toLowerCase().trim() : '';

    document.querySelectorAll('#auditTableBody tr').forEach(row => {
      // skip placeholder rows without an audit id (e.g. 'no recent' placeholder)
      const auditIdAttr = row.dataset && row.dataset.auditId;
      if (!auditIdAttr) return;
      let show = true;
      const rowEvt = (row.dataset.eventType || '').toLowerCase();
      const rowLabel = (row.dataset.label || '').toLowerCase();
      const rowSvc = (row.dataset.servicename || row.dataset.serviceName || '').toLowerCase();
      const rowClient = (row.dataset.client || '').toLowerCase();
      const rowRef = (row.dataset.publicref || row.dataset.publicRef || '').toLowerCase();

      // Event filter: 'deleted' should include all deletions (including 'successful'),
      // 'successful' matches only the successful label, 'cancelled' matches cancelled.
      if (evt && evt !== 'all'){
        if (evt === 'successful'){
          if (rowLabel !== 'successful') show = false;
        } else if (evt === 'deleted'){
          if (rowEvt !== 'deleted') show = false;
        } else {
          if (rowEvt !== evt) show = false;
        }
      }

      // Service filter (normalize both sides)
      if (svc && svc !== ''){
        if (!rowSvc || rowSvc !== svc) show = false;
      }

      if (searchTerm){
        if (!(rowClient.includes(searchTerm) || rowRef.includes(searchTerm) || (row.querySelector('td:nth-child(5)') && row.querySelector('td:nth-child(5)').textContent.toLowerCase().includes(searchTerm)))){
          show = false;
        }
      }

      row.style.display = show ? '' : 'none';
    });
  }catch(e){ console.error('filterAudits error', e); }
}

// Wire audit filter controls
try{
  const aSearch = document.getElementById('auditSearch');
  const aEvt = document.getElementById('auditEventFilter');
  const aSvc = document.getElementById('auditServiceFilter');
  // debounce input to avoid re-filtering on every keystroke
  function _debounce(fn, wait){ let t = null; return function(){ const args = arguments; clearTimeout(t); t = setTimeout(() => fn.apply(this, args), wait); }; }
  if (aSearch) aSearch.addEventListener('input', _debounce(filterAudits, 200));
  if (aEvt) aEvt.addEventListener('change', filterAudits);
  if (aSvc) aSvc.addEventListener('change', filterAudits);
}catch(e){}

async function deleteBooking(id, date, clientName, skipConfirm = false) {
  if (!skipConfirm) {
    if (!confirm(`Delete booking for ${clientName} on ${date}?`)) return;
  }
  // Capture row details to show immediately in the audit list
  const row = document.querySelector(`tr[data-booking-id="${id}"]`);
  let svcText = '';
  let startDateText = '';
  let startTimeText = '';
  let clientEmail = '';
  if (row) {
    const cells = row.querySelectorAll('td');
    // columns: 0=checkbox, 1=date/time, 2=booking id, 3=client, 4=service, ...
    svcText = cells[4] ? cells[4].textContent.trim() : '';
    // extract both date and time lines from the booking date cell so optimistic audit shows both
    try{
      const dateCellDivs = cells[1] ? cells[1].querySelectorAll('div') : [];
      startDateText = dateCellDivs[0] ? dateCellDivs[0].textContent.trim() : '';
      startTimeText = dateCellDivs[1] ? dateCellDivs[1].textContent.trim() : '';
    }catch(e){ }
    const clientDivs = cells[3] ? cells[3].querySelectorAll('div') : [];
    clientEmail = clientDivs[1] ? clientDivs[1].textContent.trim() : '';
  }

  // Remove booking row immediately
  try { if (row) row.remove(); } catch (e) {}

  // Insert an optimistic (temporary) audit row immediately so the UI updates instantly.
  // The optimistic row includes dataset.bookingId and dataset.publicRef so the
  // authoritative insertion (from poll or server response) can detect and remove it.
  try {
    const tempId = 'tmp-' + Date.now();
    const tbody = document.getElementById('auditTableBody');
    const noRow = document.getElementById('noAuditRow'); if (noRow) noRow.remove();
    const tempTr = document.createElement('tr');
    tempTr.id = 'audit-temp-' + tempId;
    tempTr.dataset.tempId = tempId;
    try { tempTr.dataset.bookingId = String(id); } catch(e) { tempTr.dataset.bookingId = ''; }
    try { tempTr.dataset.publicRef = (row && row.dataset && row.dataset.publicRef) ? row.dataset.publicRef : ''; } catch(e) { tempTr.dataset.publicRef = ''; }
    const createdNowDate = new Date();
    const createdNowDateStr = createdNowDate.toLocaleDateString(undefined,{month:'short',day:'numeric',year:'numeric'});
    const createdNowTimeStr = createdNowDate.toLocaleTimeString(undefined,{hour:'numeric',minute:'2-digit'});
    const createdHtml = `<div style="font-weight:600;">${createdNowDateStr}</div><div style="font-size:13px;color:#6c757d;">${createdNowTimeStr}</div>`;
    const snapshot = { title: clientName || '', start: null, end: null, client_name: clientName || '', client_email: clientEmail || '', service_slug: svcText || '', service_price: null, business: ORG_NAME };
    let optimisticLabel = 'Deleted';
    try { if (row && row.dataset && row.dataset.status === 'past') optimisticLabel = 'Successful'; } catch(e){}
    const normalizedDate = startDateText || '';
    const normalizedTime = startTimeText ? stripLeadingZeroFromTime(startTimeText) : '';
    const startHtmlOpt = (normalizedDate || normalizedTime) ? (`<div style="font-weight:600;">${normalizedDate}</div><div style="font-size:13px;color:#6c757d;">${normalizedTime || '&nbsp;'}</div>`) : '-';
    tempTr.innerHTML = `
      <td style="padding:8px;"><input type="checkbox" class="auditRowCb" value="${tempId}" style="margin-right:8px;" /></td>
      <td style="padding:8px;">${optimisticLabel}</td>
      <td style="padding:8px;">${startHtmlOpt}</td>
      <td style="padding:8px;">${(row && row.dataset && row.dataset.publicRef) ? row.dataset.publicRef : '-'}</td>
      <td style="padding:8px;">${clientName || '-'}<div style="font-size:12px; color:#666">${clientEmail || ''}</div></td>
      <td style="padding:8px;">${svcText || '-'}</td>
      <td style="padding:8px;">${createdHtml}</td>
      <td style="padding:8px;"><button class="btn-sm btn-view" onclick="viewAudit(this)" data-snapshot='${JSON.stringify(snapshot).replace(/'/g, "\\'") }'>View</button></td>
    `;
    if (tbody.firstChild) tbody.insertBefore(tempTr, tbody.firstChild); else tbody.appendChild(tempTr);
  } catch(e) { console.error('Error inserting optimistic audit row', e); }

  // Now call delete endpoint; on success insert authoritative audit row
  try {
    const response = await fetch(`/bus/${orgSlug}/bookings/${id}/delete/`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': csrftoken
      }
    });

    if (response.ok) {
      try {
        const j = await response.json();
        if (j && j.audit) {
          try { insertAuditRow(j.audit); } catch(e) { console.error('Error inserting audit row after delete', e); }
        } else {
          showToast('error', 'Delete succeeded but no audit record was created');
        }
      } catch (e) { console.error('Error reading delete response', e); showToast('error','Error reading server response'); }
    } else {
      showToast('error', 'Failed to delete booking');
    }
  } catch (error) {
    console.error('Error:', error);
    showToast('error', 'Error deleting booking');
  }
}

async function undoAudit(btn) {
  if (!btn) return;
  const auditId = btn.dataset.auditId;
  if (!auditId) return;
  if (!confirm('Restore this booking back to the bookings list?')) return;

  try {
    const resp = await fetch(`/bus/${orgSlug}/bookings/audit/undo/`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
      body: JSON.stringify({ audit_id: Number(auditId) })
    });
    if (!resp.ok) { const txt = await resp.text(); alert('Restore failed: ' + txt); return; }
    const j = await resp.json();
    if (j && j.booking) {
      const b = j.booking;
      // remove audit row
      const tr = btn.closest('tr'); if (tr) { try { if (tr.dataset && tr.dataset.auditId) _seenAuditIds.delete(String(tr.dataset.auditId)); } catch(e){} tr.remove(); }
      // also remove any other audit rows for the same booking_id or public_ref (defensive)
      try{
        document.querySelectorAll('.auditRowCb').forEach(cb => {
          try{
            const ct = cb.closest('tr'); if (!ct) return;
            const tempBookingId = ct.dataset.bookingId;
            const tempPublicRef = ct.dataset.publicRef;
            const bookRef = (b && (b.public_ref || (b.booking_id !== undefined ? String(b.booking_id) : '')));
            if ((tempBookingId && String(tempBookingId) === String(b.booking_id)) || (tempPublicRef && String(tempPublicRef) === String(bookRef))) {
              try { if (ct.dataset && ct.dataset.auditId) _seenAuditIds.delete(String(ct.dataset.auditId)); } catch(e){}
              ct.remove();
            }
          }catch(e){}
        });
      }catch(e){}
      // Insert booking row using helper
      insertBookingRow(b, true);
      showToast('success', 'Booking restored');
    }
  } catch (e) { console.error(e); alert('Error restoring booking'); }
}

// Audit select-all and export
const auditSelectAll = document.getElementById('auditSelectAll');
if (auditSelectAll) {
  auditSelectAll.addEventListener('change', (e) => {
    document.querySelectorAll('.auditRowCb').forEach(cb => cb.checked = e.target.checked);
  });
}

function setAuditDeleteLoading(isLoading, label){
  try{
    const btn = document.getElementById('deleteAuditBtn');
    if (!btn) return;
    if (!btn.dataset.originalText) btn.dataset.originalText = btn.textContent || 'Delete selected';

    if (isLoading){
      btn.disabled = true;
      btn.classList.add('is-loading');
      const text = String(label || 'Loading...');
      btn.innerHTML = `<span class="btn-loading-spinner"></span>${text}`;
    } else {
      btn.disabled = false;
      btn.classList.remove('is-loading');
      btn.textContent = btn.dataset.originalText || 'Delete selected';
    }
  }catch(e){}
}

// Bookings select-all and select-by-status handlers
const bookingsSelectAll = document.getElementById('bookingsSelectAll');
if (bookingsSelectAll) {
  bookingsSelectAll.addEventListener('change', (e) => {
    // only affect visible rows
    document.querySelectorAll('#bookingsTableBody tr').forEach(row => {
      if (row.style.display === 'none') return;
      const cb = row.querySelector('.bookingRowCb'); if (cb) cb.checked = e.target.checked;
    });
    updateBulkDeleteVisibility();
  });
}

function deselectAllBookings(){ document.querySelectorAll('.bookingRowCb').forEach(cb => cb.checked = false); if (bookingsSelectAll) bookingsSelectAll.checked = false; updateBulkDeleteVisibility(); }
function selectByStatus(status){ document.querySelectorAll('#bookingsTableBody tr').forEach(row => { const cb = row.querySelector('.bookingRowCb'); if (!cb) return; if (row.style.display === 'none') return; if (status === 'all') cb.checked = true; else if (row.dataset.status === status) cb.checked = true; else cb.checked = false; }); if (bookingsSelectAll) bookingsSelectAll.checked = false; updateBulkDeleteVisibility(); }

const selectAllBookingsBtn = document.getElementById('selectAllBookingsBtn'); if (selectAllBookingsBtn) selectAllBookingsBtn.addEventListener('click', () => selectByStatus('all'));
const selectStatusMenu = document.getElementById('selectStatusMenu');
if (selectStatusMenu) {
  selectStatusMenu.addEventListener('change', (e) => {
    const v = e.target.value;
    if (v === 'deselect') {
      deselectAllBookings();
    } else if (v) {
      selectByStatus(v);
    }
    // reset menu back to placeholder
    setTimeout(() => { selectStatusMenu.value = ''; }, 150);
  });
}

// Bulk delete UI wiring
const bulkDeleteBtn = document.getElementById('bulkDeleteBtn');
function updateBulkDeleteVisibility(){
  if (bulkDeleteBtn) bulkDeleteBtn.style.display = 'none';
}

// Update visibility when individual checkboxes change (delegated)
const bookingsTbody = document.getElementById('bookingsTableBody');
if (bookingsTbody){
  bookingsTbody.addEventListener('change', (e) => {
    if (e.target && e.target.classList && e.target.classList.contains('bookingRowCb')){
      updateBulkDeleteVisibility();
    }
  });
}

// Audit tbody delegated change handler: keep select-all in sync when individual boxes change
const auditTbody = document.getElementById('auditTableBody');
if (auditTbody){
  auditTbody.addEventListener('change', (e) => {
    if (e.target && e.target.classList && e.target.classList.contains('auditRowCb')){
      try{
        const all = Array.from(document.querySelectorAll('#auditTableBody .auditRowCb')).filter(cb => cb.closest('tr') && cb.closest('tr').style.display !== 'none');
        const checked = all.filter(cb => cb.checked);
        if (auditSelectAll) auditSelectAll.checked = (all.length > 0 && checked.length === all.length);
      }catch(e){ }
    }
  });
}

if (bulkDeleteBtn){
  bulkDeleteBtn.addEventListener('click', async () => {
    const checked = Array.from(document.querySelectorAll('.bookingRowCb:checked')).filter(cb => cb.closest('tr') && cb.closest('tr').style.display !== 'none');
    if (!checked.length) return;
    // Prevent deleting ongoing
    const ongoing = checked.some(cb => cb.closest('tr').dataset.status === 'ongoing');
    if (ongoing){ alert('Cannot delete ongoing bookings'); return; }
    if (!confirm(`Permanently delete ${checked.length} selected bookings? This cannot be undone.`)) return;
    // Call deleteBooking for each selected row without per-call confirmation
    for (const cb of checked){
      try{
        const tr = cb.closest('tr');
        const id = Number(cb.value);
        // gather date and client for UI friendly messages
        const dateCell = tr.querySelectorAll('td')[1];
        const dateText = dateCell ? (dateCell.querySelector('div') ? dateCell.querySelector('div').textContent : '') : '';
        const clientCell = tr.querySelectorAll('td')[2];
        const clientName = clientCell ? (clientCell.querySelector('div') ? clientCell.querySelector('div').textContent : '') : '';
        // call deleteBooking with skipConfirm = true
        deleteBooking(id, dateText, clientName, true);
      }catch(e){ console.error('Bulk delete item error', e); }
    }
    // After initiating deletes, hide bulk button until state updates
    updateBulkDeleteVisibility();
  });
}

const exportAuditBtn = document.getElementById('exportAuditBtn');
if (exportAuditBtn) {
  exportAuditBtn.addEventListener('click', async () => {
    // Export selected audit rows
    const ids = Array.from(document.querySelectorAll('#auditTableBody .auditRowCb:checked')).filter(cb => cb.closest('tr') && cb.closest('tr').style.display !== 'none').map(cb => Number(cb.value));
    if (!ids.length) { alert('No audit rows selected to export'); return; }
    try {
      const resp = await fetch(`/bus/${orgSlug}/bookings/audit/export/`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
        body: JSON.stringify({ ids })
      });
      if (!resp.ok) { alert('Export failed'); return; }
      const blob = await resp.blob();
      const contentType = resp.headers.get('Content-Type') || '';
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      if (contentType === 'application/pdf') a.download = 'audit_export.pdf';
      else a.download = 'audit_export.json';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    } catch (e) { console.error(e); alert('Export error'); }
  });

  const deleteAuditBtn = document.getElementById('deleteAuditBtn');
  if (deleteAuditBtn){
    deleteAuditBtn.addEventListener('click', async () => {
      // Delete selected audit rows.
      // Key fix: always derive canonical ids from the row's data-audit-id.
      const checkedCbs = Array.from(document.querySelectorAll('#auditTableBody .auditRowCb:checked'))
        .filter(cb => cb.closest('tr') && cb.closest('tr').style.display !== 'none');
      if (!checkedCbs.length) { alert('No audit rows selected to delete'); return; }

      const tbody = document.getElementById('auditTableBody');

      function _sleep(ms){ return new Promise(res => setTimeout(res, ms)); }
      async function _fetchAllAuditItems(){
        try{
          const listResp = await fetch(`/bus/${orgSlug}/bookings/audit/?since=${encodeURIComponent('1970-01-01T00:00:00Z')}`);
          if (!listResp || !listResp.ok) return [];
          const j = await listResp.json();
          return Array.isArray(j.items) ? j.items : [];
        }catch(e){ return []; }
      }

      const candidates = checkedCbs
        .map(cb => {
          const tr = cb.closest('tr');
          const cbVal = (cb && cb.value != null) ? String(cb.value).trim() : '';
          const dsVal = (tr && tr.dataset && tr.dataset.auditId != null) ? String(tr.dataset.auditId).trim() : '';
          // Prefer checkbox value (server-rendered rows set value to numeric id)
          const idStr = /^\d+$/.test(cbVal) ? cbVal : dsVal;
          return { tr, cbVal, dsVal, auditIdStr: idStr, html: tr ? tr.outerHTML : '' };
        })
        .filter(x => x.tr);

      const valid = candidates.filter(x => /^\d+$/.test(String(x.auditIdStr || '')));
      const needsMapping = candidates.filter(x => !/^\d+$/.test(String(x.auditIdStr || '')));
      const invalidCount = needsMapping.length;

      if (!valid.length) {
        // Fall through to mapping logic below; temp rows may not have ids yet.
      }

      // Map any rows without a numeric audit id (typically optimistic tmp-* rows)
      // by querying the server audit list a few times (gives the server time to create the record).
      const mappedIds = [];
      if (needsMapping.length > 0) {
        setAuditDeleteLoading(true, 'Preparing...');
        let items = [];
        for (let attempt = 0; attempt < 5; attempt++) {
          items = await _fetchAllAuditItems();
          mappedIds.length = 0;

          for (const r of needsMapping) {
            try{
              const tr = r.tr;
              const bid = (tr && tr.dataset && tr.dataset.bookingId) ? String(tr.dataset.bookingId) : '';
              const pref = (tr && tr.dataset && tr.dataset.publicRef) ? String(tr.dataset.publicRef).toLowerCase() : '';
              const found = items.find(it => {
                try{
                  if (!it || it.id == null) return false;
                  if (bid && it.booking_id != null && String(it.booking_id) === String(bid)) return true;
                  const itPref = (it.public_ref || (it.snapshot && it.snapshot.public_ref) || (it.booking_id != null ? String(it.booking_id) : ''));
                  if (pref && itPref && String(itPref).toLowerCase() === pref) return true;
                }catch(e){}
                return false;
              });
              if (found && found.id != null) {
                mappedIds.push(Number(found.id));
                // Update the row so future operations have the canonical id.
                try{ tr.dataset.auditId = String(found.id); }catch(e){}
              }
            }catch(e){}
          }

          if (mappedIds.length >= needsMapping.length) break;
          // Give server a moment to persist/create the audit row.
          await _sleep(350);
        }
      }

      const ids = Array.from(new Set([
        ...valid.map(x => Number(String(x.auditIdStr))),
        ...mappedIds
      ].filter(n => Number.isFinite(n))));

      if (!ids.length) {
        setAuditDeleteLoading(false);
        showToast('warning', 'These audit records are still being created. Please wait a moment and try again.');
        return;
      }

      if (invalidCount > 0 && mappedIds.length < invalidCount) {
        // keep loading state until confirm appears
        showToast('warning', 'Some selected rows are still initializing; deleting the ones that are ready.');
      }

      // Stop the loading spinner right before the confirm dialog appears.
      setAuditDeleteLoading(false);
      if (!confirm(`Permanently delete ${ids.length} selected audit record(s)? This cannot be undone.`)) return;

      // Show a loading state while the delete request runs.
      setAuditDeleteLoading(true, 'Deleting...');

      // Optimistically hide and suppress reinsertion while request runs.
      const ts = Date.now();
      try {
        for (const r of candidates) {
          try {
            const aId = r.auditIdStr;
            if (aId) {
              try { _seenAuditIds.add(String(aId)); } catch (e) {}
              try { _recentlyDeletedAuditTimestamps[aId] = ts; } catch (e) {}
              setTimeout(() => { try { delete _recentlyDeletedAuditTimestamps[aId]; } catch (e) {} }, 30000);
            }
            r.tr.dataset.deleting = '1';
            r.tr.style.display = 'none';
          } catch (e) {}
        }
      } catch (e) { console.error('optimistic audit hide error', e); }

      try {
        const resp = await fetch(`/bus/${orgSlug}/bookings/audit/delete/`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
          body: JSON.stringify({ ids })
        });
        if (!resp.ok) {
          // Restore hidden rows
          for (const r of valid) {
            try { r.tr.style.display = ''; delete r.tr.dataset.deleting; } catch (e) {}
          }
          setAuditDeleteLoading(false);
          showToast('error', 'Failed to delete audit rows.');
          return;
        }

        // Reconcile with server: ensure we only remove rows that are truly gone.
        let serverIds = null;
        try {
          const listResp = await fetch(`/bus/${orgSlug}/bookings/audit/?since=${encodeURIComponent('1970-01-01T00:00:00Z')}`);
          if (listResp && listResp.ok) {
            const j = await listResp.json();
            const items = Array.isArray(j.items) ? j.items : [];
            serverIds = new Set(items.map(it => (it && it.id != null) ? String(it.id) : '').filter(Boolean));
          }
        } catch (e) { serverIds = null; }

        let removedCount = 0;
        for (const r of candidates) {
          try {
            const idForRow = (r.tr && r.tr.dataset && r.tr.dataset.auditId) ? String(r.tr.dataset.auditId) : String(r.auditIdStr || '');
            const stillExists = serverIds ? serverIds.has(String(idForRow)) : false;
            if (serverIds && stillExists) {
              // Not actually deleted; show it again.
              r.tr.style.display = '';
              delete r.tr.dataset.deleting;
            } else {
              // Deleted (or unable to confirm list; trust delete call).
              r.tr.remove();
              removedCount += 1;
            }
          } catch (e) {}
        }

        const msg = removedCount === 1 ? 'Deleted 1 audit row.' : `Deleted ${removedCount} audit rows.`;
        showToast('success', msg);
      } catch (e) {
        console.error(e);
        // Restore hidden rows on error
        for (const r of valid) {
          try { r.tr.style.display = ''; delete r.tr.dataset.deleting; } catch (err) {}
        }
        showToast('error', 'Delete error.');
      } finally {
        setAuditDeleteLoading(false);
        try { if (auditSelectAll) auditSelectAll.checked = false; } catch (e) {}
      }
    });
  }
}

// App deep-link: open a booking modal from query param.
(function(){
  try {
    var params = new URLSearchParams(window.location.search || '');
    var raw = params.get('cc_open_booking');
    if (!raw) return;
    var id = parseInt(String(raw), 10);
    if (!isFinite(id)) return;

    // Retry briefly in case the table renders async.
    var tries = 0;
    var maxTries = 30; // ~6s @ 200ms
    var timer = setInterval(function(){
      tries += 1;
      try {
        if (typeof window.viewBooking === 'function') {
          window.viewBooking(id);
          clearInterval(timer);

          // Remove the param so back/refresh doesn't keep reopening.
          try {
            var u = new URL(window.location.href);
            u.searchParams.delete('cc_open_booking');
            window.history.replaceState({}, document.title, u.toString());
          } catch (e) {}
          return;
        }
      } catch(e) {}
      if (tries >= maxTries) clearInterval(timer);
    }, 200);
  } catch (e) {}
})();
</script>
<script>
// Visible rows selector: persist in localStorage and apply CSS variable
(function(){
  const key = 'cc_bookings_visible_rows';
  const select = document.getElementById('visibleRowsSelect');
  const customInput = document.getElementById('visibleRowsCustomInput');
  const wrapper = document.querySelector('.table-wrapper');
  function apply(val){
    try{
      if (!wrapper) return;
      if (val === 'all'){
        wrapper.classList.add('cc-visible-all');
        wrapper.style.removeProperty('--bookings-visible-rows');
      } else {
        wrapper.classList.remove('cc-visible-all');
        const n = Number(val) || Number(getComputedStyle(document.documentElement).getPropertyValue('--visible-rows-default')) || 10;
        wrapper.style.setProperty('--bookings-visible-rows', String(n));
      }
      if (select) select.value = String(val);
      if (customInput){
        if (select && select.value === 'custom'){ customInput.style.display = 'inline-block'; } else { customInput.style.display = 'none'; }
      }
    }catch(e){console.error(e);}  }

  function setAndStore(v){
    try{ window.localStorage.setItem(key, String(v)); }catch(e){}
    apply(v);
  }

  try{
    const stored = window.localStorage.getItem(key);
    if (stored) apply(stored);
    else apply(select ? select.value : '10');
  }catch(e){ apply(select ? select.value : '10'); }

  if (select){
    select.addEventListener('change', function(){
      const v = this.value;
      if (v === 'custom'){
        if (customInput){ customInput.style.display = 'inline-block'; customInput.focus(); }
        return;
      }
      setAndStore(v);
    });
  }

  if (customInput){
    customInput.addEventListener('change', function(){
      const n = Math.max(1, Number(this.value) || 10);
      setAndStore(String(n));
      if (select) select.value = 'custom';
    });
    customInput.addEventListener('keyup', function(e){ if (e.key === 'Enter') this.dispatchEvent(new Event('change')); });
  }

})();
</script>
{% endblock %}
