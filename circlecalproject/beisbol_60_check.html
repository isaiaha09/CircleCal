<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Book 60 minutes – beisbol</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    
    <!-- Tailwind (self-hosted) -->
    <link rel="stylesheet" href="/static/css/tailwind.min.css">

        <style>
                /* Two-factor specific styles: make token input visible and increase spacing */
                .twofactor-page input[type="text"],
                .twofactor-page input[type="tel"],
                .twofactor-page input[type="password"] {
                    border: 2px solid rgba(55,65,81,0.15); /* slightly stronger than default */
                    box-shadow: none;
                    padding: 0.5rem 0.75rem;
                    border-radius: 0.375rem;
                }

                .twofactor-page label.token-label {
                    display: block;
                    margin-bottom: 0.25rem;
                    font-weight: 600;
                    color: rgba(17,24,39,0.9);
                }

                .twofactor-page .twofactor-instructions p {
                    margin-top: 0.75rem;
                    margin-bottom: 0.75rem;
                    line-height: 1.5;
                }

                .twofactor-page .secret-value {
                    background: #f8fafc;
                    padding: 0.5rem 0.75rem;
                    border: 1px dashed rgba(55,65,81,0.12);
                    border-radius: 0.375rem;
                    display: inline-block;
                    margin-top: 0.5rem;
                }

                /* Disable action: make links/buttons reading 'Disable' more prominent */
                .twofactor-disable-btn {
                    display: inline-flex;
                    align-items: center;
                    gap: 8px;
                    padding: 0.5rem 0.9rem;
                    border-radius: 0.5rem;
                    background: #ef4444; /* red-500 */
                    color: #ffffff;
                    text-decoration: none;
                    border: none;
                    font-weight: 600;
                    box-shadow: 0 6px 18px rgba(239,68,68,0.08);
                }
                .twofactor-disable-btn:hover { background: #dc2626; }
                @media (max-width:640px) {
                    .twofactor-disable-btn { width:100%; justify-content:center; }
                }

                /* Extra spacing for pages where 2FA is being disabled */
                .twofactor-disable-page {
                    padding: 2.25rem; /* larger container padding for clarity */
                }
                @media (max-width:640px) {
                    .twofactor-disable-page { padding: 1.25rem; }
                }

                /* Make the numeric generator/token input clearly visible (not blend into white) */
                .twofactor-page input#id_generator-token,
                .twofactor-page input[name="generator-token"] {
                    background: #ffffff; /* ensure pure white to contrast card */
                    border: 2px solid #cbd5e1; /* gray-300 */
                    padding: 0.375rem 0.75rem; /* slightly shorter vertically */
                    border-radius: 0.375rem;
                    box-shadow: inset 0 1px 2px rgba(2,6,23,0.04);
                    font-size: 1rem;
                    color: #0f172a;
                    display: inline-block;
                    width: 68%; /* a bit wider but leave room for actions */
                    max-width: 520px;
                    margin-right: 0.75rem; /* spacing if button sits inline */
                    margin-bottom: 0.75rem; /* spacing if stacked */
                    line-height: 1.4;
                }

                .twofactor-page input#id_generator-token:focus,
                .twofactor-page input[name="generator-token"]:focus {
                    outline: none;
                    border-color: #3b82f6; /* blue-500 */
                    box-shadow: 0 0 0 4px rgba(59,130,246,0.12);
                }

            /* Scoped styles for two-factor pages to make token fields clearer */
            .twofactor-page .cc-2fa-token,
            .twofactor-page .cc-2fa-token pre,
            .twofactor-page .cc-2fa-token textarea,
            .twofactor-page .cc-2fa-token input[type="text"],
            .twofactor-page pre,
            .twofactor-page code,
            .twofactor-page .token-field,
            .twofactor-page input[type="text"] {
                font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Helvetica Neue', monospace;
                background: #f8fafc; /* light */
                border: 1px solid #cbd5e1; /* gray-300 */
                padding: 12px 14px;
                border-radius: 8px;
                font-size: 0.95rem;
                color: #0f172a;
                width: 100%;
                box-shadow: inset 0 1px 0 rgba(255,255,255,0.6);
                white-space: pre-wrap;
                word-break: break-word;
            }
            .twofactor-page .cc-2fa-token + .cc-2fa-actions { margin-top: 8px; }
            .twofactor-page .cc-2fa-actions .btn-copy { display:inline-flex; align-items:center; gap:8px; padding:8px 10px; border-radius:8px; border:1px solid #e2e8f0; background:#fff; color:#0f172a; }
            .twofactor-page .cc-2fa-help { font-size:0.92rem; color:#475569; margin-top:8px; }
            /* Add more vertical spacing for paragraphs and list items inside two-factor card */
            .twofactor-page p,
            .twofactor-page li,
            .twofactor-page .help-text {
                margin-bottom: 0.9rem;
                line-height: 1.5;
            }
            /* Make token label and input stand out */
            .twofactor-page label[for*="token"], .twofactor-page .token-label {
                display:block; font-weight:600; margin-bottom:6px; color:#0f172a;
            }
        </style>

    
</head>

<body class="bg-blue-50  text-gray-900">

    <header class="bg-white border-b shadow-sm">
        <div class="max-w-7xl mx-auto px-4 py-4">
            <div class="flex items-center justify-between">
                <!-- Left: Logo -->
                <a href="/" class="font-bold text-xl text-blue-600">
                    CircleCal
                </a>

                <!-- Mobile Menu Button -->
                <button id="mobileMenuBtn" class="md:hidden text-gray-700 focus:outline-none">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/>
                    </svg>
                </button>

                <!-- Desktop Navigation -->
                
                <nav class="hidden md:flex items-center space-x-4">
                    <a href="/accounts/login/" class="text-gray-700 hover:text-blue-600">Login</a>
                    <a href="/accounts/reactivate/" class="text-gray-700 hover:text-blue-600">Reactivate</a>
                    <a href="/signup/" class="text-blue-600 font-semibold">Sign Up</a>
                </nav>
                
            </div>

            <!-- Mobile Navigation Dropdown -->
            <div id="mobileMenu" class="hidden md:hidden mt-4 pb-4 border-t pt-4 space-y-3">
                
                    <a href="/accounts/login/" class="block text-gray-700 hover:text-blue-600 py-2">Login</a>
                    <a href="/accounts/reactivate/" class="block text-gray-700 hover:text-blue-600 py-2">Reactivate</a>
                    <a href="/signup/" class="block text-blue-600 font-semibold py-2">Sign Up</a>
                
            </div>
        </div>
    </header>

    <!-- Content -->
    <main class="max-w-6xl mx-auto px-4 py-6 md:p-6">
        
        
<style>
  .calendar-container { position: relative; max-width: 900px; margin: 20px auto; background: #fafafa; border-radius: 12px; padding: 8px; }
  @media (min-width: 768px) {
    .calendar-container { margin: 40px auto; padding: 12px; }
  }
  .month-header { text-align: center; font-size: 1.3rem; font-weight: bold; margin-bottom: 6px; color: #111; }
  @media (min-width: 768px) {
    .month-header { font-size: 1.7rem; margin-bottom: 10px; }
  }
  /* Smooth fade-out/in for month header */
  #monthHeader { opacity: 1; transition: opacity 180ms ease; }
  #monthHeader.is-fading { opacity: 0; }
  .calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 6px; padding: 12px 0; min-height: 200px; }
  @media (min-width: 768px) {
    .calendar-grid { gap: 12px; padding: 20px 0; min-height: 240px; }
  }
  /* Smooth fade-in for calendar grid on month change */
  .calendar-grid {
    opacity: 1;
    transition: opacity 180ms ease;
    will-change: opacity;
  }
  .calendar-grid.is-fading {
    opacity: 0;
    pointer-events: none;
  }
  .day-circle { width: 40px; height: 40px; border-radius: 50%; display: flex; justify-content: center; align-items: center; background: #1f1f29; color: white; cursor: pointer; transition: transform .15s ease, background .15s ease; border: 1px solid rgba(255,255,255,0.15); margin: 0 auto; font-size: 0.9rem; z-index: 1; position: relative; }
  @media (min-width: 768px) {
    .day-circle { width: 52px; height: 52px; font-size: 1rem; }
  }
  .day-circle:hover { transform: scale(1.07); background: #4b59f0; }
  /* Disabled days: greyed out like past-day or unavailable, not clickable */
  .day-circle.disabled {
    opacity: 0.65;
    pointer-events: none !important;
    background: #69696990 !important;
    color: #393535ff !important;
    border: 2px solid #454545ff !important;
    font-weight: 600;
    transform: none !important;
    transition: none !important;
    z-index: 1;
  }
  .day-circle.disabled:hover { 
    transform: none !important; 
    background: #69696990 !important; 
    color: #393535ff !important; 
    cursor: not-allowed !important; 
  }

  /* Weekday header aligned with grid */
  .weekday-row { display: grid; grid-template-columns: repeat(7, 1fr); gap: 6px; padding: 4px 0 0 0; }
  @media (min-width: 768px) {
    .weekday-row { gap: 12px; }
  }
  .weekday-cell { text-align: center; font-size: 0.75rem; color: #555; text-transform: lowercase; }
  @media (min-width: 768px) {
    .weekday-cell { font-size: 0.9rem; }
  }

  #timeModal { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.65); justify-content: center; align-items: center; padding: 8px; z-index: 50; }
  @media (min-width: 768px) {
    #timeModal { padding: 16px; }
  }
  .modal-box { 
    background: #ffffff; 
    padding: 32px 12px 12px 12px; /* extra top padding for close button */ 
    border-radius: 12px; 
    width: 100%; 
    max-width: 95vw; 
    max-height: 85vh; 
    overflow-y: auto; 
    box-shadow: 0 10px 30px rgba(0,0,0,0.2); 
    position: relative; 
    z-index: 100; 
  }
  @media (min-width: 768px) {
    .modal-box { padding: 32px 16px 16px 16px; width: 640px; max-height: 80vh; }
  }
  .time-block { padding: 8px; background: #f3f4f6; border-radius: 8px; margin-bottom: 8px; cursor: pointer; transition: background .15s ease; border: 1px solid #e5e7eb; font-size: 0.9rem; }
  @media (min-width: 768px) {
    .time-block { padding: 10px; margin-bottom: 10px; font-size: 1rem; }
  }
  .time-block:hover { background: #4b59f0; color: white; }
  .modal-title { font-weight: 600; margin-bottom: 8px; font-size: 1rem; }
  @media (min-width: 768px) {
    .modal-title { font-size: 1.125rem; }
  }
  .modal-actions { display:flex; justify-content:space-between; align-items:center; gap:8px; flex-wrap: wrap; }
  .modal-close {
    position: absolute;
    top: 8px;
    right: 10px;
    background: transparent;
    border: none;
    font-size: 24px;
    cursor: pointer !important;
    color: #666;
    z-index: 101;
  }

  /* Hard guard: when fading, hide from layout to avoid flash */
  .calendar-grid.is-fading { visibility: hidden; }
  #monthHeader.is-fading { visibility: hidden; }

  /* Centered service selector styles */
  #mainServiceSelect {
    flex: 1;
    min-width: 120px;
    padding: 0.5rem 0.75rem;
    border: 1px solid #d1d5db;
    border-radius: 0.375rem;
    background-color: #fff;
    color: #111;
    font-size: 0.875rem;
    line-height: 1.25rem;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
  }
  #mainServiceSelect:focus {
    outline: none;
    ring: 2px solid #2563eb;
    ring-offset: 2px;
  }
  #serviceInfoIcon {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background: #e0e7ff;
    color: #374151;
    font-size: 18px;
    border: 1px solid #c7d2fe;
    cursor: pointer;
    transition: background 0.2s ease, transform 0.2s ease;
  }
  #serviceInfoIcon:hover {
    background: #d1e7ff;
    transform: scale(1.05);
  }
  #mainServiceDetails {
    position: absolute;
    top: 24px;
    left: 500px;
    padding: 1rem;
    z-index: 9999;
    width: 340px;
    border: 2px solid #2563eb;
    border-radius: 0.375rem;
    background-color: #f9fafb;
    color: #111;
    font-size: 1rem;
    line-height: 1.5rem;
    box-shadow: 0 4px 24px rgba(0,0,0,0.12);
  }
  #mainServiceDetails strong {
    font-weight: 600;
    color: #111;
  }
  #mainServiceDetails span {
    color: #374151;
  }

  .service-details-fade {
    opacity: 0;
    transition: opacity 250ms ease;
    display: none; /* hidden by default via class, not ID */
  }
  .service-details-fade.visible {
    opacity: 1;
    display: block !important; /* show when visible class applied */
  }

  /* Add this to style spacers in the calendar grid */
  .calendar-grid .spacer {
     pointer-events: none;
     background: transparent;
     /* keep spacer height set by JS so layout stays correct, but don't block pointer events */
     min-height: 0 !important; /* Ensure minimum height is preserved */
     height: auto !important; /* Allow height to be set by JS */
  }
</style>

<div class="calendar-container" style="position:relative;">
  
  
    <div class="mb-4 p-3 rounded-md bg-amber-50 border-l-4 border-amber-400 text-amber-800" role="status" aria-live="polite">
      <span style="font-size:1.2rem; margin-right:8px;">⚠️</span>
      <span style="font-weight:600;">Trial:</span>
      <span style="margin-left:8px;">The current owner of this business is on a trial run which is why there is only a limited amount of days available to book. Once the trial is over or when the user subscribes, the availability will open up for future days/months.</span>
    </div>
  
  <div class="month-nav" style="display:flex; align-items:center; justify-content:space-between; gap:6px; margin-bottom:8px;">
    <button id="prevMonthBtn" class="px-2 md:px-3 py-1 rounded bg-gray-200 hover:bg-gray-300 text-sm md:text-base">Prev</button>
    <h1 class="month-header flex-1" id="monthHeader" style="font-size: clamp(1rem, 4vw, 1.7rem);"></h1>
    <button id="nextMonthBtn" class="px-2 md:px-3 py-1 rounded bg-gray-200 hover:bg-gray-300 text-sm md:text-base">Next</button>
  </div>

  
    <div class="service-dropdown-row" style="display:flex; align-items:center; justify-content:center; gap:10px; margin-bottom:18px; position:relative; z-index:20;">
      <label for="mainServiceSelect" class="font-medium text-gray-700">Service:</label>
      <select id="mainServiceSelect" class="px-3 py-2 rounded border border-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-transparent">
        
          
            <option value="60-minutes" selected>60 minutes</option>
          
        
      </select>
      <span id="serviceInfoIcon" class="ml-2 cursor-pointer" style="display:inline-flex; align-items:center; justify-content:center; width:28px; height:28px; border-radius:50%; background:#e0e7ff; color:#374151; font-size:18px; border:1px solid #c7d2fe;" title="View service details">&#9432;</span>
    </div>
  

  <div class="weekday-row" id="weekdayRow">
    <div class="weekday-cell">sun</div>
    <div class="weekday-cell">mon</div>
    <div class="weekday-cell">tue</div>
    <div class="weekday-cell">wed</div>
    <div class="weekday-cell">thu</div>
    <div class="weekday-cell">fri</div>
    <div class="weekday-cell">sat</div>
  </div>
  <div class="calendar-grid" id="dayGrid"></div>

  <div id="mainServiceDetails" class="service-details-fade">
    <div id="mainSvcTitle" class="modal-title" style="margin-bottom:6px;"></div>
    <div><strong>Description:</strong> <span id="mainSvcDesc"></span></div>
    <div><strong>Duration:</strong> <span id="mainSvcDuration"></span> minutes</div>
    <div><strong>Price:</strong> $<span id="mainSvcPrice"></span></div>
    <div><strong>Refunds:</strong>
      <span id="mainSvcRefundLine"></span>
      <div id="mainSvcRefundText" class="mt-1 text-gray-600" style="display:none;"></div>
    </div>
  </div>
</div>

<!-- TIME MODAL -->
  
<script>
if (typeof window.SERVICE_MAP === 'undefined') {
  window.SERVICE_MAP = {};
  
  window.SERVICE_MAP["60-minutes"] = {
    name: "60 minutes",
    description: "60 minutes gang",
    duration: 60,
    price: 50.00,
    refunds_allowed: true,
    refund_cutoff_hours: 24,
    refund_policy_text: "",
    buffer_after: 0,
    allow_ends_after_availability: true,
    time_increment_minutes: 30,
    use_fixed_increment: true,
    allow_squished_bookings: false,
    weekly_ranges: []
  };
  

  // Weekly ranges provided from backend
  window.SERVICE_WEEKLY_MAP = {"60-minutes": [[], [], [], [], [], [], []]} || {};
  Object.keys(window.SERVICE_WEEKLY_MAP).forEach(function(slug){
    if (window.SERVICE_MAP[slug]) {
      window.SERVICE_MAP[slug].weekly_ranges = window.SERVICE_WEEKLY_MAP[slug];
    }
  });
}
</script>

  
<script>
if (!window.__cc_service_helpers_loaded) {
  window.__cc_service_helpers_loaded = true;

  (function(){
    function updateMainServiceDetails(slug) {
      const d = (window.SERVICE_MAP || {})[slug];
      if (!d) return;
      const mainSvcTitle = document.getElementById('mainSvcTitle'); if (mainSvcTitle) mainSvcTitle.textContent = d.name;
      const mainSvcDesc = document.getElementById('mainSvcDesc'); if (mainSvcDesc) mainSvcDesc.textContent = d.description || '—';
      const mainSvcDuration = document.getElementById('mainSvcDuration'); if (mainSvcDuration) mainSvcDuration.textContent = d.duration || 0;
      const mainSvcPrice = document.getElementById('mainSvcPrice'); if (mainSvcPrice) mainSvcPrice.textContent = (typeof d.price === 'number') ? d.price.toFixed(2) : d.price;
      const mainSvcRefundLine = document.getElementById('mainSvcRefundLine'); if (mainSvcRefundLine) {
        if (d.refunds_allowed) mainSvcRefundLine.textContent = `Refunds permitted except within ${d.refund_cutoff_hours} hours of the appointment.`;
        else mainSvcRefundLine.textContent = 'Refunds are not permitted for this service.';
      }
      const mainSvcRefundText = document.getElementById('mainSvcRefundText'); if (mainSvcRefundText) {
        if (d.refund_policy_text) { mainSvcRefundText.style.display=''; mainSvcRefundText.textContent = d.refund_policy_text; }
        else { mainSvcRefundText.style.display='none'; mainSvcRefundText.textContent = ''; }
      }
      // weekly offered days
      try {
        const weekly = (d && d.weekly_ranges) ? d.weekly_ranges : (window.SERVICE_WEEKLY_MAP && window.SERVICE_WEEKLY_MAP[slug]) || [];
        const dayLabels = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
        const offered = [];
        for (let i=0;i<7;i++){
          const ranges = weekly[i] || [];
          if (ranges.length>0) offered.push(`${dayLabels[i]} ${ranges.join(',')}`);
        }
        const existing = document.getElementById('mainSvcOffered');
        if (offered.length > 0) {
          const offeredLine = offered.join('; ');
          if (existing) existing.textContent = offeredLine;
          else {
            const div = document.createElement('div'); div.id='mainSvcOffered'; div.style.marginTop='8px'; div.textContent = offeredLine;
            const parent = document.getElementById('mainSvcRefundText'); if (parent && parent.parentNode) parent.parentNode.appendChild(div);
          }
        } else if (existing) { existing.remove(); }
      } catch (e) { /* no-op */ }
    }

    document.addEventListener('DOMContentLoaded', function(){
      const mainServiceSelect = document.getElementById('mainServiceSelect');
      const serviceInfoIcon = document.getElementById('serviceInfoIcon');
      const mainServiceDetails = document.getElementById('mainServiceDetails');
      if (!mainServiceSelect) return; // nothing to wire on pages without a selector

      let infoVisible = false;
      function showInfoBox(){ updateMainServiceDetails(mainServiceSelect.value); if (mainServiceDetails) { mainServiceDetails.style.display=''; mainServiceDetails.classList.add('visible'); } infoVisible=true; }
      function hideInfoBox(){ if (mainServiceDetails) { mainServiceDetails.style.display='none'; mainServiceDetails.classList.remove('visible'); } infoVisible=false; }

      if (serviceInfoIcon) {
        serviceInfoIcon.addEventListener('mouseenter', showInfoBox);
        serviceInfoIcon.addEventListener('mouseleave', hideInfoBox);
        serviceInfoIcon.addEventListener('click', function(){ if (infoVisible) hideInfoBox(); else showInfoBox(); });
      }

      mainServiceSelect.addEventListener('change', function(e){
        updateMainServiceDetails(e.target.value);
        if (infoVisible && mainServiceDetails) { mainServiceDetails.style.display=''; mainServiceDetails.classList.add('visible'); }
        else if (mainServiceDetails) { mainServiceDetails.style.display='none'; mainServiceDetails.classList.remove('visible'); }
        window.selectedServiceSlug = e.target.value;
        if (typeof window.generateCalendar === 'function') {
          try { window.generateCalendar(window.currentMonth, window.currentYear); } catch (e) { /* ignore */ }
        }
      });

      // initial state
      updateMainServiceDetails(mainServiceSelect.value);
      window.selectedServiceSlug = mainServiceSelect.value;
      if (mainServiceDetails) { mainServiceDetails.style.display='none'; mainServiceDetails.classList.remove('visible'); }
      infoVisible=false;
    });
  })();
}
</script>

<div id="timeModal">
  <!-- Modal View 1: Time Slots -->
  <div class="modal-box" id="timeModalViewSlots">
    <button class="modal-close" type="button" onclick="closeTimeModal()">×</button>
    <h3 id="selectedDateLabel" class="modal-title text-gray-900"></h3>
    <div id="timeSlots"></div>
  </div>

  <!-- Modal View 2: Service + Details -->
  <div class="modal-box" id="timeModalViewDetails" style="display:none;">
    <button class="modal-close" type="button" onclick="closeTimeModal()">×</button>
    <h3 id="selectedDateTimeLabel" class="modal-title text-gray-900"></h3>

    <form method="POST" action="">
      <input type="hidden" name="csrfmiddlewaretoken" value="UmpHH6ynz7Hv9YOxkzPVILFS5jA5aOTVp7uVtXHwU7J4quYj6KUtxspmPXLi8Zrt">
      <input type="hidden" name="start" id="startInput">
      <input type="hidden" name="end" id="endInput">
      <input type="hidden" name="reschedule_source" id="rescheduleSourceInput" value="">
      <input type="hidden" name="reschedule_token" id="rescheduleTokenInput" value="">

      <label class="block text-sm text-gray-700 mb-1">Select service</label>
      <select id="serviceSelect" name="service_slug" required class="w-full mb-3 px-3 py-2 text-base rounded border border-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-transparent">
        
          
            <option value="60-minutes" selected>60 minutes</option>
          
        
      </select>

      <!-- Service details preview -->
      <div id="serviceDetails" class="mb-4 p-3 rounded border border-gray-200 bg-gray-50 text-sm">
        <div><strong>Name:</strong> <span id="svcName">60 minutes</span></div>
        <div><strong>Description:</strong> <span id="svcDesc">60 minutes gang</span></div>
        <div><strong>Duration:</strong> <span id="svcDuration">60</span> minutes</div>
        <div><strong>Price:</strong> $<span id="svcPrice">50.00</span></div>
        <!-- Client-facing modal intentionally omits buffer/increment/fixed/allow settings -->
        <div><strong>Refunds:</strong>
          <span id="svcRefundLine">
            
              Refunds permitted except within 24 hours of the appointment.
            
          </span>
          
            <div id="svcRefundText" class="mt-1 text-gray-600" style="display:none;"></div>
          
        </div>
      </div>

      <label class="block text-sm text-gray-700 mb-1">Your name</label>
      <input type="text" name="client_name" required value="" class="w-full mb-3 px-3 py-2 text-base rounded border border-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-transparent" placeholder="John Doe">

      <label class="block text-sm text-gray-700 mb-1">Email</label>
      <input type="email" name="client_email" required value="" class="w-full mb-4 px-3 py-2 text-base rounded border border-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-transparent" placeholder="john@example.com">

      <div class="modal-actions">
        <button type="button" id="backToSlotsBtn" class="px-4 py-2 text-sm md:text-base rounded border border-gray-300 text-gray-700 hover:bg-gray-100 flex-1 md:flex-none">Back</button>
        <button type="submit" id="bookNowBtn" class="bg-blue-600 text-white px-4 py-2 text-sm md:text-base rounded hover:bg-blue-700 flex-1 md:flex-none">Book now</button>
      </div>
    </form>
  </div>
</div>

<script>
// Global variable to track booked slots during this session
window.bookedSlotsThisSession = window.bookedSlotsThisSession || [];
</script>

<script>
document.addEventListener("DOMContentLoaded", async function () {
  try { /* init */ } catch (e) {}
  const dayGrid = document.getElementById("dayGrid");
  const monthHeader = document.getElementById("monthHeader");
  const timeModal = document.getElementById("timeModal");
  const timeModalViewSlots = document.getElementById("timeModalViewSlots");
  const timeModalViewDetails = document.getElementById("timeModalViewDetails");
  const selectedDateLabel = document.getElementById("selectedDateLabel");
  const selectedDateTimeLabel = document.getElementById("selectedDateTimeLabel");
  const timeSlots = document.getElementById("timeSlots");
  const startInput = document.getElementById("startInput");
  const endInput = document.getElementById("endInput");
  const serviceSelect = document.getElementById("serviceSelect");
  const detailsBox = document.getElementById("serviceDetails");
  const svcName = document.getElementById("svcName");
  const svcDesc = document.getElementById("svcDesc");
  const svcDuration = document.getElementById("svcDuration");
  const svcPrice = document.getElementById("svcPrice");
  const svcRefundLine = document.getElementById("svcRefundLine");
  const svcRefundText = document.getElementById("svcRefundText");

  const now = new Date();
  let currentMonth = now.getMonth();
  let currentYear = now.getFullYear();
  // Render synchronization guards
  let renderToken = 0;
  let isRendering = false;

  // Render month header and circles
  // Store day summary globally for guards
  let dayHasSlots = {};

  async function generateCalendar(month, year) {
    // Advance render token so only latest render will apply
    const myToken = ++renderToken;
    isRendering = true;
    // Build all elements off-DOM to avoid partial/incremental rendering
    const fragment = document.createDocumentFragment();
    // Trigger fade-out before rebuild and hide from layout
    dayGrid.classList.add('is-fading');
    dayGrid.style.visibility = 'hidden';
    dayGrid.innerHTML = "";
    // Fade out header before changing text (no crossfade)
    monthHeader.classList.add('is-fading');
    const newHeaderText = new Date(year, month).toLocaleString("default", { month: "long", year: "numeric" });

    const firstDay = new Date(year, month, 1).getDay();
    const numDays = new Date(year, month + 1, 0).getDate();

    for (let i = 0; i < firstDay; i++) {
      const spacer = document.createElement("div");
      spacer.style.minHeight = "52px";
      spacer.className = "spacer"; /* Add spacer class */
      fragment.appendChild(spacer);
    }

    // Fetch batch availability summary for the entire month in one call
    const todayMidnight = new Date(); todayMidnight.setHours(0,0,0,0);
    const pad = n => String(n).padStart(2, '0');
    function toIsoLocal(d) {
      const yyyy = d.getFullYear();
      const mm = pad(d.getMonth() + 1);
      const dd = pad(d.getDate());
      const HH = pad(d.getHours());
      const MM = pad(d.getMinutes());
      return `${yyyy}-${mm}-${dd}T${HH}:${MM}:00`;
    }

    const monthStart = new Date(year, month, 1, 0, 0, 0);
    const monthEnd = new Date(year, month + 1, 0, 23, 59, 59);
    const cacheBuster = `&_t=${Date.now()}`;
    const batchUrl = "/bus/beisbol/services/SERVICE_SLUG/availability/batch/".replace('SERVICE_SLUG', window.selectedServiceSlug || '60-minutes') + `?start=${encodeURIComponent(toIsoLocal(monthStart))}&end=${encodeURIComponent(toIsoLocal(monthEnd))}${cacheBuster}`;
    
    dayHasSlots = {};
    try {
      const resp = await fetch(batchUrl);
      if (resp.ok) {
        dayHasSlots = await resp.json();
      }
    } catch(e) {
      console.error('Batch availability fetch failed', e);
    }

    // Prefetch server-effective settings for this service/date so month rendering
    // and the per-day detailed calls use the same (saved) increment/fixed flags.
    let svcForLoop = SERVICE_MAP[window.selectedServiceSlug || '60-minutes'] || {};
    try {
      const effUrl = "/bus/beisbol/services/SERVICE_SLUG/effective/".replace('SERVICE_SLUG', window.selectedServiceSlug || '60-minutes') + '?date=' + encodeURIComponent(toIsoLocal(monthStart).split('T')[0]);
      const effResp = await fetch(effUrl);
      if (effResp.ok) {
        const eff = await effResp.json();
        if (eff && typeof eff.use_fixed_increment === 'boolean') {
          svcForLoop = Object.assign({}, svcForLoop, {
            use_fixed_increment: eff.use_fixed_increment,
            time_increment_minutes: eff.time_increment_minutes,
            allow_ends_after_availability: eff.allow_ends_after_availability
          });
        }
      }
    } catch (e) {
      
    }

    // Strict availability checker: only treat clearly positive values as available
    function hasAvailability(val) {
      if (val === undefined || val === null) return false;
      // Normalize strings
      if (typeof val === 'string') {
        const s = val.trim();
        if (s === '' || s === 'false' || s === '0') return false;
        if (s.startsWith('[') || s.startsWith('{')) {
          try { val = JSON.parse(s); } catch (_) { return false; }
        } else {
          // Any other string is treated as no availability
          return false;
        }
      }
      // Arrays: must have length > 0
      if (Array.isArray(val)) return val.length > 0;
      // Numbers: must be > 0
      if (typeof val === 'number') return val > 0;
      // Booleans: only true means available
      if (typeof val === 'boolean') return val === true;
      // Objects: check common shapes
      if (typeof val === 'object') {
        if ('count' in val) return Number(val.count) > 0;
        if ('slots' in val && Array.isArray(val.slots)) return val.slots.length > 0;
        // Unknown object shapes are treated as unavailable
        return false;
      }
      return false;
    }

    // Prefetch detailed availability in parallel for candidate days, then render in one batch
    const detailedDayHasSlots = {};
    const fetches = [];
    for (let day = 1; day <= numDays; day++) {
      const date = new Date(year, month, day);
      const yyyy = date.getFullYear();
      const mm = String(date.getMonth()+1).padStart(2,'0');
      const dd = String(date.getDate()).padStart(2,'0');
      const dateKey = `${yyyy}-${mm}-${dd}`;
      const summaryVal = dayHasSlots[dateKey];
      const isAvailable = hasAvailability(summaryVal);
      if (date >= todayMidnight && isAvailable) {
        const start = new Date(year, month, day, 0, 0, 0);
        const end = new Date(year, month, day, 23, 59, 59);
        const pad = n => String(n).padStart(2,'0');
        const toIsoLocal = (d) => `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}:00`;
        const cacheBuster = `&_t=${Date.now()}`;
        // Determine whether to apply edge buffers for this service. Preference order:
        // 1) explicit localStorage override if present, 2) server-side service setting.
        function getEdgeBuffersForService(slug) {
          try {
            const raw = localStorage.getItem('edge_buffers_' + slug);
            if (raw === '1' || raw === 'true') return 1;
            if (raw === '0' || raw === 'false') return 0;
          } catch (e) {}
          // Do NOT default to the service's `allow_ends_after_availability` here.
          // Edge buffer behavior should only be controlled via explicit local override.
          return 0;
        }
        const edgeVal = getEdgeBuffersForService(window.selectedServiceSlug || '60-minutes');
        // If the service is configured to use fixed increments, do NOT force an `inc` param
        // so the server can apply duration+buffer spacing. Otherwise include the preview tick.
        // use `svcForLoop` prefetched above (may contain server effective settings)
        let incQuery = '';
        
        if (!svcForLoop.use_fixed_increment) {
          const incVal = Math.max(5, Number(svcForLoop.time_increment_minutes || 30));
          incQuery = `&inc=${incVal}`;
        }
        
        const availUrl = "/bus/beisbol/services/SERVICE_SLUG/availability/".replace('SERVICE_SLUG', window.selectedServiceSlug || '60-minutes') + `?start=${encodeURIComponent(toIsoLocal(start))}&end=${encodeURIComponent(toIsoLocal(end))}${incQuery}&edge_buffers=${edgeVal}${cacheBuster}`;
        fetches.push(
          fetch(availUrl)
            .then(r => r.ok ? r.json() : [])
            .then(slots => { detailedDayHasSlots[dateKey] = Array.isArray(slots) && slots.length > 0; })
            .catch(() => { detailedDayHasSlots[dateKey] = false; })
        );
      } else {
        detailedDayHasSlots[dateKey] = false; // past or summary says no
      }
    }

    // Wait for all detailed availability calls to resolve
    try { await Promise.all(fetches); } catch (_) {}

    // If a newer render started, abort applying this one
    if (myToken !== renderToken) {
      return;
    }

    // Now render circles in one batch with accurate disabled states
    const circles = [];
    for (let day = 1; day <= numDays; day++) {
      const date = new Date(year, month, day);
      const circle = document.createElement("div");
      circle.className = "day-circle";
      circle.innerText = day;
      const yyyy = date.getFullYear();
      const mm = String(date.getMonth()+1).padStart(2,'0');
      const dd = String(date.getDate()).padStart(2,'0');
      const dateKey = `${yyyy}-${mm}-${dd}`;
      circle.dataset.date = dateKey;

      const enabled = date >= todayMidnight && !!detailedDayHasSlots[dateKey];
      if (enabled) {
        circle.style.cursor = 'pointer';
        circle.tabIndex = 0;
        circle.addEventListener("click", () => openTimeModal(year, month, day, dateKey));
      } else {
        circle.classList.add("disabled");
        circle.style.pointerEvents = 'none';
        circle.style.cursor = 'not-allowed';
        circle.setAttribute('aria-disabled', 'true');
        circle.tabIndex = -1;
      }
      fragment.appendChild(circle);
      circles.push(circle);
    }

    // Append all circles in one batch to prevent partial paints
    dayGrid.appendChild(fragment);
    // Mark render complete
    isRendering = false;
    // Orchestrate fade: header fades out, then updates text, then both fade in
    setTimeout(() => {
      if (myToken !== renderToken) return;
      // Update header text after fade-out completes
      monthHeader.innerText = newHeaderText;
      // Next frame, remove fading classes to fade in
      requestAnimationFrame(() => {
        if (myToken !== renderToken) return;
        dayGrid.classList.remove('is-fading');
        dayGrid.style.visibility = 'visible';
        monthHeader.classList.remove('is-fading');
      });
    }, 180);
  }

  // Fetch availability from server and show time circles for selected day
  async function openTimeModal(year, month, day, dateKey) {
    const date = new Date(year, month, day);
    selectedDateLabel.innerText = date.toDateString();
    timeSlots.innerHTML = "";

    // Guard: if summary indicates no slots, do not open
    const summary = dayHasSlots[dateKey];
    // Robust guard: treat ambiguous or empty shapes as no slots
    let summaryNoSlots = (
      summary === undefined || summary === null || summary === false || summary === 0 || summary === "0" ||
      (Array.isArray(summary) && summary.length === 0)
    );
    if (!summaryNoSlots && typeof summary === 'object' && summary !== null) {
      const hasCount = ('count' in summary) && Number(summary.count) === 0;
      const hasEmptySlots = ('slots' in summary) && Array.isArray(summary.slots) && summary.slots.length === 0;
      summaryNoSlots = hasCount || hasEmptySlots;
    }
    if (!summaryNoSlots && typeof summary === 'string') {
      const s = summary.trim();
      if (s === '' || s === 'false' || s === '0') {
        summaryNoSlots = true;
      } else if (s.startsWith('[') || s.startsWith('{')) {
        try {
          const parsed = JSON.parse(s);
          if (Array.isArray(parsed)) summaryNoSlots = parsed.length === 0;
          else if (parsed && typeof parsed === 'object') {
            const c0 = ('count' in parsed) && Number(parsed.count) === 0;
            const e0 = ('slots' in parsed) && Array.isArray(parsed.slots) && parsed.slots.length === 0;
            summaryNoSlots = c0 || e0;
          }
        } catch (_) {
          summaryNoSlots = true;
        }
      } else {
        summaryNoSlots = true;
      }
    }
    if (summaryNoSlots) {
      return; // prevent opening modal for fully booked day
    }

    // Build local ISO (avoid timezone drift like 1am)
    const rangeStartDate = new Date(year, month, day, 0, 0, 0);
    const rangeEndDate = new Date(year, month, day, 23, 59, 59);
    function toIsoLocal(d) {
      const pad = n => String(n).padStart(2,'0');
      const yyyy = d.getFullYear();
      const mm = pad(d.getMonth() + 1);
      const dd = pad(d.getDate());
      const HH = pad(d.getHours());
      const MM = pad(d.getMinutes());
      return `${yyyy}-${mm}-${dd}T${HH}:${MM}:00`;
    }

    try {
      // Add cache-busting timestamp to always fetch fresh data
      const cacheBuster = `&_t=${Date.now()}`;
      // Fetch ONLY availability - include increment override so backend can adjust slot stepping
      // Prefer server-side effective settings (this reflects saved changes). Fall back
      // to localStorage/client override when server call fails.
      let previewIncrement = 30;
      let eff = null; // effective settings from server
      try {
        const svcSlugLocal = window.selectedServiceSlug || '60-minutes';
        const effUrl = "/bus/beisbol/services/SERVICE_SLUG/effective/".replace('SERVICE_SLUG', svcSlugLocal) + '?date=' + encodeURIComponent(toIsoLocal(rangeStartDate).split('T')[0]);
        const effResp = await fetch(effUrl);
        if (effResp.ok) {
            eff = await effResp.json();
            if (eff && typeof eff.time_increment_minutes === 'number') previewIncrement = eff.time_increment_minutes;
            
          } else {
            
          }
      } catch (e) {
        
      }
      try {
        if (!eff) {
          const svc = SERVICE_MAP[window.selectedServiceSlug || '60-minutes'] || {};
          if (typeof svc.time_increment_minutes === 'number') previewIncrement = svc.time_increment_minutes;
          const rawPreview = localStorage.getItem('client_view_settings');
          if (rawPreview) {
            const parsed = JSON.parse(rawPreview);
            if (typeof parsed.increment === 'number') previewIncrement = parsed.increment;
          }
        }
      } catch (e) {}

      // Read service metadata from the shared window.SERVICE_MAP
      function updateServiceDetails(slug) {
        const d = (window.SERVICE_MAP || {})[slug];
        if (!d) return;
        svcName.textContent = d.name;
        svcDesc.textContent = d.description || "—";
        svcDuration.textContent = d.duration || 0;
        svcPrice.textContent = (typeof d.price === 'number') ? d.price.toFixed(2) : d.price;
        if (d.refunds_allowed) {
          svcRefundLine.textContent = `Refunds permitted except within ${d.refund_cutoff_hours} hours of the appointment.`;
          if (d.refund_policy_text) {
            svcRefundText.style.display = '';
            svcRefundText.textContent = d.refund_policy_text;
          } else {
            svcRefundText.style.display = 'none';
            svcRefundText.textContent = '';
          }
        } else {
          svcRefundLine.textContent = 'Refunds are not permitted for this service.';
          svcRefundText.style.display = 'none';
          svcRefundText.textContent = '';
        }
        // Client-facing modal intentionally omits buffer/increment/fixed/allow details
      }

      // Initialize details
      updateServiceDetails(serviceSelect.value);
      serviceSelect.addEventListener('change', (e) => {
        updateServiceDetails(e.target.value);
      });
      // Include edge buffer preference (prefer server setting, allow local override)
      const edgeVal2 = (function(){
        try {
          const raw = localStorage.getItem('edge_buffers_' + (window.selectedServiceSlug || '60-minutes'));
          if (raw === '1' || raw === 'true') return 1;
          if (raw === '0' || raw === 'false') return 0;
        } catch (e) {}
        // Default to 0 (do not apply edge buffers) unless explicitly overridden.
        return 0;
      })();
      // If service enforces fixed increments, don't send `inc` so server uses duration+buffer
      // Determine whether server indicates use_fixed_increment; prefer eff if present
      const svcPreview = SERVICE_MAP[window.selectedServiceSlug || '60-minutes'] || {};
      const useFixed = (eff && typeof eff.use_fixed_increment === 'boolean') ? eff.use_fixed_increment : !!svcPreview.use_fixed_increment;
      const previewIncQuery = (useFixed ? '' : `&inc=${previewIncrement}`);
      const svcSlug = serviceSelect.value || window.selectedServiceSlug || '60-minutes';
      let allowEndsForAvail = false;
      try {
        allowEndsForAvail = (eff && typeof eff.allow_ends_after_availability === 'boolean') ? !!eff.allow_ends_after_availability : !!svcPreview.allow_ends_after_availability;
      } catch (err) { /* ignore */ }
      const availUrl = "/bus/beisbol/services/SERVICE_SLUG/availability/".replace('SERVICE_SLUG', svcSlug) + `?start=${encodeURIComponent(toIsoLocal(rangeStartDate))}&end=${encodeURIComponent(toIsoLocal(rangeEndDate))}${previewIncQuery}&edge_buffers=${edgeVal2}&allow_ends_after_availability=${allowEndsForAvail?1:0}${cacheBuster}`;
      
      const availResp = await fetch(availUrl);
      if (!availResp.ok) throw new Error("Failed to load availability");
      const slots = await availResp.json();

      // If detailed fetch yields no slots, do not mutate the day circle state.
      // Simply avoid opening the modal or show a lightweight notice.
      if (!Array.isArray(slots) || slots.length === 0) {
        // Avoid turning the circle grey on click; just return quietly
        return;
      }

      // Read client view settings (saved from internal calendar)
      // Default increment starts as the previewIncrement (which prefers server eff when available)
      let clientSettings = { block: 1, increment: previewIncrement, startHour: 9 };
      try {
        const raw = localStorage.getItem('client_view_settings');
        if (raw) {
          const parsed = JSON.parse(raw);
          if (typeof parsed.block === 'number') clientSettings.block = parsed.block;
          if (typeof parsed.increment === 'number') clientSettings.increment = parsed.increment;
          if (typeof parsed.startHour === 'number') clientSettings.startHour = parsed.startHour;
        }
      } catch (e) {}

      // If we fetched effective server settings, prefer them for the public display
      try {
        if (eff && typeof eff.time_increment_minutes === 'number') {
          clientSettings.increment = eff.time_increment_minutes;
        }
      } catch (e) {}

      const blockMinutes = Math.max(1, clientSettings.block) * 60;
      const inc = Math.max(5, clientSettings.increment);

      // Styles for circles
      const styleId = 'publicTimeCirclesStyle';
      if (!document.getElementById(styleId)) {
        const style = document.createElement('style');
        style.id = styleId;
        style.innerHTML = `
          .time-circle { width: 80px; height: 80px; border-radius: 50%; display:flex; justify-content:center; align-items:center; cursor:pointer; font-size:13px; color:white; transition:transform .1s ease; }
          .time-circle.open { background:#28a745; }
          .time-circle.booked { background:#9ca3af; cursor:not-allowed; }
          .time-circle:hover { transform: scale(1.08); }
          .circles-row { display:flex; align-items:center; justify-content:space-between; gap:8px; border-bottom:1px solid #e5e7eb; padding:8px 0; }
          .circles-hour { width:70px; font-weight:bold; }
          .circles-container { display:flex; flex-wrap:wrap; gap:8px; margin-left:auto; }
          @media (max-width: 768px) {
            .modal-box { width: 95vw; }
            .time-circle { width: 68px; height: 68px; font-size:12px; }
          }
        `;
        document.head.appendChild(style);
      }

      // If no slots, show message
      if (!Array.isArray(slots) || slots.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'text-gray-600';
        empty.innerText = 'No available times on this day.';
        timeSlots.appendChild(empty);
        timeModal.style.display = 'flex';
        return;
      }

      // Convert slots to minute ranges (treat server times as local to avoid TZ drift)
      function isoToLocalMinutes(isoStr) {
        // Expect formats like YYYY-MM-DDTHH:MM or with seconds, possibly with 'Z'.
        // Parse HH and MM directly to avoid timezone shifts.
        const m = isoStr.match(/T(\d{2}):(\d{2})/);
        if (!m) return null;
        const h = parseInt(m[1], 10);
        const mm = parseInt(m[2], 10);
        return h * 60 + mm;
      }
      // Preserve metadata such as violates_buffer when present
      const slotRanges = slots.map(s => {
        const startMin = isoToLocalMinutes(s.start);
        const endMin = isoToLocalMinutes(s.end);
        return { startMin, endMin, meta: { violates_buffer: !!s.violates_buffer } };
      }).filter(r => r.startMin != null && r.endMin != null && r.endMin > r.startMin);

      // Group slots by hour for exact rendering; labels derive from slot starts
      const slotsByHour = new Map(); // hourStartMin -> [{startMin, endMin, label}]
        for (let idx=0; idx<slots.length; idx++) {
          const s = slots[idx];
          const sm = isoToLocalMinutes(s.start);
          const em = isoToLocalMinutes(s.end);
          if (sm == null || em == null || em <= sm) continue;
          const hourKey = Math.floor(sm/60)*60;
          const h = Math.floor(sm/60);
          const m = sm % 60;
          const ampm = h >= 12 ? 'PM' : 'AM';
          let dispH = h % 12; if (dispH === 0) dispH = 12;
          const label = `${dispH}:${String(m).padStart(2,'0')} ${ampm}`;
          const arr = slotsByHour.get(hourKey) || [];
          // attach index so we can cross-reference metadata later
          arr.push({ startMin: sm, endMin: em, label, slotIndex: idx });
          slotsByHour.set(hourKey, arr);
        }

      // Render rows using saved Client View settings (block size + increment),
      // but only at valid server-provided start times.
      if (slotRanges.length > 0) {
        // Do NOT clamp to clientSettings.startHour when earlier valid slots exist;
        // honor the earliest server-provided availability.
        const minStart = Math.min(...slotRanges.map(r => r.startMin));
        const maxEnd = Math.max(...slotRanges.map(r => r.endMin));

        // Map of valid start -> end (from server slots)
        const startToEnd = new Map();
        for (const s of slots) {
          const sm = isoToLocalMinutes(s.start);
          const em = isoToLocalMinutes(s.end);
          if (sm != null && em != null && em > sm) startToEnd.set(sm, em);
        }

        // Helper: format label from minute-of-day
        function labelFromMin(totalMin) {
          const h24 = Math.floor(totalMin/60);
          const m = totalMin % 60;
          const ampm = h24 >= 12 ? 'PM' : 'AM';
          let h = h24 % 12; if (h === 0) h = 12;
          return `${h}:${String(m).padStart(2,'0')} ${ampm}`;
        }

        // NEW: Iterate from earliest start minute directly, stepping by client increment, preserving irregular offsets.
        // Group rows by the hour of each slot's start for readability.
        const validStarts = Array.from(startToEnd.keys()).sort((a,b)=>a-b);
        const hours = [];
        const hourMap = new Map();
        for (const sm of validStarts) {
          const hourStart = Math.floor(sm/60)*60; // minute-of-day of the hour
          if (!hourMap.has(hourStart)) {
            hourMap.set(hourStart, []);
            hours.push(hourStart);
          }
          hourMap.get(hourStart).push(sm);
        }

        for (const hourStart of hours) {
          const row = document.createElement('div');
          row.className = 'circles-row';
          const hourLabel = document.createElement('div');
          hourLabel.className = 'circles-hour';
          const labelDate = new Date(year, month, day);
          labelDate.setHours(Math.floor(hourStart/60), hourStart%60, 0, 0);
          // Show minutes if not on the hour, e.g., 8:20 AM
          const labelOpts = { hour: 'numeric', minute: (hourStart%60!==0?'2-digit':undefined), hour12: true };
          hourLabel.textContent = labelDate.toLocaleString(undefined, labelOpts);
          row.appendChild(hourLabel);

          const circlesContainer = document.createElement('div');
          circlesContainer.className = 'circles-container';

          // Render circles for all server-provided starts (each window may have its own baseline).
          for (const sm of hourMap.get(hourStart)) {
            const endMin = startToEnd.get(sm);
            // find original slot object to read metadata
            const slotObj = slots.find(sl => {
              const ssm = isoToLocalMinutes(sl.start);
              return ssm === sm;
            }) || {};
            const slotKey = `${year}-${month}-${day}-${sm}`;
            const wasBookedThisSession = window.bookedSlotsThisSession.includes(slotKey);
            const circle = document.createElement('div');
            circle.className = wasBookedThisSession ? 'time-circle booked' : 'time-circle open';
            circle.textContent = labelFromMin(sm);
            circle.dataset.startMin = String(sm);
            circle.dataset.endMin = String(endMin);
            // If this slot violates buffer rules we no longer show a tooltip
            // or change the circle background here so it appears like other slots.
            // (Keep metadata on `slotObj` for potential server-side handling.)

            if (!wasBookedThisSession) {
              circle.addEventListener('click', () => {
                const start = new Date(year, month, day);
                const h = Math.floor(sm/60), m = sm % 60;
                start.setHours(h, m, 0, 0);
                const endDate = new Date(start);
                endDate.setMinutes(endDate.getMinutes() + (endMin - sm));
                function toLocalISOString(d) {
                  const pad = n => String(n).padStart(2,'0');
                  return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
                }
                startInput.value = toLocalISOString(start);
                endInput.value = toLocalISOString(endDate);
                const headerText = `${date.toDateString()} • ${labelFromMin(sm)}`;
                selectedDateLabel.innerText = headerText;
                selectedDateTimeLabel.innerText = headerText;
                circle.dataset.slotKey = slotKey;
                timeModalViewSlots.style.display = 'none';
                timeModalViewDetails.style.display = 'block';
              });
            }
            circlesContainer.appendChild(circle);
          }
          if (circlesContainer.children.length > 0) {
            row.appendChild(circlesContainer);
            timeSlots.appendChild(row);
          }
        }
      }

      if (timeSlots.lastElementChild) {
        timeSlots.lastElementChild.style.borderBottom = 'none';
      }
      timeModal.style.display = 'flex';
    } catch (e) {
      console.error(e);
      try { showToast('error', "Could not load availability. Please try another day."); } catch(err){ console.error('toast failed', err); }
    }
  }

  function closeTimeModal() { 
    timeModal.style.display = "none"; 
    // Reset to slots view when closing
    timeModalViewDetails.style.display = 'none';
    timeModalViewSlots.style.display = 'block';
  }
  window.closeTimeModal = closeTimeModal;

  // Back button to return to time slots view
  const backBtn = document.getElementById('backToSlotsBtn');
  if (backBtn) {
    backBtn.addEventListener('click', () => {
      timeModalViewDetails.style.display = 'none';
      timeModalViewSlots.style.display = 'block';
    });
  }

  // Handle booking form submission - mark slot as booked immediately
  const bookingForm = document.querySelector('#timeModalViewDetails form');
  if (bookingForm) {
    bookingForm.addEventListener('submit', (e) => {
      // Get the slot key from the start input
      const startVal = startInput.value;
      const endVal = endInput.value;
      if (startVal) {
        try {
          const startDate = new Date(startVal);
          const endDate = endVal ? new Date(endVal) : null;
          const slotKey = `${startDate.getFullYear()}-${startDate.getMonth()}-${startDate.getDate()}-${startDate.getHours() * 60 + startDate.getMinutes()}`;
          // Mark this slot as booked for this session
          if (!window.bookedSlotsThisSession.includes(slotKey)) {
            window.bookedSlotsThisSession.push(slotKey);
          }
          // Remove circles that overlap the booked range (including the booked one)
          const bookedStartMin = startDate.getHours() * 60 + startDate.getMinutes();
          const bookedEndMin = endDate ? (endDate.getHours() * 60 + endDate.getMinutes()) : (bookedStartMin);
          document.querySelectorAll('#timeSlots .time-circle').forEach(c => {
            const sm = parseInt(c.dataset.startMin || '-1', 10);
            const em = parseInt(c.dataset.endMin || '-1', 10);
            if (sm >= 0 && em >= 0) {
              const overlaps = !(em <= bookedStartMin || sm >= bookedEndMin);
              if (overlaps) {
                c.remove();
              }
            }
          });
        } catch (err) {
          console.error('Failed to track booked slot:', err);
        }
      }
      // Form will submit normally and redirect
    });
  }

  // Ensure header and grid start transparent, preventing any crossfade flash
  dayGrid.classList.add('is-fading');
  monthHeader.classList.add('is-fading');

  // Initial render
  try { generateCalendar(currentMonth, currentYear); } catch (e) { console.error('generateCalendar failed', e); }

  const prevBtn = document.getElementById('prevMonthBtn');
  const nextBtn = document.getElementById('nextMonthBtn');
  if (prevBtn) {
    prevBtn.onclick = function () {
      // Prevent overlapping renders; queue the latest intent
      if (isRendering) return;
      if (currentMonth === 0) { currentMonth = 11; currentYear--; } else { currentMonth--; }
      generateCalendar(currentMonth, currentYear);
    };
  }
  if (nextBtn) {
    nextBtn.onclick = function () {
      if (isRendering) return;
      if (currentMonth === 11) { currentMonth = 0; currentYear++; } else { currentMonth++; }
      generateCalendar(currentMonth, currentYear);
    };
  }

  // No service selection impacts availability at this stage; service is chosen in the booking form
});
</script>

    </main>

        <!-- Toast container + helper: used to replace alert() with non-blocking toasts -->
        <div id="toast-container" style="position:fixed;right:16px;top:16px;z-index:99999;display:flex;flex-direction:column;gap:8px;pointer-events:none"></div>
        <script>
            function createToastElement(type, msg) {
                const wrap = document.createElement('div');
                wrap.style.pointerEvents = 'auto';
                wrap.style.display = 'flex';
                wrap.style.alignItems = 'flex-start';
                wrap.style.gap = '10px';
                wrap.style.minWidth = '240px';
                wrap.style.maxWidth = '520px';
                wrap.style.padding = '10px 12px';
                wrap.style.borderRadius = '10px';
                wrap.style.boxShadow = '0 8px 28px rgba(15,23,42,0.12)';
                wrap.style.color = '#022047';
                wrap.style.fontSize = '13px';
                wrap.style.lineHeight = '1.25';
                wrap.style.opacity = '0';
                wrap.style.transition = 'opacity 180ms ease, transform 200ms ease';
                wrap.style.transform = 'translateY(-6px)';

                // color by type
                if (type === 'success') {
                    wrap.style.background = '#ECFDF5';
                    wrap.style.borderLeft = '4px solid #10B981';
                } else if (type === 'error') {
                    wrap.style.background = '#FEF2F2';
                    wrap.style.borderLeft = '4px solid #EF4444';
                } else if (type === 'warn' || type === 'warning') {
                    wrap.style.background = '#FFFBEB';
                    wrap.style.borderLeft = '4px solid #F59E0B';
                } else {
                    wrap.style.background = '#EFF6FF';
                    wrap.style.borderLeft = '4px solid #3B82F6';
                }

                // icon
                const icon = document.createElement('div');
                icon.style.flex = '0 0 20px';
                icon.style.marginTop = '2px';
                icon.innerHTML = ({
                    'success': '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M20 6L9 17l-5-5" stroke="#059669" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>',
                    'error': '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 9v4" stroke="#DC2626" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M12 17h.01" stroke="#DC2626" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M21 12A9 9 0 1 1 3 12a9 9 0 0 1 18 0z" stroke="#DC2626" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>',
                    'warning': '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z" stroke="#B45309" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/><path d="M12 9v4" stroke="#B45309" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/><path d="M12 17h.01" stroke="#B45309" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>',
                    'info': '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M13 16h-1v-4h-1" stroke="#2563EB" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M12 8h.01" stroke="#2563EB" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><circle cx="12" cy="12" r="9" stroke="#2563EB" stroke-width="2"/></svg>'
                })[type === 'warn' ? 'warning' : (type in {success:1,error:1,warning:1,info:1} ? type : 'info')];
                wrap.appendChild(icon);

                // content
                const content = document.createElement('div');
                content.style.flex = '1 1 auto';
                content.style.overflow = 'hidden';
                content.style.maxHeight = '6.5em';
                content.style.whiteSpace = 'normal';
                content.style.wordBreak = 'break-word';
                const text = document.createElement('div');
                text.textContent = msg;
                content.appendChild(text);
                wrap.appendChild(content);

                // close button
                const closeBtn = document.createElement('button');
                closeBtn.setAttribute('aria-label', 'Dismiss');
                closeBtn.style.marginLeft = '8px';
                closeBtn.style.flex = '0 0 auto';
                closeBtn.style.background = 'transparent';
                closeBtn.style.border = 'none';
                closeBtn.style.cursor = 'pointer';
                closeBtn.style.padding = '4px';
                closeBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M18 6L6 18M6 6l12 12" stroke="#374151" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>';
                wrap.appendChild(closeBtn);

                closeBtn.addEventListener('click', () => {
                    try { wrap.style.opacity = '0'; wrap.style.transform = 'translateY(-6px)'; setTimeout(() => { wrap.remove(); }, 200); } catch(e){}
                });

                return wrap;
            }

            function showToast(type, msg, timeout=4200) {
                try {
                    const container = document.getElementById('toast-container');
                    if (!container) return null;
                    const el = createToastElement(type, msg);
                    container.appendChild(el);
                    // animate in
                    requestAnimationFrame(() => { el.style.opacity = '1'; el.style.transform = 'translateY(0)'; });
                    const to = setTimeout(() => {
                        try { el.style.opacity = '0'; el.style.transform = 'translateY(-6px)'; setTimeout(() => { try { el.remove(); } catch(e){} }, 220); } catch(e){}
                    }, timeout);
                    // dismiss on click of body also
                    el.addEventListener('click', () => { clearTimeout(to); try { el.style.opacity = '0'; setTimeout(() => { el.remove(); }, 220); } catch(e){} });
                    return el;
                } catch (e) { console.error('showToast failed', e); }
            }

            // Override window.alert to use non-blocking toasts by default.
            try { window.alert = function(msg){ try { showToast('info', String(msg)); } catch(e){ /* fallback suppressed */ } }; } catch(e){}

        </script>

        

        <!-- Global loading overlay (site-wide) -->
        <div id="global-loading-overlay" class="hidden fixed inset-0 z-50 items-center justify-center bg-black bg-opacity-30">
            <div class="bg-white p-6 rounded-lg flex flex-col items-center shadow-lg">
                <div class="animate-spin rounded-full border-8 border-t-8 border-gray-200 h-16 w-16 mb-4" style="border-top-color:#2563EB"></div>
                <div class="text-gray-700">Loading…</div>
            </div>
        </div>

        <script>
            // Global loading overlay helpers
            function showLoading(msg) {
                const ov = document.getElementById('global-loading-overlay');
                if (!ov) return;
                try {
                    if (msg) {
                        const txt = ov.querySelector('div.text-gray-700');
                        if (txt) txt.textContent = msg;
                    }
                } catch(e){}
                ov.classList.remove('hidden');
                ov.classList.add('flex');
            }
            function hideLoading() {
                const ov = document.getElementById('global-loading-overlay');
                if (!ov) return;
                ov.classList.add('hidden');
                ov.classList.remove('flex');
                try { const txt = ov.querySelector('div.text-gray-700'); if (txt) txt.textContent = 'Loading…'; } catch(e){}
            }
            try { window.showLoading = showLoading; window.hideLoading = hideLoading; } catch(e){}
        </script>

        <!-- Loading utilities (site-wide) -->
        <script src="/static/js/loading.js"></script>

        <!-- Mobile Menu Toggle -->
    <script>
        const mobileMenuBtn = document.getElementById('mobileMenuBtn');
        const mobileMenu = document.getElementById('mobileMenu');
        if (mobileMenuBtn && mobileMenu) {
            mobileMenuBtn.addEventListener('click', () => {
                mobileMenu.classList.toggle('hidden');
            });
        }
    </script>

    <script>
        // If we're on two-factor pages, wrap the page content in a centered card
        (function(){
            try{
                const path = window.location.pathname || '';
                if (!(path.startsWith('/two_factor') || path.indexOf('/two_factor/') !== -1 || path.indexOf('/accounts/two_factor') !== -1)) return;
                const main = document.querySelector('main');
                if (!main) return;
                // Find existing messages container (leave it above the wrapper)
                const msgs = main.querySelector('.mb-4.space-y-2');
                // Create wrapper card
                const card = document.createElement('div');
                card.className = 'max-w-3xl mx-auto bg-white border border-blue-100 rounded-xl p-6 shadow-sm twofactor-page relative';
                card.style.marginTop = '16px';
                card.style.marginBottom = '16px';

                // Move all children except messages into the card
                const children = Array.from(main.children);
                children.forEach(ch => {
                    if (msgs && ch === msgs) return; // keep messages outside
                    card.appendChild(ch);
                });

                // Remove moved children from main (they were moved by appendChild)
                // Insert card after messages (or at start of main)
                if (msgs && msgs.parentNode === main) {
                    main.insertBefore(card, msgs.nextSibling);
                } else {
                    main.insertBefore(card, main.firstChild);
                }
                // Add a bottom 'Back to profile' link and enhance disable pages
                try {
                    const profileUrl = "/accounts/profile/";
                    // bottom back link for mobile/stacked layouts (kept only)
                    const bottomLink = document.createElement('div');
                    bottomLink.className = 'mt-4';
                    bottomLink.innerHTML = `<a href="${profileUrl}" class="text-sm text-blue-600 hover:underline">← Back to profile</a>`;
                    card.appendChild(bottomLink);

                    // Find and restyle any 'Disable' actions inside the card to be prominent buttons
                    try {
                        const candidates = Array.from(card.querySelectorAll('a, button, input[type="submit"], input[type="button"]'));
                        const disableEls = candidates.filter(el => {
                            const txt = (el.textContent || el.value || '').trim();
                            return /\bdisable\b/i.test(txt);
                        });
                        if (disableEls.length > 0) {
                            card.classList.add('twofactor-disable-page');
                        }
                        disableEls.forEach(el => {
                            el.classList.add('twofactor-disable-btn');
                            if (el.tagName.toLowerCase() === 'a') el.setAttribute('role', 'button');
                        });
                    } catch(e){ console.warn('twofactor: failed to style disable actions', e); }
                } catch(e){ console.warn('failed adding profile links', e); }
            }catch(e){ console.warn('two-factor wrapper failed', e); }
        })();
    </script>

        

    <!-- Footer -->
    <footer class="bg-white border-t mt-12 py-8">
        <div class="max-w-7xl mx-auto px-4">
            <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
                <!-- About -->
                <div>
                    <h3 class="font-bold text-lg mb-3">CircleCal</h3>
                    <p class="text-gray-600 text-sm">Your all-in-one scheduling and booking platform. Manage appointments, availability, and teams effortlessly.</p>
                </div>

                <!-- Quick Links -->
                <div>
                    <h3 class="font-bold text-lg mb-3">Quick Links</h3>
                    <ul class="space-y-2 text-sm">
                        
                            <li><a href="/accounts/login/" class="text-gray-600 hover:text-blue-600">Login</a></li>
                            <li><a href="/signup/" class="text-gray-600 hover:text-blue-600">Sign Up</a></li>
                        
                    </ul>
                </div>

                <!-- Contact -->
                <div>
                    <h3 class="font-bold text-lg mb-3">Contact</h3>
                    <ul class="space-y-2 text-sm text-gray-600">
                        <li>Email: support@circlecal.com</li>
                        <li>Phone: +1 (555) 123-4567</li>
                    </ul>
                </div>
            </div>

            <!-- Copyright -->
            <div class="mt-8 pt-6 border-t text-center text-sm text-gray-500 space-y-2">
                <div>
                    Copyright &copy; 2025 CircleCal - All rights reserved.
                </div>
                <div class="text-xs text-gray-500">
                    <strong>Refund Policy (CircleCal)</strong>: Bookings and payments processed through CircleCal are subject to the platform Terms of Service. Merchants may define their own refund policy per service.
                </div>
                
            </div>
        </div>
    </footer>
</body>
</html>
